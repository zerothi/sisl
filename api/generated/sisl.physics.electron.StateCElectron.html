

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.physics.electron.StateCElectron &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=7b70f75b"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="sisl.physics.electron.EigenvalueElectron" href="sisl.physics.electron.EigenvalueElectron.html" />
    <link rel="prev" title="sisl.physics.electron.StateElectron" href="sisl.physics.electron.StateElectron.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basic.html">Basic classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../geom/index.html">Geometry handling (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.geom</span></code>)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../physics.html">Physical objects (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.physics</span></code>)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../physics.brillouinzone.html">Brillouin zone</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics.matrix.html">Physical quantites</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../physics.electron.html">Electron related functions</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.DOS.html">DOS</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.PDOS.html">PDOS</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.COP.html">COP</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.berry_phase.html">berry_phase</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.ahc.html">ahc</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.shc.html">shc</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.conductivity.html">conductivity</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.wavefunction.html">wavefunction</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.spin_moment.html">spin_moment</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.physics.electron.spin_contamination.html">spin_contamination</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../physics.electron.html#supporting-classes">Supporting classes</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../physics.phonon.html">Phonon related functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics.distribution.html">Distribution functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics.html#low-level-objects">Low level objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mixing.html">Mixing (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.mixing</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../viz/index.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unit_constant.html">Units and constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../utilities.html">Utilities (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.utils</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core.html">Functional programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io/index.html">Input/Output (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.io</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../typing.html">Typing (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.typing</span></code>)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API reference</a></li>
          <li class="breadcrumb-item"><a href="../physics.html">Physical objects (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.physics</span></code>)</a></li>
          <li class="breadcrumb-item"><a href="../physics.electron.html">Electron related functions</a></li>
      <li class="breadcrumb-item active">sisl.physics.electron.StateCElectron</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/api/generated/sisl.physics.electron.StateCElectron.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sisl-physics-electron-statecelectron">
<h1>sisl.physics.electron.StateCElectron<a class="headerlink" href="#sisl-physics-electron-statecelectron" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sisl.physics.electron.</span></span><span class="sig-name descname"><span class="pre">StateCElectron</span></span><a class="reference internal" href="../../_modules/sisl/physics/electron.html#StateCElectron"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.physics.electron.StateCElectron" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="sisl.physics.electron._electron_State.html#sisl.physics.electron._electron_State" title="sisl.physics.electron._electron_State"><code class="xref py py-class docutils literal notranslate"><span class="pre">_electron_State</span></code></a>, <a class="reference internal" href="sisl.physics.StateC.html#sisl.physics.StateC" title="sisl.physics.StateC"><code class="xref py py-class docutils literal notranslate"><span class="pre">StateC</span></code></a></p>
<p>A state describing a physical quantity related to electrons, with associated coefficients of the state</p>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.Sk" title="sisl.physics.electron.StateCElectron.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a>([format])</p></td>
<td><p>Retrieve the overlap matrix corresponding to the originating parent structure.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.align_norm" title="sisl.physics.electron.StateCElectron.align_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align_norm</span></code></a>(other[, ret_index, inplace])</p></td>
<td><p>Align <em class="xref py py-obj">self</em> with the site-norms of <em class="xref py py-obj">other</em>, a copy may optionally be returned</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.align_phase" title="sisl.physics.electron.StateCElectron.align_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align_phase</span></code></a>(other[, ret_index, inplace])</p></td>
<td><p>Align <em class="xref py py-obj">self</em> with the phases for <em class="xref py py-obj">other</em>, a copy may be returned</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.asCoefficient" title="sisl.physics.electron.StateCElectron.asCoefficient"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asCoefficient</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.asState" title="sisl.physics.electron.StateCElectron.asState"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asState</span></code></a>()</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.berry_curvature" title="sisl.physics.electron.StateCElectron.berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_curvature</span></code></a>([sum, distribution, ...])</p></td>
<td><p>Calculate the Berry curvature matrix for a set of states (Kubo)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.change_gauge" title="sisl.physics.electron.StateCElectron.change_gauge"><code class="xref py py-obj docutils literal notranslate"><span class="pre">change_gauge</span></code></a>(gauge[, offset])</p></td>
<td><p>In-place change of the gauge of the state coefficients</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.copy" title="sisl.physics.electron.StateCElectron.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>Return a copy (only the coefficients and states are copied), <code class="docutils literal notranslate"><span class="pre">parent</span></code> and <code class="docutils literal notranslate"><span class="pre">info</span></code> are passed by reference</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.degenerate" title="sisl.physics.electron.StateCElectron.degenerate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">degenerate</span></code></a>(atol)</p></td>
<td><p>Find degenerate coefficients with a specified precision</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>([order, matrix, axes, operator])</p></td>
<td><p>Calculate the derivative with respect to <span class="math notranslate nohighlight">\(\mathbf k\)</span> for a set of states up to a given order</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.effective_mass" title="sisl.physics.electron.StateCElectron.effective_mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">effective_mass</span></code></a>(*args, **kwargs)</p></td>
<td><p>Calculate effective mass tensor for the states, units are (ps/Ang)^2</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.inner" title="sisl.physics.electron.StateCElectron.inner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner</span></code></a>([ket, matrix, projection])</p></td>
<td><p>Calculate the inner product as <span class="math notranslate nohighlight">\(\mathbf A_{ij} = \langle\psi_i|\mathbf M|\psi'_j\rangle\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.ipr" title="sisl.physics.electron.StateCElectron.ipr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ipr</span></code></a>([q])</p></td>
<td><p>Calculate the inverse participation ratio (IPR) for arbitrary <em class="xref py py-obj">q</em> values</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.iter" title="sisl.physics.electron.StateCElectron.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a>([asarray])</p></td>
<td><p>An iterator looping over the states in this system</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.norm" title="sisl.physics.electron.StateCElectron.norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm</span></code></a>()</p></td>
<td><p>Return a vector with the Euclidean norm of each state <span class="math notranslate nohighlight">\(\sqrt{\langle\psi|\psi\rangle}\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.norm2" title="sisl.physics.electron.StateCElectron.norm2"><code class="xref py py-obj docutils literal notranslate"><span class="pre">norm2</span></code></a>([projection])</p></td>
<td><p>Return a vector with the norm of each state <span class="math notranslate nohighlight">\(\langle\psi|\mathbf S|\psi\rangle\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.normalize" title="sisl.physics.electron.StateCElectron.normalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">normalize</span></code></a>()</p></td>
<td><p>Return a normalized state where each state has <span class="math notranslate nohighlight">\(|\psi|^2=1\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.outer" title="sisl.physics.electron.StateCElectron.outer"><code class="xref py py-obj docutils literal notranslate"><span class="pre">outer</span></code></a>([ket, matrix])</p></td>
<td><p>Return the outer product by <span class="math notranslate nohighlight">\(\sum_\alpha|\psi_\alpha\rangle\langle\psi'_\alpha|\)</span></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.phase" title="sisl.physics.electron.StateCElectron.phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">phase</span></code></a>([method, ret_index])</p></td>
<td><p>Calculate the Euler angle (phase) for the elements of the state, in the range <span class="math notranslate nohighlight">\(]-\pi;\pi]\)</span></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.remove" title="sisl.physics.electron.StateCElectron.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>(index[, inplace])</p></td>
<td><p>Return a new state without the specified indices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.rotate" title="sisl.physics.electron.StateCElectron.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code></a>([phi, individual, inplace])</p></td>
<td><p>Rotate all states to rotate the largest component to be along the angle <em class="xref py py-obj">phi</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.sort" title="sisl.physics.electron.StateCElectron.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>([ascending])</p></td>
<td><p>Sort and return a new <code class="xref py py-obj docutils literal notranslate"><span class="pre">StateC</span></code> by sorting the coefficients (default to ascending)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.spin_berry_curvature" title="sisl.physics.electron.StateCElectron.spin_berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_berry_curvature</span></code></a>([sigma, sum, ...])</p></td>
<td><p>Calculate the spin Berry curvature</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.spin_moment" title="sisl.physics.electron.StateCElectron.spin_moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_moment</span></code></a>([projection])</p></td>
<td><p>Calculate spin moment from the states</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.sub" title="sisl.physics.electron.StateCElectron.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(index[, inplace])</p></td>
<td><p>Return a new state with only the specified states</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.tile" title="sisl.physics.electron.StateCElectron.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(reps, axis[, normalize, offset])</p></td>
<td><p>Tile the state vectors for a new supercell</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.translate" title="sisl.physics.electron.StateCElectron.translate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate</span></code></a>(isc)</p></td>
<td><p>Translate the vectors to a new unit-cell position</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.velocity" title="sisl.physics.electron.StateCElectron.velocity"><code class="xref py py-obj docutils literal notranslate"><span class="pre">velocity</span></code></a>(*args, **kwargs)</p></td>
<td><p>Calculate velocity for the states</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.wavefunction" title="sisl.physics.electron.StateCElectron.wavefunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wavefunction</span></code></a>(grid[, spinor, eta])</p></td>
<td><p>Expand the coefficients as the wavefunction on <em class="xref py py-obj">grid</em> <em>as-is</em></p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.c" title="sisl.physics.electron.StateCElectron.c"><code class="xref py py-obj docutils literal notranslate"><span class="pre">c</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.dkind" title="sisl.physics.electron.StateCElectron.dkind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dkind</span></code></a></p></td>
<td><p>The data-type of the state (in str)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.dtype" title="sisl.physics.electron.StateCElectron.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></p></td>
<td><p>Data-type for the state</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.info" title="sisl.physics.electron.StateCElectron.info"><code class="xref py py-obj docutils literal notranslate"><span class="pre">info</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.parent" title="sisl.physics.electron.StateCElectron.parent"><code class="xref py py-obj docutils literal notranslate"><span class="pre">parent</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.shape" title="sisl.physics.electron.StateCElectron.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></p></td>
<td><p>Returns the shape of the state</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.electron.StateCElectron.state" title="sisl.physics.electron.StateCElectron.state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">state</span></code></a></p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.Sk">
<span class="sig-name descname"><span class="pre">Sk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.Sk" title="Link to this definition"></a></dt>
<dd><p>Retrieve the overlap matrix corresponding to the originating parent structure.</p>
<p>When <code class="docutils literal notranslate"><span class="pre">self.parent</span></code> is a Hamiltonian this will return <span class="math notranslate nohighlight">\(\mathbf S(\mathbf k)\)</span> for the
<span class="math notranslate nohighlight">\(\mathbf k\)</span>-point these eigenstates originate from.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>format</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a>, <em>optional</em>) – the returned format of the overlap matrix. This only takes effect for
non-orthogonal parents.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.align_norm">
<span class="sig-name descname"><span class="pre">align_norm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.align_norm" title="Link to this definition"></a></dt>
<dd><p>Align <em class="xref py py-obj">self</em> with the site-norms of <em class="xref py py-obj">other</em>, a copy may optionally be returned</p>
<p>To determine the new ordering of <em class="xref py py-obj">self</em> first calculate the residual norm of the site-norms.</p>
<div class="math notranslate nohighlight">
\[\delta N_{\alpha\beta} = \sum_i \big(\langle \psi^\alpha_i | \psi^\alpha_i\rangle - \langle \psi^\beta_i | \psi^\beta_i\rangle\big)^2\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> correspond to state indices in <em class="xref py py-obj">self</em> and <em class="xref py py-obj">other</em>, respectively.
The new states (from <em class="xref py py-obj">self</em>) returned is then ordered such that the index
<span class="math notranslate nohighlight">\(\alpha \equiv \beta'\)</span> where <span class="math notranslate nohighlight">\(\delta N_{\alpha\beta}\)</span> is smallest.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code>) – the other state to align against</p></li>
<li><p><strong>ret_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – also return indices for the swapped indices</p></li>
<li><p><strong>inplace</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – swap states in-place</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>self_swap</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code>) – A swapped instance of <em class="xref py py-obj">self</em>, only if <em class="xref py py-obj">inplace</em> is False</p></li>
<li><p><strong>index</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">array</span></code> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – the indices that swaps <em class="xref py py-obj">self</em> to be <code class="docutils literal notranslate"><span class="pre">self_swap</span></code>, i.e. <code class="docutils literal notranslate"><span class="pre">self_swap</span> <span class="pre">=</span> <span class="pre">self.sub(index)</span></code>
Only if <em class="xref py py-obj">inplace</em> is False and <em class="xref py py-obj">ret_index</em> is True</p></li>
</ul>
</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The input state and output state have the same number of states, but their ordering is not necessarily the same.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.align_phase" title="sisl.physics.electron.StateCElectron.align_phase"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align_phase</span></code></a></dt><dd><p>rotate states such that their phases align</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.align_phase">
<span class="sig-name descname"><span class="pre">align_phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.align_phase" title="Link to this definition"></a></dt>
<dd><p>Align <em class="xref py py-obj">self</em> with the phases for <em class="xref py py-obj">other</em>, a copy may be returned</p>
<p>States will be rotated by <span class="math notranslate nohighlight">\(\pi\)</span> provided the phase difference between the states are above <span class="math notranslate nohighlight">\(|\Delta\theta| &gt; \pi/2\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code>) – the other state to align onto this state</p></li>
<li><p><strong>ret_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – return which indices got swapped</p></li>
<li><p><strong>inplace</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – rotate the states in-place</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.align_norm" title="sisl.physics.electron.StateCElectron.align_norm"><code class="xref py py-obj docutils literal notranslate"><span class="pre">align_norm</span></code></a></dt><dd><p>re-order states such that site-norms have a smaller residual</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.asCoefficient">
<span class="sig-name descname"><span class="pre">asCoefficient</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.asCoefficient" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.asState">
<span class="sig-name descname"><span class="pre">asState</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.asState" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.berry_curvature">
<span class="sig-name descname"><span class="pre">berry_curvature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">derivative_kwargs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">lambda</span> <span class="pre">M,</span> <span class="pre">d:</span> <span class="pre">...</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.berry_curvature" title="Link to this definition"></a></dt>
<dd><p>Calculate the Berry curvature matrix for a set of states (Kubo)</p>
<p>The Berry curvature is calculated using the following expression
(<span class="math notranslate nohighlight">\(\alpha\)</span>, <span class="math notranslate nohighlight">\(\beta\)</span> corresponding to Cartesian directions):</p>
<div class="math notranslate nohighlight">
\[\boldsymbol\Omega_{i,\alpha\beta} = 2i\hbar^2\sum_{j\neq i}
         \frac{v^{\alpha}_{ij} v^\beta_{ji}}
              {[\epsilon_i - \epsilon_j]^2 + i\eta^2}\]</div>
<p>For details on the Berry curvature, see Eq. (11) in <span id="id1">[<a class="reference internal" href="../../references.html#id12" title="Xinjie Wang, Jonathan R. Yates, Ivo Souza, and David Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, November 2006. URL: https://doi.org/10.1103/physrevb.74.195118, doi:10.1103/physrevb.74.195118.">15</a>]</span>
or Eq. (2.59) in <span id="id2">[<a class="reference internal" href="../../references.html#id8" title="János K. Asbóth, László Oroszlány, and András Pályi. A Short Course on Topological Insulators. Springer International Publishing, 2016. ISBN 9783319256054, 9783319256078. URL: https://doi.org/10.1007/978-3-319-25607-8, doi:10.1007/978-3-319-25607-8.">1</a>]</span>.</p>
<p>The <a class="reference external" href="https://docs.python.org/3/library/operator.html#module-operator" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operator</span></code></a> argument can be used to define the Berry curvature in other
quantities. E.g. the spin Berry curvature is defined by replacing <span class="math notranslate nohighlight">\(v^\alpha\)</span>
by the spin current operator. see <a class="reference internal" href="#sisl.physics.electron.StateCElectron.spin_berry_curvature" title="sisl.physics.electron.StateCElectron.spin_berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_berry_curvature</span></code></a> for details.</p>
<p>For additional details on the spin Berry curvature, see Eq. (1) in
<span id="id3">[<a class="reference internal" href="../../references.html#id4" title="Junfeng Qiao, Jiaqi Zhou, Zhe Yuan, and Weisheng Zhao. Calculation of intrinsic spin hall conductivity by wannier interpolation. Phys. Rev. B, 98:214402, Dec 2018. URL: https://link.aps.org/doi/10.1103/PhysRevB.98.214402, doi:10.1103/PhysRevB.98.214402.">9</a>]</span> and Eq. (2) in <span id="id4">[<a class="reference internal" href="../../references.html#id5" title="Yimin Ji, Wenxu Zhang, Hongbin Zhang, and Wanli Zhang. Spin hall conductivity and anomalous hall conductivity in full heusler compounds. New Journal of Physics, 24(5):053027, May 2022. URL: http://dx.doi.org/10.1088/1367-2630/ac696c, doi:10.1088/1367-2630/ac696c.">4</a>]</span>.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>There exists reports on some terms missing in the above formula, for details
see <span id="id5">[<a class="reference internal" href="../../references.html#id3" title="Jin Gan, Daye Zheng, and Lixin He. Calculation of berry curvature using nonorthogonal atomic orbitals. arXiv, 2021. arXiv:2105.14662.">3</a>]</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<a class="reference internal" href="#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>) – the state describing the electronic states we wish to calculate the Berry curvature
of.</p></li>
<li><p><strong>sum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – only return the summed Berry curvature (over all states).</p></li>
<li><p><strong>distribution</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'gaussian'</em><em>, </em><em>'lorentzian'</em><em>, </em><em>'fermi'</em><em>, </em><em>'bose-einstein'</em><em>, </em><em>'cold'</em><em>, </em><em>'step-function'</em><em>, </em><em>'heaviside'</em><em>] </em><em>| </em><em>~typing.Callable</em><em>[</em><em>[</em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em><em>, </em><em>~numpy.ndarray</em><em>] </em><em>| </em><em>None</em>) – An optional distribution enabling one to automatically sum states
across occupied/unoccupied states. This is useful when calculating AHC/SHC
contributions since it can improve numerical accuracy.
If this is None, it will do the above equation exactly.</p></li>
<li><p><strong>derivative_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>) – arguments passed to <a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>. Since <a class="reference external" href="https://docs.python.org/3/library/operator.html#module-operator" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operator</span></code></a> is defined here,
one cannot have <a class="reference external" href="https://docs.python.org/3/library/operator.html#module-operator" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">operator</span></code></a> in <em class="xref py py-obj">derivative_kwargs</em>.</p></li>
<li><p><strong>operator</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable" title="(in Python v3.14)"><em>Callable</em></a><em>[</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Buffer" title="(in Python v3.14)"><em>Buffer</em></a><em> | </em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>]</em><em>] </em><em>| </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em> | </em><em>_NestedSequence</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em>]</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>] </em><em>| </em><em>tuple</em><em>[</em><em>~collections.abc.Callable</em><em>[</em><em>[</em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>, </em><em>~typing.Literal</em><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em><em>, </em><em>~collections.abc.Callable</em><em>[</em><em>[</em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>, </em><em>~typing.Literal</em><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em><em>]</em>) – the operator to use for changing the <em class="xref py py-obj">dPk</em> matrices.
Note, that this may change the resulting units, and it will be up
to the user to adapt the units accordingly.</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – direct imaginary part broadening of the Lorentzian.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a></dt><dd><p>method for calculating the exact derivatives</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.spin_berry_curvature" title="sisl.physics.electron.StateCElectron.spin_berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_berry_curvature</span></code></a></dt><dd><p>calculate the spin Berry curvature</p>
</dd>
<dt><a class="reference internal" href="sisl.physics.electron.ahc.html#sisl.physics.electron.ahc" title="sisl.physics.electron.ahc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ahc</span></code></a></dt><dd><p>anomalous Hall conductivity</p>
</dd>
<dt><a class="reference internal" href="sisl.physics.electron.shc.html#sisl.physics.electron.shc" title="sisl.physics.electron.shc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shc</span></code></a></dt><dd><p>spin Hall conductivity</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>If <em class="xref py py-obj">sum</em> is False, it will be at least a 3D array with the 3rd dimension
having the contribution from state <em class="xref py py-obj">i</em>.
If one passes <em class="xref py py-obj">axes</em> to the <em class="xref py py-obj">derivative_kwargs</em> argument one will get
dimensions according to the number of axes requested, by default all
axes will be used (even if they are non-periodic).
The dtype will be imaginary.
The unit is <span class="math notranslate nohighlight">\(\mathrm{Ang}^2\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bc</span></code></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<a class="reference internal" href="#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>)</p></li>
<li><p><strong>sum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
<li><p><strong>distribution</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'gaussian'</em><em>, </em><em>'lorentzian'</em><em>, </em><em>'fermi'</em><em>, </em><em>'bose-einstein'</em><em>, </em><em>'cold'</em><em>, </em><em>'step-function'</em><em>, </em><em>'heaviside'</em><em>] </em><em>| </em><em>~typing.Callable</em><em>[</em><em>[</em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em><em>, </em><em>~numpy.ndarray</em><em>] </em><em>| </em><em>None</em>)</p></li>
<li><p><strong>derivative_kwargs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a>)</p></li>
<li><p><strong>operator</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable" title="(in Python v3.14)"><em>Callable</em></a><em>[</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Buffer" title="(in Python v3.14)"><em>Buffer</em></a><em> | </em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>]</em><em>] </em><em>| </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em> | </em><em>_NestedSequence</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em>]</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>] </em><em>| </em><em>tuple</em><em>[</em><em>~collections.abc.Callable</em><em>[</em><em>[</em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>, </em><em>~typing.Literal</em><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em><em>, </em><em>~collections.abc.Callable</em><em>[</em><em>[</em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>, </em><em>~typing.Literal</em><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.change_gauge">
<span class="sig-name descname"><span class="pre">change_gauge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">gauge</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.change_gauge" title="Link to this definition"></a></dt>
<dd><p>In-place change of the gauge of the state coefficients</p>
<p>The two gauges are related through:</p>
<div class="math notranslate nohighlight">
\[\tilde C_\alpha = e^{i\mathbf k\mathbf r_\alpha} C_\alpha\]</div>
<p>where <span class="math notranslate nohighlight">\(C_\alpha\)</span> and <span class="math notranslate nohighlight">\(\tilde C_\alpha\)</span> belongs to the <code class="docutils literal notranslate"><span class="pre">atomic</span></code> and
<code class="docutils literal notranslate"><span class="pre">lattice</span></code> gauge, respectively.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>) – specify the new gauge for the mode coefficients</p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>, <em>optional</em>) – whether the coordinates should be offset by another phase-factor</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.copy" title="Link to this definition"></a></dt>
<dd><p>Return a copy (only the coefficients and states are copied), <code class="docutils literal notranslate"><span class="pre">parent</span></code> and <code class="docutils literal notranslate"><span class="pre">info</span></code> are passed by reference</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>statec</strong> (<a class="reference internal" href="sisl.physics.StateC.html#sisl.physics.StateC" title="sisl.physics.StateC"><em>StateC</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="sisl.physics.StateC.html#sisl.physics.StateC" title="sisl.physics.StateC"><em>StateC</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.degenerate">
<span class="sig-name descname"><span class="pre">degenerate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atol</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.degenerate" title="Link to this definition"></a></dt>
<dd><p>Find degenerate coefficients with a specified precision</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – the precision above which coefficients are not considered degenerate</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a list of indices</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.derivative">
<span class="sig-name descname"><span class="pre">derivative</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">order</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xyz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">operator</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">lambda</span> <span class="pre">M,</span> <span class="pre">d=None:</span> <span class="pre">...</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.derivative" title="Link to this definition"></a></dt>
<dd><p>Calculate the derivative with respect to <span class="math notranslate nohighlight">\(\mathbf k\)</span> for a set of states up to a given order</p>
<p>These are calculated using the analytic expression (<span class="math notranslate nohighlight">\(\alpha\)</span> corresponding to the Cartesian directions),
here only shown for the 1st order derivative:</p>
<div class="math notranslate nohighlight">
\[\mathbf{d}_{\alpha ij} = \langle \psi_i |
         \frac{\partial}{\partial\mathbf k_\alpha} \mathbf H(\mathbf k) | \psi_j \rangle\]</div>
<p>In case of non-orthogonal basis the equations substitutes <span class="math notranslate nohighlight">\(\mathbf H(\mathbf k)\)</span> by
<span class="math notranslate nohighlight">\(\mathbf H(\mathbf k) - \epsilon_i\mathbf S(\mathbf k)\)</span>.</p>
<p>The 2nd order derivatives are calculated with the Berry curvature correction:</p>
<div class="math notranslate nohighlight">
\[\mathbf d^2_{\alpha \beta ij} = \langle\psi_i|
    \frac{\partial^2}{\partial\mathbf k_\alpha\partial\mathbf k_\beta} \mathbf H(\mathbf k) | \psi_j\rangle
    - \frac12\frac{\mathbf{d}_{\alpha ij}\mathbf{d}_{\beta ij}}
          {\epsilon_i - \epsilon_j}\]</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>When requesting 2nd derivatives it will not be advisable to use a <a class="reference internal" href="#sisl.physics.electron.StateCElectron.sub" title="sisl.physics.electron.StateCElectron.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a> before
calculating the derivatives since the 1st order perturbation uses the energy
differences (Berry contribution) and the 1st derivative matrix for correcting the curvature.</p>
<p>For states at the <span class="math notranslate nohighlight">\(\Gamma\)</span> point you may get warnings about casting complex numbers
to reals. In these cases you should force the state at the <span class="math notranslate nohighlight">\(\Gamma\)</span> point to be calculated
in complex numbers to enable the correct decoupling.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>order</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>1</em><em>, </em><em>2</em><em>]</em>) – an integer specifying which order of the derivative is being calculated.</p></li>
<li><p><strong>matrix</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether the full matrix or only the diagonal components are returned</p></li>
<li><p><strong>axes</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>0</em><em>, </em><em>1</em><em>, </em><em>2</em><em>] </em><em>| </em><em>~typing.Literal</em><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>] </em><em>| </em><em>~collections.abc.Sequence</em><em>[</em><em>~typing.Literal</em><em>[</em><em>0</em><em>, </em><em>1</em><em>, </em><em>2</em><em>, </em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>]</em><em>]</em>) – NOTE: this argument may change in future versions.
only calculate the derivative(s) along specified Cartesian directions.
The axes argument will be sorted internally, so the order will always
be xyz. For the higher order derivatives all those involving only the provided axes will be used.</p></li>
<li><p><strong>operator</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable" title="(in Python v3.14)"><em>Callable</em></a><em>[</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Buffer" title="(in Python v3.14)"><em>Buffer</em></a><em> | </em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>]</em><em>] </em><em>| </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em> | </em><em>_NestedSequence</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em>]</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em>) – an operator that translates the <span class="math notranslate nohighlight">\(\delta\)</span> matrices to another operator.
The same operator will be applied to both <code class="docutils literal notranslate"><span class="pre">P</span></code> and <code class="docutils literal notranslate"><span class="pre">S</span></code> matrices.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseOrbitalBZ.dPk</span></code></dt><dd><p>function for generating the matrix derivatives</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseOrbitalBZ.dSk</span></code></dt><dd><p>function for generating the matrix derivatives in non-orthogonal basis</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">dv</span></code> – the 1st derivative, has shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">state.shape[0])</span></code> for <code class="docutils literal notranslate"><span class="pre">matrix=False</span></code>, else
has shape <code class="docutils literal notranslate"><span class="pre">(3,</span> <span class="pre">state.shape[0],</span> <span class="pre">state.shape[0])</span></code>
Also returned for <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code> since it is used in the higher order derivatives</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ddv</span></code> – the 2nd derivative, has shape <code class="docutils literal notranslate"><span class="pre">(6,</span> <span class="pre">state.shape[0])</span></code> for <code class="docutils literal notranslate"><span class="pre">matrix=False</span></code>, else
has shape <code class="docutils literal notranslate"><span class="pre">(6,</span> <span class="pre">state.shape[0],</span> <span class="pre">state.shape[0])</span></code>, the first dimension is in the Voigt representation
Only returned for <code class="docutils literal notranslate"><span class="pre">order</span> <span class="pre">&gt;=</span> <span class="pre">2</span></code></p></li>
</ul>
</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>order</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>1</em><em>, </em><em>2</em><em>]</em>)</p></li>
<li><p><strong>matrix</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
<li><p><strong>axes</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>0</em><em>, </em><em>1</em><em>, </em><em>2</em><em>] </em><em>| </em><em>~typing.Literal</em><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>] </em><em>| </em><em>~collections.abc.Sequence</em><em>[</em><em>~typing.Literal</em><em>[</em><em>0</em><em>, </em><em>1</em><em>, </em><em>2</em><em>, </em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>]</em><em>]</em>)</p></li>
<li><p><strong>operator</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Callable" title="(in Python v3.14)"><em>Callable</em></a><em>[</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Buffer" title="(in Python v3.14)"><em>Buffer</em></a><em> | </em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>] </em><em>| </em><em>_NestedSequence</em><em>[</em><em>_SupportsArray</em><em>[</em><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><em>dtype</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Any" title="(in Python v3.14)"><em>Any</em></a><em>]</em><em>]</em><em>] </em><em>| </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em> | </em><em>_NestedSequence</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#bytes" title="(in Python v3.14)"><em>bytes</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em>]</em><em>, </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'x'</em><em>, </em><em>'y'</em><em>, </em><em>'z'</em><em>, </em><em>'xx'</em><em>, </em><em>'yy'</em><em>, </em><em>'zz'</em><em>, </em><em>'yz'</em><em>, </em><em>'xz'</em><em>, </em><em>'xy'</em><em>] </em><em>| </em><em>None</em><em>]</em><em>, </em><em>~collections.abc.Buffer</em><em> | </em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>] </em><em>| </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>~numpy._typing._array_like._SupportsArray</em><em>[</em><em>~numpy.dtype</em><em>[</em><em>~typing.Any</em><em>]</em><em>]</em><em>] </em><em>| </em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em> | </em><em>~numpy._typing._nested_sequence._NestedSequence</em><em>[</em><em>complex</em><em> | </em><em>bytes</em><em> | </em><em>str</em><em>]</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.effective_mass">
<span class="sig-name descname"><span class="pre">effective_mass</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/physics/electron.html#StateCElectron.effective_mass"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.physics.electron.StateCElectron.effective_mass" title="Link to this definition"></a></dt>
<dd><p>Calculate effective mass tensor for the states, units are (ps/Ang)^2</p>
<p>This routine calls <code class="docutils literal notranslate"><span class="pre">derivative(2,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and
returns the effective mass for all states.</p>
<p>Note that the coefficients associated with the <a class="reference internal" href="#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StateCElectron</span></code></a> <em>must</em> correspond
to the energies of the states.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Since some directions may not be periodic there will be zeros. This routine will
invert elements where the values are different from 0.</p>
<p>It is not advisable to use a <a class="reference internal" href="#sisl.physics.electron.StateCElectron.sub" title="sisl.physics.electron.StateCElectron.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a> before calculating the effective mass
since the 1st order perturbation uses the energy differences and the 1st derivative
matrix for correcting the curvature.</p>
<p>The returned effective mass is given in the Voigt notation.</p>
<p>For <span class="math notranslate nohighlight">\(\Gamma\)</span> point calculations it may be beneficial to pass <em class="xref py py-obj">dtype=np.complex128</em>
to the <em class="xref py py-obj">eigenstate</em> argument to ensure their complex values. This is necessary for the
degeneracy decoupling.</p>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a></dt><dd><p>for details of the implementation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.inner">
<span class="sig-name descname"><span class="pre">inner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ket</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'diagonal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.inner" title="Link to this definition"></a></dt>
<dd><p>Calculate the inner product as <span class="math notranslate nohighlight">\(\mathbf A_{ij} = \langle\psi_i|\mathbf M|\psi'_j\rangle\)</span></p>
<p>Inner product calculation allows for a variety of things.</p>
<ul>
<li><p>for <code class="docutils literal notranslate"><span class="pre">matrix</span></code> it will compute off-diagonal elements as well</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf A_{\alpha\beta} = \langle\psi_\alpha|\mathbf M|\psi'_\beta\rangle\]</div>
</div></blockquote>
</li>
<li><p>for <code class="docutils literal notranslate"><span class="pre">diag</span></code> only the diagonal components will be returned</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf a_\alpha = \langle\psi_\alpha|\mathbf M|\psi_\alpha\rangle\]</div>
</div></blockquote>
</li>
<li><p>for <code class="docutils literal notranslate"><span class="pre">basis</span></code>, only do inner products for individual states, but return them basis-resolved</p>
<blockquote>
<div><div class="math notranslate nohighlight">
\[\mathbf A_{\alpha\beta} = \psi^*_{\alpha,\beta} \mathbf M|\psi_\alpha\rangle_\beta\]</div>
</div></blockquote>
</li>
<li><p>for <code class="docutils literal notranslate"><span class="pre">atoms</span></code>, only do inner products for individual states, but return them atom-resolved</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ket</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code>, <em>optional</em>) – the ket object to calculate the inner product with, if not passed it will do the inner
product with itself. The object itself will always be the bra <span class="math notranslate nohighlight">\(\langle\psi_i|\)</span></p></li>
<li><p><strong>matrix</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>, <em>optional</em>) – whether a matrix is sandwiched between the bra and ket, defaults to the identity matrix.
1D arrays will be treated as a diagonal matrix.</p></li>
<li><p><strong>projection</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.ProjectionType.html#sisl.typing.ProjectionType" title="sisl.typing.ProjectionType"><em>ProjectionType</em></a><em>, </em><a class="reference internal" href="sisl.typing.ProjectionTypeHadamard.html#sisl.typing.ProjectionTypeHadamard" title="sisl.typing.ProjectionTypeHadamard"><em>ProjectionTypeHadamard</em></a><em>, </em><a class="reference internal" href="sisl.typing.ProjectionTypeHadamardAtoms.html#sisl.typing.ProjectionTypeHadamardAtoms" title="sisl.typing.ProjectionTypeHadamardAtoms"><em>ProjectionTypeHadamardAtoms</em></a><em>]</em>) – <p>how to perform the final projection.
This can be used to sum specific sub-elements, return the diagonal, or the
full matrix.</p>
<ul>
<li><p><code class="docutils literal notranslate"><span class="pre">diagonal</span></code> only return the diagonal of the inner product (‘ii’ elements)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">matrix</span></code> a matrix with diagonals and the off-diagonals (‘ij’ elements)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hadamard</span></code> only do element wise products for the states (equivalent to
basis resolved inner-products)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">atoms</span></code> only do inner products for individual states, but return them atom-resolved</p></li>
</ul>
</p></li>
</ul>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This does <em>not</em> take into account a possible overlap matrix when
non-orthogonal basis sets are used.
One have to add the overlap matrix in the <em class="xref py py-obj">matrix</em> argument, if needed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.14)"><strong>ValueError</strong></a> – if the number of state coefficients are different for the bra and ket</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#RuntimeError" title="(in Python v3.14)"><strong>RuntimeError</strong></a> – if the matrix shapes are incompatible with an atomic resolution conversion</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a matrix with the sum of inner state products</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>projection</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.ProjectionType.html#sisl.typing.ProjectionType" title="sisl.typing.ProjectionType"><em>ProjectionType</em></a><em>, </em><a class="reference internal" href="sisl.typing.ProjectionTypeHadamard.html#sisl.typing.ProjectionTypeHadamard" title="sisl.typing.ProjectionTypeHadamard"><em>ProjectionTypeHadamard</em></a><em>, </em><a class="reference internal" href="sisl.typing.ProjectionTypeHadamardAtoms.html#sisl.typing.ProjectionTypeHadamardAtoms" title="sisl.typing.ProjectionTypeHadamardAtoms"><em>ProjectionTypeHadamardAtoms</em></a><em>]</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.ipr">
<span class="sig-name descname"><span class="pre">ipr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">q</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.ipr" title="Link to this definition"></a></dt>
<dd><p>Calculate the inverse participation ratio (IPR) for arbitrary <em class="xref py py-obj">q</em> values</p>
<p>The inverse participation ratio is defined as</p>
<div class="math notranslate nohighlight">
\[I_{q,\alpha} = \frac{\sum_i |\psi_{\alpha,i}|^{2q}}{
   \big[\sum_i |\psi_{\alpha,i}|^2\big]^q}\]</div>
<p>where <span class="math notranslate nohighlight">\(\alpha\)</span> is the band index and <span class="math notranslate nohighlight">\(i\)</span> is the orbital.
The order of the IPR is defaulted to <span class="math notranslate nohighlight">\(q=2\)</span>, see following equation for details.
The IPR may be used to distinguish Anderson localization and extended
states:</p>
<div class="math notranslate nohighlight">
 \begin{align}
  \lim_{L\to\infty} I_{2,\alpha} = \left\{
    \begin{aligned}
     1/L^d &amp;\quad \text{extended state}
     \\
     \text{const.} &amp;\quad \text{localized state}
    \end{aligned}\right.
 \end{align}</div><p>For further details see <span id="id6">[<a class="reference internal" href="../../references.html#id14" title="N. C. Murphy, R. Wortis, and W. A. Atkinson. Generalized inverse participation ratio as a possible measure of localization for interacting systems. Phys. Rev. B, May 2011. URL: https://doi.org/10.1103/physrevb.83.184206, doi:10.1103/physrevb.83.184206.">7</a>]</span>. Note that for eigenstates the IPR reduces to:</p>
<div class="math notranslate nohighlight">
\[I_{q,\alpha} = \sum_i |\psi_{\alpha,i}|^{2q}\]</div>
<p>since the denominator is <span class="math notranslate nohighlight">\(1^{q} = 1\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>q</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – order parameter for the IPR</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">asarray</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.iter" title="Link to this definition"></a></dt>
<dd><p>An iterator looping over the states in this system</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>asarray</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>optional</em>) – if true the yielded values are the state vectors, i.e. a numpy array.
Otherwise an equivalent object is yielded.</p>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>state</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code>) – a state <em>only</em> containing individual elements, if <em class="xref py py-obj">asarray</em> is false</p></li>
<li><p><strong>state</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a>) – a state <em>only</em> containing individual elements, if <em class="xref py py-obj">asarray</em> is true</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.norm">
<span class="sig-name descname"><span class="pre">norm</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.norm" title="Link to this definition"></a></dt>
<dd><p>Return a vector with the Euclidean norm of each state <span class="math notranslate nohighlight">\(\sqrt{\langle\psi|\psi\rangle}\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the Euclidean norm for each state</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.norm2">
<span class="sig-name descname"><span class="pre">norm2</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'diagonal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.norm2" title="Link to this definition"></a></dt>
<dd><p>Return a vector with the norm of each state <span class="math notranslate nohighlight">\(\langle\psi|\mathbf S|\psi\rangle\)</span></p>
<p><span class="math notranslate nohighlight">\(\mathbf S\)</span> is the overlap matrix (or basis), for orthogonal basis
<span class="math notranslate nohighlight">\(\mathbf S \equiv \mathbf I\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>projection</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'matrix'</em><em>, </em><em>'ij'</em><em>, </em><em>'diagonal'</em><em>, </em><em>'diag'</em><em>, </em><em>'ii'</em><em>, </em><em>'trace'</em><em>, </em><em>'sum'</em><em>, </em><em>'hadamard'</em><em>, </em><em>'basis'</em><em>, </em><em>'hadamard:atoms'</em><em>, </em><em>'atoms'</em><em>]</em>) – whether to compute the norm per state as a single number or as orbital-/atom-resolved quantity</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.inner" title="sisl.physics.electron.StateCElectron.inner"><code class="xref py py-obj docutils literal notranslate"><span class="pre">inner</span></code></a></dt><dd><p>used method for calculating the squared norm.</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>the squared norm for each state</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>projection</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'matrix'</em><em>, </em><em>'ij'</em><em>, </em><em>'diagonal'</em><em>, </em><em>'diag'</em><em>, </em><em>'ii'</em><em>, </em><em>'trace'</em><em>, </em><em>'sum'</em><em>, </em><em>'hadamard'</em><em>, </em><em>'basis'</em><em>, </em><em>'hadamard:atoms'</em><em>, </em><em>'atoms'</em><em>]</em>)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.normalize">
<span class="sig-name descname"><span class="pre">normalize</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.normalize" title="Link to this definition"></a></dt>
<dd><p>Return a normalized state where each state has <span class="math notranslate nohighlight">\(|\psi|^2=1\)</span></p>
<p>This is roughly equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">state</span> <span class="o">=</span> <span class="n">StateC</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">10</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">n</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">norm_state</span> <span class="o">=</span> <span class="n">StateC</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">state</span> <span class="o">/</span> <span class="n">n</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">state</span><span class="o">.</span><span class="n">c</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">norm_state</span><span class="o">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a new state with all states normalized, otherwise equal to this</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.outer">
<span class="sig-name descname"><span class="pre">outer</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ket</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.outer" title="Link to this definition"></a></dt>
<dd><p>Return the outer product by <span class="math notranslate nohighlight">\(\sum_\alpha|\psi_\alpha\rangle\langle\psi'_\alpha|\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ket</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">State</span></code>, <em>optional</em>) – the ket object to calculate the outer product of, if not passed it will do the outer
product with itself. The object itself will always be the bra <span class="math notranslate nohighlight">\(|\psi_\alpha\rangle\)</span></p></li>
<li><p><strong>matrix</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>, <em>optional</em>) – whether a matrix is sandwiched between the ket and bra, defaults to the identity matrix.
1D arrays will be treated as a diagonal matrix.</p></li>
</ul>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This does <em>not</em> take into account a possible overlap matrix when non-orthogonal basis sets are used.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a matrix with the sum of outer state products</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.phase">
<span class="sig-name descname"><span class="pre">phase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'max'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.phase" title="Link to this definition"></a></dt>
<dd><p>Calculate the Euler angle (phase) for the elements of the state, in the range <span class="math notranslate nohighlight">\(]-\pi;\pi]\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<code class="docutils literal notranslate"><span class="pre">{'max',</span> <span class="pre">'all'}</span></code>) – for max, the phase for the element which has the largest absolute magnitude is returned,
for all, all phases are calculated</p></li>
<li><p><strong>ret_index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – return indices for the elements used when <code class="docutils literal notranslate"><span class="pre">method=='max'</span></code></p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.remove" title="Link to this definition"></a></dt>
<dd><p>Return a new state without the specified indices</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>] </em><em>| </em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>]</em>) – indices that are removed in the returned object</p></li>
<li><p><strong>inplace</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether the values will be removed inplace</p></li>
<li><p><strong>statec</strong> (<a class="reference internal" href="sisl.physics.StateC.html#sisl.physics.StateC" title="sisl.physics.StateC"><em>StateC</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new state without containing the requested elements, only if <em class="xref py py-obj">inplace</em> is false</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">StateC</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">phi</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">individual</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.rotate" title="Link to this definition"></a></dt>
<dd><p>Rotate all states to rotate the largest component to be along the angle <em class="xref py py-obj">phi</em></p>
<p>The states will be rotated according to:</p>
<div class="math notranslate nohighlight">
\[\mathbf S' = \mathbf S / \mathbf S^\dagger_{\phi-\mathrm{max}} \exp (i \phi),\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf S^\dagger_{\phi-\mathrm{max}}\)</span> is the phase of the component with the largest amplitude
and <span class="math notranslate nohighlight">\(\phi\)</span> is the angle to align on.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>phi</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>optional</em>) – angle to align the state at (in radians), 0 is the positive real axis</p></li>
<li><p><strong>individual</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>optional</em>) – whether the rotation is per state, or a single maximum component is chosen.</p></li>
<li><p><strong>inplace</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether to do the rotation on the object it-self (True), or return a copy
with the rotated states (False).</p></li>
<li><p><strong>state</strong> (<a class="reference internal" href="sisl.physics.State.html#sisl.physics.State" title="sisl.physics.State"><em>State</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="sisl.physics.State.html#sisl.physics.State" title="sisl.physics.State"><em>State</em></a> | <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ascending</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.sort" title="Link to this definition"></a></dt>
<dd><p>Sort and return a new <code class="xref py py-obj docutils literal notranslate"><span class="pre">StateC</span></code> by sorting the coefficients (default to ascending)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ascending</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – sort the contained elements ascending, else they will be sorted descending</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.spin_berry_curvature">
<span class="sig-name descname"><span class="pre">spin_berry_curvature</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sigma</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'z'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sum</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">distribution</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">J_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xyz'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">berry_kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.spin_berry_curvature" title="Link to this definition"></a></dt>
<dd><p>Calculate the spin Berry curvature</p>
<p>This is equivalent to calling <a class="reference internal" href="#sisl.physics.electron.StateCElectron.berry_curvature" title="sisl.physics.electron.StateCElectron.berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_curvature</span></code></a>
with the spin current operator and the regular velocity
operator instead of <span class="math notranslate nohighlight">\(v^\alpha\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="k">def</span><span class="w"> </span><span class="nf">noop</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span> <span class="k">return</span> <span class="n">M</span>
<span class="k">def</span><span class="w"> </span><span class="nf">Jz</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">J_axes</span><span class="p">:</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">M</span> <span class="o">@</span> <span class="n">sigma_z</span> <span class="o">+</span> <span class="n">sigma_z</span> <span class="o">@</span> <span class="n">M</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.5</span>
    <span class="k">return</span> <span class="n">M</span>

<span class="n">state</span><span class="o">.</span><span class="n">berry_curvature</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Jz</span><span class="p">,</span> <span class="n">noop</span><span class="p">))</span>
</pre></div>
</div>
<p>I.e. the <em>left</em> velocity operator being swapped with the
spin current operator:</p>
<div class="math notranslate nohighlight">
\[J^{\gamma\alpha} = \frac12 \{ v^\alpha, \hat{\sigma}^\gamma \}\]</div>
<p>where <span class="math notranslate nohighlight">\(\{\}\)</span> means the anticommutator.</p>
<p>When calling it like this, the spin Berry curvature is found in the
index corresponding to the axes the spin operator is acting on. The regular
spin Berry curvature is found in all indices (<em class="xref py py-obj">J_axes</em>).</p>
<p>E.g. if <code class="docutils literal notranslate"><span class="pre">J_axes</span> <span class="pre">=</span> <span class="pre">'xy',</span> <span class="pre">sigma</span> <span class="pre">=</span> <span class="pre">'z'</span></code>, then <code class="docutils literal notranslate"><span class="pre">shc[[0,</span> <span class="pre">1]]</span></code> will be the
spin Berry curvature using the Pauli matrix
<span class="math notranslate nohighlight">\(\hat{\sigma}^z\)</span> (not the spin-operator
<span class="math notranslate nohighlight">\(\hat{s}^z = \dfrac\hbar2\hat{\sigma}^z\)</span>),
and <code class="docutils literal notranslate"><span class="pre">shc[2]</span></code> will be the <em>normal</em> Berry curvature (since only
the left velocity operator will be changed for <em class="xref py py-obj">J_axes</em>).</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>For performance reasons, it can be very benificial to extract the
above methods and call <a class="reference internal" href="#sisl.physics.electron.StateCElectron.berry_curvature" title="sisl.physics.electron.StateCElectron.berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_curvature</span></code></a> directly.
This is because the <span class="math notranslate nohighlight">\(\sigma\)</span> operator gets created on every
call of this method.</p>
<p>This, repeated matrix creation, might change in the future.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sigma</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.CartesianAxisStrLiteral.html#sisl.typing.CartesianAxisStrLiteral" title="sisl.typing.CartesianAxisStrLiteral"><em>CartesianAxisStrLiteral</em></a><em>, </em><em>npt.ArrayLike</em><em>]</em>) – which Pauli matrix is used, alternatively one can pass a custom spin matrix,
or the full sigma.</p></li>
<li><p><strong>J_axes</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.CartesianAxisStrLiteral.html#sisl.typing.CartesianAxisStrLiteral" title="sisl.typing.CartesianAxisStrLiteral"><em>CartesianAxisStrLiteral</em></a><em>, </em><em>Sequence</em><em>[</em><a class="reference internal" href="sisl.typing.CartesianAxisStrLiteral.html#sisl.typing.CartesianAxisStrLiteral" title="sisl.typing.CartesianAxisStrLiteral"><em>CartesianAxisStrLiteral</em></a><em>]</em><em>]</em>) – the direction(s) where the <span class="math notranslate nohighlight">\(J^\sigma\)</span> operator will be applied, defaults
to all.</p></li>
<li><p><strong>**kwargs</strong> – see <a class="reference internal" href="#sisl.physics.electron.StateCElectron.berry_curvature" title="sisl.physics.electron.StateCElectron.berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_curvature</span></code></a> for the remaining arguments.</p></li>
<li><p><strong>state</strong> (<a class="reference internal" href="#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>)</p></li>
<li><p><strong>sum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
<li><p><strong>distribution</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.DistributionType.html#sisl.typing.DistributionType" title="sisl.typing.DistributionType"><em>DistributionType</em></a><em>]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>np.ndarray</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.berry_curvature" title="sisl.physics.electron.StateCElectron.berry_curvature"><code class="xref py py-obj docutils literal notranslate"><span class="pre">berry_curvature</span></code></a></dt><dd><p>calculate the Berry curvature (internally called)</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a></dt><dd><p>method for calculating the exact derivatives</p>
</dd>
<dt><a class="reference internal" href="sisl.physics.electron.ahc.html#sisl.physics.electron.ahc" title="sisl.physics.electron.ahc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ahc</span></code></a></dt><dd><p>anomalous Hall conductivity</p>
</dd>
<dt><a class="reference internal" href="sisl.physics.electron.shc.html#sisl.physics.electron.shc" title="sisl.physics.electron.shc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shc</span></code></a></dt><dd><p>spin Hall conductivity</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Spin Berry curvature + (possibly Berry curvature) returned in certain dimensions.
If one passes <em class="xref py py-obj">axes</em> to the <em class="xref py py-obj">derivative_kwargs</em> argument one will get
dimensions according to the number of axes requested, by default all
axes will be used (even if they are non-periodic).
The dtype will be imaginary.
The unit is <span class="math notranslate nohighlight">\(\mathrm{Ang}^2\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">bc</span></code></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<a class="reference internal" href="#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>)</p></li>
<li><p><strong>sigma</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.CartesianAxisStrLiteral.html#sisl.typing.CartesianAxisStrLiteral" title="sisl.typing.CartesianAxisStrLiteral"><em>CartesianAxisStrLiteral</em></a><em>, </em><em>npt.ArrayLike</em><em>]</em>)</p></li>
<li><p><strong>sum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
<li><p><strong>distribution</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.DistributionType.html#sisl.typing.DistributionType" title="sisl.typing.DistributionType"><em>DistributionType</em></a><em>]</em>)</p></li>
<li><p><strong>J_axes</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.CartesianAxisStrLiteral.html#sisl.typing.CartesianAxisStrLiteral" title="sisl.typing.CartesianAxisStrLiteral"><em>CartesianAxisStrLiteral</em></a><em>, </em><em>Sequence</em><em>[</em><a class="reference internal" href="sisl.typing.CartesianAxisStrLiteral.html#sisl.typing.CartesianAxisStrLiteral" title="sisl.typing.CartesianAxisStrLiteral"><em>CartesianAxisStrLiteral</em></a><em>]</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.spin_moment">
<span class="sig-name descname"><span class="pre">spin_moment</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'diagonal'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.spin_moment" title="Link to this definition"></a></dt>
<dd><p>Calculate spin moment from the states</p>
<p>This routine calls <a class="reference internal" href="sisl.physics.electron.spin_moment.html#sisl.physics.electron.spin_moment" title="sisl.physics.electron.spin_moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_moment</span></code></a> with appropriate arguments
and returns the spin moment for the states.</p>
<p>See <a class="reference internal" href="sisl.physics.electron.spin_moment.html#sisl.physics.electron.spin_moment" title="sisl.physics.electron.spin_moment"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_moment</span></code></a> for details.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>projection</strong> – whether the moments are orbitally resolved or not</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">inplace</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.sub" title="Link to this definition"></a></dt>
<dd><p>Return a new state with only the specified states</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>index</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>] </em><em>| </em><a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>]</em>) – indices that are retained in the returned object</p></li>
<li><p><strong>inplace</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether the values will be retained inplace</p></li>
<li><p><strong>statec</strong> (<a class="reference internal" href="sisl.physics.StateC.html#sisl.physics.StateC" title="sisl.physics.StateC"><em>StateC</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new object with a subset of the states, only if <em class="xref py py-obj">inplace</em> is false</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">StateC</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.tile">
<span class="sig-name descname"><span class="pre">tile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">normalize</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.tile" title="Link to this definition"></a></dt>
<dd><p>Tile the state vectors for a new supercell</p>
<p>Tiling a state vector makes use of the Bloch factors for a state by utilizing</p>
<div class="math notranslate nohighlight">
\[\psi_{\mathbf k}(\mathbf r + \mathbf T) \propto e^{i\mathbf k\cdot \mathbf T}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf T = i\mathbf a_0 + j\mathbf a_1 + l\mathbf a_2\)</span>. Note that <em class="xref py py-obj">axis</em>
selects which of the <span class="math notranslate nohighlight">\(\mathbf a_i\)</span> vectors that are translated and <em class="xref py py-obj">reps</em> corresponds
to the <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> and <span class="math notranslate nohighlight">\(l\)</span> variables. The <em class="xref py py-obj">offset</em> moves the individual states
by said amount, i.e. <span class="math notranslate nohighlight">\(i\to i+\mathrm{offset}\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – number of repetitions along a specific lattice vector</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – lattice vector to tile along</p></li>
<li><p><strong>normalize</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether the states are normalized upon return, may be useful for
eigenstates, equivalent to <code class="docutils literal notranslate"><span class="pre">state.tile().normalize()</span></code></p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – the offset for the phase factors</p></li>
<li><p><strong>state</strong> (<a class="reference internal" href="sisl.physics.State.html#sisl.physics.State" title="sisl.physics.State"><em>State</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="sisl.physics.State.html#sisl.physics.State" title="sisl.physics.State"><em>State</em></a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.tile</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Grid.tile</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Lattice.tile</span></code></p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.translate">
<span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">isc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.translate" title="Link to this definition"></a></dt>
<dd><p>Translate the vectors to a new unit-cell position</p>
<p>The method is thoroughly explained in <a class="reference internal" href="#sisl.physics.electron.StateCElectron.tile" title="sisl.physics.electron.StateCElectron.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a> while this one only
selects the corresponding state vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>isc</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">(3,)</span></code>) – number of offsets for the statevector</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.tile" title="sisl.physics.electron.StateCElectron.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>equivalent method for generating more cells simultaneously</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.velocity">
<span class="sig-name descname"><span class="pre">velocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.velocity" title="Link to this definition"></a></dt>
<dd><p>Calculate velocity for the states</p>
<p>This routine calls <code class="docutils literal notranslate"><span class="pre">derivative(1,</span> <span class="pre">*args,</span> <span class="pre">**kwargs)</span></code> and returns the velocity for the states.</p>
<p>Note that the coefficients associated with the <a class="reference internal" href="#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><code class="xref py py-obj docutils literal notranslate"><span class="pre">StateCElectron</span></code></a> <em>must</em> correspond
to the energies of the states.</p>
<p>The unit is Ang/ps.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The velocities are calculated without the Berry curvature contribution see Eq. (2) in <span id="id7">[<a class="reference internal" href="../../references.html#id12" title="Xinjie Wang, Jonathan R. Yates, Ivo Souza, and David Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, November 2006. URL: https://doi.org/10.1103/physrevb.74.195118, doi:10.1103/physrevb.74.195118.">15</a>]</span>.
It is thus typically denoted as the <em>effective velocity operater</em> (see Ref. 21 in <span id="id8">[<a class="reference internal" href="../../references.html#id12" title="Xinjie Wang, Jonathan R. Yates, Ivo Souza, and David Vanderbilt. Ab initio calculation of the anomalous hall conductivity by wannier interpolation. Phys. Rev. B, November 2006. URL: https://doi.org/10.1103/physrevb.74.195118, doi:10.1103/physrevb.74.195118.">15</a>]</span>.
The missing contribution may be added in later editions, for completeness sake, it is:</p>
<div class="math notranslate nohighlight">
\[\delta \mathbf v = - \mathbf k\times \Omega_i(\mathbf k)\]</div>
<p>where <span class="math notranslate nohighlight">\(\Omega_i\)</span> is the Berry curvature for state <span class="math notranslate nohighlight">\(i\)</span>.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>*args</strong> – arguments passed directly to <a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>, see that method
for argument details.</p></li>
<li><p><strong>**kwargs</strong> – arguments passed directly to <a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a>, see that method
for argument details.</p></li>
<li><p><strong>state</strong> (<a class="reference internal" href="#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>)</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.electron.StateCElectron.derivative" title="sisl.physics.electron.StateCElectron.derivative"><code class="xref py py-obj docutils literal notranslate"><span class="pre">derivative</span></code></a></dt><dd><p>for details of the implementation</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.wavefunction">
<span class="sig-name descname"><span class="pre">wavefunction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spinor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.wavefunction" title="Link to this definition"></a></dt>
<dd><p>Expand the coefficients as the wavefunction on <em class="xref py py-obj">grid</em> <em>as-is</em></p>
<p>See <a class="reference internal" href="sisl.physics.electron.wavefunction.html#sisl.physics.electron.wavefunction" title="sisl.physics.electron.wavefunction"><code class="xref py py-obj docutils literal notranslate"><span class="pre">wavefunction</span></code></a> for argument details, the arguments not present
in this method are automatically passed from this object.</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.c">
<span class="sig-name descname"><span class="pre">c</span></span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.c" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.dkind">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dkind</span></span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.dkind" title="Link to this definition"></a></dt>
<dd><p>The data-type of the state (in str)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.dtype" title="Link to this definition"></a></dt>
<dd><p>Data-type for the state</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.info">
<span class="sig-name descname"><span class="pre">info</span></span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.info" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.parent">
<span class="sig-name descname"><span class="pre">parent</span></span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.parent" title="Link to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.shape" title="Link to this definition"></a></dt>
<dd><p>Returns the shape of the state</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.physics.electron.StateCElectron.state">
<span class="sig-name descname"><span class="pre">state</span></span><a class="headerlink" href="#sisl.physics.electron.StateCElectron.state" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sisl.physics.electron.StateElectron.html" class="btn btn-neutral float-left" title="sisl.physics.electron.StateElectron" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sisl.physics.electron.EigenvalueElectron.html" class="btn btn-neutral float-right" title="sisl.physics.electron.EigenvalueElectron" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>