<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.Geometry &mdash; sisl 0.1.dev1+g851d78c documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
        <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="sisl.SuperCell" href="sisl.SuperCell.html" />
    <link rel="prev" title="sisl.Atoms" href="sisl.Atoms.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> sisl
          </a>
              <div class="version">
                0.1.dev1+g851d78c
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other.html">Other resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/scripts.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/ase/index.html">ASE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/viz_module/index.html">The <code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API documentation</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="../basic.html">Basic classes</a><ul class="current">
<li class="toctree-l3 current"><a class="reference internal" href="../basic.html#simple-objects">Simple objects</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="sisl.PeriodicTable.html">sisl.PeriodicTable</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Orbital.html">sisl.Orbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.SphericalOrbital.html">sisl.SphericalOrbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.AtomicOrbital.html">sisl.AtomicOrbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.HydrogenicOrbital.html">sisl.HydrogenicOrbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.GTOrbital.html">sisl.GTOrbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.STOrbital.html">sisl.STOrbital</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Atom.html">sisl.Atom</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Atoms.html">sisl.Atoms</a></li>
<li class="toctree-l4 current"><a class="current reference internal" href="#">sisl.Geometry</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.SuperCell.html">sisl.SuperCell</a></li>
<li class="toctree-l4"><a class="reference internal" href="sisl.Grid.html">sisl.Grid</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../basic.html#advanced-classes">Advanced classes</a></li>
<li class="toctree-l3"><a class="reference internal" href="../basic.html#utility-classes">Utility classes</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../default_geom.html">Common geometries</a></li>
<li class="toctree-l2"><a class="reference internal" href="../physics.html">Physical objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="../mixing.html">Mixing self-consistent quantities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../viz/index.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unit_constant.html">Units and constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../utilities.html">Utilities</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io/index.html">Input/Output</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API documentation</a></li>
          <li class="breadcrumb-item"><a href="../basic.html">Basic classes</a></li>
      <li class="breadcrumb-item active">sisl.Geometry</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/api/generated/sisl.Geometry.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<section id="sisl-geometry">
<h1>sisl.Geometry<a class="headerlink" href="#sisl-geometry" title="Permalink to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="sisl.Geometry">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sisl.</span></span><span class="sig-name descname"><span class="pre">Geometry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry" title="Permalink to this definition"></a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal notranslate"><span class="pre">SuperCellChild</span></code></p>
<p>Holds atomic information, coordinates, species, lattice vectors</p>
<p>The <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> class holds information regarding atomic coordinates,
the atomic species, the corresponding lattice-vectors.</p>
<p>It enables the interaction and conversion of atomic structures via
simple routine methods.</p>
<p>All lengths are assumed to be in units of Angstrom, however, as
long as units are kept same the exact units are irrespective.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">square</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">]],</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
<span class="gp">... </span>                  <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">square</span><span class="p">)</span>
<span class="go">Geometry{na: 1, no: 1,</span>
<span class="go"> Atoms{species: 1,</span>
<span class="go">  Atom{H, Z: 1, mass(au): 1.00794, maxR: -1.00000,</span>
<span class="go">   Orbital{R: -1.00000, q0: 0.0}</span>
<span class="go">  }: 1,</span>
<span class="go"> },</span>
<span class="go"> maxR: -1.00000,</span>
<span class="go"> SuperCell{volume: 1.0000e+01, nsc: [3 3 1]}</span>
<span class="go">}</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyz</strong> (<em>array_like</em>) – atomic coordinates
<code class="docutils literal notranslate"><span class="pre">xyz[i,</span> <span class="pre">:]</span></code> is the atomic coordinate of the i’th atom.</p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em> or </em><a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><em>Atoms</em></a>) – atomic species retrieved from the <a class="reference internal" href="sisl.PeriodicTable.html#sisl.PeriodicTable" title="sisl.PeriodicTable"><code class="xref py py-obj docutils literal notranslate"><span class="pre">PeriodicTable</span></code></a></p></li>
<li><p><strong>sc</strong> (<a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><em>SuperCell</em></a>) – the unit-cell describing the atoms in a periodic
super-cell</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>An atomic cubic lattice of Hydrogen atoms</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">),</span> <span class="n">sc</span><span class="p">)</span>
</pre></div>
</div>
<p>The following estimates the lattice vectors from the
atomic coordinates, although possible, it is not recommended
to be used.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
<span class="gp">... </span>       <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Conversion of geometries to other projects instances can be done via
sisl’s dispatch functionality</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">ase</span><span class="p">()</span>
<span class="go">Atoms(...)</span>
</pre></div>
</div>
<p>converts to an ASE <code class="docutils literal notranslate"><span class="pre">Atoms</span></code> object. See <code class="docutils literal notranslate"><span class="pre">sisl/geometry.py</span></code> for details
on how to add more conversion methods.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a></dt><dd><p>contained atoms <em class="xref py py-obj">self.atoms</em></p>
</dd>
<dt><a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a></dt><dd><p>contained atoms are each an object of this</p>
</dd>
</dl>
</div>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.Rij" title="sisl.Geometry.Rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rij</span></code></a>(ia, ja)</p></td>
<td><p>Vector between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.a2isc" title="sisl.Geometry.a2isc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2isc</span></code></a>(atoms)</p></td>
<td><p>Super-cell indices for a specific/list atom</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.a2o" title="sisl.Geometry.a2o"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2o</span></code></a>(atoms[, all])</p></td>
<td><p>Returns an orbital index of the first orbital of said atom.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.a2sc" title="sisl.Geometry.a2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2sc</span></code></a>(atoms)</p></td>
<td><p>Returns the super-cell offset for a specific atom</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.a2transpose" title="sisl.Geometry.a2transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">a2transpose</span></code></a>(atoms1[, atoms2])</p></td>
<td><p>Transposes connections from <em class="xref py py-obj">atoms1</em> to <em class="xref py py-obj">atoms2</em> such that supercell connections are transposed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(other[, offset])</p></td>
<td><p>Merge two geometries (or a Geometry and SuperCell) by adding the two atoms together</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.add_vacuum" title="sisl.Geometry.add_vacuum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add_vacuum</span></code></a>(vacuum, axis)</p></td>
<td><p>Add vacuum along the <em class="xref py py-obj">axis</em> lattice vector</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.angle" title="sisl.Geometry.angle"><code class="xref py py-obj docutils literal notranslate"><span class="pre">angle</span></code></a>(atoms[, dir, ref, rad])</p></td>
<td><p>The angle between atom <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> and the direction <em class="xref py py-obj">dir</em>, with possibility of a reference coordinate <em class="xref py py-obj">ref</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(other, axis[, offset])</p></td>
<td><p>Appends two structures along <em class="xref py py-obj">axis</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.apply" title="sisl.Geometry.apply"><code class="xref py py-obj docutils literal notranslate"><span class="pre">apply</span></code></a>(data, func, mapper[, axis, segments])</p></td>
<td><p>Apply a function <em class="xref py py-obj">func</em> to the data along axis <em class="xref py py-obj">axis</em> using the method specified</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.area" title="sisl.Geometry.area"><code class="xref py py-obj docutils literal notranslate"><span class="pre">area</span></code></a>(ax0, ax1)</p></td>
<td><p>Calculate the area spanned by the two axis <em class="xref py py-obj">ax0</em> and <em class="xref py py-obj">ax1</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.as_primary" title="sisl.Geometry.as_primary"><code class="xref py py-obj docutils literal notranslate"><span class="pre">as_primary</span></code></a>(na_primary[, axes, ret_super])</p></td>
<td><p>Try and reduce the geometry to the primary unit-cell comprising <em class="xref py py-obj">na_primary</em> atoms</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.asc2uc" title="sisl.Geometry.asc2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">asc2uc</span></code></a>(atoms[, unique])</p></td>
<td><p>Returns atoms from supercell indices to unit-cell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a>(atom, other, other_atom[, dist, axis])</p></td>
<td><p>Attaches another <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> at the <code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code> index with respect to <em class="xref py py-obj">other_atom</em> using different methods.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.auc2sc" title="sisl.Geometry.auc2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">auc2sc</span></code></a>(atoms[, unique])</p></td>
<td><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.axyz" title="sisl.Geometry.axyz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">axyz</span></code></a>([atoms, isc])</p></td>
<td><p>Return the atomic coordinates in the supercell of a given atom.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.bond_correct" title="sisl.Geometry.bond_correct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_correct</span></code></a>(ia, atoms[, method])</p></td>
<td><p>Corrects the bond between <em class="xref py py-obj">ia</em> and the <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.center" title="sisl.Geometry.center"><code class="xref py py-obj docutils literal notranslate"><span class="pre">center</span></code></a>([atoms, what])</p></td>
<td><p>Returns the center of the geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.close" title="sisl.Geometry.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a>(xyz_ia[, R, atoms, atoms_xyz, ...])</p></td>
<td><p>Indices of atoms in the entire supercell within a given radius from a given coordinate</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.close_sc" title="sisl.Geometry.close_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close_sc</span></code></a>(xyz_ia[, isc, R, atoms, atoms_xyz, ...])</p></td>
<td><p>Indices of atoms in a given supercell within a given radius from a given coordinate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.copy" title="sisl.Geometry.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>()</p></td>
<td><p>A copy of the object.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.distance" title="sisl.Geometry.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a>([atoms, R, tol, method])</p></td>
<td><p>Calculate the distances for all atoms in shells of radius <em class="xref py py-obj">tol</em> within <em class="xref py py-obj">max_R</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.equal" title="sisl.Geometry.equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">equal</span></code></a>(other[, R, tol])</p></td>
<td><p>Whether two geometries are the same (optional not check of the orbital radius)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iR" title="sisl.Geometry.iR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iR</span></code></a>([na, iR, R])</p></td>
<td><p>Return an integer number of maximum radii (<code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>) which holds approximately <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a> atoms</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a>(atom, other)</p></td>
<td><p>Inserts other atoms right before index</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.is_orthogonal" title="sisl.Geometry.is_orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">is_orthogonal</span></code></a>()</p></td>
<td><p>Return true if all cell vectors are linearly independent</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a>()</p></td>
<td><p>An iterator over all atomic indices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a>([iR, R, atoms, method])</p></td>
<td><p>Iterator for performance critical loops</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.iter_block_rand" title="sisl.Geometry.iter_block_rand"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block_rand</span></code></a>([iR, R, atoms])</p></td>
<td><p>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iter_block_shape" title="sisl.Geometry.iter_block_shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block_shape</span></code></a>([shape, iR, atoms])</p></td>
<td><p>Perform the <em>grid</em> block-iteration by looping a grid</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_orbitals</span></code></a>([atoms, local])</p></td>
<td><p>Returns an iterator over all atoms and their associated orbitals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_species</span></code></a>([atoms])</p></td>
<td><p>Iterator over all atoms (or a subset) and species as a tuple in this geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.maxR" title="sisl.Geometry.maxR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">maxR</span></code></a>([all])</p></td>
<td><p>Maximum orbital range of the atoms</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.mirror" title="sisl.Geometry.mirror"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mirror</span></code></a>(method[, atoms, point])</p></td>
<td><p>Mirrors the atomic coordinates about a plane given by its normal vector</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.move" title="sisl.Geometry.move"><code class="xref py py-obj docutils literal notranslate"><span class="pre">move</span></code></a>(v[, atoms, cell])</p></td>
<td><p>Translates the geometry by <em class="xref py py-obj">v</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.o2a" title="sisl.Geometry.o2a"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2a</span></code></a>(orbitals[, unique])</p></td>
<td><p>Atomic index corresponding to the orbital indicies.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.o2isc" title="sisl.Geometry.o2isc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2isc</span></code></a>(orbitals)</p></td>
<td><p>Returns the super-cell index for a specific orbital.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.o2sc" title="sisl.Geometry.o2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2sc</span></code></a>(orbitals)</p></td>
<td><p>Returns the super-cell offset for a specific orbital.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.o2transpose" title="sisl.Geometry.o2transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">o2transpose</span></code></a>(orb1[, orb2])</p></td>
<td><p>Transposes connections from <em class="xref py py-obj">orb1</em> to <em class="xref py py-obj">orb2</em> such that supercell connections are transposed</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.oRij" title="sisl.Geometry.oRij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">oRij</span></code></a>(orbitals1, orbitals2)</p></td>
<td><p>Vector between orbital <em class="xref py py-obj">orbitals1</em> and <em class="xref py py-obj">orbitals2</em>, orbitals can be in super-cell indices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.optimize_nsc" title="sisl.Geometry.optimize_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">optimize_nsc</span></code></a>([axis, R])</p></td>
<td><p>Optimize the number of supercell connections based on <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.orij" title="sisl.Geometry.orij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orij</span></code></a>(orbitals1, orbitals2)</p></td>
<td><p>Distance between orbital <em class="xref py py-obj">orbitals1</em> and <em class="xref py py-obj">orbitals2</em>, orbitals can be in super-cell indices</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.osc2uc" title="sisl.Geometry.osc2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">osc2uc</span></code></a>(orbitals[, unique])</p></td>
<td><p>Orbitals from supercell indices to unit-cell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.ouc2sc" title="sisl.Geometry.ouc2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ouc2sc</span></code></a>(orbitals[, unique])</p></td>
<td><p>Orbitals from unit-cell indices to supercell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.overlap" title="sisl.Geometry.overlap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">overlap</span></code></a>(other[, eps, offset, offset_other])</p></td>
<td><p>Calculate the overlapping indices between two geometries</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a>(other, axis[, offset])</p></td>
<td><p>Prepend two structures along <em class="xref py py-obj">axis</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.read" title="sisl.Geometry.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a>(sile, *args, **kwargs)</p></td>
<td><p>Reads geometry from the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">Sile.read_geometry</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.reduce" title="sisl.Geometry.reduce"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reduce</span></code></a>()</p></td>
<td><p>Remove all atoms not currently used in the <code class="docutils literal notranslate"><span class="pre">self.atoms</span></code> object</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.remove" title="sisl.Geometry.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>(atoms)</p></td>
<td><p>Remove atoms from the geometry.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.remove_orbital" title="sisl.Geometry.remove_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_orbital</span></code></a>(atoms, orbitals)</p></td>
<td><p>Remove a subset of orbitals on <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> according to <a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.reorder" title="sisl.Geometry.reorder"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reorder</span></code></a>()</p></td>
<td><p>Reorders atoms according to first occurence in the geometry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.repeat" title="sisl.Geometry.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(reps, axis)</p></td>
<td><p>Create a repeated geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.replace" title="sisl.Geometry.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(atoms, other[, offset])</p></td>
<td><p>Create a new geometry from <em class="xref py py-obj">self</em> and replace <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> with <em class="xref py py-obj">other</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.reverse" title="sisl.Geometry.reverse"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reverse</span></code></a>([atoms])</p></td>
<td><p>Returns a reversed geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.rij" title="sisl.Geometry.rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rij</span></code></a>(ia, ja)</p></td>
<td><p>Distance between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.rotate" title="sisl.Geometry.rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate</span></code></a>(angle, v[, origin, atoms, only, rad])</p></td>
<td><p>Rotate geometry around vector and return a new geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.rotate_miller" title="sisl.Geometry.rotate_miller"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rotate_miller</span></code></a>(m, v)</p></td>
<td><p>Align Miller direction along <code class="docutils literal notranslate"><span class="pre">v</span></code></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.sc2uc" title="sisl.Geometry.sc2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc2uc</span></code></a>(atoms[, unique])</p></td>
<td><p>Returns atoms from supercell indices to unit-cell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_index</span></code></a>(*args, **kwargs)</p></td>
<td><p>Call local <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_index</span></code></a> function</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.scale" title="sisl.Geometry.scale"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scale</span></code></a>(scale[, what, scale_atoms])</p></td>
<td><p>Scale coordinates and unit-cell to get a new geometry with proper scaling</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.set_nsc" title="sisl.Geometry.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_nsc</span></code></a>(*args, **kwargs)</p></td>
<td><p>Set the number of super-cells in the <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.set_sc" title="sisl.Geometry.set_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_sc</span></code></a>(sc)</p></td>
<td><p>Overwrites the local supercell</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.set_supercell" title="sisl.Geometry.set_supercell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_supercell</span></code></a>(sc)</p></td>
<td><p>Overwrites the local supercell</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.sort" title="sisl.Geometry.sort"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sort</span></code></a>(**kwargs)</p></td>
<td><p>Sort atoms in a nested fashion according to various criteria</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.sparserij" title="sisl.Geometry.sparserij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparserij</span></code></a>([dtype, na_iR, method])</p></td>
<td><p>Return the sparse matrix with all distances in the matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.sub" title="sisl.Geometry.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(atoms)</p></td>
<td><p>Create a new <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> with a subset of this <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.sub_orbital" title="sisl.Geometry.sub_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_orbital</span></code></a>(atoms, orbitals)</p></td>
<td><p>Retain only a subset of the orbitals on <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> according to <a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.swap" title="sisl.Geometry.swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap</span></code></a>(atoms_a, atoms_b)</p></td>
<td><p>Swap a set of atoms in the geometry and return a new one</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.swapaxes" title="sisl.Geometry.swapaxes"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swapaxes</span></code></a>(axis_a, axis_b[, what])</p></td>
<td><p>Swap the axis for the atomic coordinates and the cell vectors</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(reps, axis)</p></td>
<td><p>Tile the geometry to create a bigger one</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.translate" title="sisl.Geometry.translate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate</span></code></a>(v[, atoms, cell])</p></td>
<td><p>Translates the geometry by <em class="xref py py-obj">v</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.translate2uc" title="sisl.Geometry.translate2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate2uc</span></code></a>([atoms, axes])</p></td>
<td><p>Translates atoms in the geometry into the unit cell</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.uc2sc" title="sisl.Geometry.uc2sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">uc2sc</span></code></a>(atoms[, unique])</p></td>
<td><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.unrepeat" title="sisl.Geometry.unrepeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unrepeat</span></code></a>(reps, axis, *args, **kwargs)</p></td>
<td><p>Unrepeats the geometry similarly as <a class="reference internal" href="#sisl.Geometry.untile" title="sisl.Geometry.untile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">untile</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.untile" title="sisl.Geometry.untile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">untile</span></code></a>(reps, axis[, segment, rtol, atol])</p></td>
<td><p>A subset of atoms from the geometry by cutting the geometry into <em class="xref py py-obj">reps</em> parts along the direction <em class="xref py py-obj">axis</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.within" title="sisl.Geometry.within"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within</span></code></a>(shapes[, atoms, atoms_xyz, ret_xyz, ...])</p></td>
<td><p>Indices of atoms in the entire supercell within a given shape from a given coordinate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.within_inf" title="sisl.Geometry.within_inf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within_inf</span></code></a>(sc[, periodic, tol, origin])</p></td>
<td><p>Find all atoms within a provided supercell</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.within_sc" title="sisl.Geometry.within_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within_sc</span></code></a>(shapes[, isc, atoms, atoms_xyz, ...])</p></td>
<td><p>Indices of atoms in a given supercell within a given shape from a given coordinate</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.write" title="sisl.Geometry.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(sile, *args, **kwargs)</p></td>
<td><p>Writes geometry to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">sile.write_geometry</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a></p></td>
<td><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a> object)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.cell" title="sisl.Geometry.cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.cell" title="sisl.Geometry.cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.firsto" title="sisl.Geometry.firsto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">firsto</span></code></a></p></td>
<td><p>The first orbital on the corresponding atom</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.fxyz" title="sisl.Geometry.fxyz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fxyz</span></code></a></p></td>
<td><p>Returns geometry coordinates in fractional coordinates</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.icell" title="sisl.Geometry.icell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">icell</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.icell" title="sisl.Geometry.icell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">icell</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.isc_off" title="sisl.Geometry.isc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isc_off</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.isc_off" title="sisl.Geometry.isc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isc_off</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.lasto" title="sisl.Geometry.lasto"><code class="xref py py-obj docutils literal notranslate"><span class="pre">lasto</span></code></a></p></td>
<td><p>The last orbital on the corresponding atom</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.length" title="sisl.Geometry.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.length" title="sisl.Geometry.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.mass" title="sisl.Geometry.mass"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mass</span></code></a></p></td>
<td><p>The mass of all atoms as an array</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a></p></td>
<td><p>Number of atoms in geometry</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.na_s" title="sisl.Geometry.na_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na_s</span></code></a></p></td>
<td><p>Number of supercell atoms</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.names" title="sisl.Geometry.names"><code class="xref py py-obj docutils literal notranslate"><span class="pre">names</span></code></a></p></td>
<td><p>The named index specifier</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.new" title="sisl.Geometry.new"><code class="xref py py-obj docutils literal notranslate"><span class="pre">new</span></code></a></p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.no" title="sisl.Geometry.no"><code class="xref py py-obj docutils literal notranslate"><span class="pre">no</span></code></a></p></td>
<td><p>Number of orbitals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.no_s" title="sisl.Geometry.no_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">no_s</span></code></a></p></td>
<td><p>Number of supercell orbitals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.nsc" title="sisl.Geometry.nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsc</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.nsc" title="sisl.Geometry.nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsc</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p></td>
<td><p>List of orbitals per atom</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.origin" title="sisl.Geometry.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.origin" title="sisl.Geometry.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.origo" title="sisl.Geometry.origo"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origo</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.origin" title="sisl.Geometry.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.q0" title="sisl.Geometry.q0"><code class="xref py py-obj docutils literal notranslate"><span class="pre">q0</span></code></a></p></td>
<td><p>Total initial charge in this geometry (sum of q0 in all atoms)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.rcell" title="sisl.Geometry.rcell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcell</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.rcell" title="sisl.Geometry.rcell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcell</span></code></a></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.sc_off" title="sisl.Geometry.sc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_off</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.sc_off" title="sisl.Geometry.sc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_off</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.Geometry.to" title="sisl.Geometry.to"><code class="xref py py-obj docutils literal notranslate"><span class="pre">to</span></code></a></p></td>
<td><p>A dispatcher for classes, using <em class="xref py py-obj">__get__</em> it converts into <em class="xref py py-obj">ObjectDispatcher</em> upon invocation from an object, or a <em class="xref py py-obj">TypeDispatcher</em> when invoked from a class</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.Geometry.volume" title="sisl.Geometry.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></p></td>
<td><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.volume" title="sisl.Geometry.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.Rij">
<span class="sig-name descname"><span class="pre">Rij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ia</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ja</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.Rij"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.Rij" title="Permalink to this definition"></a></dt>
<dd><p>Vector between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p>
<p>Returns the vector between two atoms:</p>
<div class="math notranslate nohighlight">
\[R_{ij} = r_j - r_i\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ia</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – atomic index of first atom</p></li>
<li><p><strong>ja</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – atomic indices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">names</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.__init__"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.__init__" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.a2isc">
<span class="sig-name descname"><span class="pre">a2isc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.a2isc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.a2isc" title="Permalink to this definition"></a></dt>
<dd><p>Super-cell indices for a specific/list atom</p>
<p>Returns a vector of 3 numbers with integers.
Any multi-dimensional input will be flattened before return.</p>
<p>The returned indices will thus always be a 2D matrix or a 1D vector.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.a2o">
<span class="sig-name descname"><span class="pre">a2o</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">all</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.a2o"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.a2o" title="Permalink to this definition"></a></dt>
<dd><p>Returns an orbital index of the first orbital of said atom.
This is particularly handy if you want to create
TB models with more than one orbital per atom.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em>) – Atomic indices</p></li>
<li><p><strong>all</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – <code class="docutils literal notranslate"><span class="pre">False</span></code>, return only the first orbital corresponding to the atom,
<code class="docutils literal notranslate"><span class="pre">True</span></code>, returns list of the full atom(s), will always return a 1D array.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.a2sc">
<span class="sig-name descname"><span class="pre">a2sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.a2sc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.a2sc" title="Permalink to this definition"></a></dt>
<dd><p>Returns the super-cell offset for a specific atom</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.a2transpose">
<span class="sig-name descname"><span class="pre">a2transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><span class="pre">tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.a2transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.a2transpose" title="Permalink to this definition"></a></dt>
<dd><p>Transposes connections from <em class="xref py py-obj">atoms1</em> to <em class="xref py py-obj">atoms2</em> such that supercell connections are transposed</p>
<p>When handling supercell indices it is useful to get the <em>transposed</em> connection. I.e. if you have
a connection from site <code class="docutils literal notranslate"><span class="pre">i</span></code> (in unit cell indices) to site <code class="docutils literal notranslate"><span class="pre">j</span></code> (in supercell indices) it may be
useful to get the equivalent supercell connection such for site <code class="docutils literal notranslate"><span class="pre">j</span></code> (in unit cell indices) to
site <code class="docutils literal notranslate"><span class="pre">i</span></code> (in supercell indices) such that they correspond to the transposed coupling.</p>
<p>Note that since this transposes couplings the indices returned are always expanded to the full
length if either of the inputs are a single index.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span>
<span class="go">array([0, 1, 5, 9], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span><span class="o">.</span><span class="n">a2transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
<span class="go">(array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms1</strong> (<em>array_like</em>) – atomic indices must have same length as <em class="xref py py-obj">atoms2</em> or length 1</p></li>
<li><p><strong>atoms2</strong> (<em>array_like</em><em>, </em><em>optional</em>) – atomic indices must have same length as <em class="xref py py-obj">atoms1</em> or length 1.
If not present then only <em class="xref py py-obj">atoms1</em> will be returned in transposed indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>atoms2</strong> (<em>array_like</em>) – transposed indices for atoms2 (only returned if <em class="xref py py-obj">atoms2</em> is not None)</p></li>
<li><p><strong>atoms1</strong> (<em>array_like</em>) – transposed indices for atoms1</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.add"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.add" title="Permalink to this definition"></a></dt>
<dd><p>Merge two geometries (or a Geometry and SuperCell) by adding the two atoms together</p>
<p>If <em class="xref py py-obj">other</em> is a Geometry only the atoms gets added, to also add the supercell vectors
simply do <code class="docutils literal notranslate"><span class="pre">geom.add(other).add(other.sc)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a><em> or </em><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><em>SuperCell</em></a>) – Other geometry class which is added</p></li>
<li><p><strong>offset</strong> (<em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – offset in geometry of <em class="xref py py-obj">other</em> when adding the atoms. Only if <em class="xref py py-obj">other</em> is
of instance <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a>.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>appending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>prending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a></dt><dd><p>insert a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.add_vacuum">
<span class="sig-name descname"><span class="pre">add_vacuum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vacuum</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.add_vacuum" title="Permalink to this definition"></a></dt>
<dd><p>Add vacuum along the <em class="xref py py-obj">axis</em> lattice vector</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vacuum</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – amount of vacuum added, in Ang</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the lattice vector to add vacuum along</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.angle">
<span class="sig-name descname"><span class="pre">angle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dir</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(1.0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ref</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.angle"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.angle" title="Permalink to this definition"></a></dt>
<dd><p>The angle between atom <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> and the direction <em class="xref py py-obj">dir</em>, with possibility of a reference coordinate <em class="xref py py-obj">ref</em></p>
<p>The calculated angle can be written as this</p>
<div class="math notranslate nohighlight">
\[\alpha = \arccos \frac{(\mathrm{atom} - \mathrm{ref})\cdot \mathrm{dir}}
{|\mathrm{atom}-\mathrm{ref}||\mathrm{dir}|}\]</div>
<p>and thus lies in the interval <span class="math notranslate nohighlight">\([0 ; \pi]\)</span> as one cannot distinguish orientation without
additional vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – indices/boolean of all atoms where angles should be calculated on</p></li>
<li><p><strong>dir</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – the direction from which the angle is calculated from, default to <code class="docutils literal notranslate"><span class="pre">x</span></code>.
An integer specifies the corresponding lattice vector as the direction.</p></li>
<li><p><strong>ref</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – the reference point from which the vectors are drawn, default to origin
An integer species an atomic index.</p></li>
<li><p><strong>rad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – whether the returned value is in radians</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.append"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.append" title="Permalink to this definition"></a></dt>
<dd><p>Appends two structures along <em class="xref py py-obj">axis</em></p>
<p>This will automatically add the <code class="docutils literal notranslate"><span class="pre">self.cell[axis,:]</span></code> to all atomic
coordiates in the <em class="xref py py-obj">other</em> structure before appending.</p>
<p>The basic algorithm is this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="kc">None</span><span class="p">,:]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span><span class="n">oxa</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
</pre></div>
</div>
<p>NOTE: The cell appended is only in the axis that
is appended, which means that the other cell directions
need not conform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a><em> or </em><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><em>SuperCell</em></a>) – Other geometry class which needs to be appended
If a <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> only the super cell will be extended</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Cell direction to which the <em class="xref py py-obj">other</em> geometry should be
appended.</p></li>
<li><p><strong>offset</strong> (<em>{'none'</em><em>, </em><em>'min'</em><em>, </em><em>(</em><em>3</em><em>,</em><em>)</em><em>}</em>) – By default appending two structures will simply use the coordinates,
as is.
With ‘min’, the routine will shift both the structures along the cell
axis of <em class="xref py py-obj">self</em> such that they coincide at the first atom, lastly one
may use a specified offset to manually select how <em class="xref py py-obj">other</em> is displaced.
NOTE: That <em class="xref py py-obj">self.cell[axis, :]</em> will be added to <em class="xref py py-obj">offset</em> if <em class="xref py py-obj">other</em> is
a geometry.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>add geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>prending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a></dt><dd><p>insert a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mapper</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segments</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'atoms'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.apply"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.apply" title="Permalink to this definition"></a></dt>
<dd><p>Apply a function <em class="xref py py-obj">func</em> to the data along axis <em class="xref py py-obj">axis</em> using the method specified</p>
<p>This can be useful for applying conversions from orbital data to atomic data through
sums or other functions.</p>
<p>The data may be of any shape but it is expected the function can handle arguments as
<code class="docutils literal notranslate"><span class="pre">func(data,</span> <span class="pre">axis=axis)</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>data</strong> (<em>array_like</em>) – the data to be converted</p></li>
<li><p><strong>func</strong> – a callable function that transforms the data in some way</p></li>
<li><p><strong>mapper</strong> (<em>func</em><em>, </em><em>optional</em>) – a function transforming the <em class="xref py py-obj">segments</em> into some other segments that
is present in <code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code>.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – axis selector for <code class="xref py py-obj docutils literal notranslate"><span class="pre">data</span></code> along which <em class="xref py py-obj">func</em> will be applied</p></li>
<li><p><strong>segments</strong> (<em>{&quot;atoms&quot;</em><em>, </em><em>&quot;orbitals&quot;</em><em>, </em><em>&quot;all&quot;}</em><em> or </em><em>iterator</em><em>, </em><em>optional</em>) – which segments the <em class="xref py py-obj">mapper</em> will recieve, if atoms, each atom
index will be passed to the <em class="xref py py-obj">mapper(ia)</em>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>This will likely be moved to a separate function since it in principle has nothing to
do with the Geometry class.</p>
<p class="rubric">Examples</p>
<p>Convert orbital data into summed atomic data</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">diamond</span><span class="p">(</span><span class="n">atoms</span><span class="o">=</span><span class="n">sisl</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">orbital_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atomic_data</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">orbital_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">a2o</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>The same can be accomblished by passing an explicit segment iterator,
note that <code class="docutils literal notranslate"><span class="pre">iter(g)</span> <span class="pre">==</span> <span class="pre">range(g.na)</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">atomic_data</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">orbital_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="n">g</span><span class="o">.</span><span class="n">a2o</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                      <span class="n">segments</span><span class="o">=</span><span class="nb">iter</span><span class="p">(</span><span class="n">g</span><span class="p">))</span>
</pre></div>
</div>
<p>To only take out every 2nd orbital:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">alternate_data</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">orbital_data</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">,</span> <span class="n">mapper</span><span class="o">=</span><span class="k">lambda</span> <span class="n">idx</span><span class="p">:</span> <span class="n">idx</span><span class="p">[::</span><span class="mi">2</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
<span class="gp">... </span>                         <span class="n">segments</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.area">
<span class="sig-name descname"><span class="pre">area</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ax0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ax1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.area" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the area spanned by the two axis <em class="xref py py-obj">ax0</em> and <em class="xref py py-obj">ax1</em></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.as_primary">
<span class="sig-name descname"><span class="pre">as_primary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">na_primary</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_super</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.as_primary"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.as_primary" title="Permalink to this definition"></a></dt>
<dd><p>Try and reduce the geometry to the primary unit-cell comprising <em class="xref py py-obj">na_primary</em> atoms</p>
<p>This will basically try and find the tiling/repetitions required for the geometry to only have
<em class="xref py py-obj">na_primary</em> atoms in the unit cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>na_primary</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – number of atoms in the primary unit cell</p></li>
<li><p><strong>axes</strong> (<em>array_like</em><em>, </em><em>optional</em>) – only search the given directions for supercells, default to all directions</p></li>
<li><p><strong>ret_super</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – also return the number of supercells used in each direction</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>Geometry</em> – the primary unit cell</p></li>
<li><p><em>SuperCell</em> – the tiled supercell numbers used to find the primary unit cell (only if <em class="xref py py-obj">ret_super</em> is true)</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Raises</dt>
<dd class="field-odd"><p><strong>SislError</strong> – If the algorithm fails.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.asc2uc">
<span class="sig-name descname"><span class="pre">asc2uc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#sisl.Geometry.asc2uc" title="Permalink to this definition"></a></dt>
<dd><p>Returns atoms from supercell indices to unit-cell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the atomic supercell indices to be converted to unit-cell indices</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the returned indices are unique and sorted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.atoms">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">atoms</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><span class="pre">Atoms</span></a></em><a class="headerlink" href="#sisl.Geometry.atoms" title="Permalink to this definition"></a></dt>
<dd><p>Atoms for the geometry (<a class="reference internal" href="sisl.Atoms.html#sisl.Atoms" title="sisl.Atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atoms</span></code></a> object)</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.attach">
<span class="sig-name descname"><span class="pre">attach</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other_atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dist</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'calc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.attach"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.attach" title="Permalink to this definition"></a></dt>
<dd><p>Attaches another <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> at the <code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code> index with respect to <em class="xref py py-obj">other_atom</em> using different methods.</p>
<p>The attached geometry will be inserted at the end of the geometry via <a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atom</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – atomic index which is the base position of the attachment. The distance
between <code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code> and <em class="xref py py-obj">other_atom</em> is <em class="xref py py-obj">dist</em>.</p></li>
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a>) – the other Geometry to attach at the given point. In this case <em class="xref py py-obj">dist</em> from
<code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code>.</p></li>
<li><p><strong>other_atom</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the index of the atom in <em class="xref py py-obj">other</em> that is inserted at <code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code>.</p></li>
<li><p><strong>dist</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em>) – the distance (in <em class="xref py py-obj">Ang</em>) between the attached coordinates.
If <em class="xref py py-obj">dist</em> is <em class="xref py py-obj">array_like</em> it should be the vector between
the atoms;
if <em class="xref py py-obj">dist</em> is <em class="xref py py-obj">float</em> the argument <em class="xref py py-obj">axis</em> is required
and the vector will be calculated along the corresponding latticevector;
else if <em class="xref py py-obj">dist</em> is <em class="xref py py-obj">str</em> this will correspond to the
<em class="xref py py-obj">method</em> argument of the <a class="reference internal" href="sisl.Atom.html#sisl.Atom.radius" title="sisl.Atom.radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom.radius</span></code></a> class of the two
atoms. Here <em class="xref py py-obj">axis</em> is also required.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – specify the direction of the lattice vectors used.
Not used if <em class="xref py py-obj">dist</em> is an array-like argument.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.auc2sc">
<span class="sig-name descname"><span class="pre">auc2sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="headerlink" href="#sisl.Geometry.auc2sc" title="Permalink to this definition"></a></dt>
<dd><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the atomic unit-cell indices to be converted to supercell indices</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the returned indices are unique and sorted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.axyz">
<span class="sig-name descname"><span class="pre">axyz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.axyz"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.axyz" title="Permalink to this definition"></a></dt>
<dd><p>Return the atomic coordinates in the supercell of a given atom.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">Geometry[...]</span></code> slicing is calling this function with appropriate options.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – atom(s) from which we should return the coordinates, the atomic indices
may be in supercell format.</p></li>
<li><p><strong>isc</strong> (<em>array_like</em><em>, </em><em>optional</em>) – Returns the atomic coordinates shifted according to the integer
parts of the cell. Defaults to the unit-cell</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">isc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">]))</span> 
<span class="go">[[1.   0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]]</span>
</pre></div>
</div>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> 
<span class="go">[0.  0.  0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.bond_correct">
<span class="sig-name descname"><span class="pre">bond_correct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ia</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'calc'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.bond_correct"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.bond_correct" title="Permalink to this definition"></a></dt>
<dd><p>Corrects the bond between <em class="xref py py-obj">ia</em> and the <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a>.</p>
<p>Corrects the bond-length between atom <em class="xref py py-obj">ia</em> and <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> in such
a way that the atomic radius is preserved.
I.e. the sum of the bond-lengths minimizes the distance matrix.</p>
<p>Only atom <em class="xref py py-obj">ia</em> is moved.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ia</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The atom to be displaced according to the atomic radius</p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – The atom(s) from which the radius should be reduced.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – If str will use that as lookup in <a class="reference internal" href="sisl.Atom.html#sisl.Atom.radius" title="sisl.Atom.radius"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom.radius</span></code></a>.
Else it will be the new bond-length.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.cell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">cell</span></span><a class="headerlink" href="#sisl.Geometry.cell" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.cell" title="sisl.Geometry.cell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">cell</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.center">
<span class="sig-name descname"><span class="pre">center</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">what</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'xyz'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.center"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.center" title="Permalink to this definition"></a></dt>
<dd><p>Returns the center of the geometry</p>
<p>By specifying <em class="xref py py-obj">what</em> one can control whether it should be:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">xyz|position</span></code>: Center of coordinates (default)</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mm:xyz</span></code> or <code class="docutils literal notranslate"><span class="pre">mm(xyz)</span></code>: Center of minimum/maximum of coordinates</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">mass</span></code>: Center of mass</p></li>
<li><dl class="simple">
<dt><code class="docutils literal notranslate"><span class="pre">mass:pbc</span></code>: Center of mass using periodicity, if the point 0, 0, 0 is returned it</dt><dd><p>may likely be because of a completely periodic system with no true center of mass</p>
</dd>
</dl>
</li>
<li><p><code class="docutils literal notranslate"><span class="pre">cell</span></code>: Center of cell</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em>) – list of atomic indices to find center of</p></li>
<li><p><strong>what</strong> (<em>{'xyz'</em><em>, </em><em>'mm:xyz'</em><em>, </em><em>'mass'</em><em>, </em><em>'mass:pbc'</em><em>, </em><em>'cell'}</em>) – determine which center to calculate</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.close">
<span class="sig-name descname"><span class="pre">close</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz_ia</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_rij</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_isc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.close"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.close" title="Permalink to this definition"></a></dt>
<dd><p>Indices of atoms in the entire supercell within a given radius from a given coordinate</p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.Geometry.close_sc" title="sisl.Geometry.close_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyz_ia</strong> (<em>coordinate/index</em>) – Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="docutils literal notranslate"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p></li>
<li><p><strong>R</strong> (<em>(</em><em>None</em><em>)</em><em>, </em><em>float/tuple</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – <p>The radii parameter to where the atomic connections are found.
If <em class="xref py py-obj">R</em> is an array it will return the indices:
in the ranges:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<p>If a single float it will return:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span>
</pre></div>
</div>
</p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em>, </em><em>optional</em>) – List of indices for atoms that are to be considered</p></li>
<li><p><strong>atoms_xyz</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The atomic coordinates of the equivalent <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> variable (<a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> must also be passed)</p></li>
<li><p><strong>ret_xyz</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If true this method will return the coordinates
for each of the couplings.</p></li>
<li><p><strong>ret_rij</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If true this method will return the distances from the <em class="xref py py-obj">xyz_ia</em>
for each of the couplings.</p></li>
<li><p><strong>ret_isc</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If true this method will return the lattice offset from <em class="xref py py-obj">xyz_ia</em>
for each of the couplings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>index</em> – indices of atoms (in supercell indices) within the shells of radius <em class="xref py py-obj">R</em></p></li>
<li><p><em>xyz</em> – atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p></li>
<li><p><em>rij</em> – distance of the indexed atoms to the center coordinate (only for true <em class="xref py py-obj">ret_rij</em>)</p></li>
<li><p><em>isc</em> – integer lattice offsets for the couplings (related to <a class="reference internal" href="#sisl.Geometry.rij" title="sisl.Geometry.rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rij</span></code></a> without atomic coordinates)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.close_sc">
<span class="sig-name descname"><span class="pre">close_sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">xyz_ia</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_rij</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.close_sc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.close_sc" title="Permalink to this definition"></a></dt>
<dd><p>Indices of atoms in a given supercell within a given radius from a given coordinate</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <em class="xref py py-obj">R</em>.</p>
<p>If <em class="xref py py-obj">R</em> is a tuple/list/array it will return the indices:
in the ranges:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>xyz_ia</strong> (<em>array_like</em><em> of </em><em>floats</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Either a point in space or an index of an atom.
If an index is passed it is the equivalent of passing
the atomic coordinate <code class="docutils literal notranslate"><span class="pre">close_sc(self.xyz[xyz_ia,:])</span></code>.</p></li>
<li><p><strong>isc</strong> (<em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – Integer super-cell offsets in which the coordinates are checked in.
I.e. <code class="docutils literal notranslate"><span class="pre">isc=[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code> is the primary cell (default).</p></li>
<li><p><strong>R</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – The radii parameter to where the atomic connections are found.
If <em class="xref py py-obj">R</em> is an array it will return the indices:
in the ranges <code class="docutils literal notranslate"><span class="pre">(</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[0]</span> <span class="pre">,</span> <span class="pre">R[0]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[1],</span> <span class="pre">R[1]</span> <span class="pre">&lt;</span> <span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R[2]</span> <span class="pre">)</span></code>.
If a single float it will return <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;=</span> <span class="pre">R</span></code>.</p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – List of atoms that will be considered. This can
be used to only take out a certain atoms.</p></li>
<li><p><strong>atoms_xyz</strong> (<em>array_like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – The atomic coordinates of the equivalent <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> variable (<a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> must also be passed)</p></li>
<li><p><strong>ret_xyz</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True this method will return the coordinates
for each of the couplings.</p></li>
<li><p><strong>ret_rij</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True this method will return the distance
for each of the couplings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>index</em> – indices of atoms (in supercell indices) within the shells of radius <em class="xref py py-obj">R</em></p></li>
<li><p><em>xyz</em> – atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p></li>
<li><p><em>rij</em> – distance of the indexed atoms to the center coordinate (only for true <em class="xref py py-obj">ret_rij</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.copy"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.copy" title="Permalink to this definition"></a></dt>
<dd><p>A copy of the object.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.distance">
<span class="sig-name descname"><span class="pre">distance</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'average'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.distance"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.distance" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the distances for all atoms in shells of radius <em class="xref py py-obj">tol</em> within <em class="xref py py-obj">max_R</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only create list of distances from the given atoms, default to all atoms</p></li>
<li><p><strong>R</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – the maximum radius to consider, default to <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>.
To retrieve all distances for atoms within the supercell structure
you can pass <a class="reference external" href="https://numpy.org/doc/stable/reference/constants.html#numpy.inf" title="(in NumPy v1.24)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.inf</span></code></a>.</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – <p>the tolerance for grouping a set of atoms.
This parameter sets the shell radius for each shell.
I.e. the returned distances between two shells will be maximally
<code class="docutils literal notranslate"><span class="pre">2*tol</span></code>, but only if atoms are within two consecutive lists.
If this is a list, the shells will be of unequal size.</p>
<p>The first shell size will be <code class="docutils literal notranslate"><span class="pre">tol</span> <span class="pre">*</span> <span class="pre">.5</span></code> or <code class="docutils literal notranslate"><span class="pre">tol[0]</span> <span class="pre">*</span> <span class="pre">.5</span></code> if <em class="xref py py-obj">tol</em> is a list.</p>
</p></li>
<li><p><strong>method</strong> (<em>{'average'</em><em>, </em><em>'mode'</em><em>, </em><em>'&lt;numpy.func&gt;'</em><em>, </em><em>func}</em>) – How the distance in each shell is determined.
A list of distances within each shell is gathered and the equivalent
method will be used to extract a single quantity from the list of
distances in the shell.
If <em class="xref py py-obj">‘mode’</em> is chosen it will use <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.mode.html#scipy.stats.mode" title="(in SciPy v1.10.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.stats.mode</span></code></a>.
If a string is given it will correspond to <code class="docutils literal notranslate"><span class="pre">getattr(numpy,</span> <span class="pre">method)</span></code>,
while any callable function may be passed. The passed function
will only be passed a list of unsorted distances that needs to be
processed.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="mf">1.</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">SuperCell</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">1</span><span class="p">]))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">()</span> <span class="c1"># use geom.maxR() </span>
<span class="go">array([1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span>
<span class="go">array([1.])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.3</span><span class="p">,</span> <span class="mf">0.2</span><span class="p">])</span> 
<span class="go">array([1.        ,  1.41421356,  2.        ])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">distance</span><span class="p">(</span><span class="n">R</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">0.7</span><span class="p">])</span> <span class="c1"># the R = 1 and R = 2 ** .5 gets averaged </span>
<span class="go">array([1.20710678,  2.        ])</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p>an array of positive numbers yielding the distances from the atoms in reduced form</p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)">numpy.ndarray</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.sparserij" title="sisl.Geometry.sparserij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sparserij</span></code></a></dt><dd><p>return a sparse matrix will all distances between atoms</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.equal">
<span class="sig-name descname"><span class="pre">equal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.equal"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.equal" title="Permalink to this definition"></a></dt>
<dd><p>Whether two geometries are the same (optional not check of the orbital radius)</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a>) – the other Geometry to check against</p></li>
<li><p><strong>R</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – if True also check if the orbital radii are the same (see <a class="reference internal" href="sisl.Atom.html#sisl.Atom.equal" title="sisl.Atom.equal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom.equal</span></code></a>)</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – tolerance for checking the atomic coordinates</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.firsto">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">firsto</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></em><a class="headerlink" href="#sisl.Geometry.firsto" title="Permalink to this definition"></a></dt>
<dd><p>The first orbital on the corresponding atom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.fxyz">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fxyz</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></em><a class="headerlink" href="#sisl.Geometry.fxyz" title="Permalink to this definition"></a></dt>
<dd><p>Returns geometry coordinates in fractional coordinates</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.iR">
<span class="sig-name descname"><span class="pre">iR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">na</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iR</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.iR"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.iR" title="Permalink to this definition"></a></dt>
<dd><p>Return an integer number of maximum radii (<code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>) which holds approximately <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a> atoms</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>na</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – number of atoms within the radius</p></li>
<li><p><strong>iR</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – initial <a class="reference internal" href="#sisl.Geometry.iR" title="sisl.Geometry.iR"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iR</span></code></a> value, which the sphere is estitametd from</p></li>
<li><p><strong>R</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – the value used for atomic range (defaults to <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>number of radius needed to contain <a class="reference internal" href="#sisl.Geometry.na" title="sisl.Geometry.na"><code class="xref py py-obj docutils literal notranslate"><span class="pre">na</span></code></a> atoms. Minimally 2 will be returned.</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)">int</a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.icell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">icell</span></span><a class="headerlink" href="#sisl.Geometry.icell" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.icell" title="sisl.Geometry.icell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">icell</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.insert"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.insert" title="Permalink to this definition"></a></dt>
<dd><p>Inserts other atoms right before index</p>
<p>We insert the <code class="xref py py-obj docutils literal notranslate"><span class="pre">geometry</span></code> <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> before <code class="xref py py-obj docutils literal notranslate"><span class="pre">atom</span></code>.
Note that this will not change the unit cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atom</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the atomic index at which the other geometry is inserted</p></li>
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a>) – the other geometry to be inserted</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>add geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>appending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.prepend" title="sisl.Geometry.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>prending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.is_orthogonal">
<span class="sig-name descname"><span class="pre">is_orthogonal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.is_orthogonal" title="Permalink to this definition"></a></dt>
<dd><p>Return true if all cell vectors are linearly independent</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.isc_off">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">isc_off</span></span><a class="headerlink" href="#sisl.Geometry.isc_off" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.isc_off" title="sisl.Geometry.isc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">isc_off</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.iter">
<span class="sig-name descname"><span class="pre">iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.iter"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.iter" title="Permalink to this definition"></a></dt>
<dd><p>An iterator over all atomic indices</p>
<p>This iterator is the same as:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
<span class="gp">... </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>or equivalently</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
<span class="gp">... </span>   <span class="o">&lt;</span><span class="n">do</span> <span class="n">something</span><span class="o">&gt;</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_species</span></code></a></dt><dd><p>iterate across indices and atomic species</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_orbitals</span></code></a></dt><dd><p>iterate across atomic indices and orbital indices</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.iter_block">
<span class="sig-name descname"><span class="pre">iter_block</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iR</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><span class="pre">str</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'rand'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.iter_block"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.iter_block" title="Permalink to this definition"></a></dt>
<dd><p>Iterator for performance critical loops</p>
<p>NOTE: This requires that <em class="xref py py-obj">R</em> has been set correctly as the maximum interaction range.</p>
<p>I.e. the loop would look like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block</span><span class="p">():</span>
<span class="gp">... </span>   <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
<span class="gp">... </span>       <span class="n">idx_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">,</span> <span class="n">idx</span> <span class="o">=</span> <span class="n">idxs</span><span class="p">)</span>
</pre></div>
</div>
<p>This iterator is intended for systems with more than 1000 atoms.</p>
<p>Remark that the iterator used is non-deterministic, i.e. any two iterators need
not return the same atoms in any way.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>iR</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – the number of <em class="xref py py-obj">R</em> ranges taken into account when doing the iterator</p></li>
<li><p><strong>R</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – enables overwriting the local R quantity. Defaults to <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code></p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em>, </em><em>optional</em>) – enables only effectively looping a subset of the full geometry</p></li>
<li><p><strong>method</strong> (<em>{'rand'</em><em>, </em><em>'sphere'</em><em>, </em><em>'cube'}</em>) – <p>select the method by which the block iteration is performed.
Possible values are:</p>
<blockquote>
<div><p><em class="xref py py-obj">rand</em>: a spherical object is constructed with a random center according to the internal atoms
<em class="xref py py-obj">sphere</em>: a spherical equispaced shape is constructed and looped
<em class="xref py py-obj">cube</em>: a cube shape is constructed and looped</p>
</div></blockquote>
</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>numpy.ndarray</em> – current list of atoms currently searched</p></li>
<li><p><em>numpy.ndarray</em> – atoms that needs searching</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.iter_block_rand">
<span class="sig-name descname"><span class="pre">iter_block_rand</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iR</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.iter_block_rand"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.iter_block_rand" title="Permalink to this definition"></a></dt>
<dd><p>Perform the <em>random</em> block-iteration by randomly selecting the next center of block</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.iter_block_shape">
<span class="sig-name descname"><span class="pre">iter_block_shape</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shape</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">iR</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">20</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.iter_block_shape"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.iter_block_shape" title="Permalink to this definition"></a></dt>
<dd><p>Perform the <em>grid</em> block-iteration by looping a grid</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.iter_orbitals">
<span class="sig-name descname"><span class="pre">iter_orbitals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.iter_orbitals"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.iter_orbitals" title="Permalink to this definition"></a></dt>
<dd><p>Returns an iterator over all atoms and their associated orbitals</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_orbitals</span><span class="p">():</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal notranslate"><span class="pre">io</span></code> the associated orbital index on atom <code class="docutils literal notranslate"><span class="pre">ia</span></code>.
Note that <code class="docutils literal notranslate"><span class="pre">io</span></code> will start from <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only loop on the given atoms, default to all atoms</p></li>
<li><p><strong>local</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – whether the orbital index is the global index, or the local index relative to
the atom it resides on.</p></li>
</ul>
</dd>
<dt class="field-even">Yields</dt>
<dd class="field-even"><ul class="simple">
<li><p><em>ia</em> – atomic index</p></li>
<li><p><em>io</em> – orbital index</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a></dt><dd><p>iterate over atomic indices</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_species" title="sisl.Geometry.iter_species"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_species</span></code></a></dt><dd><p>iterate across indices and atomic species</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.iter_species">
<span class="sig-name descname"><span class="pre">iter_species</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.iter_species"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.iter_species" title="Permalink to this definition"></a></dt>
<dd><p>Iterator over all atoms (or a subset) and species as a tuple in this geometry</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">idx_specie</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_species</span><span class="p">():</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
<span class="gp">... </span>    <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx_specie</span><span class="p">,</span> <span class="nb">int</span><span class="p">)</span> <span class="o">==</span> <span class="kc">True</span>
</pre></div>
</div>
<p>with <code class="docutils literal notranslate"><span class="pre">ia</span></code> being the atomic index, <code class="docutils literal notranslate"><span class="pre">a</span></code> the <a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a> object, <code class="docutils literal notranslate"><span class="pre">idx_specie</span></code>
is the index of the specie</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only loop on the given atoms, default to all atoms</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter" title="sisl.Geometry.iter"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter</span></code></a></dt><dd><p>iterate over atomic indices</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.iter_orbitals" title="sisl.Geometry.iter_orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_orbitals</span></code></a></dt><dd><p>iterate across atomic indices and orbital indices</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.lasto">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">lasto</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></em><a class="headerlink" href="#sisl.Geometry.lasto" title="Permalink to this definition"></a></dt>
<dd><p>The last orbital on the corresponding atom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.length">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">length</span></span><a class="headerlink" href="#sisl.Geometry.length" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.length" title="sisl.Geometry.length"><code class="xref py py-obj docutils literal notranslate"><span class="pre">length</span></code></a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.mass">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">mass</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></em><a class="headerlink" href="#sisl.Geometry.mass" title="Permalink to this definition"></a></dt>
<dd><p>The mass of all atoms as an array</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.maxR">
<span class="sig-name descname"><span class="pre">maxR</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">all</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><span class="pre">bool</span></a></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.maxR"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.maxR" title="Permalink to this definition"></a></dt>
<dd><p>Maximum orbital range of the atoms</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.mirror">
<span class="sig-name descname"><span class="pre">mirror</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">point</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.mirror"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.mirror" title="Permalink to this definition"></a></dt>
<dd><p>Mirrors the atomic coordinates about a plane given by its normal vector</p>
<p>This will typically move the atomic coordinates outside of the unit-cell.
This method should be used with care.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<em>{'xy'/'z'</em><em>, </em><em>...</em><em>, </em><em>'ab'</em><em>, </em><em>...</em><em>, </em><em>v}</em>) – mirror the structure about a Cartesian direction (<code class="docutils literal notranslate"><span class="pre">x</span></code>, <code class="docutils literal notranslate"><span class="pre">y</span></code>, <code class="docutils literal notranslate"><span class="pre">z</span></code>),
plane (<code class="docutils literal notranslate"><span class="pre">xy</span></code>, <code class="docutils literal notranslate"><span class="pre">xz</span></code>, <code class="docutils literal notranslate"><span class="pre">yz</span></code>) or about user defined vectors (<code class="docutils literal notranslate"><span class="pre">v</span></code>).
A vector may also be specified by <code class="docutils literal notranslate"><span class="pre">'ab'</span></code> which is the vector normal
to the plane spanned by the first and second lattice vector.
or user defined vector (<em class="xref py py-obj">v</em>) which is defining a plane.</p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em>, </em><em>optional</em>) – only mirror a subset of atoms</p></li>
<li><p><strong>point</strong> (<em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – mirror coordinates around the plane that intersects the <em>method</em> vector
and this point</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[0.  -1.42]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">mirror</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mf">1.42</span><span class="o">/</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">out</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[1.42  0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.move">
<span class="sig-name descname"><span class="pre">move</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="headerlink" href="#sisl.Geometry.move" title="Permalink to this definition"></a></dt>
<dd><p>Translates the geometry by <em class="xref py py-obj">v</em></p>
<p>One can translate a subset of the atoms by supplying <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a>.</p>
<p>Returns a copy of the structure translated by <em class="xref py py-obj">v</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><em>array_like</em>) – the value or vector to displace all atomic coordinates
It should just be broad-castable with the geometry’s coordinates.</p></li>
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only displace the given atomic indices, if not specified, all
atoms will be displaced</p></li>
<li><p><strong>cell</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the supercell also gets enlarged by the vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.n_s">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">n_s</span></span><a class="headerlink" href="#sisl.Geometry.n_s" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.n_s" title="sisl.Geometry.n_s"><code class="xref py py-obj docutils literal notranslate"><span class="pre">n_s</span></code></a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.na">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">na</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></em><a class="headerlink" href="#sisl.Geometry.na" title="Permalink to this definition"></a></dt>
<dd><p>Number of atoms in geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.na_s">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">na_s</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></em><a class="headerlink" href="#sisl.Geometry.na_s" title="Permalink to this definition"></a></dt>
<dd><p>Number of supercell atoms</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.names">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">names</span></span><a class="headerlink" href="#sisl.Geometry.names" title="Permalink to this definition"></a></dt>
<dd><p>The named index specifier</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.Geometry.new">
<span class="sig-name descname"><span class="pre">new</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;sisl._dispatcher.TypeDispatcher</span> <span class="pre">object&gt;</span></em><a class="headerlink" href="#sisl.Geometry.new" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.no">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">no</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></em><a class="headerlink" href="#sisl.Geometry.no" title="Permalink to this definition"></a></dt>
<dd><p>Number of orbitals</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.no_s">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">no_s</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><span class="pre">int</span></a></em><a class="headerlink" href="#sisl.Geometry.no_s" title="Permalink to this definition"></a></dt>
<dd><p>Number of supercell orbitals</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.nsc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nsc</span></span><a class="headerlink" href="#sisl.Geometry.nsc" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.nsc" title="sisl.Geometry.nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nsc</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.o2a">
<span class="sig-name descname"><span class="pre">o2a</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.o2a"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.o2a" title="Permalink to this definition"></a></dt>
<dd><p>Atomic index corresponding to the orbital indicies.</p>
<p>Note that this will preserve the super-cell offsets.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orbitals</strong> (<em>array_like</em>) – List of orbital indices to return the atoms for</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True only return the unique atoms.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.o2isc">
<span class="sig-name descname"><span class="pre">o2isc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.o2isc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.o2isc" title="Permalink to this definition"></a></dt>
<dd><p>Returns the super-cell index for a specific orbital.</p>
<p>Returns a vector of 3 numbers with integers.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.o2sc">
<span class="sig-name descname"><span class="pre">o2sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.o2sc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.o2sc" title="Permalink to this definition"></a></dt>
<dd><p>Returns the super-cell offset for a specific orbital.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.o2transpose">
<span class="sig-name descname"><span class="pre">o2transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orb1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orb2</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><span class="pre">tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.o2transpose"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.o2transpose" title="Permalink to this definition"></a></dt>
<dd><p>Transposes connections from <em class="xref py py-obj">orb1</em> to <em class="xref py py-obj">orb2</em> such that supercell connections are transposed</p>
<p>When handling supercell indices it is useful to get the <em>transposed</em> connection. I.e. if you have
a connection from site <code class="docutils literal notranslate"><span class="pre">i</span></code> (in unit cell indices) to site <code class="docutils literal notranslate"><span class="pre">J</span></code> (in supercell indices) it may be
useful to get the equivalent supercell connection such for site <code class="docutils literal notranslate"><span class="pre">j</span></code> (in unit cell indices) to
site <code class="docutils literal notranslate"><span class="pre">I</span></code> (in supercell indices) such that they correspond to the transposed coupling.</p>
<p>Note that since this transposes couplings the indices returned are always expanded to the full
length if either of the inputs are a single index.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span> <span class="c1"># one orbital per site</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span> <span class="o">=</span> <span class="n">gr</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">atoms</span>
<span class="go">array([0, 1, 5, 9], dtype=int32)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gr</span><span class="o">.</span><span class="n">o2transpose</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
<span class="go">(array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orb1</strong> (<em>array_like</em>) – orbital indices must have same length as <em class="xref py py-obj">orb2</em> or length 1</p></li>
<li><p><strong>orb2</strong> (<em>array_like</em><em>, </em><em>optional</em>) – orbital indices must have same length as <em class="xref py py-obj">orb1</em> or length 1.
If not present then only <em class="xref py py-obj">orb1</em> will be returned in transposed indices.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>orb2</strong> (<em>array_like</em>) – transposed indices for orb2 (only returned if <em class="xref py py-obj">orb2</em> is not None)</p></li>
<li><p><strong>orb1</strong> (<em>array_like</em>) – transposed indices for orb1</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.oRij">
<span class="sig-name descname"><span class="pre">oRij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbitals1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.oRij"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.oRij" title="Permalink to this definition"></a></dt>
<dd><p>Vector between orbital <em class="xref py py-obj">orbitals1</em> and <em class="xref py py-obj">orbitals2</em>, orbitals can be in super-cell indices</p>
<p>Returns the vector between two orbitals:</p>
<div class="math notranslate nohighlight">
\[R_{ij} = r_j - r_i\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orbitals1</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – orbital index of first orbital</p></li>
<li><p><strong>orbitals2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – orbital indices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.optimize_nsc">
<span class="sig-name descname"><span class="pre">optimize_nsc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.optimize_nsc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.optimize_nsc" title="Permalink to this definition"></a></dt>
<dd><p>Optimize the number of supercell connections based on <code class="docutils literal notranslate"><span class="pre">self.maxR()</span></code></p>
<p>After this routine the number of supercells may not necessarily be the same.</p>
<p>This is an in-place operation.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only optimize the specified axis (default to all)</p></li>
<li><p><strong>R</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – the maximum connection radius for each atom</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.orbitals">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">orbitals</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></em><a class="headerlink" href="#sisl.Geometry.orbitals" title="Permalink to this definition"></a></dt>
<dd><p>List of orbitals per atom</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.origin">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">origin</span></span><a class="headerlink" href="#sisl.Geometry.origin" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.origin" title="sisl.Geometry.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.origo">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">origo</span></span><a class="headerlink" href="#sisl.Geometry.origo" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.origin" title="sisl.Geometry.origin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">origin</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.orij">
<span class="sig-name descname"><span class="pre">orij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbitals1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals2</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.orij"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.orij" title="Permalink to this definition"></a></dt>
<dd><p>Distance between orbital <em class="xref py py-obj">orbitals1</em> and <em class="xref py py-obj">orbitals2</em>, orbitals can be in super-cell indices</p>
<p>Returns the distance between two orbitals:</p>
<div class="math notranslate nohighlight">
\[r_{ij} = |r_j - r_i|\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orbitals1</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – orbital index of first orbital</p></li>
<li><p><strong>orbitals2</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – orbital indices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.osc2uc">
<span class="sig-name descname"><span class="pre">osc2uc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.osc2uc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.osc2uc" title="Permalink to this definition"></a></dt>
<dd><p>Orbitals from supercell indices to unit-cell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orbitals</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the orbital supercell indices to be converted to unit-cell indices</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the returned indices are unique and sorted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.ouc2sc">
<span class="sig-name descname"><span class="pre">ouc2sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.ouc2sc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.ouc2sc" title="Permalink to this definition"></a></dt>
<dd><p>Orbitals from unit-cell indices to supercell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>orbitals</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the orbital unit-cell indices to be converted to supercell indices</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the returned indices are unique and sorted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.overlap">
<span class="sig-name descname"><span class="pre">overlap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eps</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset_other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0.0,</span> <span class="pre">0.0,</span> <span class="pre">0.0)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><span class="pre">tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">numpy.ndarray</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.overlap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.overlap" title="Permalink to this definition"></a></dt>
<dd><p>Calculate the overlapping indices between two geometries</p>
<p>Find equivalent atoms (in the primary unit-cell only) in two geometries.
This routine finds which atoms have the same atomic positions in <em class="xref py py-obj">self</em> and <em class="xref py py-obj">other</em>.</p>
<p>Note that this will return duplicate overlapping atoms if one atoms lies within <em class="xref py py-obj">eps</em>
of more than 1 atom in <em class="xref py py-obj">other</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a>) – Geometry to compare with <em class="xref py py-obj">self</em></p></li>
<li><p><strong>eps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – atoms within this distance will be considered <em>equivalent</em></p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – offset for <em class="xref py py-obj">self.xyz</em> before comparing</p></li>
<li><p><strong>offset_other</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – offset for <em class="xref py py-obj">other.xyz</em> before comparing</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">gr22</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gr44</span> <span class="o">=</span> <span class="n">gr22</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">offset</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.2</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gr22</span> <span class="o">=</span> <span class="n">gr22</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gr22</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gr22</span> <span class="o">=</span> <span class="n">gr22</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">idx22</span><span class="p">,</span> <span class="n">idx44</span> <span class="o">=</span> <span class="n">gr22</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">gr44</span><span class="p">,</span> <span class="n">offset</span><span class="o">=-</span><span class="n">offset</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">idx22</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">gr22</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">idx44</span> <span class="o">==</span> <span class="n">idx</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>idx_self</strong> (<em>numpy.ndarray of int</em>) – indices in <em class="xref py py-obj">self</em> that are equivalent with <em class="xref py py-obj">idx_other</em></p></li>
<li><p><strong>idx_other</strong> (<em>numpy.ndarray of int</em>) – indices in <em class="xref py py-obj">other</em> that are equivalent with <em class="xref py py-obj">idx_self</em></p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.Geometry.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><a class="headerlink" href="#sisl.Geometry.plot" title="Permalink to this definition"></a></dt>
<dd><p>Handles all plotting possibilities for a class</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.prepend">
<span class="sig-name descname"><span class="pre">prepend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'none'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.prepend"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.prepend" title="Permalink to this definition"></a></dt>
<dd><p>Prepend two structures along <em class="xref py py-obj">axis</em></p>
<p>This will automatically add the <code class="docutils literal notranslate"><span class="pre">self.cell[axis,:]</span></code> to all atomic
coordiates in the <em class="xref py py-obj">other</em> structure before appending.</p>
<p>The basic algorithm is this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">oxa</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">oxa</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:][</span><span class="kc">None</span><span class="p">,:])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,:]</span>
</pre></div>
</div>
<p>NOTE: The cell prepended is only in the axis that
is prependend, which means that the other cell directions
need not conform.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a><em> or </em><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><em>SuperCell</em></a>) – Other geometry class which needs to be prepended
If a <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> only the super cell will be extended</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – Cell direction to which the <em class="xref py py-obj">other</em> geometry should be
prepended</p></li>
<li><p><strong>offset</strong> (<em>{'none'</em><em>, </em><em>'min'</em><em>, </em><em>(</em><em>3</em><em>,</em><em>)</em><em>}</em>) – By default appending two structures will simply use the coordinates,
as is.
With ‘min’, the routine will shift both the structures along the cell
axis of <em class="xref py py-obj">other</em> such that they coincide at the first atom, lastly one
may use a specified offset to manually select how <em class="xref py py-obj">self</em> is displaced.
NOTE: That <em class="xref py py-obj">other.cell[axis, :]</em> will be added to <em class="xref py py-obj">offset</em> if <em class="xref py py-obj">other</em> is
a geometry.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.add" title="sisl.Geometry.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>add geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.append" title="sisl.Geometry.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>appending geometries</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.attach" title="sisl.Geometry.attach"><code class="xref py py-obj docutils literal notranslate"><span class="pre">attach</span></code></a></dt><dd><p>attach a geometry</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.insert" title="sisl.Geometry.insert"><code class="xref py py-obj docutils literal notranslate"><span class="pre">insert</span></code></a></dt><dd><p>insert a geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.q0">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">q0</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><span class="pre">float</span></a></em><a class="headerlink" href="#sisl.Geometry.q0" title="Permalink to this definition"></a></dt>
<dd><p>Total initial charge in this geometry (sum of q0 in all atoms)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.rcell">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rcell</span></span><a class="headerlink" href="#sisl.Geometry.rcell" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.rcell" title="sisl.Geometry.rcell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rcell</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.read">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.read" title="Permalink to this definition"></a></dt>
<dd><p>Reads geometry from the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">Sile.read_geometry</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>sile</strong> (<a class="reference internal" href="../io/generated/sisl.io.Sile.html#sisl.io.Sile" title="sisl.io.Sile"><em>Sile</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.11)"><em>pathlib.Path</em></a>) – a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> object which will be used to read the geometry
if it is a string it will create a new sile using <code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sile</span></code>.</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.write" title="sisl.Geometry.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a></dt><dd><p>writes a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> to a given <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code>/file</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.reduce">
<span class="sig-name descname"><span class="pre">reduce</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.11)"><span class="pre">None</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.reduce"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.reduce" title="Permalink to this definition"></a></dt>
<dd><p>Remove all atoms not currently used in the <code class="docutils literal notranslate"><span class="pre">self.atoms</span></code> object</p>
<p class="rubric">Notes</p>
<p>This is an in-place operation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.remove"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.remove" title="Permalink to this definition"></a></dt>
<dd><p>Remove atoms from the geometry.</p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – indices/boolean of all atoms to be removed</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.sub" title="sisl.Geometry.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a></dt><dd><p>the negative of this routine, i.e. retain a subset of atoms</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.remove_orbital">
<span class="sig-name descname"><span class="pre">remove_orbital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.remove_orbital"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.remove_orbital" title="Permalink to this definition"></a></dt>
<dd><p>Remove a subset of orbitals on <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> according to <a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p>
<p>For more detailed examples, please see the equivalent (but opposite) method
<a class="reference internal" href="#sisl.Geometry.sub_orbital" title="sisl.Geometry.sub_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_orbital</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><em>Atom</em></a>) – indices of atoms or <a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a> that will be reduced in size according to <a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p></li>
<li><p><strong>orbitals</strong> (<em>array_like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference internal" href="sisl.Orbital.html#sisl.Orbital" title="sisl.Orbital"><em>Orbital</em></a>) – indices of the orbitals on <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> that are removed from the geometry.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.sub_orbital" title="sisl.Geometry.sub_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_orbital</span></code></a></dt><dd><p>retaining a set of orbitals (see here for examples)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.reorder">
<span class="sig-name descname"><span class="pre">reorder</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.11)"><span class="pre">None</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.reorder"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.reorder" title="Permalink to this definition"></a></dt>
<dd><p>Reorders atoms according to first occurence in the geometry</p>
<p class="rubric">Notes</p>
<p>This is an in-place operation.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.repeat">
<span class="sig-name descname"><span class="pre">repeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.repeat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.repeat" title="Permalink to this definition"></a></dt>
<dd><p>Create a repeated geometry</p>
<p>The atomic indices are <em>NOT</em> retained from the base structure.</p>
<p>The expansion of the atoms are basically performed using this
algorithm:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ja</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="nb">id</span><span class="p">,</span><span class="n">r</span> <span class="ow">in</span> <span class="n">args</span><span class="p">:</span>
<span class="gp">... </span>       <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="gp">... </span>          <span class="n">ja</span> <span class="o">=</span> <span class="n">ia</span> <span class="o">+</span> <span class="n">cell</span><span class="p">[</span><span class="nb">id</span><span class="p">,:]</span> <span class="o">*</span> <span class="n">i</span>
</pre></div>
</div>
<p>For geometries with a single atom this routine returns the same as
<a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>.</p>
<p>Tiling and repeating a geometry will result in the same geometry.
The <em>only</em> difference between the two is the final ordering of the atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – number of repetitions</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – direction of repetition, 0, 1, 2 according to the cell-direction</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> 
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> 
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [0.   1.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [1.   1.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [0.5  1.   0. ]</span>
<span class="go"> [1.5  0.   0. ]</span>
<span class="go"> [1.5  1.   0. ]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>equivalent but different ordering of final structure</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.replace"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.replace" title="Permalink to this definition"></a></dt>
<dd><p>Create a new geometry from <em class="xref py py-obj">self</em> and replace <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> with <em class="xref py py-obj">other</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – atoms in <em class="xref py py-obj">self</em> to be removed and replaced by other
<em class="xref py py-obj">other</em> will be placed in the geometry at the lowest index of <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a></p></li>
<li><p><strong>other</strong> (<a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a>) – the other Geometry to insert instead, the unit-cell will not
be used.</p></li>
<li><p><strong>offset</strong> (<em>(</em><em>3</em><em>,</em><em>)</em><em>, </em><em>optional</em>) – the offset for <em class="xref py py-obj">other</em> when adding its coordinates, default to no offset</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.reverse">
<span class="sig-name descname"><span class="pre">reverse</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.reverse"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.reverse" title="Permalink to this definition"></a></dt>
<dd><p>Returns a reversed geometry</p>
<p>Also enables reversing a subset of the atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only reverse the given atomic indices, if not specified, all
atoms will be reversed</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.rij">
<span class="sig-name descname"><span class="pre">rij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">ia</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ja</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.rij"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.rij" title="Permalink to this definition"></a></dt>
<dd><p>Distance between atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ja</em>, atoms can be in super-cell indices</p>
<p>Returns the distance between two atoms:</p>
<div class="math notranslate nohighlight">
\[r_{ij} = |r_j - r_i|\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>ia</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – atomic index of first atom</p></li>
<li><p><strong>ja</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – atomic indices</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.rotate">
<span class="sig-name descname"><span class="pre">rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">angle</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'abc+xyz'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.rotate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.rotate" title="Permalink to this definition"></a></dt>
<dd><p>Rotate geometry around vector and return a new geometry</p>
<p>Per default will the entire geometry be rotated, such that everything
is aligned as before rotation.</p>
<p>However, by supplying <code class="docutils literal notranslate"><span class="pre">only</span> <span class="pre">=</span> <span class="pre">'abc|xyz'</span></code> one can designate which
part of the geometry that will be rotated.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>angle</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a>) – the angle in degrees to rotate the geometry. Set the <code class="docutils literal notranslate"><span class="pre">rad</span></code>
argument to use radians.</p></li>
<li><p><strong>v</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em> or </em><em>array_like</em>) – the normal vector to the rotated plane, i.e.
v = [1,0,0] will rotate the <code class="docutils literal notranslate"><span class="pre">yz</span></code> plane</p></li>
<li><p><strong>origin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – the origin of rotation. Anything but [0, 0, 0] is equivalent
to a <em class="xref py py-obj">self.move(-origin).rotate(…).move(origin)</em>.
If this is an <em class="xref py py-obj">int</em> it corresponds to the atomic index.</p></li>
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only rotate the given atomic indices, if not specified, all
atoms will be rotated.</p></li>
<li><p><strong>only</strong> (<em>{'abc+xyz'</em><em>, </em><em>'xyz'</em><em>, </em><em>'abc'}</em>) – which coordinate subject should be rotated,
if <code class="docutils literal notranslate"><span class="pre">abc</span></code> is in this string the cell will be rotated
if <code class="docutils literal notranslate"><span class="pre">xyz</span></code> is in this string the coordinates will be rotated</p></li>
<li><p><strong>rad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – if <code class="docutils literal notranslate"><span class="pre">True</span></code> the angle is provided in radians (rather than degrees)</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.Quaternion.html#sisl.Quaternion" title="sisl.Quaternion"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Quaternion</span></code></a></dt><dd><p>class to rotate</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.rotate_miller">
<span class="sig-name descname"><span class="pre">rotate_miller</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">m</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.rotate_miller"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.rotate_miller" title="Permalink to this definition"></a></dt>
<dd><p>Align Miller direction along <code class="docutils literal notranslate"><span class="pre">v</span></code></p>
<p>Rotate geometry and cell such that the Miller direction
points along the Cartesian vector <code class="docutils literal notranslate"><span class="pre">v</span></code>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.sc2uc">
<span class="sig-name descname"><span class="pre">sc2uc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.sc2uc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.sc2uc" title="Permalink to this definition"></a></dt>
<dd><p>Returns atoms from supercell indices to unit-cell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the atomic supercell indices to be converted to unit-cell indices</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the returned indices are unique and sorted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.sc_index">
<span class="sig-name descname"><span class="pre">sc_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.sc_index" title="Permalink to this definition"></a></dt>
<dd><p>Call local <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object <a class="reference internal" href="#sisl.Geometry.sc_index" title="sisl.Geometry.sc_index"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_index</span></code></a> function</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.sc_off">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sc_off</span></span><a class="headerlink" href="#sisl.Geometry.sc_off" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.sc_off" title="sisl.Geometry.sc_off"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sc_off</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.scale">
<span class="sig-name descname"><span class="pre">scale</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scale</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">what</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'abc'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale_atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.scale"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.scale" title="Permalink to this definition"></a></dt>
<dd><p>Scale coordinates and unit-cell to get a new geometry with proper scaling</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>scale</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><em>array-like</em><em> of </em><em>floats with shape</em><em> (</em><em>3</em><em>,</em><em>)</em>) – the scale factor for the new geometry (lattice vectors, coordinates
and the atomic radii are scaled).</p></li>
<li><p><strong>what</strong> (<em>{&quot;abc&quot;</em><em>, </em><em>&quot;xyz&quot;}</em>) – If three different scale factors are provided, whether each scaling factor
is to be applied on the corresponding lattice vector (“abc”) or on the
corresponding cartesian coordinate (“xyz”).</p></li>
<li><p><strong>scale_atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – whether atoms (basis) should be scaled as well.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.set_nsc">
<span class="sig-name descname"><span class="pre">set_nsc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_nsc" title="Permalink to this definition"></a></dt>
<dd><p>Set the number of super-cells in the <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> object</p>
<p>See <a class="reference internal" href="#sisl.Geometry.set_nsc" title="sisl.Geometry.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_nsc</span></code></a> for allowed parameters.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell.set_nsc" title="sisl.SuperCell.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell.set_nsc</span></code></a></dt><dd><p>the underlying called method</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.set_sc">
<span class="sig-name descname"><span class="pre">set_sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_sc" title="Permalink to this definition"></a></dt>
<dd><p>Overwrites the local supercell</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.set_supercell">
<span class="sig-name descname"><span class="pre">set_supercell</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.Geometry.set_supercell" title="Permalink to this definition"></a></dt>
<dd><p>Overwrites the local supercell</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.sort">
<span class="sig-name descname"><span class="pre">sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a><span class="w"> </span><span class="p"><span class="pre">|</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><span class="pre">tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">List</span><span class="p"><span class="pre">]</span></span></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.sort"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.sort" title="Permalink to this definition"></a></dt>
<dd><p>Sort atoms in a nested fashion according to various criteria</p>
<p>There are many ways to sort a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a>.
- by Cartesian coordinates, <em class="xref py py-obj">axis</em>
- by lattice vectors, <em class="xref py py-obj">lattice</em>
- by user defined vectors, <em class="xref py py-obj">vector</em>
- by grouping atoms, <em class="xref py py-obj">group</em>
- by a user defined function, <em class="xref py py-obj">func</em>
- by a user defined function using internal sorting algorithm, <em class="xref py py-obj">func_sort</em></p>
<ul class="simple">
<li><p>a combination of the above in arbitrary order</p></li>
</ul>
<p>Additionally one may sort ascending or descending.</p>
<p>This method allows nested sorting based on keyword arguments.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only perform sorting algorithm for subset of atoms. This is <em>NOT</em> a positional dependent
argument. All sorting algorithms will _only_ be performed on these atoms.
Default, all atoms will be sorted.</p></li>
<li><p><strong>ret_atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – return a list of list for the groups of atoms that have been sorted.</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><em>tuple</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – sort coordinates according to Cartesian coordinates, if a tuple of
ints is passed it will be equivalent to <code class="docutils literal notranslate"><span class="pre">sort(axis0=axis[0],</span> <span class="pre">axis1=axis[1])</span></code>.
This behaves differently than <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html#numpy.lexsort" title="(in NumPy v1.24)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.lexsort</span></code></a>!</p></li>
<li><p><strong>lattice</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.11)"><em>tuple</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – sort coordinates according to lattice vectors, if a tuple of
ints is passed it will be equivalent to <code class="docutils literal notranslate"><span class="pre">sort(lattice0=lattice[0],</span> <span class="pre">lattice1=lattice[1])</span></code>.
Note that before sorting we multiply the fractional coordinates by the length of the
lattice vector. This ensures that <em class="xref py py-obj">atol</em> is meaningful for both <em class="xref py py-obj">axis</em> and <em class="xref py py-obj">lattice</em> since
they will be on the same order of magnitude.
This behaves differently than <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.lexsort.html#numpy.lexsort" title="(in NumPy v1.24)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.lexsort</span></code></a>!</p></li>
<li><p><strong>vector</strong> (<em>(</em><em>3</em><em>, </em><em>)</em><em>, </em><em>optional</em>) – sort along a user defined vector, similar to <em class="xref py py-obj">lattice</em> but with a user defined
direction. Note that <em class="xref py py-obj">lattice</em> sorting and <em class="xref py py-obj">vector</em> sorting are <em>only</em> equivalent
when the lattice vector is orthogonal to the other lattice vectors.</p></li>
<li><p><strong>group</strong> (<em>{'Z'</em><em>, </em><em>'symbol'</em><em>, </em><em>'tag'</em><em>, </em><em>'species'}</em><em> or </em><em>(</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>...</em><em>)</em><em>, </em><em>optional</em>) – group together a set of atoms by various means.
<em class="xref py py-obj">group</em> may be one of the listed strings.
For <code class="docutils literal notranslate"><span class="pre">'Z'</span></code> atoms will be grouped in atomic number
For <code class="docutils literal notranslate"><span class="pre">'symbol'</span></code> atoms will be grouped by their atomic symbol.
For <code class="docutils literal notranslate"><span class="pre">'tag'</span></code> atoms will be grouped by their atomic tag.
For <code class="docutils literal notranslate"><span class="pre">'species'</span></code> atoms will be sorted according to their specie index.
If a tuple/list is passed the first item is described. All subsequent items are a
list of groups, where each group comprises elements that should be sorted on an
equal footing. If one of the groups is None, that group will be replaced with all
non-mentioned elements. See examples.</p></li>
<li><p><strong>func</strong> (<em>callable</em><em> or </em><em>list-like</em><em> of </em><em>callable</em><em>, </em><em>optional</em>) – pass a sorting function which should have an interface like <code class="docutils literal notranslate"><span class="pre">func(geometry,</span> <span class="pre">atoms,</span> <span class="pre">**kwargs)</span></code>.
The first argument is the geometry to sort. The 2nd argument is a list of indices in
the current group of sorted atoms. And <code class="docutils literal notranslate"><span class="pre">**kwargs</span></code> are any optional arguments
currently collected, i.e. <em class="xref py py-obj">ascend</em>, <em class="xref py py-obj">atol</em> etc.
The function should return either a list of atoms, or a list of list of atoms (in which
case the atomic indices have been split into several groups that will be sorted individually
for subsequent sorting methods).
In either case the returned indices must never hold any other indices but the ones passed
as <code class="docutils literal notranslate"><span class="pre">atoms</span></code>.
If a list/tuple of functions, they will be processed in that order.</p></li>
<li><p><strong>func_sort</strong> (<em>callable</em><em> or </em><em>list-like</em><em> of </em><em>callable</em><em>, </em><em>optional</em>) – pass a function returning a 1D array corresponding to all atoms in the geometry.
The interface should simply be: <code class="docutils literal notranslate"><span class="pre">func(geometry)</span></code>.
Those values will be passed down to the internal sorting algorithm.
To be compatible with <em class="xref py py-obj">atol</em> the returned values from <em class="xref py py-obj">func_sort</em> should
be on the scale of coordinates (in Ang).</p></li>
<li><p><strong>ascend</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – control ascending or descending sorting for all subsequent sorting methods.
Default <code class="docutils literal notranslate"><span class="pre">ascend=True</span></code>.</p></li>
<li><p><strong>descend</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – control ascending or descending sorting for all subsequent sorting methods.
Default <code class="docutils literal notranslate"><span class="pre">ascend=True</span></code>.</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – absolute tolerance when sorting numerical arrays for subsequent sorting methods.
When a selection of sorted coordinates are grouped via <em class="xref py py-obj">atol</em>, we ensure such
a group does not alter its indices. I.e. the group is <em>always</em> ascending indices.
Note this may have unwanted side-effects if <em class="xref py py-obj">atol</em> is very large compared
to the difference between atomic coordinates.
Default <code class="docutils literal notranslate"><span class="pre">1e-9</span></code>.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>The order of arguments is also the sorting order. <code class="docutils literal notranslate"><span class="pre">sort(axis=0,</span> <span class="pre">lattice=0)</span></code> is different
from <code class="docutils literal notranslate"><span class="pre">sort(lattice=0,</span> <span class="pre">axis=0)</span></code></p>
<p>All arguments may be suffixed with integers. This allows multiple keyword arguments
to control sorting algorithms
in different order. It also allows changing of sorting settings between different calls.
Note that the integers have no relevance to the order of execution!
See examples.</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><ul class="simple">
<li><p><strong>geometry</strong> (<em>Geometry</em>) – sorted geometry</p></li>
<li><p><strong>index</strong> (<em>list of list of indices</em>) – indices that would sort the original structure to the output, only returned if <em class="xref py py-obj">ret_atoms</em> is True</p></li>
</ul>
</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">bilayer</span><span class="p">(</span><span class="n">top_atoms</span><span class="o">=</span><span class="n">sisl</span><span class="o">.</span><span class="n">Atom</span><span class="p">[</span><span class="mi">5</span><span class="p">,</span> <span class="mi">7</span><span class="p">],</span> <span class="n">bottom_atoms</span><span class="o">=</span><span class="n">sisl</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="mi">6</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Sort according to <span class="math notranslate nohighlight">\(x\)</span> coordinate</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Sort according to <span class="math notranslate nohighlight">\(z\)</span>, then <span class="math notranslate nohighlight">\(x\)</span> for each group created from first sort</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
</pre></div>
</div>
<p>Sort according to <span class="math notranslate nohighlight">\(z\)</span>, then first lattice vector</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Sort according to <span class="math notranslate nohighlight">\(z\)</span> (ascending), then first lattice vector (descending)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ascend</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Sort according to <span class="math notranslate nohighlight">\(z\)</span> (descending), then first lattice vector (ascending)
Note how integer suffixes has no importance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ascend1</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ascend0</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
<p>Sort only atoms <code class="docutils literal notranslate"><span class="pre">range(1,</span> <span class="pre">5)</span></code> first by <span class="math notranslate nohighlight">\(z\)</span>, then by first lattice vector</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">))</span>
</pre></div>
</div>
<p>Sort two groups of atoms <code class="docutils literal notranslate"><span class="pre">[range(1,</span> <span class="pre">5),</span> <span class="pre">range(5,</span> <span class="pre">10)]</span></code> (individually) by <span class="math notranslate nohighlight">\(z\)</span> coordinate</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">10</span><span class="p">)])</span>
</pre></div>
</div>
<p>The returned sorting indices may be used for manual sorting. Note
however, that this requires one to perform a sorting for all atoms.
In such a case the following sortings are equal.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom0</span><span class="p">,</span> <span class="n">atoms0</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ret_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">_</span><span class="p">,</span> <span class="n">atoms1</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">ret_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom1</span><span class="p">,</span> <span class="n">atoms1</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">lattice</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms1</span><span class="p">,</span> <span class="n">ret_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom2</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">atoms0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom3</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">atoms1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">geom0</span> <span class="o">==</span> <span class="n">geom1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">geom0</span> <span class="o">==</span> <span class="n">geom2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">geom0</span> <span class="o">==</span> <span class="n">geom3</span>
</pre></div>
</div>
<p>Default sorting is equivalent to <code class="docutils literal notranslate"><span class="pre">axis=(0,</span> <span class="pre">1,</span> <span class="pre">2)</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Sort along a user defined vector <code class="docutils literal notranslate"><span class="pre">[2.2,</span> <span class="pre">1.,</span> <span class="pre">0.]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">vector</span><span class="o">=</span><span class="p">[</span><span class="mf">2.2</span><span class="p">,</span> <span class="mf">1.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">])</span>
</pre></div>
</div>
<p>Integer specification has no influence on the order of operations.
It is _always_ the keyword argument order that determines the operation.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis2</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis0</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</pre></div>
</div>
<p>Sort by atomic numbers</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="s1">&#39;Z&#39;</span><span class="p">)</span> <span class="c1"># 5, 6, 7</span>
</pre></div>
</div>
<p>One may group several elements together on an equal footing (<code class="docutils literal notranslate"><span class="pre">None</span></code> means all non-mentioned elements)
The order of the groups are important (the first two are _not_ equal, the last three _are_ equal)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;symbol&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># C will be sorted along z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="n">axis1</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span> <span class="c1"># all along y, then C sorted along z</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;symbol&#39;</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span> <span class="c1"># C, [B, N]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;symbol&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span> <span class="c1"># [B, N], C</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;symbol&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;N&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">],</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span> <span class="c1"># [B, N], C (B and N unaltered order)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;symbol&#39;</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;B&#39;</span><span class="p">,</span> <span class="s1">&#39;N&#39;</span><span class="p">],</span> <span class="s1">&#39;C&#39;</span><span class="p">))</span> <span class="c1"># [B, N], C (B and N unaltered order)</span>
</pre></div>
</div>
<p>A group based sorting can use <em>anything</em> that can be fetched from the <a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a> object,
sort first according to mass, then for all with the same mass, sort according to atomic
tag:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">group0</span><span class="o">=</span><span class="s1">&#39;mass&#39;</span><span class="p">,</span> <span class="n">group1</span><span class="o">=</span><span class="s1">&#39;tag&#39;</span><span class="p">)</span>
</pre></div>
</div>
<p>A too high <em class="xref py py-obj">atol</em> may have unexpected side-effects. This is because of the way
the sorting algorithm splits the sections for nested sorting.
So for coordinates with a continuous displacement the sorting may break and group
a large range into 1 group. Consider the following array to be split in groups
while sorting.</p>
<p>An example would be a linear chain with a middle point with a much shorter distance.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">x</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span> <span class="o">-=</span> <span class="mf">0.095</span>
<span class="go">y = z = np.zeros(5)</span>
<span class="go">geom = si.Geometry(np.stack((x, y, z), axis=1))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
<span class="go">[0.    0.1   0.2   0.205 0.305]</span>
</pre></div>
</div>
<p>In this case a high tolerance (<code class="docutils literal notranslate"><span class="pre">atol&gt;0.005</span></code>) would group atoms 2 and 3
together</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">atol</span><span class="o">=</span><span class="mf">0.01</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ret_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[[0], [1], [2, 3], [4]]</span>
</pre></div>
</div>
<p>However, a very low tolerance will not find these two as atoms close
to each other.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">atol</span><span class="o">=</span><span class="mf">0.001</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ret_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
<span class="go">[[0], [1], [2], [3], [4]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.sparserij">
<span class="sig-name descname"><span class="pre">sparserij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype=&lt;class</span> <span class="pre">'numpy.float64'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">na_iR=1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method='rand'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.sparserij"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.sparserij" title="Permalink to this definition"></a></dt>
<dd><p>Return the sparse matrix with all distances in the matrix</p>
<p>The sparse matrix will only be defined for the elements which have
orbitals overlapping with other atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v1.24)"><em>numpy.dtype</em></a><em>, </em><em>numpy.float64</em>) – the data-type of the sparse matrix</p></li>
<li><p><strong>na_iR</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>1000</em>) – number of atoms within the sphere for speeding
up the <a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a> loop.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em>, </em><em>optional</em>) – see <a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a> for details</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p>sparse matrix with all rij elements</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p><a class="reference internal" href="sisl.SparseAtom.html#sisl.SparseAtom" title="sisl.SparseAtom">SparseAtom</a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.iter_block" title="sisl.Geometry.iter_block"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_block</span></code></a></dt><dd><p>the method for looping the atoms</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.distance" title="sisl.Geometry.distance"><code class="xref py py-obj docutils literal notranslate"><span class="pre">distance</span></code></a></dt><dd><p>create a list of distances</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.sub"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.sub" title="Permalink to this definition"></a></dt>
<dd><p>Create a new <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> with a subset of this <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a></p>
<p>Indices passed <em>MUST</em> be unique.</p>
<p>Negative indices are wrapped and thus works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em>) – indices/boolean of all atoms to be removed</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell.fit" title="sisl.SuperCell.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell.fit</span></code></a></dt><dd><p>update the supercell according to a reference supercell</p>
</dd>
<dt><a class="reference internal" href="#sisl.Geometry.remove" title="sisl.Geometry.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a></dt><dd><p>the negative of this routine, i.e. remove a subset of atoms</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.sub_orbital">
<span class="sig-name descname"><span class="pre">sub_orbital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.sub_orbital"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.sub_orbital" title="Permalink to this definition"></a></dt>
<dd><p>Retain only a subset of the orbitals on <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> according to <a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p>
<p>This allows one to retain only a given subset of geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><em>Atom</em></a>) – indices of atoms or <a class="reference internal" href="sisl.Atom.html#sisl.Atom" title="sisl.Atom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Atom</span></code></a> that will be reduced in size according to <a class="reference internal" href="#sisl.Geometry.orbitals" title="sisl.Geometry.orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbitals</span></code></a></p></li>
<li><p><strong>orbitals</strong> (<em>array_like</em><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><a class="reference internal" href="sisl.Orbital.html#sisl.Orbital" title="sisl.Orbital"><em>Orbital</em></a>) – indices of the orbitals on <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> that are retained in the geometry, the list of
orbitals will be sorted.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Future implementations may allow one to re-arange orbitals using this method.</p>
<p>When using this method the internal species list will be populated by another specie
that is named after the orbitals removed. This is to distinguish different atoms.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># a Carbon atom with 2 orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># an oxygen atom with 3 orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometry</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]],</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">O</span><span class="p">])</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">geometry</span></code> is a geometry with 2 different species and 6 atoms (3 of each).
They are ordered <code class="docutils literal notranslate"><span class="pre">[C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O]</span></code>. In the following we
will note species that are different from the original by a <code class="docutils literal notranslate"><span class="pre">'</span></code> in the list.</p>
<p>Retain 2nd orbital on the 2nd atom: <code class="docutils literal notranslate"><span class="pre">[C,</span> <span class="pre">O',</span> <span class="pre">C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_geom</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 2nd orbital on 1st and 2nd atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O',</span> <span class="pre">C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_geom</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 2nd orbital on the 1st atom and 3rd orbital on 4th atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O',</span> <span class="pre">C,</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_geom</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 2nd orbital on all atoms equivalent to the first atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O,</span> <span class="pre">C',</span> <span class="pre">O,</span> <span class="pre">C',</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_geom</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 1st orbital on 1st atom, and 2nd orbital on 3rd and 5th atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O,</span> <span class="pre">C'',</span> <span class="pre">O,</span> <span class="pre">C'',</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_geom</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.remove_orbital" title="sisl.Geometry.remove_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_orbital</span></code></a></dt><dd><p>removing a set of orbitals (opposite of this)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.swap">
<span class="sig-name descname"><span class="pre">swap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_b</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.swap"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.swap" title="Permalink to this definition"></a></dt>
<dd><p>Swap a set of atoms in the geometry and return a new one</p>
<p>This can be used to reorder elements of a geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms_a</strong> (<em>array_like</em>) – the first list of atomic coordinates</p></li>
<li><p><strong>atoms_b</strong> (<em>array_like</em>) – the second list of atomic coordinates</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.swapaxes">
<span class="sig-name descname"><span class="pre">swapaxes</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">axis_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis_b</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">what</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'cell+xyz'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.swapaxes"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.swapaxes" title="Permalink to this definition"></a></dt>
<dd><p>Swap the axis for the atomic coordinates and the cell vectors</p>
<p>If <code class="docutils literal notranslate"><span class="pre">swapaxes(0,1)</span></code> it returns the 0 and 1 values
swapped in the <code class="docutils literal notranslate"><span class="pre">cell</span></code> variable.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis_a</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – axis 1, swaps with <em class="xref py py-obj">b</em></p></li>
<li><p><strong>axis_b</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – axis 2, swaps with <em class="xref py py-obj">a</em></p></li>
<li><p><strong>what</strong> (<em>{'cell+xyz'</em><em>, </em><em>'cell'</em><em>, </em><em>'xyz'}</em>) – decide what to swap, if <em class="xref py py-obj">‘cell’</em> is in <em class="xref py py-obj">what</em> then
the cell axis are swapped.
if <em class="xref py py-obj">‘xyz’</em> is in <em class="xref py py-obj">what</em> then
the xyz (Cartesian) axis are swapped.
Both may be in <em class="xref py py-obj">what</em>.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.tile">
<span class="sig-name descname"><span class="pre">tile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.tile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.tile" title="Permalink to this definition"></a></dt>
<dd><p>Tile the geometry to create a bigger one</p>
<p>The atomic indices are retained for the base structure.</p>
<p>Tiling and repeating a geometry will result in the same geometry.
The <em>only</em> difference between the two is the final ordering of the atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – number of tiles (repetitions)</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – direction of tiling, 0, 1, 2 according to the cell-direction</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="p">[</span><span class="mf">0.5</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]],</span> <span class="n">sc</span><span class="o">=</span><span class="mf">1.</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> 
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> 
<span class="go">[[0.   0.   0. ]</span>
<span class="go"> [0.5  0.   0. ]</span>
<span class="go"> [1.   0.   0. ]</span>
<span class="go"> [1.5  0.   0. ]</span>
<span class="go"> [0.   1.   0. ]</span>
<span class="go"> [0.5  1.   0. ]</span>
<span class="go"> [1.   1.   0. ]</span>
<span class="go"> [1.5  1.   0. ]]</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.repeat" title="sisl.Geometry.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a></dt><dd><p>equivalent but different ordering of final structure</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">cut</span></code></dt><dd><p>opposite method of this</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.Geometry.to">
<span class="sig-name descname"><span class="pre">to</span></span><a class="headerlink" href="#sisl.Geometry.to" title="Permalink to this definition"></a></dt>
<dd><p>A dispatcher for classes, using <em class="xref py py-obj">__get__</em> it converts into <em class="xref py py-obj">ObjectDispatcher</em> upon invocation from an object, or a <em class="xref py py-obj">TypeDispatcher</em> when invoked from a class</p>
<p>This is a class-placeholder allowing a dispatcher to be a class attribute and converted into an
<em class="xref py py-obj">ObjectDispatcher</em> when invoked from an object.</p>
<p>If it is called on the class, it will return a <em class="xref py py-obj">TypeDispatcher</em>.</p>
<p>This class should be an attribute of a class. It heavily relies on the <em class="xref py py-obj">__get__</em> special
method.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>name</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a>) – name of the attribute in the class</p></li>
<li><p><strong>dispatchs</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.11)"><em>dict</em></a><em>, </em><em>optional</em>) – dictionary of dispatch methods</p></li>
<li><p><strong>obj_getattr</strong> (<em>callable</em><em>, </em><em>optional</em>) – method with 2 arguments, an <code class="docutils literal notranslate"><span class="pre">obj</span></code> and the <code class="docutils literal notranslate"><span class="pre">attr</span></code> which may be used
to control how the attribute is called.</p></li>
<li><p><strong>instance_dispatcher</strong> (<em>AbstractDispatcher</em><em>, </em><em>optional</em>) – control how instance dispatchers are handled through <em class="xref py py-obj">__get__</em> method.
This controls the dispatcher used if called from an instance.</p></li>
<li><p><strong>type_dispatcher</strong> (<em>AbstractDispatcher</em><em>, </em><em>optional</em>) – control how class dispatchers are handled through <em class="xref py py-obj">__get__</em> method.
This controls the dispatcher used if called from a class.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">class</span> <span class="nc">A</span><span class="p">:</span>
<span class="gp">... </span>  <span class="n">new</span> <span class="o">=</span> <span class="n">ClassDispatcher</span><span class="p">(</span><span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="n">obj_getattr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">sub</span><span class="p">,</span> <span class="n">attr</span><span class="p">))</span>
</pre></div>
</div>
<p>The above defers any attributes to the contained <em class="xref py py-obj">A.sub</em> attribute.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.translate">
<span class="sig-name descname"><span class="pre">translate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cell</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.translate"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.translate" title="Permalink to this definition"></a></dt>
<dd><p>Translates the geometry by <em class="xref py py-obj">v</em></p>
<p>One can translate a subset of the atoms by supplying <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a>.</p>
<p>Returns a copy of the structure translated by <em class="xref py py-obj">v</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em> or </em><em>array_like</em>) – the value or vector to displace all atomic coordinates
It should just be broad-castable with the geometry’s coordinates.</p></li>
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only displace the given atomic indices, if not specified, all
atoms will be displaced</p></li>
<li><p><strong>cell</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the supercell also gets enlarged by the vector</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.translate2uc">
<span class="sig-name descname"><span class="pre">translate2uc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">1,</span> <span class="pre">2)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.translate2uc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.translate2uc" title="Permalink to this definition"></a></dt>
<dd><p>Translates atoms in the geometry into the unit cell</p>
<p>One can translate a subset of the atoms or axes by appropriate arguments.</p>
<p>When coordinates are lying on one of the edges, they may move to the other
side of the unit-cell due to small rounding errors.
In such situations you are encouraged to shift all coordinates by a small
amount to remove numerical errors, in the following case we have atomic
coordinates lying close to the lower side of each lattice vector.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">geometry</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="mf">1e-8</span><span class="p">)</span><span class="o">.</span><span class="n">translate2uc</span><span class="p">()</span><span class="o">.</span><span class="n">move</span><span class="p">(</span><span class="o">-</span><span class="mf">1e-8</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only translate the given atomic indices, if not specified, all
atoms will be translated</p></li>
<li><p><strong>axes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em> or </em><em>array_like</em><em>, </em><em>optional</em>) – only translate certain lattice directions, defaults to all</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.uc2sc">
<span class="sig-name descname"><span class="pre">uc2sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">unique</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.24)"><span class="pre">ndarray</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.uc2sc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.uc2sc" title="Permalink to this definition"></a></dt>
<dd><p>Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<em>array_like</em><em> or </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the atomic unit-cell indices to be converted to supercell indices</p></li>
<li><p><strong>unique</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True the returned indices are unique and sorted.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.unrepeat">
<span class="sig-name descname"><span class="pre">unrepeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.unrepeat"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.unrepeat" title="Permalink to this definition"></a></dt>
<dd><p>Unrepeats the geometry similarly as <a class="reference internal" href="#sisl.Geometry.untile" title="sisl.Geometry.untile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">untile</span></code></a></p>
<p>Please see <a class="reference internal" href="#sisl.Geometry.untile" title="sisl.Geometry.untile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">untile</span></code></a> for argument details, the algorithm and arguments are the same however,
this is the opposite of <a class="reference internal" href="#sisl.Geometry.repeat" title="sisl.Geometry.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.untile">
<span class="sig-name descname"><span class="pre">untile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rtol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0001</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></span></span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.untile"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.untile" title="Permalink to this definition"></a></dt>
<dd><p>A subset of atoms from the geometry by cutting the geometry into <em class="xref py py-obj">reps</em> parts along the direction <em class="xref py py-obj">axis</em>.</p>
<p>This will effectively change the unit-cell in the <em class="xref py py-obj">axis</em> as-well
as removing <code class="docutils literal notranslate"><span class="pre">self.na/reps</span></code> atoms.
It requires that <code class="docutils literal notranslate"><span class="pre">self.na</span> <span class="pre">%</span> <span class="pre">reps</span> <span class="pre">==</span> <span class="pre">0</span></code>.</p>
<p>REMARK: You need to ensure that all atoms within the first
cut out region are within the primary unit-cell.</p>
<p>Doing <code class="docutils literal notranslate"><span class="pre">geom.untile(2,</span> <span class="pre">1).tile(2,</span> <span class="pre">1)</span></code>, could for symmetric setups,
be equivalent to a no-op operation. A <code class="docutils literal notranslate"><span class="pre">UserWarning</span></code> will be issued
if this is not the case.</p>
<p>This method may be regarded as the opposite of <a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – number of times the structure will be cut (untiled)</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a>) – the axis that will be cut</p></li>
<li><p><strong>segment</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.11)"><em>int</em></a><em>, </em><em>optional</em>) – returns the i’th segment of the untiled structure
Currently the atomic coordinates are not translated,
this may change in the future.</p></li>
<li><p><strong>rtol</strong> ((tolerance for checking tiling, see <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.allclose.html#numpy.allclose" title="(in NumPy v1.24)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.allclose</span></code></a>)) – </p></li>
<li><p><strong>atol</strong> ((tolerance for checking tiling, see <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.allclose.html#numpy.allclose" title="(in NumPy v1.24)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.allclose</span></code></a>)) – </p></li>
</ul>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">g</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">geom</span><span class="o">.</span><span class="n">graphene</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">gxyz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">G</span> <span class="o">=</span> <span class="n">gxyz</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">G</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.tile" title="sisl.Geometry.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>opposite method of this</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.Geometry.volume">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">volume</span></span><a class="headerlink" href="#sisl.Geometry.volume" title="Permalink to this definition"></a></dt>
<dd><p>Returns the inherent <a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><code class="xref py py-obj docutils literal notranslate"><span class="pre">SuperCell</span></code></a> objects <a class="reference internal" href="#sisl.Geometry.volume" title="sisl.Geometry.volume"><code class="xref py py-obj docutils literal notranslate"><span class="pre">volume</span></code></a></p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.within">
<span class="sig-name descname"><span class="pre">within</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shapes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_rij</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_isc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.within"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.within" title="Permalink to this definition"></a></dt>
<dd><p>Indices of atoms in the entire supercell within a given shape from a given coordinate</p>
<p>This heavily relies on the <a class="reference internal" href="#sisl.Geometry.within_sc" title="sisl.Geometry.within_sc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within_sc</span></code></a> method.</p>
<p>Note that if a connection is made in a neighbouring super-cell
then the atomic index is shifted by the super-cell index times
number of atoms.
This allows one to decipher super-cell atoms from unit-cell atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shapes</strong> (<a class="reference internal" href="sisl.shape.Shape.html#sisl.shape.Shape" title="sisl.shape.Shape"><em>Shape</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><a class="reference internal" href="sisl.shape.Shape.html#sisl.shape.Shape" title="sisl.shape.Shape"><em>Shape</em></a>) – </p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em>, </em><em>optional</em>) – List of indices for atoms that are to be considered</p></li>
<li><p><strong>atoms_xyz</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The atomic coordinates of the equivalent <a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> variable (<a class="reference internal" href="#sisl.Geometry.atoms" title="sisl.Geometry.atoms"><code class="xref py py-obj docutils literal notranslate"><span class="pre">atoms</span></code></a> must also be passed)</p></li>
<li><p><strong>ret_xyz</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If true this method will return the coordinates
for each of the couplings.</p></li>
<li><p><strong>ret_rij</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If true this method will return the distances from the <em class="xref py py-obj">xyz_ia</em>
for each of the couplings.</p></li>
<li><p><strong>ret_isc</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If true this method will return the supercell offsets for each of the couplings.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>index</em> – indices of atoms (in supercell indices) within the shape</p></li>
<li><p><em>xyz</em> – atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p></li>
<li><p><em>rij</em> – distance of the indexed atoms to the center of the shape (only for true <em class="xref py py-obj">ret_rij</em>)</p></li>
<li><p><em>isc</em> – supercell indices of the couplings (only for true <em class="xref py py-obj">ret_isc</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.within_inf">
<span class="sig-name descname"><span class="pre">within_inf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">periodic</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">tol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-05</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">origin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.within_inf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.within_inf" title="Permalink to this definition"></a></dt>
<dd><p>Find all atoms within a provided supercell</p>
<p>Note this function is rather different from <a class="reference internal" href="#sisl.Geometry.close" title="sisl.Geometry.close"><code class="xref py py-obj docutils literal notranslate"><span class="pre">close</span></code></a> and <a class="reference internal" href="#sisl.Geometry.within" title="sisl.Geometry.within"><code class="xref py py-obj docutils literal notranslate"><span class="pre">within</span></code></a>.
Specifically this routine is returning <em>all</em> indices for the infinite
periodic system (where <code class="docutils literal notranslate"><span class="pre">self.nsc</span> <span class="pre">&gt;</span> <span class="pre">1</span></code> or <em class="xref py py-obj">periodic</em> is true).</p>
<p>Atomic coordinates lying on the boundary of the supercell will be duplicated
on the neighbouring supercell images. Thus performing <em class="xref py py-obj">geom.within_inf(geom.sc)</em>
may result in more atoms than in the structure.</p>
<p class="rubric">Notes</p>
<p>The name of this function may change. Currently it should only be used
internally in sisl.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sc</strong> (<a class="reference internal" href="sisl.SuperCell.html#sisl.SuperCell" title="sisl.SuperCell"><em>SuperCell</em></a><em> or </em><em>SuperCellChild</em>) – the supercell in which this geometry should be expanded into.</p></li>
<li><p><strong>periodic</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a>) – explicitly define the periodic directions, by default the periodic
directions are only where <code class="docutils literal notranslate"><span class="pre">self.nsc</span> <span class="pre">&gt;</span> <span class="pre">1</span></code>.</p></li>
<li><p><strong>tol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – length tolerance for the fractional coordinates to be on a duplicate site (in Ang).
This allows atoms within <em class="xref py py-obj">tol</em> of the cell boundaries to be taken as <em>inside</em> the
cell.</p></li>
<li><p><strong>origin</strong> (<em>(</em><em>3</em><em>,</em><em>) of </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.11)"><em>float</em></a><em>, </em><em>optional</em>) – origin that is the basis for comparison, default to 0.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>numpy.ndarray</em> – unit-cell atomic indices which are inside the <em class="xref py py-obj">sc</em> cell</p></li>
<li><p><em>numpy.ndarray</em> – atomic coordinates for the <em class="xref py py-obj">ia</em> atoms (including supercell offsets)</p></li>
<li><p><em>numpy.ndarray</em> – integer supercell offsets for <em class="xref py py-obj">ia</em> atoms</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.within_sc">
<span class="sig-name descname"><span class="pre">within_sc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">shapes</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_xyz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_rij</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.within_sc"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.within_sc" title="Permalink to this definition"></a></dt>
<dd><p>Indices of atoms in a given supercell within a given shape from a given coordinate</p>
<p>This returns a set of atomic indices which are within a
sphere of radius <code class="docutils literal notranslate"><span class="pre">R</span></code>.</p>
<p>If R is a tuple/list/array it will return the indices:
in the ranges:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="p">(</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">x</span> <span class="o">&lt;=</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>shapes</strong> (<a class="reference internal" href="sisl.shape.Shape.html#sisl.shape.Shape" title="sisl.shape.Shape"><em>Shape</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.11)"><em>list</em></a><em> of </em><a class="reference internal" href="sisl.shape.Shape.html#sisl.shape.Shape" title="sisl.shape.Shape"><em>Shape</em></a>) – <p>A list of increasing shapes that define the extend of the geometric
volume that is searched.
It is vital that:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">shapes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="n">shapes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">...</span>
</pre></div>
</div>
</p></li>
<li><p><strong>isc</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The super-cell which the coordinates are checked in. Defaults to <code class="docutils literal notranslate"><span class="pre">[0,</span> <span class="pre">0,</span> <span class="pre">0]</span></code></p></li>
<li><p><strong>atoms</strong> (<em>array_like</em><em>, </em><em>optional</em>) – List of atoms that will be considered. This can
be used to only take out a certain atoms.</p></li>
<li><p><strong>atoms_xyz</strong> (<em>array_like</em><em>, </em><em>optional</em>) – The atomic coordinates of the equivalent <em class="xref py py-obj">idx</em> variable (<em class="xref py py-obj">idx</em> must also be passed)</p></li>
<li><p><strong>ret_xyz</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True this method will return the coordinates
for each of the couplings.</p></li>
<li><p><strong>ret_rij</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.11)"><em>bool</em></a><em>, </em><em>optional</em>) – If True this method will return the distance to the center of the shapes</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><ul class="simple">
<li><p><em>index</em> – indices of atoms (in supercell indices) within the shape</p></li>
<li><p><em>xyz</em> – atomic coordinates of the indexed atoms (only for true <em class="xref py py-obj">ret_xyz</em>)</p></li>
<li><p><em>rij</em> – distance of the indexed atoms to the center of the shape (only for true <em class="xref py py-obj">ret_rij</em>)</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.Geometry.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/geometry.html#Geometry.write"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.Geometry.write" title="Permalink to this definition"></a></dt>
<dd><p>Writes geometry to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> using <em class="xref py py-obj">sile.write_geometry</em></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sile</strong> (<a class="reference internal" href="../io/generated/sisl.io.Sile.html#sisl.io.Sile" title="sisl.io.Sile"><em>Sile</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.11)"><em>str</em></a><em> or </em><a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.11)"><em>pathlib.Path</em></a>) – a <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code> object which will be used to write the geometry
if it is a string it will create a new sile using <code class="xref py py-obj docutils literal notranslate"><span class="pre">get_sile</span></code></p></li>
<li><p><strong>*args</strong> – Any other args will be passed directly to the
underlying routine</p></li>
<li><p><strong>**kwargs</strong> – Any other args will be passed directly to the
underlying routine</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.Geometry.read" title="sisl.Geometry.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a></dt><dd><p>reads a <a class="reference internal" href="#sisl.Geometry" title="sisl.Geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry</span></code></a> from a given <code class="xref py py-obj docutils literal notranslate"><span class="pre">Sile</span></code>/file</p>
</dd>
</dl>
</div>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sisl.Atoms.html" class="btn btn-neutral float-left" title="sisl.Atoms" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sisl.SuperCell.html" class="btn btn-neutral float-right" title="sisl.SuperCell" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2023, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>