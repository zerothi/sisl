

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.physics.DensityMatrix &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../_static/documentation_options.js?v=7b70f75b"></script>
      <script src="../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="next" title="sisl.physics.Hamiltonian" href="sisl.physics.Hamiltonian.html" />
    <link rel="prev" title="sisl.physics.EnergyDensityMatrix" href="sisl.physics.EnergyDensityMatrix.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="../index.html">API reference</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../basic.html">Basic classes</a></li>
<li class="toctree-l2"><a class="reference internal" href="../geom/index.html">Geometry handling (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.geom</span></code>)</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../physics.html">Physical objects (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.physics</span></code>)</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../physics.brillouinzone.html">Brillouin zone</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../physics.matrix.html">Physical quantites</a><ul class="current">
<li class="toctree-l4"><a class="reference internal" href="../physics.matrix.html#spin">Spin</a></li>
<li class="toctree-l4 current"><a class="reference internal" href="../physics.matrix.html#matrices">Matrices</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics.matrix.html#self-energies">Self energies</a></li>
<li class="toctree-l4"><a class="reference internal" href="../physics.matrix.html#bloch-s-theorem">Bloch’s theorem</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../physics.electron.html">Electron related functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics.phonon.html">Phonon related functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics.distribution.html">Distribution functions</a></li>
<li class="toctree-l3"><a class="reference internal" href="../physics.html#low-level-objects">Low level objects</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../mixing.html">Mixing (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.mixing</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../viz/index.html">Visualization</a></li>
<li class="toctree-l2"><a class="reference internal" href="../unit_constant.html">Units and constants</a></li>
<li class="toctree-l2"><a class="reference internal" href="../utilities.html">Utilities (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.utils</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../core.html">Functional programming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../io/index.html">Input/Output (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.io</span></code>)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../typing.html">Typing (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.typing</span></code>)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">API reference</a></li>
          <li class="breadcrumb-item"><a href="../physics.html">Physical objects (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.physics</span></code>)</a></li>
          <li class="breadcrumb-item"><a href="../physics.matrix.html">Physical quantites</a></li>
      <li class="breadcrumb-item active">sisl.physics.DensityMatrix</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../_sources/api/generated/sisl.physics.DensityMatrix.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sisl-physics-densitymatrix">
<h1>sisl.physics.DensityMatrix<a class="headerlink" href="#sisl-physics-densitymatrix" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sisl.physics.</span></span><span class="sig-name descname"><span class="pre">DensityMatrix</span></span><a class="headerlink" href="#sisl.physics.DensityMatrix" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference internal" href="sisl.physics.densitymatrix._densitymatrix.html#sisl.physics.densitymatrix._densitymatrix" title="sisl.physics.densitymatrix._densitymatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">_densitymatrix</span></code></a></p>
<p>Sparse density matrix object</p>
<p>Assigning or changing elements is as easy as with standard <a class="reference external" href="https://numpy.org/doc/stable/reference/index.html#module-numpy" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy</span></code></a> assignments:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">DM</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">DM</span><span class="o">.</span><span class="n">D</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.1</span>
</pre></div>
</div>
<p>which assigns 0.1 as the density element between orbital 2 and 3.
(remember that Python is 0-based elements).</p>
<p>For spin matrices the elements are defined with an extra dimension.</p>
<p>For a polarized matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="s2">&quot;polarized&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># onsite spin up</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># onsite spin down</span>
</pre></div>
</div>
<p>For non-colinear the indices are a bit more tricky:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="s2">&quot;non-colinear&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M11</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Re(up-up)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M22</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Re(down-down)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M12r</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Re(up-down)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M12i</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Im(up-down)</span>
</pre></div>
</div>
<p>For spin-orbit it looks like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="s2">&quot;spin-orbit&quot;</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M11r</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Re(up-up)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M11i</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Im(up-up)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M22r</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Re(down-down)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M22i</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Im(down-down)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M12r</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Re(up-down)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M12i</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Im(up-down)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M21r</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Re(down-up)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">M</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">M</span><span class="o">.</span><span class="n">M21i</span><span class="p">]</span> <span class="o">=</span> <span class="c1"># Im(down-up)</span>
</pre></div>
</div>
<p>Thus the number of <em>orbitals</em> is unchanged but a sub-block exists for
the spin-block.</p>
<p>When transferring the matrix to a k-point the spin-box is local to each
orbital, meaning that the spin-box for orbital i will be:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">Dk</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">Dk</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">Dk</span><span class="p">[</span><span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="n">i</span><span class="o">*</span><span class="mi">2</span><span class="p">:(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">2</span><span class="p">]</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geometry</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Geometry</span></code>) – parent geometry to create a density matrix from. The density matrix will
have size equivalent to the number of orbitals in the geometry</p></li>
<li><p><strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin" title="sisl.physics.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a>, <em>optional</em>) – number of components per element, may be a <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin" title="sisl.physics.Spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin</span></code></a> object</p></li>
<li><p><strong>dtype</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">np.dtype</span></code>, <em>optional</em>) – data type contained in the density matrix. See details of <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin" title="sisl.physics.Spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin</span></code></a> for default values.</p></li>
<li><p><strong>nnzpr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – number of initially allocated memory per orbital in the density matrix.
For increased performance this should be larger than the actual number of entries
per orbital.</p></li>
<li><p><strong>spin</strong> (<a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin" title="sisl.physics.Spin"><code class="xref py py-class docutils literal notranslate"><span class="pre">Spin</span></code></a>, <em>optional</em>) – equivalent to <a class="reference internal" href="#sisl.physics.DensityMatrix.dim" title="sisl.physics.DensityMatrix.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a> argument. This keyword-only argument has precedence over <a class="reference internal" href="#sisl.physics.DensityMatrix.dim" title="sisl.physics.DensityMatrix.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a>.</p></li>
<li><p><strong>orthogonal</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>optional</em>) – whether the density matrix corresponds to a non-orthogonal basis. In this case
the dimensionality of the density matrix is one more than <a class="reference internal" href="#sisl.physics.DensityMatrix.dim" title="sisl.physics.DensityMatrix.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a>.
This is a keyword-only argument.</p></li>
</ul>
</dd>
</dl>
<p class="rubric">Plotting</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.plot" title="sisl.physics.DensityMatrix.plot"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot</span></code></a></p></td>
<td><p>Plotting functions for the <em class="xref py py-obj">SparseOrbital</em> class.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.plot.atomicmatrix" title="sisl.physics.DensityMatrix.plot.atomicmatrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">plot.atomicmatrix</span></code></a>([dim, isc, ...])</p></td>
<td><p>Builds a <code class="docutils literal notranslate"><span class="pre">AtomicMatrixPlot</span></code> by setting the value of &quot;matrix&quot; to the current object.</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.Dk" title="sisl.physics.DensityMatrix.Dk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dk</span></code></a>([k, dtype, gauge, format])</p></td>
<td><p>Setup the density matrix for a given k-point</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.Rij" title="sisl.physics.DensityMatrix.Rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Rij</span></code></a>([what, dtype])</p></td>
<td><p>Create a sparse matrix with the vectors between atoms/orbitals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.Sk" title="sisl.physics.DensityMatrix.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a>([k, dtype, gauge, format])</p></td>
<td><p>Setup the overlap matrix for a given k-point</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.add" title="sisl.physics.DensityMatrix.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a>(other[, axis, offset])</p></td>
<td><p>Add two sparse matrices by adding the parameters to one set.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a>(other, axis[, atol, scale])</p></td>
<td><p>Append <em class="xref py py-obj">other</em> along <em class="xref py py-obj">axis</em> to construct a new connected sparse matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.astype" title="sisl.physics.DensityMatrix.astype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">astype</span></code></a>(dtype, *[, copy])</p></td>
<td><p>Convert the sparse matrix to a specific <a class="reference internal" href="#sisl.physics.DensityMatrix.dtype" title="sisl.physics.DensityMatrix.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.bond_order" title="sisl.physics.DensityMatrix.bond_order"><code class="xref py py-obj docutils literal notranslate"><span class="pre">bond_order</span></code></a>([method, projection])</p></td>
<td><p>Bond-order calculation using various methods</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.construct" title="sisl.physics.DensityMatrix.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a>(func[, na_iR, method, eta])</p></td>
<td><p>Automatically construct the sparse model based on a function that does the setting up of the elements</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.copy" title="sisl.physics.DensityMatrix.copy"><code class="xref py py-obj docutils literal notranslate"><span class="pre">copy</span></code></a>([dtype])</p></td>
<td><p>A copy of this object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.create_construct" title="sisl.physics.DensityMatrix.create_construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_construct</span></code></a>(R, params)</p></td>
<td><p>Create a simple function for passing to the <a class="reference internal" href="#sisl.physics.DensityMatrix.construct" title="sisl.physics.DensityMatrix.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a> function.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.dDk" title="sisl.physics.DensityMatrix.dDk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dDk</span></code></a>([k, dtype, gauge, format])</p></td>
<td><p>Setup the density matrix derivative for a given k-point</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.dSk" title="sisl.physics.DensityMatrix.dSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dSk</span></code></a>([k, dtype, gauge, format])</p></td>
<td><p>Setup the <span class="math notranslate nohighlight">\(\mathbf k\)</span>-derivatie of the overlap matrix for a given k-point</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.ddDk" title="sisl.physics.DensityMatrix.ddDk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddDk</span></code></a>([k, dtype, gauge, format])</p></td>
<td><p>Setup the density matrix double derivative for a given k-point</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.ddSk" title="sisl.physics.DensityMatrix.ddSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddSk</span></code></a>([k, dtype, gauge, format])</p></td>
<td><p>Setup the double <span class="math notranslate nohighlight">\(\mathbf k\)</span>-derivatie of the overlap matrix for a given k-point</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.density" title="sisl.physics.DensityMatrix.density"><code class="xref py py-obj docutils literal notranslate"><span class="pre">density</span></code></a>(grid[, spinor, atol, eta, method])</p></td>
<td><p>Expand the density matrix to the charge density on a grid</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.edges" title="sisl.physics.DensityMatrix.edges"><code class="xref py py-obj docutils literal notranslate"><span class="pre">edges</span></code></a>([atoms, exclude, orbitals])</p></td>
<td><p>Retrieve edges (connections) for all <em class="xref py py-obj">atoms</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.eig" title="sisl.physics.DensityMatrix.eig"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eig</span></code></a>([k, gauge, eigvals_only])</p></td>
<td><p>Returns the eigenvalues of the physical quantity (using the non-Hermitian solver)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.eigh" title="sisl.physics.DensityMatrix.eigh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigh</span></code></a>([k, gauge, eigvals_only])</p></td>
<td><p>Returns the eigenvalues of the physical quantity</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.eigsh" title="sisl.physics.DensityMatrix.eigsh"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigsh</span></code></a>([k, n, gauge, eigvals_only])</p></td>
<td><p>Calculates a subset of eigenvalues of the physical quantity using sparse matrices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.eliminate_zeros" title="sisl.physics.DensityMatrix.eliminate_zeros"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eliminate_zeros</span></code></a>(*args, **kwargs)</p></td>
<td><p>Removes all zero elements from the sparse matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.empty" title="sisl.physics.DensityMatrix.empty"><code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code></a>([keep_nnz])</p></td>
<td><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">empty</span></code> for details</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.finalize" title="sisl.physics.DensityMatrix.finalize"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finalize</span></code></a>(*args, **kwargs)</p></td>
<td><p>Finalizes the model</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.fromsp" title="sisl.physics.DensityMatrix.fromsp"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fromsp</span></code></a>(geometry, P[, S])</p></td>
<td><p>Create a sparse model from a preset <em class="xref py py-obj">Geometry</em> and a list of sparse matrices</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.iter_nnz" title="sisl.physics.DensityMatrix.iter_nnz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_nnz</span></code></a>([atoms, orbitals])</p></td>
<td><p>Iterations of the non-zero elements</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.iter_orbitals" title="sisl.physics.DensityMatrix.iter_orbitals"><code class="xref py py-obj docutils literal notranslate"><span class="pre">iter_orbitals</span></code></a>([atoms, local])</p></td>
<td><p>Iterations of the orbital space in the geometry, two indices from loop</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.mulliken" title="sisl.physics.DensityMatrix.mulliken"><code class="xref py py-obj docutils literal notranslate"><span class="pre">mulliken</span></code></a>([projection])</p></td>
<td><p>Calculate Mulliken charges from the density matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.nonzero" title="sisl.physics.DensityMatrix.nonzero"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nonzero</span></code></a>([atoms, only_cols])</p></td>
<td><p>Indices row and column indices where non-zero elements exists</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.orbital_momentum" title="sisl.physics.DensityMatrix.orbital_momentum"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orbital_momentum</span></code></a>([projection, method])</p></td>
<td><p>Calculate orbital angular momentum on either atoms or orbitals</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.prepend" title="sisl.physics.DensityMatrix.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a>(other, axis[, atol, scale])</p></td>
<td><p>See <a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a> for details</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.prune_range" title="sisl.physics.DensityMatrix.prune_range"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prune_range</span></code></a>(*, R[, atoms, atoms_to])</p></td>
<td><p>Prune elements coupling further than <em class="xref py py-obj">R</em>.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.read" title="sisl.physics.DensityMatrix.read"><code class="xref py py-obj docutils literal notranslate"><span class="pre">read</span></code></a>(sile, *args, **kwargs)</p></td>
<td><p>Reads density matrix from <em class="xref py py-obj">Sile</em> using <em class="xref py py-obj">read_density_matrix</em>.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.remove" title="sisl.physics.DensityMatrix.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>(atoms)</p></td>
<td><p>Create a subset of this sparse matrix by removing the atoms corresponding to <em class="xref py py-obj">atoms</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.remove_orbital" title="sisl.physics.DensityMatrix.remove_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_orbital</span></code></a>(atoms, orbitals)</p></td>
<td><p>Remove a subset of orbitals on <em class="xref py py-obj">atoms</em> according to <em class="xref py py-obj">orbitals</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.repeat" title="sisl.physics.DensityMatrix.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>(reps, axis)</p></td>
<td><p>Create a repeated sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.repeat</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.replace" title="sisl.physics.DensityMatrix.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a>(atoms, other[, other_atoms, atol, scale])</p></td>
<td><p>Replace <em class="xref py py-obj">atoms</em> in <em class="xref py py-obj">self</em> with <em class="xref py py-obj">other_atoms</em> in <em class="xref py py-obj">other</em> and retain couplings between them</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.reset" title="sisl.physics.DensityMatrix.reset"><code class="xref py py-obj docutils literal notranslate"><span class="pre">reset</span></code></a>([dim, dtype, nnzpr])</p></td>
<td><p>The sparsity pattern has all elements removed and everything is reset.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.rij" title="sisl.physics.DensityMatrix.rij"><code class="xref py py-obj docutils literal notranslate"><span class="pre">rij</span></code></a>([what, dtype])</p></td>
<td><p>Create a sparse matrix with the distance between atoms/orbitals</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.set_nsc" title="sisl.physics.DensityMatrix.set_nsc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_nsc</span></code></a>(*args, **kwargs)</p></td>
<td><p>Reset the number of allowed supercells in the sparse orbital</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.spalign" title="sisl.physics.DensityMatrix.spalign"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spalign</span></code></a>(other)</p></td>
<td><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">align</span></code> for details</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.spin_align" title="sisl.physics.DensityMatrix.spin_align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_align</span></code></a>(vec[, atoms])</p></td>
<td><p>Aligns <em>all</em> spin along the vector <em class="xref py py-obj">vec</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.spin_rotate" title="sisl.physics.DensityMatrix.spin_rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_rotate</span></code></a>(rotation[, rad])</p></td>
<td><p>Rotate spin-boxes by fixed angles around the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes, respectively.</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.spsame" title="sisl.physics.DensityMatrix.spsame"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spsame</span></code></a>(other)</p></td>
<td><p>Compare two sparse objects and check whether they have the same entries.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.sub" title="sisl.physics.DensityMatrix.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>(atoms)</p></td>
<td><p>Create a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atoms</em></p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.sub_orbital" title="sisl.physics.DensityMatrix.sub_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_orbital</span></code></a>(atoms, orbitals)</p></td>
<td><p>Retain only a subset of the orbitals on <em class="xref py py-obj">atoms</em> according to <em class="xref py py-obj">orbitals</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.swap" title="sisl.physics.DensityMatrix.swap"><code class="xref py py-obj docutils literal notranslate"><span class="pre">swap</span></code></a>(atoms_a, atoms_b)</p></td>
<td><p>Swaps atoms in the sparse geometry to obtain a new order of atoms</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.tile" title="sisl.physics.DensityMatrix.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a>(reps, axis)</p></td>
<td><p>Create a tiled sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.tile</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.toSparseAtom" title="sisl.physics.DensityMatrix.toSparseAtom"><code class="xref py py-obj docutils literal notranslate"><span class="pre">toSparseAtom</span></code></a>([dim, dtype])</p></td>
<td><p>Convert the sparse object (without data) to a new sparse object with equivalent but reduced sparse pattern</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.tocsr" title="sisl.physics.DensityMatrix.tocsr"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tocsr</span></code></a>([dim, isc])</p></td>
<td><p>Return a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> for the specified dimension</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.transform" title="sisl.physics.DensityMatrix.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a>([matrix, dtype, spin, orthogonal])</p></td>
<td><p>Transform the matrix by either a matrix or new spin configuration</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.translate2uc" title="sisl.physics.DensityMatrix.translate2uc"><code class="xref py py-obj docutils literal notranslate"><span class="pre">translate2uc</span></code></a>([atoms, axes])</p></td>
<td><p>Translates all primary atoms to the unit cell.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.transpose" title="sisl.physics.DensityMatrix.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a>(*[, conjugate, spin, sort])</p></td>
<td><p>A transpose copy of this object with options for spin-box and conjugations</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.trs" title="sisl.physics.DensityMatrix.trs"><code class="xref py py-obj docutils literal notranslate"><span class="pre">trs</span></code></a>()</p></td>
<td><p>Return a matrix with applied time-reversal operator</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.unrepeat" title="sisl.physics.DensityMatrix.unrepeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">unrepeat</span></code></a>(reps, axis[, segment, sym])</p></td>
<td><p>Unrepeats the sparse model into different parts (retaining couplings)</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.untile" title="sisl.physics.DensityMatrix.untile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">untile</span></code></a>(reps, axis[, segment, sym])</p></td>
<td><p>Untiles the sparse model into different parts (retaining couplings)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.write" title="sisl.physics.DensityMatrix.write"><code class="xref py py-obj docutils literal notranslate"><span class="pre">write</span></code></a>(sile, *args, **kwargs)</p></td>
<td><p>Writes a density matrix to the <em class="xref py py-obj">Sile</em> as implemented in the <code class="code docutils literal notranslate"><span class="pre">Sile.write_density_matrix</span></code> method</p></td>
</tr>
</tbody>
</table>
<p class="rubric">Attributes</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.D" title="sisl.physics.DensityMatrix.D"><code class="xref py py-obj docutils literal notranslate"><span class="pre">D</span></code></a></p></td>
<td><p>Access the density matrix elements</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.S" title="sisl.physics.DensityMatrix.S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">S</span></code></a></p></td>
<td><p>Access the overlap elements associated with the sparse matrix</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.dim" title="sisl.physics.DensityMatrix.dim"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dim</span></code></a></p></td>
<td><p>Number of components per element</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.dkind" title="sisl.physics.DensityMatrix.dkind"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dkind</span></code></a></p></td>
<td><p>Data type of sparse elements (in str)</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.dtype" title="sisl.physics.DensityMatrix.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></p></td>
<td><p>Data type of sparse elements</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.finalized" title="sisl.physics.DensityMatrix.finalized"><code class="xref py py-obj docutils literal notranslate"><span class="pre">finalized</span></code></a></p></td>
<td><p>Whether the contained data is finalized and non-used elements have been removed</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.geometry" title="sisl.physics.DensityMatrix.geometry"><code class="xref py py-obj docutils literal notranslate"><span class="pre">geometry</span></code></a></p></td>
<td><p>Associated geometry</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.nnz" title="sisl.physics.DensityMatrix.nnz"><code class="xref py py-obj docutils literal notranslate"><span class="pre">nnz</span></code></a></p></td>
<td><p>Number of non-zero elements</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.non_orthogonal" title="sisl.physics.DensityMatrix.non_orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">non_orthogonal</span></code></a></p></td>
<td><p>True if the object is using a non-orthogonal basis</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.orthogonal" title="sisl.physics.DensityMatrix.orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthogonal</span></code></a></p></td>
<td><p>True if the object is using an orthogonal basis</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.shape" title="sisl.physics.DensityMatrix.shape"><code class="xref py py-obj docutils literal notranslate"><span class="pre">shape</span></code></a></p></td>
<td><p>Shape of sparse matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl.physics.DensityMatrix.spin" title="sisl.physics.DensityMatrix.spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin</span></code></a></p></td>
<td><p>Associated spin class</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.Dk">
<span class="sig-name descname"><span class="pre">Dk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/physics/densitymatrix.html#DensityMatrix.Dk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.physics.DensityMatrix.Dk" title="Link to this definition"></a></dt>
<dd><p>Setup the density matrix for a given k-point</p>
<p>Creation and return of the density matrix for a given k-point (default to Gamma).</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\mathbf D(\mathbf k) = \mathbf D_{ij} e^{i \mathbf k\cdot\mathbf R}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> are orbital indices.</p>
<p>Another possible gauge is the atomic distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\mathbf D(\mathbf k) = \mathbf D_{ij} e^{i \mathbf k\cdot\mathb r}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf r\)</span> is the distance between the orbitals.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – the k-point to setup the density matrix at</p></li>
<li><p><strong>dtype</strong> (numpy.dtype , <em>optional</em>) – the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complex128" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>) – the chosen gauge, <code class="docutils literal notranslate"><span class="pre">lattice</span></code> for cell vector gauge, and <code class="docutils literal notranslate"><span class="pre">atomic</span></code> for atomic distance
gauge.</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{'csr',</span> <span class="pre">'array',</span> <span class="pre">'dense',</span> <span class="pre">'coo',</span> <span class="pre">...}</span></code>) – the returned format of the matrix, defaulting to the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).
Prefixing with ‘sc:’, or simply ‘sc’ returns the matrix in supercell format
with phases.</p></li>
<li><p><strong>spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – if the density matrix is a spin polarized one can extract the specific spin direction
matrix by passing an integer (0 or 1). If the density matrix is not <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a>
this keyword is ignored.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.dDk" title="sisl.physics.DensityMatrix.dDk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dDk</span></code></a></dt><dd><p>Density matrix derivative with respect to <em class="xref py py-obj">k</em></p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.ddDk" title="sisl.physics.DensityMatrix.ddDk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddDk</span></code></a></dt><dd><p>Density matrix double derivative with respect to <em class="xref py py-obj">k</em></p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> – the density matrix at <span class="math notranslate nohighlight">\(\mathbf k\)</span>. The returned object depends on <em class="xref py py-obj">format</em>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.sparse.*_matrix</span></code></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.Rij">
<span class="sig-name descname"><span class="pre">Rij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">what</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'orbital'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.Rij" title="Link to this definition"></a></dt>
<dd><p>Create a sparse matrix with the vectors between atoms/orbitals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>what</strong> (<code class="docutils literal notranslate"><span class="pre">{'orbital',</span> <span class="pre">'atom'}</span></code>) – which kind of sparse vector matrix to return, either an atomic vector matrix
or an orbital vector matrix. The orbital matrix is equivalent to the atomic
one with the same vectors repeated for the same atomic orbitals.
The default is the same type as the parent class.</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – the data-type of the sparse matrix.</p></li>
</ul>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The returned sparse matrix with vectors are taken from the current sparse pattern.
I.e. a subsequent addition of sparse elements will make them inequivalent.
It is thus important to <em>only</em> create the sparse vector matrix when the sparse
structure is completed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.Sk">
<span class="sig-name descname"><span class="pre">Sk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.Sk" title="Link to this definition"></a></dt>
<dd><p>Setup the overlap matrix for a given k-point</p>
<p>Creation and return of the overlap matrix for a given k-point (default to Gamma).</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Currently the implemented gauge for the k-point is the lattice vector gauge:</p>
<div class="math notranslate nohighlight">
\[\mathbf S(\mathbf k) = \mathbf S_{ij} e^{i\mathbf k\cdot\mathbf R}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> are orbital indices.</p>
<p>Another possible gauge is the atomic distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\mathbf S(\mathbf k) = \mathbf S_{ij} e^{i\mathbf k\cdot\mathbf r}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf r\)</span> is the distance between the orbitals.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – the k-point to setup the overlap at (default Gamma point)</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complex128" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>) – the chosen gauge</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{&quot;csr&quot;,</span> <span class="pre">&quot;array&quot;,</span> <span class="pre">&quot;matrix&quot;,</span> <span class="pre">&quot;coo&quot;,</span> <span class="pre">...}</span></code>) – the returned format of the matrix, defaulting to the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">“array”</em>/<em class="xref py py-obj">”dense”</em>/<em class="xref py py-obj">”matrix”</em>).
Prefixing with “sc:”, or simply “sc” returns the matrix in supercell format
with phases. This is useful for e.g. bond-current calculations where individual
hopping + phases are required.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.dSk" title="sisl.physics.DensityMatrix.dSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dSk</span></code></a></dt><dd><p>Overlap matrix derivative with respect to <em class="xref py py-obj">k</em></p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.ddSk" title="sisl.physics.DensityMatrix.ddSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddSk</span></code></a></dt><dd><p>Overlap matrix double derivative with respect to <em class="xref py py-obj">k</em></p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>matrix</strong> – the overlap matrix at <span class="math notranslate nohighlight">\(\mathbf k\)</span>. The returned object depends on <em class="xref py py-obj">format</em>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">scipy.sparse.*_matrix</span></code></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
<li><p><strong>format</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">offset</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.add" title="Link to this definition"></a></dt>
<dd><p>Add two sparse matrices by adding the parameters to one set. The final matrix will have no couplings between <em class="xref py py-obj">self</em> and <em class="xref py py-obj">other</em></p>
<p>The final sparse matrix will not have any couplings between <em class="xref py py-obj">self</em> and <em class="xref py py-obj">other</em>. Not even if they
have commensurate overlapping regions. If you want to create couplings you have to use <a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a> but that
requires the structures are commensurate in the coupling region.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">SparseGeometry</span></code>) – the other sparse matrix to be added, all atoms will be appended</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a>) – whether a specific axis of the cell will be added to the final geometry.
For <code class="docutils literal notranslate"><span class="pre">None</span></code> the final cell will be that of <em class="xref py py-obj">self</em>, otherwise the lattice
vector corresponding to <em class="xref py py-obj">axis</em> will be appended.</p></li>
<li><p><strong>offset</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – offset in geometry of <em class="xref py py-obj">other</em> when adding the atoms.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>append two matrices by also adding overlap couplings</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.prepend" title="sisl.physics.DensityMatrix.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>see <a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.append" title="Link to this definition"></a></dt>
<dd><p>Append <em class="xref py py-obj">other</em> along <em class="xref py py-obj">axis</em> to construct a new connected sparse matrix</p>
<p>This method tries to append two sparse geometry objects together by
the following these steps:</p>
<ol class="arabic simple">
<li><p>Create the new extended geometry</p></li>
<li><p>Use neighbor cell couplings from <em class="xref py py-obj">self</em> as the couplings to <em class="xref py py-obj">other</em>
This <em>may</em> cause problems if the coupling atoms are not exactly equi-positioned.
If the coupling coordinates and the coordinates in <em class="xref py py-obj">other</em> differ by more than
0.01 Ang, a warning will be issued.
If this difference is above <em class="xref py py-obj">atol</em> the couplings will be removed.</p></li>
</ol>
<p>When appending sparse matrices made up of atoms, this method assumes that
the orbitals on the overlapping atoms have the same orbitals, as well as the
same orbital ordering.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sporb</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sporb2</span> <span class="o">=</span> <span class="n">sporb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sporb</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sporbt</span> <span class="o">=</span> <span class="n">sporb</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sporb2</span><span class="o">.</span><span class="n">spsame</span><span class="p">(</span><span class="n">sporbt</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To retain couplings only from the <em>left</em> sparse matrix, do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sporb</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sporb</span> <span class="o">=</span> <span class="p">(</span><span class="n">sporb</span> <span class="o">+</span> <span class="n">sporb</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>To retain couplings only from the <em>right</em> sparse matrix, do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sporb</span> <span class="o">=</span> <span class="n">left</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">right</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mf">2.</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sporb</span> <span class="o">=</span> <span class="p">(</span><span class="n">sporb</span> <span class="o">+</span> <span class="n">sporb</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The current implementation does not preserve the hermiticity of the matrix.
If you want to preserve hermiticity of the matrix you have to do the
following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sm</span> <span class="o">=</span> <span class="p">(</span><span class="n">sm</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>other</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>) – must be an object of the same type as <em class="xref py py-obj">self</em></p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – axis to append the two sparse geometries along</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – tolerance that all coordinates <em>must</em> be within to allow an append.
It is important that this value is smaller than half the distance between
the two closests atoms such that there is no ambiguity in selecting
equivalent atoms. An internal stricter tolerance is used as a baseline, see above.</p></li>
<li><p><strong>scale</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>, <em>optional</em>) – the scale used for the overlapping region. For scalar values it corresponds
to passing: <code class="docutils literal notranslate"><span class="pre">(scale,</span> <span class="pre">scale)</span></code>.
For array-like input <code class="docutils literal notranslate"><span class="pre">scale[0]</span></code> refers to the scale of the matrix elements
coupling from <em class="xref py py-obj">self</em>, while <code class="docutils literal notranslate"><span class="pre">scale[1]</span></code> is the scale of the matrix elements
in <em class="xref py py-obj">other</em>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.prepend" title="sisl.physics.DensityMatrix.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>equivalent scheme as this method</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.add" title="sisl.physics.DensityMatrix.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>merge two matrices without considering overlap or commensurability</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.transpose" title="sisl.physics.DensityMatrix.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a></dt><dd><p>ensure hermiticity by using this routine</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.replace" title="sisl.physics.DensityMatrix.replace"><code class="xref py py-obj docutils literal notranslate"><span class="pre">replace</span></code></a></dt><dd><p>replace a sub-set of atoms with another sparse matrix</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.append</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.prepend</span></code></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseCSR.scale_columns</span></code></dt><dd><p>method used to scale the two matrix elements values</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.14)"><strong>ValueError</strong></a> – if the two geometries are not compatible for either coordinate, orbital or supercell errors</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new instance with two sparse matrices joined and appended together</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>)</p></li>
<li><p><strong>scale</strong> (<a class="reference internal" href="sisl.typing.SeqOrScalarFloat.html#sisl.typing.SeqOrScalarFloat" title="sisl.typing.SeqOrScalarFloat"><em>SeqOrScalarFloat</em></a>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.astype">
<span class="sig-name descname"><span class="pre">astype</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">copy</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.astype" title="Link to this definition"></a></dt>
<dd><p>Convert the sparse matrix to a specific <a class="reference internal" href="#sisl.physics.DensityMatrix.dtype" title="sisl.physics.DensityMatrix.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a></p>
<p>The data-conversion depends on the spin configuration of the system.
In practice this means that real valued arrays in non-colinear calculations
can be packed to complex valued arrays, which might be more intuitive.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Historically, <a class="reference internal" href="../../index.html#module-sisl" title="sisl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl</span></code></a> was built with large inspiration from SIESTA.
In SIESTA the matrices are always stored in real valued arrays, meaning
that spin-orbit systems has 2x2x2 = 8 values to represent the spin-box.
However, this might as well be stored in 2x2 = 4 complex valued arrays.</p>
<p>Later versions of <a class="reference internal" href="../../index.html#module-sisl" title="sisl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl</span></code></a> might force non-colinear matrices to be stored
in complex arrays for consistency, but for now, both the real and the
complex valued arrays are allowed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dtype</strong> – the resulting data-type of the returned new sparse matrix</p></li>
<li><p><strong>copy</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether the data should be copied (i.e. if <a class="reference internal" href="#sisl.physics.DensityMatrix.dtype" title="sisl.physics.DensityMatrix.dtype"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dtype</span></code></a> is not changed)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.bond_order">
<span class="sig-name descname"><span class="pre">bond_order</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'mayer'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'atom'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.bond_order" title="Link to this definition"></a></dt>
<dd><p>Bond-order calculation using various methods</p>
<p>For <code class="docutils literal notranslate"><span class="pre">method='wiberg'</span></code>, the bond-order is calculated as:</p>
<div class="math notranslate nohighlight">
\[\mathbf B_{ij}^{\mathrm{Wiberg}} &amp;= \mathbf M_{ij}^2\]</div>
<p>For <code class="docutils literal notranslate"><span class="pre">method='mayer'</span></code>, the bond-order is calculated as:</p>
<div class="math notranslate nohighlight">
\[\mathbf B_{ij}^{\mathrm{Mayer}} &amp;= (\mathbf M\mathbf S)_{ij} (\mathbf M\mathbf S)_{ji}\]</div>
<p>For <code class="docutils literal notranslate"><span class="pre">method='mulliken'</span></code>, the bond-order is calculated as:</p>
<div class="math notranslate nohighlight">
\[\mathbf B_{ij}^{\mathrm{Mulliken}} &amp;= 2\mathbf M_{ij}\mathbf S_{ij}\]</div>
<p>The bond order will then be using the above notation for the summation for atoms:</p>
<div class="math notranslate nohighlight">
\[\mathbf B_{IJ}^{\langle\rangle} &amp;= \sum_{i\in I}\sum_{j\in J} \mathbf B^{\langle\rangle}_{ij}\]</div>
<p>The Mulliken bond-order is closely related to the COOP interpretation.
The COOP is generally an energy resolved Mulliken bond-order (so makes
sense for density matrices). So if the
density matrix represents a particular eigen-state, it would yield the COOP
value for the energy of the eigenstate. Generally the density matrix is
the sum over all occupied eigen states, and hence represents the full
picture.</p>
<p>For all options one can do the bond-order calculation for the
spin components. Albeit, their meaning may be more doubtful.
Simply add <code class="docutils literal notranslate"><span class="pre">':spin'</span></code> to the <em class="xref py py-obj">method</em> argument, and the returned
quantity will be spin-resolved with <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span>
components.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>It is unclear what the spin-density bond-order really means.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'mayer'</em><em>, </em><em>'mulliken'</em><em>, </em><em>'wiberg'</em><em>]</em>) – which method to calculate the bond-order with. Optionally suffix
with <code class="docutils literal notranslate"><span class="pre">:spin</span></code> to get spin-resolved method.</p></li>
<li><p><strong>projection</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'atom'</em><em>, </em><em>'orbital'</em><em>]</em>) – whether the returned matrix is in orbital form, or in atom form.
If orbital is used, then the above formulas will be changed</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>SparseAtom</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">with</span> <span class="pre">the</span> <span class="pre">bond-order</span> <span class="pre">between</span> <span class="pre">any</span> <span class="pre">two</span> <span class="pre">atoms</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">in</span> <span class="pre">a</span> <span class="pre">supercell</span> <span class="pre">matrix.</span></code>) – Returned only if projection is atom.</p></li>
<li><p><strong>SparseOrbital</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">with</span> <span class="pre">the</span> <span class="pre">bond-order</span> <span class="pre">between</span> <span class="pre">any</span> <span class="pre">two</span> <span class="pre">orbitals</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">in</span> <span class="pre">a</span> <span class="pre">supercell</span> <span class="pre">matrix.</span></code>) – Returned only if projection is orbital.</p></li>
</ul>
</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.construct">
<span class="sig-name descname"><span class="pre">construct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">func</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">na_iR</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1000</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'rand'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.construct" title="Link to this definition"></a></dt>
<dd><p>Automatically construct the sparse model based on a function that does the setting up of the elements</p>
<p>This may be called in two variants.</p>
<ol class="arabic simple">
<li><p>Pass a function (<em class="xref py py-obj">func</em>), see e.g. <code class="docutils literal notranslate"><span class="pre">create_construct</span></code>
which does the setting up.</p></li>
<li><p>Pass a tuple/list in <em class="xref py py-obj">func</em> which consists of two
elements, one is <code class="docutils literal notranslate"><span class="pre">R</span></code> the radii parameters for
the corresponding parameters.
The second is the parameters
corresponding to the <code class="docutils literal notranslate"><span class="pre">R[i]</span></code> elements.
In this second case all atoms must only have
one orbital.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>func</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">callable</span></code> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – <p>this function <em>must</em> take 4 arguments.
1. Is this object (<code class="docutils literal notranslate"><span class="pre">self</span></code>)
2. Is the currently examined atom (<code class="docutils literal notranslate"><span class="pre">ia</span></code>)
3. Is the currently bounded indices (<code class="docutils literal notranslate"><span class="pre">idxs</span></code>)
4. Is the currently bounded indices atomic coordinates (<code class="docutils literal notranslate"><span class="pre">idxs_xyz</span></code>)
An example <em class="xref py py-obj">func</em> could be:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">[</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.44</span><span class="p">],</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">)</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
<span class="gp">... </span>    <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="mf">2.7</span>
</pre></div>
</div>
</p></li>
<li><p><strong>na_iR</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – number of atoms within the sphere for speeding
up the <em class="xref py py-obj">iter_block</em> loop.</p></li>
<li><p><strong>method</strong> (<code class="docutils literal notranslate"><span class="pre">{'rand',</span> <span class="pre">str}</span></code>) – method used in <em class="xref py py-obj">Geometry.iter_block</em>, see there for details</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>optional</em>) – whether an ETA will be printed</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.create_construct" title="sisl.physics.DensityMatrix.create_construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_construct</span></code></a></dt><dd><p>a generic function used to create a generic function which this routine requires</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.tile" title="sisl.physics.DensityMatrix.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>tiling <em>after</em> construct is much faster for very large systems</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.repeat" title="sisl.physics.DensityMatrix.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a></dt><dd><p>repeating <em>after</em> construct is much faster for very large systems</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.copy">
<span class="sig-name descname"><span class="pre">copy</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.copy" title="Link to this definition"></a></dt>
<dd><p>A copy of this object</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – it is possible to convert the data to a different data-type
If not specified, it will use <code class="docutils literal notranslate"><span class="pre">self.dtype</span></code></p></li>
<li><p><strong>S</strong> (<em>_SparseGeometry</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>_SparseGeometry</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.create_construct">
<span class="sig-name descname"><span class="pre">create_construct</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">params</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.create_construct" title="Link to this definition"></a></dt>
<dd><p>Create a simple function for passing to the <a class="reference internal" href="#sisl.physics.DensityMatrix.construct" title="sisl.physics.DensityMatrix.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a> function.</p>
<p>This is to relieve the creation of simplistic
functions needed for setting up sparse elements.</p>
<p>For simple matrices this returns a function:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="gp">... </span>    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">)</span>
<span class="gp">... </span>    <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="gp">... </span>        <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>
</pre></div>
</div>
<p>In the non-colinear case the matrix element <span class="math notranslate nohighlight">\(\mathbf M_{ij}\)</span> will be set
to input values <em class="xref py py-obj">param</em> if <span class="math notranslate nohighlight">\(i \le j\)</span> and the Hermitian conjugated
values for <span class="math notranslate nohighlight">\(j &lt; i\)</span>.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This function only works for geometry sparse matrices (i.e. one
element per atom). If you have more than one element per atom
you have to implement the function your-self.</p>
<p>This method issues warnings if the on-site terms are not Hermitian
for spin-orbit systems. Do note that it <em>still</em> creates the matrices
based on the input.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> – radii parameters for different shells.
Must have same length as <em class="xref py py-obj">params</em> or one less.
If one less it will be extended with <code class="docutils literal notranslate"><span class="pre">R[0]/100</span></code></p></li>
<li><p><strong>params</strong> – coupling constants corresponding to the <em class="xref py py-obj">R</em>
ranges. <code class="docutils literal notranslate"><span class="pre">params[0,:]</span></code> are the elements
for the all atoms within <code class="docutils literal notranslate"><span class="pre">R[0]</span></code> of each atom.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Callable</em>[[<em>Self</em>, <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>, <a class="reference internal" href="sisl.typing.AtomsLike.html#sisl.typing.AtomsLike" title="sisl.typing.AtomsLike"><em>AtomsLike</em></a>, np.ndarray], <a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a>]</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.construct" title="sisl.physics.DensityMatrix.construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">construct</span></code></a></dt><dd><p>routine to create the sparse matrix from a generic function (as returned from <a class="reference internal" href="#sisl.physics.DensityMatrix.create_construct" title="sisl.physics.DensityMatrix.create_construct"><code class="xref py py-obj docutils literal notranslate"><span class="pre">create_construct</span></code></a>)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.dDk">
<span class="sig-name descname"><span class="pre">dDk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/physics/densitymatrix.html#DensityMatrix.dDk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.physics.DensityMatrix.dDk" title="Link to this definition"></a></dt>
<dd><p>Setup the density matrix derivative for a given k-point</p>
<p>Creation and return of the density matrix derivative for a given k-point (default to Gamma).</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_k \mathbf D_\alpha(\mathbf k) = i \mathbf R_\alpha \mathbf D_{ij} e^{i \mathbf k\cdot\mathbf R}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> is one of the Cartesian directions.</p>
<p>Another possible gauge is the atomic distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_k \mathbf D_\alpha(\mathbf k) = i \mathbf r_\alpha \mathbf D_{ij} e^{i \mathbf k\cdot\mathbf r}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf r\)</span> is the distance between the orbitals.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – the k-point to setup the density matrix at</p></li>
<li><p><strong>dtype</strong> (numpy.dtype , <em>optional</em>) – the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complex128" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>) – the chosen gauge, <code class="docutils literal notranslate"><span class="pre">lattice</span></code> for cell vector gauge, and <code class="docutils literal notranslate"><span class="pre">atomic</span></code> for atomic distance
gauge.</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{'csr',</span> <span class="pre">'array',</span> <span class="pre">'dense',</span> <span class="pre">'coo',</span> <span class="pre">...}</span></code>) – the returned format of the matrix, defaulting to the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p></li>
<li><p><strong>spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – if the density matrix is a spin polarized one can extract the specific spin direction
matrix by passing an integer (0 or 1). If the density matrix is not <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a>
this keyword is ignored.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.Dk" title="sisl.physics.DensityMatrix.Dk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dk</span></code></a></dt><dd><p>Density matrix with respect to <em class="xref py py-obj">k</em></p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.ddDk" title="sisl.physics.DensityMatrix.ddDk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddDk</span></code></a></dt><dd><p>Density matrix double derivative with respect to <em class="xref py py-obj">k</em></p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>for each of the Cartesian directions a <span class="math notranslate nohighlight">\(\partial \mathbf D(\mathbf k)/\partial\mathbf k\)</span> is returned.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.dSk">
<span class="sig-name descname"><span class="pre">dSk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.dSk" title="Link to this definition"></a></dt>
<dd><p>Setup the <span class="math notranslate nohighlight">\(\mathbf k\)</span>-derivatie of the overlap matrix for a given k-point</p>
<p>Creation and return of the derivative of the overlap matrix for a given k-point (default to Gamma).</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Currently the implemented gauge for the k-point is the lattice vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_{\mathbf k} \mathbf S_\alpha(\mathbf k) = i \mathbf R_\alpha \mathbf S_{ij} e^{i\mathbf k\cdot\mathbf R}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> is one of the Cartesian directions.</p>
<p>Another possible gauge is the atomic distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_{\mathbf k} \mathbf S_\alpha(\mathbf k) = i \mathbf r_\alpha \mathbf S_{ij} e^{i\mathbf k\cdot\mathbf r}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf r\)</span> is the distance between the orbitals.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – the k-point to setup the overlap at (default Gamma point)</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complex128" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>) – the chosen gauge.</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{&quot;csr&quot;,</span> <span class="pre">&quot;array&quot;,</span> <span class="pre">&quot;matrix&quot;,</span> <span class="pre">&quot;coo&quot;,</span> <span class="pre">...}</span></code>) – the returned format of the matrix, defaulting to the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">“array”</em>/<em class="xref py py-obj">”dense”</em>/<em class="xref py py-obj">”matrix”</em>).</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.Sk" title="sisl.physics.DensityMatrix.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a></dt><dd><p>Overlap matrix at <em class="xref py py-obj">k</em></p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.ddSk" title="sisl.physics.DensityMatrix.ddSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ddSk</span></code></a></dt><dd><p>Overlap matrix double derivative at <em class="xref py py-obj">k</em></p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>for each of the Cartesian directions a <span class="math notranslate nohighlight">\(\partial \mathbf S(\mathbf k)/\partial\mathbf k\)</span> is returned.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">tuple</span></code></a></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
<li><p><strong>format</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.ddDk">
<span class="sig-name descname"><span class="pre">ddDk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/physics/densitymatrix.html#DensityMatrix.ddDk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.physics.DensityMatrix.ddDk" title="Link to this definition"></a></dt>
<dd><p>Setup the density matrix double derivative for a given k-point</p>
<p>Creation and return of the density matrix double derivative for a given k-point (default to Gamma).</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_k^2 \mathbf D^{(alpha\beta)}(\mathbf k) = - \mathbf R_\alpha \mathbf R_\beta \mathbf D_{ij} e^{i \mathbf k\cdot\mathbf R}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are one of the Cartesian directions.</p>
<p>Another possible gauge is the atomic distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_k^2 \mathbf D^{(\alpha\beta)}(\mathbf k) = - \mathbf r^{(i)} \mathbf r^{\beta} \mathbf D_{ij} e^{i\mathbf k\cdot\mathbf r}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf r\)</span> is the distance between the orbitals.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – the k-point to setup the density matrix at</p></li>
<li><p><strong>dtype</strong> (numpy.dtype , <em>optional</em>) – the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complex128" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>) – the chosen gauge, <code class="docutils literal notranslate"><span class="pre">lattice</span></code> for cell vector gauge, and <code class="docutils literal notranslate"><span class="pre">atomic</span></code> for atomic distance
gauge.</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{'csr',</span> <span class="pre">'array',</span> <span class="pre">'dense',</span> <span class="pre">'coo',</span> <span class="pre">...}</span></code>) – the returned format of the matrix, defaulting to the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">‘array’</em>/<em class="xref py py-obj">’dense’</em>/<em class="xref py py-obj">’matrix’</em>).</p></li>
<li><p><strong>spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – if the density matrix is a spin polarized one can extract the specific spin direction
matrix by passing an integer (0 or 1). If the density matrix is not <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a>
this keyword is ignored.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.Dk" title="sisl.physics.DensityMatrix.Dk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Dk</span></code></a></dt><dd><p>Density matrix with respect to <em class="xref py py-obj">k</em></p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.dDk" title="sisl.physics.DensityMatrix.dDk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dDk</span></code></a></dt><dd><p>Density matrix derivative with respect to <em class="xref py py-obj">k</em></p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>for each of the Cartesian directions (in Voigt representation); xx, yy, zz, zy, xz, xy</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">matrices</span></code></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.ddSk">
<span class="sig-name descname"><span class="pre">ddSk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'csr'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.ddSk" title="Link to this definition"></a></dt>
<dd><p>Setup the double <span class="math notranslate nohighlight">\(\mathbf k\)</span>-derivatie of the overlap matrix for a given k-point</p>
<p>Creation and return of the double derivative of the overlap matrix for a given k-point (default to Gamma).</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Currently the implemented gauge for the k-point is the cell vector gauge:</p>
<div class="math notranslate nohighlight">
\[\nabla_{\mathbf k^2} \mathbf S_{\alpha\beta}(\mathbf k) = - \mathbf R_\alpha \mathbf R_\beta \mathbf S_{ij} e^{i\mathbf k\cdot\mathbf R}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf R\)</span> is an integer times the cell vector and <span class="math notranslate nohighlight">\(i\)</span>, <span class="math notranslate nohighlight">\(j\)</span> are orbital indices.
And <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\beta\)</span> are one of the Cartesian directions.</p>
<p>Another possible gauge is the atomic distance which can be written as</p>
<div class="math notranslate nohighlight">
\[\nabla_{\mathbf k^2} \mathbf S_{\alpha\beta}(\mathbf k) = - \mathbf r_\alpha \mathbf r_\beta \mathbf S_{ij} e^{i\mathbf k\cdot\mathbf r}\]</div>
<p>where <span class="math notranslate nohighlight">\(\mathbf r\)</span> is the distance between the orbitals.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – the k-point to setup the overlap at (default Gamma point)</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – the data type of the returned matrix. Do NOT request non-complex
data-type for non-Gamma k.
The default data-type is <a class="reference external" href="https://numpy.org/doc/stable/reference/arrays.scalars.html#numpy.complex128" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.complex128</span></code></a></p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>) – the chosen gauge, <code class="docutils literal notranslate"><span class="pre">cell</span></code> for cell vector gauge, and <code class="docutils literal notranslate"><span class="pre">atom</span></code> for atomic distance
gauge.</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{&quot;csr&quot;,</span> <span class="pre">&quot;array&quot;,</span> <span class="pre">&quot;matrix&quot;,</span> <span class="pre">&quot;coo&quot;,</span> <span class="pre">...}</span></code>) – the returned format of the matrix, defaulting to the <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>,
however if one always requires operations on dense matrices, one can always
return in <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a> (<em class="xref py py-obj">“array”</em>/<em class="xref py py-obj">”dense”</em>/<em class="xref py py-obj">”matrix”</em>).</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.Sk" title="sisl.physics.DensityMatrix.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a></dt><dd><p>Overlap matrix at <em class="xref py py-obj">k</em></p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.dSk" title="sisl.physics.DensityMatrix.dSk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">dSk</span></code></a></dt><dd><p>Overlap matrix derivative at <em class="xref py py-obj">k</em></p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>for each of the Cartesian directions (in Voigt representation); xx, yy, zz, zy, xz, xy</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <code class="xref py py-class docutils literal notranslate"><span class="pre">matrices</span></code></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
<li><p><strong>format</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.density">
<span class="sig-name descname"><span class="pre">density</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">grid</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spinor</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-7</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'pre-compute'</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.density" title="Link to this definition"></a></dt>
<dd><p>Expand the density matrix to the charge density on a grid</p>
<p>This routine calculates the real-space density components on a specified grid.</p>
<p>This is an <em>in-place</em> operation that <em>adds</em> to the current values in the grid.</p>
<p>Note: To calculate <span class="math notranslate nohighlight">\(\boldsymbol\rho(\mathbf r)\)</span> in a unit-cell different from the
originating geometry, simply pass a grid with a unit-cell different than the originating
supercell.</p>
<p>The real-space density is calculated as:</p>
<div class="math notranslate nohighlight">
\[\boldsymbol\rho(\mathbf r) = \sum_{ij}\phi_i(\mathbf r)\phi_j(\mathbf r) \mathbf D_{ij}\]</div>
<p>While for non-collinear/spin-orbit calculations the density is determined from the
spinor component (<em class="xref py py-obj">spinor</em>) by</p>
<div class="math notranslate nohighlight">
\[\boldsymbol\rho_{\boldsymbol\sigma}(\mathbf r) = \sum_{ij}\phi_i(\mathbf r)\phi_j(\mathbf r) \sum_\alpha [\boldsymbol\sigma \boldsymbol \rho_{ij}]_{\alpha\alpha}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\boldsymbol\sigma\)</span> corresponds to a spinor operator to extract relevant quantities. By passing the identity matrix the total charge is added. By using the Pauli matrix <span class="math notranslate nohighlight">\(\boldsymbol\sigma_x\)</span>
only the <span class="math notranslate nohighlight">\(x\)</span> component of the density is added to the grid (see <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.X" title="sisl.physics.Spin.X"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.X</span></code></a>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>grid</strong> (<a class="reference internal" href="sisl.Grid.html#sisl.Grid" title="sisl.Grid"><em>Grid</em></a>) – the grid on which to add the density (the density is in <code class="docutils literal notranslate"><span class="pre">e/Ang^3</span></code>)</p></li>
<li><p><strong>spinor</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">(2,)</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">(2</span></code>, <code class="xref py py-class docutils literal notranslate"><span class="pre">2)</span></code>, <em>optional</em>) – the spinor matrix to obtain the diagonal components of the density. For un-polarized density matrices
this keyword has no influence. For spin-polarized it <em>has</em> to be either 1 integer or a vector of
length 2 (defaults to total density).
For non-collinear/spin-orbit density matrices it has to be a 2x2 matrix (defaults to total density).</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – DM tolerance for accepted values. For all density matrix elements with absolute values below
the tolerance, they will be treated as strictly zeros.</p></li>
<li><p><strong>eta</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a>) – show a progressbar on stdout</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'pre-compute'</em><em>, </em><em>'direct'</em><em>]</em>) – It determines if the orbital values are computed on the fly (direct) or they are all pre-computed
on the grid at the beginning (pre-compute).
Pre computing orbitals results in a faster computation, but it requires more memory.</p></li>
</ul>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The <em class="xref py py-obj">method</em> argument may change at will since this is an experimental feature.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.edges">
<span class="sig-name descname"><span class="pre">edges</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exclude</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.edges" title="Link to this definition"></a></dt>
<dd><p>Retrieve edges (connections) for all <em class="xref py py-obj">atoms</em></p>
<p>The returned edges are unique and sorted (see <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.unique.html#numpy.unique" title="(in NumPy v2.3)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">numpy.unique</span></code></a>) and are returned
in supercell indices (i.e. <code class="docutils literal notranslate"><span class="pre">0</span> <span class="pre">&lt;=</span> <span class="pre">edge</span> <span class="pre">&lt;</span> <span class="pre">self.geometry.no_s</span></code>).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – the edges are returned only for the given atom (but by using  all orbitals of the
requested atom). The returned edges are also atoms.</p></li>
<li><p><strong>exclude</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – remove edges which are in the <em class="xref py py-obj">exclude</em> list, this list refers to orbitals.</p></li>
<li><p><strong>orbitals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">list</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – the edges are returned only for the given orbital. The returned edges are orbitals.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>If <em class="xref py py-obj">orbitals</em> is None, the returned indices are atomic indices.
Otherwise it will be orbital indices.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">indices</span></code></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseCSR.edges</span></code></dt><dd><p>the underlying routine used for extracting the edges</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.eig">
<span class="sig-name descname"><span class="pre">eig</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvals_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.eig" title="Link to this definition"></a></dt>
<dd><p>Returns the eigenvalues of the physical quantity (using the non-Hermitian solver)</p>
<p>Setup the system and overlap matrix with respect to
the given k-point and calculate the eigenvalues.</p>
<p>All subsequent arguments gets passed directly to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eig.html#scipy.linalg.eig" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.eig</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – the spin-component to calculate the eigenvalue spectrum of, note that
this parameter is only valid for <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a> matrices.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
<li><p><strong>eigvals_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a> | <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.14)"><em>Tuple</em></a>[<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.eigh">
<span class="sig-name descname"><span class="pre">eigh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvals_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.eigh" title="Link to this definition"></a></dt>
<dd><p>Returns the eigenvalues of the physical quantity</p>
<p>Setup the system and overlap matrix with respect to
the given k-point and calculate the eigenvalues.</p>
<p>All subsequent arguments gets passed directly to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.linalg.eigh.html#scipy.linalg.eigh" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.linalg.eigh</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – the spin-component to calculate the eigenvalue spectrum of, note that
this parameter is only valid for <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a> matrices.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
<li><p><strong>eigvals_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a> | <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.14)"><em>Tuple</em></a>[<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.eigsh">
<span class="sig-name descname"><span class="pre">eigsh</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gauge</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'lattice'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eigvals_only</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.eigsh" title="Link to this definition"></a></dt>
<dd><p>Calculates a subset of eigenvalues of the physical quantity using sparse matrices</p>
<p>Setup the quantity and overlap matrix with respect to
the given k-point and calculate a subset of the eigenvalues using the sparse algorithms.</p>
<p>All subsequent arguments gets passed directly to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigsh</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>n</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – number of eigenvalues to calculate
Defaults to the <em class="xref py py-obj">n</em> smallest magnitude eigevalues.</p></li>
<li><p><strong>spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – the spin-component to calculate the eigenvalue spectrum of, note that
this parameter is only valid for <a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin.POLARIZED" title="sisl.physics.Spin.POLARIZED"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Spin.POLARIZED</span></code></a> matrices.</p></li>
<li><p><strong>**kwargs</strong> – arguments passed directly to <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.linalg.eigsh.html#scipy.sparse.linalg.eigsh" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.linalg.eigsh</span></code></a>.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>)</p></li>
<li><p><strong>gauge</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'lattice'</em><em>, </em><em>'atomic'</em><em>]</em>)</p></li>
<li><p><strong>eigvals_only</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a> | <a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.14)"><em>Tuple</em></a>[<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a>, <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><em>ndarray</em></a>]</p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The performance and accuracy of this method depends heavily on <em class="xref py py-obj">kwargs</em>.
Playing around with a small test example before doing large scale calculations
is adviced!</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.eliminate_zeros">
<span class="sig-name descname"><span class="pre">eliminate_zeros</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.eliminate_zeros" title="Link to this definition"></a></dt>
<dd><p>Removes all zero elements from the sparse matrix</p>
<p>This is an <em>in-place</em> operation.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseCSR.eliminate_zeros</span></code></dt><dd><p>method called, see there for parameters</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.empty">
<span class="sig-name descname"><span class="pre">empty</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">keep_nnz</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.empty" title="Link to this definition"></a></dt>
<dd><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">empty</span></code> for details</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>keep_nnz</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.finalize">
<span class="sig-name descname"><span class="pre">finalize</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.finalize" title="Link to this definition"></a></dt>
<dd><p>Finalizes the model</p>
<p>Finalizes the model so that all non-used elements are removed. I.e. this simply reduces the memory requirement for the sparse matrix.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Adding more elements to the sparse matrix is more time-consuming than for a non-finalized sparse matrix due to the
internal data-representation.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.fromsp">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">fromsp</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">geometry</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">P</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">S</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.fromsp" title="Link to this definition"></a></dt>
<dd><p>Create a sparse model from a preset <em class="xref py py-obj">Geometry</em> and a list of sparse matrices</p>
<p>The passed sparse matrices are in one of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/sparse.html#module-scipy.sparse" title="(in SciPy v1.16.2)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse</span></code></a> formats.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>geometry</strong> (<a class="reference internal" href="sisl.Geometry.html#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a>) – geometry to describe the new sparse geometry</p></li>
<li><p><strong>P</strong> (<em>Union</em><em>[</em><em>OrSequence</em><em>[</em><a class="reference internal" href="sisl.typing.SparseMatrix.html#sisl.typing.SparseMatrix" title="sisl.typing.SparseMatrix"><em>SparseMatrix</em></a><em>]</em><em>, </em><a class="reference internal" href="sisl.typing.SparseMatrixPhysical.html#sisl.typing.SparseMatrixPhysical" title="sisl.typing.SparseMatrixPhysical"><em>SparseMatrixPhysical</em></a><em>]</em>) – the new sparse matrices that are to be populated in the sparse
matrix.
If <em class="xref py py-obj">P</em> contains a <a class="reference internal" href="../../index.html#module-sisl" title="sisl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl</span></code></a> sparse matrix with an overlap matrix,
that part of the matrix will be omitted.
Use <a class="reference internal" href="#sisl.physics.DensityMatrix.S" title="sisl.physics.DensityMatrix.S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">S</span></code></a> for included the overlap.</p></li>
<li><p><strong>S</strong> (<em>Optional</em><em>[</em><em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.SparseMatrix.html#sisl.typing.SparseMatrix" title="sisl.typing.SparseMatrix"><em>SparseMatrix</em></a><em>, </em><a class="reference internal" href="sisl.typing.SparseMatrixPhysical.html#sisl.typing.SparseMatrixPhysical" title="sisl.typing.SparseMatrixPhysical"><em>SparseMatrixPhysical</em></a><em>]</em><em>]</em>) – if provided this refers to the overlap matrix and will force the
returned sparse matrix to be non-orthogonal.
If the passed matrix is a non-orthogonal <a class="reference internal" href="../../index.html#module-sisl" title="sisl"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl</span></code></a> matrix object
(e.g. a <a class="reference internal" href="sisl.physics.Hamiltonian.html#sisl.physics.Hamiltonian" title="sisl.physics.Hamiltonian"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hamiltonian</span></code></a>), then it will take the overlap part of the
object and pass that along. See examples for details.</p></li>
<li><p><strong>**kwargs</strong> – any arguments that are directly passed to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">__init__</span></code> method
of the class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>a new sparse matrix that holds the passed geometry and the elements of <em class="xref py py-obj">P</em> and optionally being non-orthogonal if <a class="reference internal" href="#sisl.physics.DensityMatrix.S" title="sisl.physics.DensityMatrix.S"><code class="xref py py-obj docutils literal notranslate"><span class="pre">S</span></code></a> is not none</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseGeometry</span></code></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p>Merging two Hamiltonians, for instance a spin-up/down Hamiltonian</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H1</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">H1</span><span class="o">.</span><span class="n">fromsp</span><span class="p">([</span><span class="n">H1</span><span class="p">,</span> <span class="n">H2</span><span class="p">])</span>
</pre></div>
</div>
<p>Adding an overlap from another matrix.
<code class="docutils literal notranslate"><span class="pre">H</span></code>, will now only contain the <code class="docutils literal notranslate"><span class="pre">H1</span></code> data <em>and</em> the overlap
matrix from <code class="docutils literal notranslate"><span class="pre">H2</span></code> (the Hamiltonian values in <code class="docutils literal notranslate"><span class="pre">H2</span></code> will be
neglected)</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H1</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H2</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">H</span> <span class="o">=</span> <span class="n">H1</span><span class="o">.</span><span class="n">fromsp</span><span class="p">(</span><span class="n">H1</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="n">H2</span><span class="p">)</span>
</pre></div>
</div>
<p>If one wishes to construct a merged Hamiltonian with
the overlap parts in the final matrix, then it should be added
explicitly.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">H1</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="p">(</span><span class="o">...</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">s</span> <span class="o">=</span> <span class="n">H1</span><span class="o">.</span><span class="n">shape</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">H1</span><span class="o">.</span><span class="n">fromsp</span><span class="p">([</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1</span><span class="p">])</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="k">assert</span> <span class="n">H1</span><span class="o">.</span><span class="n">fromsp</span><span class="p">([</span><span class="n">H1</span><span class="p">,</span> <span class="n">H1</span><span class="p">],</span> <span class="n">S</span><span class="o">=</span><span class="n">H1</span><span class="p">)</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">s</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.iter_nnz">
<span class="sig-name descname"><span class="pre">iter_nnz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.iter_nnz" title="Link to this definition"></a></dt>
<dd><p>Iterations of the non-zero elements</p>
<p>An iterator on the sparse matrix with, row and column</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">():</span>
<span class="gp">... </span>   <span class="bp">self</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="c1"># is then the non-zero value</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – only loop on the non-zero elements coinciding with the orbitals
on these atoms (not compatible with the <em class="xref py py-obj">orbitals</em> keyword)</p></li>
<li><p><strong>orbitals</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>) – only loop on the non-zero elements coinciding with the orbital
(not compatible with the <em class="xref py py-obj">atoms</em> keyword)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.iter_orbitals">
<span class="sig-name descname"><span class="pre">iter_orbitals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">local</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.iter_orbitals" title="Link to this definition"></a></dt>
<dd><p>Iterations of the orbital space in the geometry, two indices from loop</p>
<p>An iterator returning the current atomic index and the corresponding
orbital index.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_orbitals</span><span class="p">():</span>
</pre></div>
</div>
<p>In the above case <a class="reference external" href="https://docs.python.org/3/library/io.html#module-io" title="(in Python v3.14)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">io</span></code></a> always belongs to atom <em class="xref py py-obj">ia</em> and <em class="xref py py-obj">ia</em> may be
repeated according to the number of orbitals associated with
the atom <em class="xref py py-obj">ia</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>, <em>optional</em>) – only loop on the given atoms, default to all atoms</p></li>
<li><p><strong>local</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">bool</span></code></a>, <em>optional</em>) – whether the orbital index is the global index, or the local index relative to
the atom it resides on.</p></li>
</ul>
</dd>
<dt class="field-even">Yields<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">ia</span></code> – atomic index</p></li>
<li><p><code class="xref py py-class docutils literal notranslate"><span class="pre">io</span></code> – orbital index</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.iter_orbitals</span></code></dt><dd><p>method used to iterate orbitals</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.mulliken">
<span class="sig-name descname"><span class="pre">mulliken</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'orbital'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.mulliken" title="Link to this definition"></a></dt>
<dd><p>Calculate Mulliken charges from the density matrix</p>
<p>See <a class="reference internal" href="../../math.html#math-convention"><span class="std std-ref">here</span></a> for details on the mathematical notation.
Matrices <span class="math notranslate nohighlight">\(\boldsymbol\rho\)</span> and <span class="math notranslate nohighlight">\(\mathbf S\)</span> are density
and overlap matrices, respectively.</p>
<p>For polarized calculations the Mulliken charges are calculated as
(for each spin-channel)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf m_i &amp;= \sum_{i} [\boldsymbol\rho_{ij} \mathbf S_{ij}]
\\
\mathbf m_I &amp;= \sum_{i\in I} \mathbf m_i\end{split}\]</div>
<p>For non-colinear calculations (including spin-orbit) they are calculated
as above but using the spin-box per orbital (<span class="math notranslate nohighlight">\(\sigma\)</span> is spin)</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf m_i &amp;= \sum_\sigma\sum_j [\boldsymbol\rho_{ij,\sigma\sigma} \mathbf S_{ij,\sigma\sigma}]
\\
\mathbf m^{S^x}_i &amp;= \sum_j \Re [\boldsymbol\rho_{ij,\uparrow\downarrow} \mathbf S_{ij,\uparrow\downarrow}] +
             \Re [\boldsymbol\rho_{ij,\downarrow\uparrow} \mathbf S_{ij,\downarrow\uparrow}]
\\
\mathbf m^{S^y}_i &amp;= \sum_j \Im [\boldsymbol\rho_{ij,\uparrow\downarrow} \mathbf S_{ij,\uparrow\downarrow}] -
             \Im [\boldsymbol\rho_{ij,\downarrow\uparrow} \mathbf S_{ij,\downarrow\uparrow}]
\\
\mathbf m^{S^z}_i &amp;= \sum_{j} \Re [\boldsymbol\rho_{ij,\uparrow\uparrow} \mathbf S_{ij,\uparrow\uparrow}] -
             \Re [\boldsymbol\rho_{ij,\downarrow\downarrow} \mathbf S_{ij,\downarrow\downarrow}]\end{split}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>projection</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'orbital'</em><em>, </em><em>'atom'</em><em>]</em>) – how the Mulliken charges are returned.
Can be atom-resolved, orbital-resolved or the
charge matrix (off-diagonal elements)</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Contains Mulliken charges for each orbital/atom (depending on
<em class="xref py py-obj">projection</em>).
The first dimension holds the spin-components, total charge for un-polarized,
(T, Sz) for polarized. (T, Sx, Sy, Sz) for all non-colinear cases.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.nonzero">
<span class="sig-name descname"><span class="pre">nonzero</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">only_cols</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.nonzero" title="Link to this definition"></a></dt>
<dd><p>Indices row and column indices where non-zero elements exists</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – only return the tuples for the requested atoms, default is all atoms
But for <em>all</em> orbitals.</p></li>
<li><p><strong>only_cols</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – only return then non-zero columns</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseCSR.nonzero</span></code></dt><dd><p>the equivalent function call</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.orbital_momentum">
<span class="sig-name descname"><span class="pre">orbital_momentum</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">projection</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'orbital'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'onsite'</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/physics/densitymatrix.html#DensityMatrix.orbital_momentum"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.physics.DensityMatrix.orbital_momentum" title="Link to this definition"></a></dt>
<dd><p>Calculate orbital angular momentum on either atoms or orbitals</p>
<p>Currently this implementation equals the Siesta implementation in that
the on-site approximation is enforced thus limiting the calculated quantities
to obey the following conditions:</p>
<ol class="arabic simple">
<li><p>Same atom</p></li>
<li><p><span class="math notranslate nohighlight">\(l&gt;0\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(l_i \equiv l_j\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(m_i \neq m_j\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(\zeta_i \equiv \zeta_j\)</span></p></li>
</ol>
<p>This allows one to sum the orbital angular moments on a per atom site.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>projection</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'orbital'</em><em>, </em><em>'atom'</em><em>]</em>) – whether the angular momentum is resolved per atom, or per orbital</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'onsite'</em><em>]</em>) – method used to calculate the angular momentum</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>orbital angular momentum with the last dimension equalling the <span class="math notranslate nohighlight">\(L_x\)</span>, <span class="math notranslate nohighlight">\(L_y\)</span> and <span class="math notranslate nohighlight">\(L_z\)</span> components</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.plot.atomicmatrix">
<span class="sig-prename descclassname"><span class="pre">plot.</span></span><span class="sig-name descname"><span class="pre">atomicmatrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fill_value</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">geometry</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atom_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbital_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sc_lines</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">color_pixels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">colorscale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'RdBu'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">crange</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cmid</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">text</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">textfont</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">set_labels</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">constrain_axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arrows</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">[]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">backend</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'plotly'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.plot.atomicmatrix" title="Link to this definition"></a></dt>
<dd><p>Builds a <code class="docutils literal notranslate"><span class="pre">AtomicMatrixPlot</span></code> by setting the value of “matrix” to the current object.</p>
<p>Plots a (possibly sparse) matrix where rows and columns are either orbitals or atoms.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – If the matrix has a third dimension (e.g. spin), which index to
plot in that third dimension.</p></li>
<li><p><strong>isc</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em>]</em>) – If the matrix contains data for an auxiliary supercell, the index of the
cell to plot. If None, the whole matrix is plotted.</p></li>
<li><p><strong>fill_value</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – If the matrix is sparse, the value to use for the missing entries.</p></li>
<li><p><strong>geometry</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.Geometry.html#sisl.Geometry" title="sisl.Geometry"><em>Geometry</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a><em>]</em>) – Only needed if the matrix does not contain a geometry (e.g. it is a numpy array)
and separator lines or labels are requested.</p></li>
<li><p><strong>atom_lines</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a><em>]</em>) – If a boolean, whether to draw lines separating atom blocks, using default styles.
If a dict, draws the lines with the specified plotly line styles.</p></li>
<li><p><strong>orbital_lines</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a><em>]</em>) – If a boolean, whether to draw lines separating blocks of orbital sets, using default styles.
If a dict, draws the lines with the specified plotly line styles.</p></li>
<li><p><strong>sc_lines</strong> (<em>Union</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a><em>]</em>) – If a boolean, whether to draw lines separating the supercells, using default styles.
If a dict, draws the lines with the specified plotly line styles.</p></li>
<li><p><strong>color_pixels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – Whether to color the pixels of the matrix according to the colorscale.</p></li>
<li><p><strong>colorscale</strong> (<em>Optional</em><em>[</em><em>Colorscale</em><em>]</em>) – The colorscale to use to color the pixels.</p></li>
<li><p><strong>crange</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.14)"><em>tuple</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>, </em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em><em>]</em>) – The minimum and maximum values of the colorscale.</p></li>
<li><p><strong>cmid</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – <p>The midpoint of the colorscale. If <code class="docutils literal notranslate"><span class="pre">crange</span></code> is provided, this is ignored.</p>
<p>If None and crange is also None, the midpoint
is set to 0 if the data contains both positive and negative values.</p>
</p></li>
<li><p><strong>text</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a><em>]</em>) – If provided, show text of pixel value with the specified format.
E.g. text=”.3f” shows the value with three decimal places.</p></li>
<li><p><strong>textfont</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a><em>]</em>) – The font to use for the text.
This is a dictionary that may contain the keys “family”, “size”, “color”.</p></li>
<li><p><strong>set_labels</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – Whether to set the axes labels to the atom/orbital that each row and column corresponds to.
For orbitals the labels will be of the form “Atom: (l, m)”, where <em class="xref py py-obj">Atom</em> is the index of
the atom and l and m are the quantum numbers of the orbital.</p></li>
<li><p><strong>constrain_axes</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – Whether to set the ranges of the axes to exactly fit the matrix.</p></li>
<li><p><strong>backend</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><em>str</em></a>) – The backend to use for plotting.</p></li>
<li><p><strong>arrows</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#list" title="(in Python v3.14)"><em>list</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#dict" title="(in Python v3.14)"><em>dict</em></a><em>]</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="../viz/generated/sisl.viz.AtomicMatrixPlot.html#sisl.viz.AtomicMatrixPlot" title="sisl.viz.plots.matrix.AtomicMatrixPlot"><em>AtomicMatrixPlot</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.prepend">
<span class="sig-name descname"><span class="pre">prepend</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.prepend" title="Link to this definition"></a></dt>
<dd><p>See <a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a> for details</p>
<p>This is currently equivalent to:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span>
</pre></div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>)</p></li>
<li><p><strong>scale</strong> (<a class="reference internal" href="sisl.typing.SeqOrScalarFloat.html#sisl.typing.SeqOrScalarFloat" title="sisl.typing.SeqOrScalarFloat"><em>SeqOrScalarFloat</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.prune_range">
<span class="sig-name descname"><span class="pre">prune_range</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">R</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.prune_range" title="Link to this definition"></a></dt>
<dd><p>Prune elements coupling further than <em class="xref py py-obj">R</em>.</p>
<p>Search for connections from <em class="xref py py-obj">atoms</em> to <em class="xref py py-obj">atoms_to</em> where the distances are
further than <em class="xref py py-obj">R</em>. If such couplings exists, remove them.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>R</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – the distance at which the couplings are cut</p></li>
<li><p><strong>atoms</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.AtomsLike.html#sisl.typing.AtomsLike" title="sisl.typing.AtomsLike"><em>AtomsLike</em></a><em>]</em>) – atoms that will be considered in the check.
The rows of the couplings that is taken into account.</p></li>
<li><p><strong>atoms_to</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.AtomsLike.html#sisl.typing.AtomsLike" title="sisl.typing.AtomsLike"><em>AtomsLike</em></a><em>]</em>) – The columns of the couplings that is taken into account.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The transposed couplings are <em>also</em> deleted to ensure a symmetric
matrix.</p>
<p>Currently, one cannot select subset of atoms.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.read">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">read</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../_modules/sisl/physics/densitymatrix.html#DensityMatrix.read"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl.physics.DensityMatrix.read" title="Link to this definition"></a></dt>
<dd><p>Reads density matrix from <em class="xref py py-obj">Sile</em> using <em class="xref py py-obj">read_density_matrix</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>sile</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">Sile</span></code>, <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/pathlib.html#pathlib.Path" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">pathlib.Path</span></code></a>) – a <em class="xref py py-obj">Sile</em> object which will be used to read the density matrix
and the overlap matrix (if any)
if it is a string it will create a new sile using <em class="xref py py-obj">get_sile</em>.</p></li>
<li><p><strong>*</strong> (<code class="xref py py-class docutils literal notranslate"><span class="pre">args</span> <span class="pre">passed</span> <span class="pre">directly</span></code> to <code class="docutils literal notranslate"><span class="pre">read_density_matrix(,**)</span></code>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.remove">
<span class="sig-name descname"><span class="pre">remove</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.remove" title="Link to this definition"></a></dt>
<dd><p>Create a subset of this sparse matrix by removing the atoms corresponding to <em class="xref py py-obj">atoms</em></p>
<p>Negative indices are wrapped and thus works.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – indices of removed atoms</p></li>
<li><p><strong>S</strong> (<em>_SparseGeometry</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>_SparseGeometry</p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.remove</span></code></dt><dd><p>equivalent to the resulting <em class="xref py py-obj">Geometry</em> from this routine</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.sub</span></code></dt><dd><p>the negative of <em class="xref py py-obj">Geometry.remove</em></p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.sub" title="sisl.physics.DensityMatrix.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a></dt><dd><p>the opposite of <a class="reference internal" href="#sisl.physics.DensityMatrix.remove" title="sisl.physics.DensityMatrix.remove"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove</span></code></a>, i.e. retain a subset of atoms</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.remove_orbital">
<span class="sig-name descname"><span class="pre">remove_orbital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.remove_orbital" title="Link to this definition"></a></dt>
<dd><p>Remove a subset of orbitals on <em class="xref py py-obj">atoms</em> according to <em class="xref py py-obj">orbitals</em></p>
<p>For more detailed examples, please see the equivalent (but opposite) method
<a class="reference internal" href="#sisl.physics.DensityMatrix.sub_orbital" title="sisl.physics.DensityMatrix.sub_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_orbital</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – indices of atoms or <em class="xref py py-obj">Atom</em> that will be reduced in size according to <em class="xref py py-obj">orbitals</em></p></li>
<li><p><strong>orbitals</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> of <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">Orbital</span></code>) – indices of the orbitals on <em class="xref py py-obj">atoms</em> that are removed from the sparse matrix.</p></li>
</ul>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.sub_orbital" title="sisl.physics.DensityMatrix.sub_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub_orbital</span></code></a></dt><dd><p>retaining a set of orbitals (see here for examples)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.repeat">
<span class="sig-name descname"><span class="pre">repeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.repeat" title="Link to this definition"></a></dt>
<dd><p>Create a repeated sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.repeat</em></p>
<p>The already existing sparse elements are extrapolated
to the new supercell by repeating them in blocks like the coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – number of repetitions along cell-vector <em class="xref py py-obj">axis</em></p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – 0, 1, 2 according to the cell-direction</p></li>
<li><p><strong>SO</strong> (<a class="reference internal" href="sisl.SparseOrbital.html#sisl.SparseOrbital" title="sisl.SparseOrbital"><em>SparseOrbital</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="sisl.SparseOrbital.html#sisl.SparseOrbital" title="sisl.SparseOrbital"><em>SparseOrbital</em></a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.repeat</span></code></dt><dd><p>the same ordering as the final geometry</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.tile</span></code></dt><dd><p>a different ordering of the final geometry</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseOrbital.tile</span></code></dt><dd><p>a different ordering of the final geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.replace">
<span class="sig-name descname"><span class="pre">replace</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other_atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atol</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.005</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scale</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1.0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.replace" title="Link to this definition"></a></dt>
<dd><p>Replace <em class="xref py py-obj">atoms</em> in <em class="xref py py-obj">self</em> with <em class="xref py py-obj">other_atoms</em> in <em class="xref py py-obj">other</em> and retain couplings between them</p>
<p>This method replaces a subset of atoms in <em class="xref py py-obj">self</em> with
another sparse geometry retaining any couplings between them.
The algorithm checks whether the coupling atoms have the same number of
orbitals. Meaning that atoms in the overlapping region should have the same
connections and number of orbitals per atom.
It will _not_ check whether the orbitals or atoms _are_ the same, nor the order
of the orbitals.</p>
<p>The replacement algorithm takes the couplings from <code class="docutils literal notranslate"><span class="pre">self</span> <span class="pre">-&gt;</span> <span class="pre">other</span></code> on atoms
belonging to <code class="docutils literal notranslate"><span class="pre">self</span></code> and <code class="docutils literal notranslate"><span class="pre">other</span> <span class="pre">-&gt;</span> <span class="pre">self</span></code> from <code class="docutils literal notranslate"><span class="pre">other</span></code>. This will in some
cases mean that the matrix becomes non-symmetric. See in Notes for details on
symmetrizing the matrices.</p>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">minimal</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">....</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big</span> <span class="o">=</span> <span class="n">minimal</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big2</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">big</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">minimal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big</span><span class="o">.</span><span class="n">spsame</span><span class="p">(</span><span class="n">big2</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
</div>
<p>To ensure hermiticity and using the average of the couplings from <code class="docutils literal notranslate"><span class="pre">big</span></code> and
<code class="docutils literal notranslate"><span class="pre">minimal</span></code> one can do:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">big2</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">big</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">minimal</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big2</span> <span class="o">=</span> <span class="p">(</span><span class="n">big2</span> <span class="o">+</span> <span class="n">big2</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>To retain couplings only from the <code class="docutils literal notranslate"><span class="pre">big</span></code> sparse matrix, one should
do the following (note the subsequent transposing which ensures hermiticy
and is effectively copying couplings from <code class="docutils literal notranslate"><span class="pre">big</span></code> to the replaced region.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">big2</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">big</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">minimal</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big2</span> <span class="o">=</span> <span class="p">(</span><span class="n">big2</span> <span class="o">+</span> <span class="n">big2</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>To only retain couplings from the <code class="docutils literal notranslate"><span class="pre">minimal</span></code> sparse matrix:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">big2</span> <span class="o">=</span> <span class="n">big</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">big</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">minimal</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">big2</span> <span class="o">=</span> <span class="p">(</span><span class="n">big2</span> <span class="o">+</span> <span class="n">big2</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The current implementation does not preserve the hermiticity of the matrix.
If you want to preserve hermiticity of the matrix you have to do the
following:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sm</span> <span class="o">=</span> <span class="p">(</span><span class="n">sm</span> <span class="o">+</span> <span class="n">sm</span><span class="o">.</span><span class="n">transpose</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<p>Also note that the ordering of the atoms will be <code class="docutils literal notranslate"><span class="pre">range(atoms.min()),</span> <span class="pre">range(len(other_atoms)),</span> <span class="pre">&lt;rest&gt;</span></code>.</p>
<p>Algorithms that utilizes atomic indices should be careful.</p>
<p>When the tolerance <em class="xref py py-obj">atol</em> is high, the elements may be more prone to differences in the
symmetry elements. A good idea would be to check the difference between the couplings.
The below variable <code class="docutils literal notranslate"><span class="pre">diff</span></code> will contain the difference <code class="docutils literal notranslate"><span class="pre">(self</span> <span class="pre">-&gt;</span> <span class="pre">other)</span> <span class="pre">-</span> <span class="pre">(other</span> <span class="pre">-&gt;</span> <span class="pre">self)</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">diff</span> <span class="o">=</span> <span class="n">sm</span> <span class="o">-</span> <span class="n">sm</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – which atoms in <em class="xref py py-obj">self</em> that are removed and replaced with <code class="docutils literal notranslate"><span class="pre">other.sub(other_atoms)</span></code></p></li>
<li><p><strong>other</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a>) – must be an object of the same type as <em class="xref py py-obj">self</em>, a subset is taken from this
sparse matrix and combined with <em class="xref py py-obj">self</em> to create a new sparse matrix</p></li>
<li><p><strong>other_atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – to select a subset of atoms in <em class="xref py py-obj">other</em> that are taken out.
Defaults to all atoms in <em class="xref py py-obj">other</em>.</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – coordinate tolerance for allowing replacement.
It is important that this value is at least smaller than half the distance between
the two closests atoms such that there is no ambiguity in selecting
equivalent atoms.</p></li>
<li><p><strong>scale</strong> (<a class="reference internal" href="sisl.typing.SeqOrScalarFloat.html#sisl.typing.SeqOrScalarFloat" title="sisl.typing.SeqOrScalarFloat"><em>SeqOrScalarFloat</em></a>) – the scale used for the overlapping region. For scalar values it corresponds
to passing: <code class="docutils literal notranslate"><span class="pre">(scale,</span> <span class="pre">scale)</span></code>.
For array-like input <code class="docutils literal notranslate"><span class="pre">scale[0]</span></code> refers to the scale of the matrix elements
coupling from <em class="xref py py-obj">self</em>, while <code class="docutils literal notranslate"><span class="pre">scale[1]</span></code> is the scale of the matrix elements
in <em class="xref py py-obj">other</em>.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.prepend" title="sisl.physics.DensityMatrix.prepend"><code class="xref py py-obj docutils literal notranslate"><span class="pre">prepend</span></code></a></dt><dd><p>prepend two sparse matrices, see <a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a> for details</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.add" title="sisl.physics.DensityMatrix.add"><code class="xref py py-obj docutils literal notranslate"><span class="pre">add</span></code></a></dt><dd><p>merge two matrices without considering overlap or commensurability</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.transpose" title="sisl.physics.DensityMatrix.transpose"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transpose</span></code></a></dt><dd><p>may be used to ensure hermiticity (symmetrization of the matrix elements)</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.append" title="sisl.physics.DensityMatrix.append"><code class="xref py py-obj docutils literal notranslate"><span class="pre">append</span></code></a></dt><dd><p>append two sparse matrices</p>
</dd>
</dl>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.append</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.prepend</span></code></p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseCSR.scale_columns</span></code></dt><dd><p>method used to scale the two matrix elements values</p>
</dd>
</dl>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#ValueError" title="(in Python v3.14)"><strong>ValueError</strong></a> – if the two geometries are not compatible for either coordinate, orbital or supercell errors</p></li>
<li><p><a class="reference external" href="https://docs.python.org/3/library/exceptions.html#AssertionError" title="(in Python v3.14)"><strong>AssertionError</strong></a> – if the two geometries are not compatible for either coordinate, orbital or supercell errors</p></li>
</ul>
</dd>
<dt class="field-even">Warns<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>SislWarning</strong> – in case the overlapping atoms are not comprising the same atomic specie.
In some cases this may not be a problem.
However, care must be taken by the user if this warning is issued.</p>
</dd>
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a new instance with two sparse matrices merged together by replacing some atoms</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>)</p></li>
<li><p><strong>other_atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>)</p></li>
<li><p><strong>atol</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>)</p></li>
<li><p><strong>scale</strong> (<a class="reference internal" href="sisl.typing.SeqOrScalarFloat.html#sisl.typing.SeqOrScalarFloat" title="sisl.typing.SeqOrScalarFloat"><em>SeqOrScalarFloat</em></a>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.reset">
<span class="sig-name descname"><span class="pre">reset</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.float64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nnzpr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.reset" title="Link to this definition"></a></dt>
<dd><p>The sparsity pattern has all elements removed and everything is reset.</p>
<p>The object will be the same as if it had been
initialized with the same geometry as it were
created with.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a>) – number of dimensions per element, default to the current number of
elements per matrix element.</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – the datatype of the sparse elements</p></li>
<li><p><strong>nnzpr</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a>) – number of non-zero elements per row</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.rij">
<span class="sig-name descname"><span class="pre">rij</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">what</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'orbital'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.float64</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.rij" title="Link to this definition"></a></dt>
<dd><p>Create a sparse matrix with the distance between atoms/orbitals</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>what</strong> (<code class="docutils literal notranslate"><span class="pre">{'orbital',</span> <span class="pre">'atom'}</span></code>) – which kind of sparse distance matrix to return, either an atomic distance matrix
or an orbital distance matrix. The orbital matrix is equivalent to the atomic
one with the same distance repeated for the same atomic orbitals.
The default is the same type as the parent class.</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – the data-type of the sparse matrix.</p></li>
</ul>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The returned sparse matrix with distances are taken from the current sparse pattern.
I.e. a subsequent addition of sparse elements will make them inequivalent.
It is thus important to <em>only</em> create the sparse distance when the sparse
structure is completed.</p>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.set_nsc">
<span class="sig-name descname"><span class="pre">set_nsc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.set_nsc" title="Link to this definition"></a></dt>
<dd><p>Reset the number of allowed supercells in the sparse orbital</p>
<p>If one reduces the number of supercells <em>any</em> sparse element
that references the supercell will be deleted.</p>
<p>See <em class="xref py py-obj">Lattice.set_nsc</em> for allowed parameters.</p>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Lattice.set_nsc</span></code></dt><dd><p>the underlying called method</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.spalign">
<span class="sig-name descname"><span class="pre">spalign</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.spalign" title="Link to this definition"></a></dt>
<dd><p>See <code class="xref py py-meth docutils literal notranslate"><span class="pre">align</span></code> for details</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.spin_align">
<span class="sig-name descname"><span class="pre">spin_align</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">vec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.spin_align" title="Link to this definition"></a></dt>
<dd><p>Aligns <em>all</em> spin along the vector <em class="xref py py-obj">vec</em></p>
<p>In case the matrix is polarized and <em class="xref py py-obj">vec</em> is not aligned at the z-axis, the returned
matrix will be a non-collinear spin configuration.</p>
<p>This is equivalent to rotate each spin-population to point along <em class="xref py py-obj">vec</em> but
while keeping its magnitude.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<a class="reference internal" href="sisl.typing.SeqFloat.html#sisl.typing.SeqFloat" title="sisl.typing.SeqFloat"><em>SeqFloat</em></a>) – vector to align the spin boxes against</p></li>
<li><p><strong>atoms</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a><em>]</em>) – only perform alignment for matrix elements on atoms.
If multiple atoms are specified, the off-diagonal elements between the
atoms will also be aligned.
To only align atomic on-site values, one would have to do a loop.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.spin_rotate" title="sisl.physics.DensityMatrix.spin_rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_rotate</span></code></a></dt><dd><p>rotate spin-boxes by a fixed amount (does not align spins)</p>
</dd>
</dl>
</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The returned data-type of the matrix may have changed, depending
on options. To retain the <em>old</em> datatype, do something like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">M</span> <span class="o">=</span> <span class="n">M</span><span class="o">.</span><span class="n">spin_align</span><span class="p">(</span><span class="o">...</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">M</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a new object with aligned spins</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>vec</strong> (<a class="reference internal" href="sisl.typing.SeqFloat.html#sisl.typing.SeqFloat" title="sisl.typing.SeqFloat"><em>SeqFloat</em></a>)</p></li>
<li><p><strong>atoms</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a><em>]</em>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.spin_rotate">
<span class="sig-name descname"><span class="pre">spin_rotate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">rotation</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rad</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.spin_rotate" title="Link to this definition"></a></dt>
<dd><p>Rotate spin-boxes by fixed angles around the <span class="math notranslate nohighlight">\(x\)</span>, <span class="math notranslate nohighlight">\(y\)</span> and <span class="math notranslate nohighlight">\(z\)</span> axes, respectively.</p>
<p>The angles are with respect to each spin-box initial angle.
One should use <a class="reference internal" href="#sisl.physics.DensityMatrix.spin_align" title="sisl.physics.DensityMatrix.spin_align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_align</span></code></a> to fix all angles along a specific direction.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>For a polarized matrix:
The returned matrix will be in non-collinear spin-configuration in case
the angles does not reflect a pure flip of spin in the <span class="math notranslate nohighlight">\(z\)</span>-axis.
If you explicitly want a spin-orbit matrix, convert it to that before
using <a class="reference internal" href="#sisl.physics.DensityMatrix.spin_rotate" title="sisl.physics.DensityMatrix.spin_rotate"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_rotate</span></code></a>.</p>
<p>The data-type of the returned matrix, may have changed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotation</strong> (<a class="reference internal" href="sisl.typing.RotationType.html#sisl.typing.RotationType" title="sisl.typing.RotationType"><em>RotationType</em></a>) – <p>How to perform the rotation, can be:</p>
<ul>
<li><p>3 floats: Euler angles around Cartesian coordinates</p></li>
<li><p>(float, str): angle + Cartesian/lattice vector name</p></li>
<li><p>(float, 3 floats): angle + vector of rotation</p></li>
<li><p>Quaternion: direct used rotation</p></li>
<li><p>or a sequence of the above.
The resulting rotation matrix will be constructed as
<code class="docutils literal notranslate"><span class="pre">U[n]</span> <span class="pre">&#64;</span> <span class="pre">U[n-1]</span> <span class="pre">&#64;</span> <span class="pre">...</span> <span class="pre">&#64;</span> <span class="pre">U[0]</span></code>.</p></li>
</ul>
</p></li>
<li><p><strong>rad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – Determines the unit of <em class="xref py py-obj">angles</em>, for true it is in radians.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.transform" title="sisl.physics.DensityMatrix.transform"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transform</span></code></a></dt><dd><p>convert the matrix to another spin-configuration</p>
</dd>
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.spin_align" title="sisl.physics.DensityMatrix.spin_align"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin_align</span></code></a></dt><dd><p>align all spin-boxes along a specific direction</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Quaternion</span></code></dt><dd><p>used method for rotation.</p>
</dd>
</dl>
</div>
<p class="rubric">Examples</p>
<p>Rotating 45 degrees around the <span class="math notranslate nohighlight">\(x\)</span> axis can by any of the following:
&gt;&gt;&gt; M.spin_rotate((45, “x”), rad=False)
&gt;&gt;&gt; M.spin_rotate((45, [1, 0, 0]), rad=False)
&gt;&gt;&gt; M.spin_rotate((45, 0, 0), rad=False)</p>
<p>Rotating 45 degrees around the <span class="math notranslate nohighlight">\(x\)</span> and <span class="math notranslate nohighlight">\(y\)</span> axes can be done by
either of the following:
&gt;&gt;&gt; M.spin_rotate((45, “xy”), rad=False)
&gt;&gt;&gt; M.spin_rotate([(45, [1, 0, 0]), (45, [0, 1, 0])], rad=False)
&gt;&gt;&gt; M.spin_rotate([(45, [1, 0, 0]), (45, “y”)], rad=False)
&gt;&gt;&gt; M.spin_rotate([(45, 0, 0), (0, 45, 0)], rad=False)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>a new object with rotated spins</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
</dd>
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>rotation</strong> (<a class="reference internal" href="sisl.typing.RotationType.html#sisl.typing.RotationType" title="sisl.typing.RotationType"><em>RotationType</em></a>)</p></li>
<li><p><strong>rad</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.spsame">
<span class="sig-name descname"><span class="pre">spsame</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">other</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.spsame" title="Link to this definition"></a></dt>
<dd><p>Compare two sparse objects and check whether they have the same entries.</p>
<p>This does not necessarily mean that the elements are the same</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.sub">
<span class="sig-name descname"><span class="pre">sub</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.sub" title="Link to this definition"></a></dt>
<dd><p>Create a subset of this sparse matrix by only retaining the atoms corresponding to <em class="xref py py-obj">atoms</em></p>
<p>Negative indices are wrapped and thus works, supercell atoms are also wrapped to the unit-cell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – indices of retained atoms or <em class="xref py py-obj">Atom</em> for retaining only <em>that</em> atom</p></li>
<li><p><strong>SO</strong> (<a class="reference internal" href="sisl.SparseOrbital.html#sisl.SparseOrbital" title="sisl.SparseOrbital"><em>SparseOrbital</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="sisl.SparseOrbital.html#sisl.SparseOrbital" title="sisl.SparseOrbital"><em>SparseOrbital</em></a></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="c1"># only retain the second atom in the SparseGeometry</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">atom</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="c1"># retain all atoms which is equivalent to</span>
<span class="gp">&gt;&gt;&gt; </span>                           <span class="c1"># the first atomic specie</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.remove</span></code></dt><dd><p>the negative of <em class="xref py py-obj">Geometry.sub</em></p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.sub</span></code></dt><dd><p>equivalent to the resulting <em class="xref py py-obj">Geometry</em> from this routine</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseOrbital.remove</span></code></dt><dd><p>the negative of <a class="reference internal" href="#sisl.physics.DensityMatrix.sub" title="sisl.physics.DensityMatrix.sub"><code class="xref py py-obj docutils literal notranslate"><span class="pre">sub</span></code></a>, i.e. remove a subset of atoms</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.sub_orbital">
<span class="sig-name descname"><span class="pre">sub_orbital</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orbitals</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.sub_orbital" title="Link to this definition"></a></dt>
<dd><p>Retain only a subset of the orbitals on <em class="xref py py-obj">atoms</em> according to <em class="xref py py-obj">orbitals</em></p>
<p>This allows one to retain only a given subset of the sparse matrix elements.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – indices of atoms or <em class="xref py py-obj">Atom</em> that will be reduced in size according to <em class="xref py py-obj">orbitals</em></p></li>
<li><p><strong>orbitals</strong> (<em>Union</em><em>[</em><a class="reference internal" href="sisl.typing.SeqOrScalarInt.html#sisl.typing.SeqOrScalarInt" title="sisl.typing.SeqOrScalarInt"><em>SeqOrScalarInt</em></a><em>, </em><a class="reference internal" href="sisl.Orbital.html#sisl.Orbital" title="sisl.Orbital"><em>Orbital</em></a><em>]</em>) – indices of the orbitals on <em class="xref py py-obj">atoms</em> that are retained in the sparse matrix, the list of
orbitals will be sorted. One cannot re-arrange matrix elements currently.</p></li>
</ul>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Future implementations may allow one to re-arrange orbitals using this method.</p>
<p>When using this method the internal species list will be populated by another species
that is named after the orbitals removed. This is to distinguish different atoms.</p>
</div>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="c1"># a Carbon atom with 2 orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">C</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;C&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># an oxygen atom with 3 orbitals</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">O</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;O&#39;</span><span class="p">,</span> <span class="p">[</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">2.4</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">geometry</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Geometry</span><span class="p">([[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">]],</span> <span class="mi">2</span><span class="p">,</span> <span class="p">[</span><span class="n">C</span><span class="p">,</span> <span class="n">O</span><span class="p">])</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">obj</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="c1"># fill in obj data...</span>
</pre></div>
</div>
<p>Now <code class="docutils literal notranslate"><span class="pre">obj</span></code> is a sparse geometry with 2 different species and 6 atoms (3 of each).
They are ordered <code class="docutils literal notranslate"><span class="pre">[C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O]</span></code>. In the following we
will note species that are different from the original by a <code class="docutils literal notranslate"><span class="pre">'</span></code> in the list.</p>
<p>Retain 2nd orbital on the 2nd atom: <code class="docutils literal notranslate"><span class="pre">[C,</span> <span class="pre">O',</span> <span class="pre">C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 2nd orbital on 1st and 2nd atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O',</span> <span class="pre">C,</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 2nd orbital on the 1st atom and 3rd orbital on 4th atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O,</span> <span class="pre">C,</span> <span class="pre">O',</span> <span class="pre">C,</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 2nd orbital on all atoms equivalent to the first atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O,</span> <span class="pre">C',</span> <span class="pre">O,</span> <span class="pre">C',</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<p>Retain 1st orbital on 1st atom, and 2nd orbital on 3rd and 5th atom: <code class="docutils literal notranslate"><span class="pre">[C',</span> <span class="pre">O,</span> <span class="pre">C'',</span> <span class="pre">O,</span> <span class="pre">C'',</span> <span class="pre">O]</span></code></p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">new_obj</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">],</span> <span class="mi">1</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.remove_orbital" title="sisl.physics.DensityMatrix.remove_orbital"><code class="xref py py-obj docutils literal notranslate"><span class="pre">remove_orbital</span></code></a></dt><dd><p>removing a set of orbitals (opposite of this)</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.swap">
<span class="sig-name descname"><span class="pre">swap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms_a</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">atoms_b</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.swap" title="Link to this definition"></a></dt>
<dd><p>Swaps atoms in the sparse geometry to obtain a new order of atoms</p>
<p>This can be used to reorder elements of a geometry.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms_a</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – the first list of atomic coordinates</p></li>
<li><p><strong>atoms_b</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – the second list of atomic coordinates</p></li>
<li><p><strong>S</strong> (<em>_SparseGeometry</em>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>_SparseGeometry</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.tile">
<span class="sig-name descname"><span class="pre">tile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.tile" title="Link to this definition"></a></dt>
<dd><p>Create a tiled sparse orbital object, equivalent to <em class="xref py py-obj">Geometry.tile</em></p>
<p>The already existing sparse elements are extrapolated
to the new supercell by repeating them in blocks like the coordinates.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – number of repetitions along cell-vector <em class="xref py py-obj">axis</em></p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – 0, 1, 2 according to the cell-direction</p></li>
<li><p><strong>SO</strong> (<a class="reference internal" href="sisl.SparseOrbital.html#sisl.SparseOrbital" title="sisl.SparseOrbital"><em>SparseOrbital</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference internal" href="sisl.SparseOrbital.html#sisl.SparseOrbital" title="sisl.SparseOrbital"><em>SparseOrbital</em></a></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseOrbital.repeat</span></code></dt><dd><p>a different ordering of the final geometry</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">SparseOrbital.untile</span></code></dt><dd><p>opposite of this method</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.tile</span></code></dt><dd><p>the same ordering as the final geometry</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.repeat</span></code></dt><dd><p>a different ordering of the final geometry</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.toSparseAtom">
<span class="sig-name descname"><span class="pre">toSparseAtom</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.toSparseAtom" title="Link to this definition"></a></dt>
<dd><p>Convert the sparse object (without data) to a new sparse object with equivalent but reduced sparse pattern</p>
<p>This converts the orbital sparse pattern to an atomic sparse pattern.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a>) – number of dimensions allocated in the SparseAtom object, default to the same</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – used data-type for the sparse object. Defaults to the same.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.tocsr">
<span class="sig-name descname"><span class="pre">tocsr</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dim</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">isc</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.tocsr" title="Link to this definition"></a></dt>
<dd><p>Return a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.16.2)"><code class="xref py py-class docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> for the specified dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dim</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – the dimension in the sparse matrix (for non-orthogonal cases the last
dimension is the overlap matrix)</p></li>
<li><p><strong>isc</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>, <em>optional</em>) – the supercell index, or all (if <code class="docutils literal notranslate"><span class="pre">isc=None</span></code>)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.transform">
<span class="sig-name descname"><span class="pre">transform</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">matrix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">orthogonal</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.transform" title="Link to this definition"></a></dt>
<dd><p>Transform the matrix by either a matrix or new spin configuration</p>
<p>1. General transformation:
* If <em class="xref py py-obj">matrix</em> is provided, a linear transformation <span class="math notranslate nohighlight">\(\mathbf R^n \rightarrow \mathbf R^m\)</span> is applied
to the <span class="math notranslate nohighlight">\(n\)</span>-dimensional elements of the original sparse matrix.
The <a class="reference internal" href="#sisl.physics.DensityMatrix.spin" title="sisl.physics.DensityMatrix.spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin</span></code></a> and <a class="reference internal" href="#sisl.physics.DensityMatrix.orthogonal" title="sisl.physics.DensityMatrix.orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthogonal</span></code></a> flags are optional but need to be consistent with the creation of an
<em class="xref py py-obj">m</em>-dimensional matrix.</p>
<p>This method will copy over the overlap matrix in case the <em class="xref py py-obj">matrix</em> argument
only acts on the non-overlap matrix elements and both input and output
matrices are non-orthogonal.</p>
<p>2. Spin conversion:
If <a class="reference internal" href="#sisl.physics.DensityMatrix.spin" title="sisl.physics.DensityMatrix.spin"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spin</span></code></a> is provided (without <em class="xref py py-obj">matrix</em>), the spin class
is changed according to the following conversions:</p>
<p>Upscaling
* unpolarized -&gt; (polarized, non-colinear, spinorbit, nambu): Copy unpolarized value to both up and down components
* polarized -&gt; (non-colinear, spinorbit, nambu): Copy up and down components
* non-colinear -&gt; (spinorbit, nambu): Copy first four spin components
* spinorbit -&gt; nambu: Copy first four spin components
* all other new spin components are set to zero</p>
<p>Downscaling
* (polarized, non-colinear, spinorbit, nambu) -&gt; unpolarized: Set unpolarized value to a mix 0.5*up + 0.5*down
* (non-colinear, spinorbit, nambu) -&gt; polarized: Keep up and down spin components
* (spinorbit, nambu) -&gt; non-colinear: Keep first four spin components
* nambu -&gt; spinorbit: Keep first four spin components
* all other spin components are dropped</p>
<p>3. Orthogonality:
If the <a class="reference internal" href="#sisl.physics.DensityMatrix.orthogonal" title="sisl.physics.DensityMatrix.orthogonal"><code class="xref py py-obj docutils literal notranslate"><span class="pre">orthogonal</span></code></a> flag is provided, the overlap matrix is either dropped
or explicitly introduced as the identity matrix.</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The transformation matrix does <em>not</em> act on the rows and columns, only on the
final dimension of the matrix.</p>
<p>The matrix transformation is done like this:</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">out</span> <span class="o">=</span> <span class="ow">in</span> <span class="o">@</span> <span class="n">matrix</span><span class="o">.</span><span class="n">T</span>
</pre></div>
</div>
<p>Meaning that <code class="docutils literal notranslate"><span class="pre">matrix[0,</span> <span class="pre">:]</span></code> will be the factors of the input matrix elements.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>matrix</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a>, <em>optional</em>) – transformation matrix of shape <span class="math notranslate nohighlight">\(m \times n\)</span>. Default is no transformation.</p></li>
<li><p><strong>dtype</strong> (<a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.dtype.html#numpy.dtype" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.dtype</span></code></a>, <em>optional</em>) – data type contained in the matrix. Defaults to the input type.</p></li>
<li><p><strong>spin</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.SpinType.html#sisl.typing.SpinType" title="sisl.typing.SpinType"><em>SpinType</em></a><em>]</em>) – spin class of created matrix. Defaults to the input type.</p></li>
<li><p><strong>orthogonal</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a><em>]</em>) – flag to control if the new matrix includes overlaps. Defaults to the input type.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.translate2uc">
<span class="sig-name descname"><span class="pre">translate2uc</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">atoms</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axes</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.translate2uc" title="Link to this definition"></a></dt>
<dd><p>Translates all primary atoms to the unit cell.</p>
<p>With this, the coordinates of the geometry are translated to the unit cell
and the supercell connections in the matrix are updated accordingly.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>atoms</strong> (<a class="reference internal" href="sisl.typing.AtomsIndex.html#sisl.typing.AtomsIndex" title="sisl.typing.AtomsIndex"><em>AtomsIndex</em></a>) – only translate the specified atoms. If not specified, all
atoms will be translated.</p></li>
<li><p><strong>axes</strong> (<em>Optional</em><em>[</em><a class="reference internal" href="sisl.typing.CellAxes.html#sisl.typing.CellAxes" title="sisl.typing.CellAxes"><em>CellAxes</em></a><em>]</em>) – only translate certain lattice directions, <em class="xref py py-obj">None</em> specifies
only the periodic directions</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A new sparse matrix with the updated connections and a new associated geometry.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><code class="xref py py-class docutils literal notranslate"><span class="pre">SparseOrbital</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">SparseAtom</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.transpose">
<span class="sig-name descname"><span class="pre">transpose</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">conjugate</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">spin</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sort</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.transpose" title="Link to this definition"></a></dt>
<dd><p>A transpose copy of this object with options for spin-box and conjugations</p>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>The overlap elements won’t be conjugated, in case asked for.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>conjugate</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – if true, also apply a conjugation of the values.
Together with <code class="docutils literal notranslate"><span class="pre">spin=True</span></code>, this will result in the adjoint operator.</p></li>
<li><p><strong>spin</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether the spin-box is also transposed if this is false, and <em class="xref py py-obj">hermitian</em> is true,
then only imaginary values will change sign.</p></li>
<li><p><strong>sort</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – the returned columns for the transposed structure will be sorted
if this is true, default</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.trs">
<span class="sig-name descname"><span class="pre">trs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.trs" title="Link to this definition"></a></dt>
<dd><p>Return a matrix with applied time-reversal operator</p>
<p>For a Hamiltonian to obey time reversal symmetry, it must hold this
equality:</p>
<div class="math notranslate nohighlight">
\[\mathbf M = \boldsymbol\sigma_y \mathbf M^* \boldsymbol\sigma_y\]</div>
<p>This method returns the RHS of the above equation.</p>
<p>If you want to ensure that your matrix fulfills TRS, simply do:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">M</span> <span class="o">=</span> <span class="p">(</span><span class="n">M</span> <span class="o">+</span> <span class="n">M</span><span class="o">.</span><span class="n">trs</span><span class="p">())</span> <span class="o">/</span> <span class="mi">2</span>
</pre></div>
</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>This method will be obsoleted at some point when <a class="extlink-issue reference external" href="https://github.com/zerothi/sisl/issues/816">GH816</a> is
completed.</p>
</div>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.unrepeat">
<span class="sig-name descname"><span class="pre">unrepeat</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.unrepeat" title="Link to this definition"></a></dt>
<dd><p>Unrepeats the sparse model into different parts (retaining couplings)</p>
<p>Please see <a class="reference internal" href="#sisl.physics.DensityMatrix.untile" title="sisl.physics.DensityMatrix.untile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">untile</span></code></a> for details, the algorithm and arguments are the same however,
this is the opposite of <a class="reference internal" href="#sisl.physics.DensityMatrix.repeat" title="sisl.physics.DensityMatrix.repeat"><code class="xref py py-obj docutils literal notranslate"><span class="pre">repeat</span></code></a>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>segment</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>sym</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.untile">
<span class="sig-name descname"><span class="pre">untile</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">reps</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">axis</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">segment</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">sym</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.untile" title="Link to this definition"></a></dt>
<dd><p>Untiles the sparse model into different parts (retaining couplings)</p>
<p>Recreates a new sparse object with only the cutted
atoms in the structure. This will preserve matrix elements in the supercell.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – number of repetitions the tiling function created (opposite meaning as in <a class="reference internal" href="#sisl.physics.DensityMatrix.untile" title="sisl.physics.DensityMatrix.untile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">untile</span></code></a>)</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – which axis to untile along</p></li>
<li><p><strong>segment</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>) – which segment to retain. Generally each segment should be equivalent, however
requesting individiual segments can help uncover inconsistencies in the sparse matrix</p></li>
<li><p><strong>*args</strong> – arguments passed directly to <em class="xref py py-obj">Geometry.untile</em></p></li>
<li><p><strong>sym</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – if True, the algorithm will ensure the returned matrix is symmetrized (i.e.
return <code class="docutils literal notranslate"><span class="pre">(M</span> <span class="pre">+</span> <span class="pre">M.transpose())/2</span></code>, else return data as is.
False should generally only be used for debugging precision of the matrix elements,
or if one wishes to check the warnings.</p></li>
<li><p><strong>**kwargs</strong> – keyword arguments passed directly to <em class="xref py py-obj">Geometry.untile</em></p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Untiling structures with <code class="docutils literal notranslate"><span class="pre">nsc</span> <span class="pre">==</span> <span class="pre">1</span></code> along <em class="xref py py-obj">axis</em> are assumed to have periodic boundary
conditions.</p>
<p>When untiling structures with <code class="docutils literal notranslate"><span class="pre">nsc</span> <span class="pre">==</span> <span class="pre">1</span></code> along <em class="xref py py-obj">axis</em> it is important to
untile <em>as much as possible</em>. This is because otherwise the algorithm cannot determine
the correct couplings. Therefore to create a geometry of 3 times a unit-cell, one should
untile to the unit-cell, and subsequently tile 3 times.</p>
<p>Consider for example a system of 4 atoms, each atom connects to its 2 neighbors.
Due to the PBC atom 0 will connect to 1 and 3. Untiling this structure in 2 will
group couplings of atoms 0 and 1. As it will only see one coupling to the right
it will halve the coupling and use the same coupling to the left, which is clearly wrong.</p>
<p>In the following the latter is the correct way to do it.</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">SPM</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">!=</span> <span class="n">SPM</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
</pre></div>
</div>
</div>
<dl class="field-list simple">
<dt class="field-odd">Raises<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>ValueError :</strong> – in case the matrix elements are not conseuctive when determining the
    new supercell structure. This may often happen if untiling a matrix
    too few times, and then untiling it again.</p>
</dd>
<dt class="field-even">Parameters<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>reps</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>axis</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>segment</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><em>int</em></a>)</p></li>
<li><p><strong>sym</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
</ul>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>Self</em></p>
</dd>
</dl>
<div class="admonition seealso">
<p class="admonition-title">See also</p>
<dl class="simple">
<dt><a class="reference internal" href="#sisl.physics.DensityMatrix.tile" title="sisl.physics.DensityMatrix.tile"><code class="xref py py-obj docutils literal notranslate"><span class="pre">tile</span></code></a></dt><dd><p>opposite of this method</p>
</dd>
<dt><code class="xref py py-obj docutils literal notranslate"><span class="pre">Geometry.untile</span></code></dt><dd><p>same as this method, see details about parameters here</p>
</dd>
</dl>
</div>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.write">
<span class="sig-name descname"><span class="pre">write</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">sile</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#sisl.physics.DensityMatrix.write" title="Link to this definition"></a></dt>
<dd><p>Writes a density matrix to the <em class="xref py py-obj">Sile</em> as implemented in the <code class="code docutils literal notranslate"><span class="pre">Sile.write_density_matrix</span></code> method</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dm</strong> (<a class="reference internal" href="#sisl.physics.DensityMatrix" title="sisl.physics.DensityMatrix"><em>DensityMatrix</em></a>)</p></li>
<li><p><strong>sile</strong> (<a class="reference internal" href="sisl.typing.SileLike.html#sisl.typing.SileLike" title="sisl.typing.SileLike"><em>SileLike</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.D">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">D</span></span><a class="headerlink" href="#sisl.physics.DensityMatrix.D" title="Link to this definition"></a></dt>
<dd><p>Access the density matrix elements</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.S">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">S</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="pre">Self</span></em><a class="headerlink" href="#sisl.physics.DensityMatrix.S" title="Link to this definition"></a></dt>
<dd><p>Access the overlap elements associated with the sparse matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.dim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dim</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><span class="pre">int</span></a></em><a class="headerlink" href="#sisl.physics.DensityMatrix.dim" title="Link to this definition"></a></dt>
<dd><p>Number of components per element</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.dkind">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dkind</span></span><a class="headerlink" href="#sisl.physics.DensityMatrix.dkind" title="Link to this definition"></a></dt>
<dd><p>Data type of sparse elements (in str)</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.dtype">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">dtype</span></span><a class="headerlink" href="#sisl.physics.DensityMatrix.dtype" title="Link to this definition"></a></dt>
<dd><p>Data type of sparse elements</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.finalized">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">finalized</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><span class="pre">bool</span></a></em><a class="headerlink" href="#sisl.physics.DensityMatrix.finalized" title="Link to this definition"></a></dt>
<dd><p>Whether the contained data is finalized and non-used elements have been removed</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.geometry">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">geometry</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="sisl.Geometry.html#sisl.Geometry" title="sisl.Geometry"><span class="pre">Geometry</span></a></em><a class="headerlink" href="#sisl.physics.DensityMatrix.geometry" title="Link to this definition"></a></dt>
<dd><p>Associated geometry</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.nnz">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nnz</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><span class="pre">int</span></a></em><a class="headerlink" href="#sisl.physics.DensityMatrix.nnz" title="Link to this definition"></a></dt>
<dd><p>Number of non-zero elements</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.non_orthogonal">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">non_orthogonal</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><span class="pre">bool</span></a></em><a class="headerlink" href="#sisl.physics.DensityMatrix.non_orthogonal" title="Link to this definition"></a></dt>
<dd><p>True if the object is using a non-orthogonal basis</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.orthogonal">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">orthogonal</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><span class="pre">bool</span></a></em><a class="headerlink" href="#sisl.physics.DensityMatrix.orthogonal" title="Link to this definition"></a></dt>
<dd><p>True if the object is using an orthogonal basis</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.plot">
<span class="sig-name descname"><span class="pre">plot</span></span><a class="headerlink" href="#sisl.physics.DensityMatrix.plot" title="Link to this definition"></a></dt>
<dd><p>Plotting functions for the <em class="xref py py-obj">SparseOrbital</em> class.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.shape">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">shape</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Tuple" title="(in Python v3.14)"><span class="pre">Tuple</span></a><span class="p"><span class="pre">[</span></span><a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><span class="pre">int</span></a><span class="p"><span class="pre">]</span></span></em><a class="headerlink" href="#sisl.physics.DensityMatrix.shape" title="Link to this definition"></a></dt>
<dd><p>Shape of sparse matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.spin">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">spin</span></span><em class="property"><span class="p"><span class="pre">:</span></span><span class="w"> </span><a class="reference internal" href="sisl.physics.Spin.html#sisl.physics.Spin" title="sisl.physics.Spin"><span class="pre">Spin</span></a></em><a class="headerlink" href="#sisl.physics.DensityMatrix.spin" title="Link to this definition"></a></dt>
<dd><p>Associated spin class</p>
</dd></dl>

<dl class="py attribute">
<dt class="sig sig-object py" id="sisl.physics.DensityMatrix.um">
<span class="sig-name descname"><span class="pre">um</span></span><em class="property"><span class="w"> </span><span class="p"><span class="pre">=</span></span><span class="w"> </span><span class="pre">&lt;module</span> <span class="pre">'numpy._core.umath'</span> <span class="pre">from</span> <span class="pre">'/opt/hostedtoolcache/Python/3.12.11/x64/lib/python3.12/site-packages/numpy/_core/umath.py'&gt;</span></em><a class="headerlink" href="#sisl.physics.DensityMatrix.um" title="Link to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sisl.physics.EnergyDensityMatrix.html" class="btn btn-neutral float-left" title="sisl.physics.EnergyDensityMatrix" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="sisl.physics.Hamiltonian.html" class="btn btn-neutral float-right" title="sisl.physics.Hamiltonian" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>