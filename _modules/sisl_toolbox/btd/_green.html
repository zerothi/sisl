

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl_toolbox.btd._green &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=e6894c64"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl_toolbox.btd._green</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl_toolbox.btd._green</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">ssp</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="n">svds</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sisl</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">si</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl</span><span class="w"> </span><span class="kn">import</span> <span class="n">_array</span> <span class="k">as</span> <span class="n">_a</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._indices</span><span class="w"> </span><span class="kn">import</span> <span class="n">indices_only</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.linalg</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">cholesky</span><span class="p">,</span>
    <span class="n">eigh</span><span class="p">,</span>
    <span class="n">eigh_destroy</span><span class="p">,</span>
    <span class="n">inv_destroy</span><span class="p">,</span>
    <span class="n">signsqrt</span><span class="p">,</span>
    <span class="n">solve</span><span class="p">,</span>
    <span class="n">sqrth</span><span class="p">,</span>
    <span class="n">svd_destroy</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">KPoint</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing._core</span><span class="w"> </span><span class="kn">import</span> <span class="n">SileLike</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">PropertyDict</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">._btd</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._electrode</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._help</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;DeviceGreen&quot;</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_scat_state_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Calculating the SVD of matrix A for the scattering state</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    A : numpy.ndarray</span>
<span class="sd">       matrix to obtain SVD from</span>
<span class="sd">    scale : bool or float, optional</span>
<span class="sd">       whether to scale matrix `A` to be above ``1e-12`` or by a user-defined number</span>
<span class="sd">    lapack_driver : str, optional</span>
<span class="sd">       driver queried from `scipy.linalg.svd`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">scale</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;scale&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Scale matrix by a factor to lie in [1e-12; inf[</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">log10</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">scale</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">12</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="mi">10</span> <span class="o">**</span> <span class="p">(</span><span class="o">-</span><span class="mi">12</span> <span class="o">-</span> <span class="n">scale</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">scale</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">A</span> <span class="o">*=</span> <span class="n">scale</span>

    <span class="n">ret_uv</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ret_uv&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

    <span class="c1"># Numerous accounts of SVD algorithms using gesdd results</span>
    <span class="c1"># in poor results when min(M, N) &gt;= 26 (block size).</span>
    <span class="c1"># This may be an error in the D&amp;C algorithm.</span>
    <span class="c1"># Here we resort to precision over time, but user may decide.</span>
    <span class="n">driver</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;driver&quot;</span><span class="p">,</span> <span class="s2">&quot;gesvd&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">driver</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;arpack&quot;</span><span class="p">,</span> <span class="s2">&quot;lobpcg&quot;</span><span class="p">,</span> <span class="s2">&quot;sparse&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">driver</span> <span class="o">==</span> <span class="s2">&quot;sparse&quot;</span><span class="p">:</span>
            <span class="n">driver</span> <span class="o">=</span> <span class="s2">&quot;arpack&quot;</span>  <span class="c1"># scipy default</span>

        <span class="c1"># filter out keys for scipy.sparse.svds</span>
        <span class="n">svds_kwargs</span> <span class="o">=</span> <span class="p">{</span>
            <span class="n">key</span><span class="p">:</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;ncv&quot;</span><span class="p">,</span> <span class="s2">&quot;tol&quot;</span><span class="p">,</span> <span class="s2">&quot;v0&quot;</span><span class="p">)</span> <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span>
        <span class="p">}</span>
        <span class="c1"># do not calculate vt</span>
        <span class="n">svds_kwargs</span><span class="p">[</span><span class="s2">&quot;return_singular_vectors&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span> <span class="k">if</span> <span class="n">ret_uv</span> <span class="k">else</span> <span class="s2">&quot;u&quot;</span>
        <span class="n">svds_kwargs</span><span class="p">[</span><span class="s2">&quot;solver&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">driver</span>
        <span class="k">if</span> <span class="s2">&quot;k&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">svds_kwargs</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="k">if</span> <span class="n">k</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">svds_kwargs</span><span class="p">[</span><span class="s2">&quot;k&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">k</span>

        <span class="n">A</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">svds</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">svds_kwargs</span><span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># it must be a lapack driver:</span>
        <span class="n">A</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">B</span> <span class="o">=</span> <span class="n">svd_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">full_matrices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">lapack_driver</span><span class="o">=</span><span class="n">driver</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;ret_uv&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">del</span> <span class="n">B</span>

    <span class="k">if</span> <span class="n">scale</span><span class="p">:</span>
        <span class="n">DOS</span> <span class="o">/=</span> <span class="n">scale</span>

    <span class="c1"># A note of caution.</span>
    <span class="c1"># The DOS values are not actual DOS values.</span>
    <span class="c1"># In fact the DOS should be calculated as:</span>
    <span class="c1">#   DOS * &lt;i| S(k) |i&gt;</span>
    <span class="c1"># to account for the overlap matrix. For orthogonal basis sets</span>
    <span class="c1"># this DOS eigenvalue is correct.</span>
    <span class="k">return</span> <span class="n">DOS</span> <span class="o">*</span> <span class="n">DOS</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">),</span> <span class="n">A</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl_toolbox.btd&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">DeviceGreen</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Block-tri-diagonal Green function calculator</span>

<span class="sd">    This class enables the extraction and calculation of some important</span>
<span class="sd">    quantities not currently accessible in TBtrans.</span>

<span class="sd">    For instance it may be used to calculate scattering states from</span>
<span class="sd">    the Green function.</span>
<span class="sd">    Once scattering states have been calculated one may also calculate</span>
<span class="sd">    the eigenchannels.</span>

<span class="sd">    Both calculations are very efficient and uses very little memory</span>
<span class="sd">    compared to the full matrices normally used.</span>

<span class="sd">    Consider a regular 2 electrode setup with transport direction</span>
<span class="sd">    along the 3rd lattice vector. Then the following example may</span>
<span class="sd">    be used to calculate the eigen-channels.</span>

<span class="sd">    The below short-form of reading all variables should cover most variables</span>
<span class="sd">    encountered in the FDF file.</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       G = DeviceGreen.from_fdf(&quot;RUN.fdf&quot;)</span>

<span class="sd">       # Calculate the scattering state from the left electrode</span>
<span class="sd">       # and then the eigen channels to the right electrode</span>
<span class="sd">       state = G.scattering_state(&quot;Left&quot;, E=0.1)</span>
<span class="sd">       eig_channel = G.eigenchannel(state, &quot;Right&quot;)</span>

<span class="sd">    The above ``DeviceGreen.from_fdf`` is a short-hand for something</span>
<span class="sd">    like the below (it actually does more than that, so prefer the `from_fdf`):</span>

<span class="sd">    .. code-block:: python</span>

<span class="sd">       import sisl</span>
<span class="sd">       from sisl_toolbox.btd import *</span>
<span class="sd">       # First read in the required data</span>
<span class="sd">       H_elec = sisl.Hamiltonian.read(&quot;ELECTRODE.nc&quot;)</span>
<span class="sd">       H = sisl.Hamiltonian.read(&quot;DEVICE.nc&quot;)</span>
<span class="sd">       # remove couplings along the self-energy direction</span>
<span class="sd">       # to ensure no fake couplings.</span>
<span class="sd">       H.set_nsc(c=1)</span>

<span class="sd">       # Read in a single tbtrans output which contains the BTD matrices</span>
<span class="sd">       # and instructs this class how it should pivot the matrix to obtain</span>
<span class="sd">       # a BTD matrix.</span>
<span class="sd">       tbt = sisl.get_sile(&quot;siesta.TBT.nc&quot;)</span>

<span class="sd">       # Define the self-energy calculators which will downfold the</span>
<span class="sd">       # self-energies into the device region.</span>
<span class="sd">       # Since a downfolding will be done it requires the device Hamiltonian.</span>
<span class="sd">       H_elec.shift(tbt.mu(&quot;Left&quot;))</span>
<span class="sd">       left = DownfoldSelfEnergy(&quot;Left&quot;, s.RecursiveSI(H_elec, &quot;-C&quot;, eta=tbt.eta(&quot;Left&quot;),</span>
<span class="sd">                                 tbt, H)</span>
<span class="sd">       H_elec.shift(tbt.mu(&quot;Right&quot;))</span>
<span class="sd">       left = DownfoldSelfEnergy(&quot;Right&quot;, s.RecursiveSI(H_elec, &quot;+C&quot;, eta=tbt.eta(&quot;Right&quot;),</span>
<span class="sd">                                 tbt, H)</span>

<span class="sd">       G = DeviceGreen(H, [left, right], tbt)</span>


<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    Sometimes one wishes to investigate more details in the calculation process</span>
<span class="sd">    to discern importance of the eigenvalue separations.</span>

<span class="sd">    When calculating scattering states/matrices one can</span>
<span class="sd">    reduce the complexity by removing eigen/singular values.</span>
<span class="sd">    By default we use the `cutoff` values as a relative cutoff value for</span>
<span class="sd">    the values. I.e. keeping ``value / value.max() &gt; cutoff``.</span>
<span class="sd">    However, sometimes the relative value is a bad metric since there are</span>
<span class="sd">    still important values close to unity value. Consider e.g. an array of</span>
<span class="sd">    values of ``[1e5, 1e4, 1, 0.5, 1e-4]``. In this case we would require the</span>
<span class="sd">    ``[1, 0.5]`` values as important, but this would only be grabbed by a relative</span>
<span class="sd">    cutoff value of ``1e-6`` which in some other cases are a too high value.</span>

<span class="sd">    Instead of providing `cutoff` values as `float` values, one can also</span>
<span class="sd">    pass a function that takes in an array of values. It should return the</span>
<span class="sd">    indices of the values it wishes to retain.</span>

<span class="sd">    The below is equivalent to a cutoff value of ``1e-4``, or values</span>
<span class="sd">    above 0.01.</span>
<span class="sd">    &gt;&gt;&gt; def cutoff_func(V):</span>
<span class="sd">    &gt;&gt;&gt;     return np.logical_or(V / V.max() &gt; 1e-4, V &gt; 1e-2).nonzero()[0]</span>

<span class="sd">    Passing functions for cutting off values can be useful because one</span>
<span class="sd">    can also debug the values and see what&#39;s happening.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># TODO we should speed this up by overwriting A with the inverse once</span>
    <span class="c1">#      calculated. We don&#39;t need it at that point.</span>
    <span class="c1">#      That would probably require us to use a method to retrieve</span>
    <span class="c1">#      the elements which determines if it has been calculated or not.</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">:</span> <span class="n">si</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="p">,</span> <span class="n">elecs</span><span class="p">,</span> <span class="n">pivot</span><span class="p">,</span> <span class="n">eta</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create Green function with Hamiltonian and BTD matrix elements&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">H</span> <span class="o">=</span> <span class="n">H</span>

        <span class="c1"># Store electrodes (for easy retrieval of the SE)</span>
        <span class="c1"># There may be no electrodes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span> <span class="o">=</span> <span class="n">elecs</span>

        <span class="c1"># In case the pivot scheme does match the spin-orbit case</span>
        <span class="c1"># We should fix things</span>
        <span class="n">expand</span> <span class="o">=</span> <span class="n">get_expand</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">),</span> <span class="n">pivot</span><span class="o">.</span><span class="n">no_u</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">expand</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The pivoting information in </span><span class="si">{</span><span class="n">pivot</span><span class="si">!s}</span><span class="s2"> does not &quot;</span>
                <span class="s2">&quot;match the number of expanded orbitals in the Hamiltonian.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Will expand all necessary arrays with </span><span class="si">{</span><span class="n">expand</span><span class="si">}</span><span class="s2"> for compatibility.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># the pivoting table for the device region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span> <span class="o">=</span> <span class="n">expand_orbs</span><span class="p">(</span><span class="n">pivot</span><span class="o">.</span><span class="n">pivot</span><span class="p">(),</span> <span class="n">expand</span><span class="p">)</span>
        <span class="c1"># the BTD blocks (in the pivoted space) for the device region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd</span> <span class="o">=</span> <span class="n">expand_btd</span><span class="p">(</span><span class="n">pivot</span><span class="o">.</span><span class="n">btd</span><span class="p">(),</span> <span class="n">expand</span><span class="p">)</span>

        <span class="c1"># global device eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">eta</span>

        <span class="c1"># Create BTD indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">no: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">, blocks: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span><span class="si">}</span><span class="s2">, eta: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="si">:</span><span class="s2">.3e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="n">e</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">  &quot;</span><span class="p">)</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">elec</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">:</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ret</span><span class="si">}</span><span class="se">\n}}</span><span class="s2">&quot;</span>

<div class="viewcode-block" id="DeviceGreen.from_fdf">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.from_fdf">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">from_fdf</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">fdf</span><span class="p">:</span> <span class="n">SileLike</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;TBT&quot;</span><span class="p">,</span> <span class="s2">&quot;TS&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;TBT&quot;</span><span class="p">,</span>
        <span class="n">use_tbt_se</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">eta</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a new `DeviceGreen` using information gathered from the fdf file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        fdf :</span>
<span class="sd">           fdf file to read the parameters from</span>
<span class="sd">        prefix :</span>
<span class="sd">           which prefix to use, if TBT it will prefer TBT prefix, but fall back</span>
<span class="sd">           to TS prefixes.</span>
<span class="sd">           If TS, only these prefixes will be used.</span>
<span class="sd">        use_tbt_se :</span>
<span class="sd">           whether to use the TBT.SE.nc files for self-energies</span>
<span class="sd">           or calculate them on the fly.</span>
<span class="sd">        eta :</span>
<span class="sd">            force a specific eta value</span>
<span class="sd">        kwargs :</span>
<span class="sd">            passed to the class instantiating.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">fdf</span><span class="p">,</span> <span class="n">si</span><span class="o">.</span><span class="n">BaseSile</span><span class="p">):</span>
            <span class="n">fdf</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">io</span><span class="o">.</span><span class="n">siesta</span><span class="o">.</span><span class="n">fdfSileSiesta</span><span class="p">(</span><span class="n">fdf</span><span class="p">)</span>

        <span class="c1"># Now read the values needed</span>
        <span class="n">slabel</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;SystemLabel&quot;</span><span class="p">,</span> <span class="s2">&quot;siesta&quot;</span><span class="p">)</span>
        <span class="c1"># Test if the TBT output file exists:</span>
        <span class="n">tbt</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">end</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;TBT.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;TBT_UP.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;TBT_DN.nc&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                <span class="n">tbt</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">tbt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf could &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;not find file </span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.[TBT|TBT_UP|TBT_DN].nc&quot;</span>
            <span class="p">)</span>
        <span class="n">tbt</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="n">tbt</span><span class="p">)</span>
        <span class="n">is_tbtrans</span> <span class="o">=</span> <span class="n">prefix</span><span class="o">.</span><span class="n">upper</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;TBT&quot;</span>

        <span class="c1"># Read the device H, only valid for TBT stuff</span>
        <span class="k">for</span> <span class="n">hs_ext</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;TS.HSX&quot;</span><span class="p">,</span> <span class="s2">&quot;TSHS&quot;</span><span class="p">,</span> <span class="s2">&quot;HSX&quot;</span><span class="p">,</span> <span class="s2">&quot;nc&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">hs_ext</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">exists</span><span class="p">():</span>
                <span class="c1"># choose a sane default (if it exists!)</span>
                <span class="n">hs_default</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">hs_ext</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="k">break</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">hs_default</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TSHS&quot;</span>
        <span class="n">Hdev</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TBT.HS&quot;</span><span class="p">,</span> <span class="n">hs_default</span><span class="p">))</span><span class="o">.</span><span class="n">read_hamiltonian</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_line</span><span class="p">(</span><span class="n">line</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Parse lines in the %block constructs of fdf&#39;s&quot;&quot;&quot;</span>
            <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">val</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;#&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">read_electrode</span><span class="p">(</span><span class="n">elec_prefix</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Parse the electrode information and return a dictionary with content&quot;&quot;&quot;</span>
            <span class="kn">from</span><span class="w"> </span><span class="nn">sisl.unit.siesta</span><span class="w"> </span><span class="kn">import</span> <span class="n">unit_convert</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">is_tbtrans</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;tbt.</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">ret</span>
                    <span class="n">ret</span><span class="p">,</span> <span class="n">un</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_convert</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ret</span> <span class="o">=</span> <span class="n">dic</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">unit</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                        <span class="k">return</span> <span class="n">ret</span>
                    <span class="n">ret</span><span class="p">,</span> <span class="n">un</span> <span class="o">=</span> <span class="n">ret</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="k">return</span> <span class="nb">float</span><span class="p">(</span><span class="n">ret</span><span class="p">)</span> <span class="o">*</span> <span class="n">unit_convert</span><span class="p">(</span><span class="n">un</span><span class="p">,</span> <span class="n">unit</span><span class="p">)</span>

            <span class="n">tbt_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;TBT.</span><span class="si">{</span><span class="n">elec_prefix</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">ts_prefix</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;TS.</span><span class="si">{</span><span class="n">elec_prefix</span><span class="si">}</span><span class="s2">&quot;</span>

            <span class="n">block</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts_prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">Helec</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts_prefix</span><span class="si">}</span><span class="s2">.HS&quot;</span><span class="p">)</span>
            <span class="n">bulk</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TS.Elecs.Bulk&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">eta</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TS.Elecs.Eta&quot;</span><span class="p">,</span> <span class="mf">1e-3</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
            <span class="n">bloch</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">ts_prefix</span><span class="si">}</span><span class="s2">.Bloch.A</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">is_tbtrans</span><span class="p">:</span>
                <span class="n">block</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tbt_prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">block</span><span class="p">)</span>
                <span class="n">Helec</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tbt_prefix</span><span class="si">}</span><span class="s2">.HS&quot;</span><span class="p">,</span> <span class="n">Helec</span><span class="p">)</span>
                <span class="n">bulk</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TBT.Elecs.Bulk&quot;</span><span class="p">,</span> <span class="n">bulk</span><span class="p">)</span>
                <span class="n">eta</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;TBT.Elecs.Eta&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                    <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">tbt_prefix</span><span class="si">}</span><span class="s2">.Bloch.A</span><span class="si">{</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="c1"># Convert to key value based function</span>
            <span class="n">dic</span> <span class="o">=</span> <span class="p">{</span><span class="n">key</span><span class="p">:</span> <span class="n">val</span> <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span> <span class="ow">in</span> <span class="nb">map</span><span class="p">(</span><span class="n">get_line</span><span class="p">,</span> <span class="n">block</span><span class="p">)}</span>

            <span class="c1"># Retrieve data</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;hs&quot;</span><span class="p">,</span> <span class="s2">&quot;hs-file&quot;</span><span class="p">,</span> <span class="s2">&quot;tshs&quot;</span><span class="p">,</span> <span class="s2">&quot;tshs-file&quot;</span><span class="p">):</span>
                <span class="n">Helec</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">Helec</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">Helec</span><span class="p">:</span>
                <span class="n">Helec</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="n">Helec</span><span class="p">)</span><span class="o">.</span><span class="n">read_hamiltonian</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf could not find &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;electrode HS in block: </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> ??&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Get semi-infinite direction</span>
            <span class="n">semi_inf</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">for</span> <span class="n">suf</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-direction&quot;</span><span class="p">,</span> <span class="s2">&quot;-dir&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
                <span class="n">semi_inf</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;semi-inf</span><span class="si">{</span><span class="n">suf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">semi_inf</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">semi_inf</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf could not find &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;electrode semi-inf-direction in block: </span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2"> ??&quot;</span>
                <span class="p">)</span>
            <span class="c1"># convert to sisl infinite</span>
            <span class="n">semi_inf</span> <span class="o">=</span> <span class="n">semi_inf</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="n">semi_inf</span> <span class="o">=</span> <span class="n">semi_inf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="p">{</span><span class="s2">&quot;a1&quot;</span><span class="p">:</span> <span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a2&quot;</span><span class="p">:</span> <span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a3&quot;</span><span class="p">:</span> <span class="s2">&quot;c&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span>
                <span class="n">semi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">semi_inf</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
            <span class="p">)</span>
            <span class="c1"># Check that semi_inf is a recursive one!</span>
            <span class="k">if</span> <span class="n">semi_inf</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-a&quot;</span><span class="p">,</span> <span class="s2">&quot;+a&quot;</span><span class="p">,</span> <span class="s2">&quot;-b&quot;</span><span class="p">,</span> <span class="s2">&quot;+b&quot;</span><span class="p">,</span> <span class="s2">&quot;-c&quot;</span><span class="p">,</span> <span class="s2">&quot;+c&quot;</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not implement other &quot;</span>
                    <span class="s2">&quot;self energies than the recursive one.&quot;</span>
                <span class="p">)</span>

            <span class="n">bulk</span> <span class="o">=</span> <span class="nb">bool</span><span class="p">(</span><span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;bulk&quot;</span><span class="p">,</span> <span class="n">bulk</span><span class="p">))</span>
            <span class="c1"># loop for 0</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sufs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">([(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="s2">&quot;a1&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;a2&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;c&quot;</span><span class="p">,</span> <span class="s2">&quot;a3&quot;</span><span class="p">)]):</span>
                <span class="k">for</span> <span class="n">suf</span> <span class="ow">in</span> <span class="n">sufs</span><span class="p">:</span>
                    <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;bloch-</span><span class="si">{</span><span class="n">suf</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">bloch</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

            <span class="n">bloch</span> <span class="o">=</span> <span class="p">[</span>
                <span class="nb">int</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">block_get</span><span class="p">(</span>
                    <span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;bloch&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">bloch</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bloch</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">bloch</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
            <span class="p">]</span>

            <span class="n">ret</span><span class="o">.</span><span class="n">eta</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;eta&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
            <span class="c1"># manual shift of the fermi-level</span>
            <span class="n">dEf</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;delta-Ef&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
            <span class="c1"># shift electronic structure here, we store it in the returned</span>
            <span class="c1"># dictionary, for information, but it shouldn&#39;t be used!</span>
            <span class="n">Helec</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">dEf</span><span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">dEf</span> <span class="o">=</span> <span class="n">dEf</span>
            <span class="c1"># add a fraction of the bias in the coupling elements of the</span>
            <span class="c1"># E-C region, only meaningful for</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">V_fraction</span> <span class="o">=</span> <span class="n">block_get</span><span class="p">(</span><span class="n">dic</span><span class="p">,</span> <span class="s2">&quot;V-fraction&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret</span><span class="o">.</span><span class="n">V_fraction</span> <span class="o">&gt;</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf(electrode=</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">) found a non-zero V-fraction value. &quot;</span>
                    <span class="s2">&quot;This is currently not implemented.&quot;</span>
                <span class="p">)</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">Helec</span> <span class="o">=</span> <span class="n">Helec</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">bloch</span> <span class="o">=</span> <span class="n">bloch</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">semi_inf</span> <span class="o">=</span> <span class="n">semi_inf</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">bulk</span> <span class="o">=</span> <span class="n">bulk</span>
            <span class="k">return</span> <span class="n">ret</span>

        <span class="c1"># Loop electrodes and read in and construct data</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_tbt_se</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">use_tbt_se</span><span class="p">:</span>
                <span class="n">use_tbt_se</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elecs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">use_tbt_se</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">use_tbt_se</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">use_tbt_se</span> <span class="o">=</span> <span class="p">[</span><span class="n">use_tbt_se</span><span class="p">]</span>

        <span class="n">elec_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">eta_dev</span> <span class="o">=</span> <span class="mf">1e123</span>  <span class="c1"># just a very large number so we default to the smallest one</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="c1"># read from the block</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">read_electrode</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Elec.</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">elec_data</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">=</span> <span class="n">data</span>

            <span class="c1"># read from the TBT file (to check if the user has changed the input file)</span>
            <span class="n">elec_eta</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">elec_eta</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf(electrode=</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">) found inconsistent &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;imaginary eta from the fdf vs. TBT output, will use fdf value.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tbt</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">elec_eta</span><span class="si">}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">fdf</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="si">}</span><span class="s2"> eV&quot;</span>
                <span class="p">)</span>

            <span class="n">bloch</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">bloch</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">bloch</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">bloch</span><span class="p">):</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf(electrode=</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">) found inconsistent &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;Bloch expansions from the fdf vs. TBT output, will use fdf value.</span><span class="se">\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tbt</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">bloch</span><span class="si">}</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">fdf</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">data</span><span class="o">.</span><span class="n">bloch</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

            <span class="n">eta_dev</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="p">,</span> <span class="n">eta_dev</span><span class="p">)</span>

        <span class="c1"># Correct by a factor 1/10 to minimize smearing for device states.</span>
        <span class="c1"># We want the electrode to smear.</span>
        <span class="n">eta_dev</span> <span class="o">/=</span> <span class="mi">10</span>

        <span class="c1"># Now we can estimate the device eta value.</span>
        <span class="c1"># It is based on the electrode values</span>
        <span class="n">eta_dev_tbt</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">eta</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">is_tbtrans</span><span class="p">:</span>
            <span class="n">eta_key</span> <span class="o">=</span> <span class="s2">&quot;TBT.Contours.Eta&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eta_key</span> <span class="o">=</span> <span class="s2">&quot;TS.Contours.nEq.Eta&quot;</span>
        <span class="n">eta_dev_found</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">type</span><span class="p">(</span><span class="n">eta_key</span><span class="p">)</span>
        <span class="c1"># work-around to ensure we don&#39;t default to something that</span>
        <span class="c1"># isn&#39;t in the TBT.nc file</span>
        <span class="k">if</span> <span class="n">eta_dev_found</span><span class="p">:</span>
            <span class="n">eta_dev</span> <span class="o">=</span> <span class="n">fdf</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">eta_key</span><span class="p">,</span> <span class="n">eta_dev</span><span class="p">,</span> <span class="n">unit</span><span class="o">=</span><span class="s2">&quot;eV&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">eta_dev</span> <span class="o">=</span> <span class="n">eta_dev_tbt</span>

        <span class="k">if</span> <span class="n">eta</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># use passed option</span>
            <span class="n">eta_dev</span> <span class="o">=</span> <span class="n">eta</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">eta_dev</span><span class="p">,</span> <span class="n">eta_dev_tbt</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf found inconsistent &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;imaginary eta from the fdf vs. TBT output, will use fdf value.</span><span class="se">\n</span><span class="s2">&quot;</span>
                <span class="sa">f</span><span class="s2">&quot;  </span><span class="si">{</span><span class="n">tbt</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">eta_dev_tbt</span><span class="si">}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">  </span><span class="si">{</span><span class="n">fdf</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">eta_dev</span><span class="si">}</span><span class="s2"> eV&quot;</span>
            <span class="p">)</span>

        <span class="n">elecs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="n">mu</span> <span class="o">=</span> <span class="n">tbt</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">elec_data</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">use_tbt_se</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">Path</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TBT.SE.nc&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
                    <span class="n">tbtse</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TBT.SE.nc&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">FileNotFoundError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.from_fdf &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;could not find file </span><span class="si">{</span><span class="n">slabel</span><span class="si">}</span><span class="s2">.TBT.SE.nc &quot;</span>
                        <span class="s2">&quot;but it was requested by &#39;use_tbt_se&#39;!&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># shift according to potential</span>
            <span class="n">data</span><span class="o">.</span><span class="n">Helec</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span>
            <span class="n">data</span><span class="o">.</span><span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
            <span class="n">se</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">RecursiveSI</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">Helec</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">semi_inf</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">eta</span><span class="p">)</span>

            <span class="c1"># Limit connections of the device along the semi-inf directions</span>
            <span class="c1"># TODO check whether there are systems where it is important</span>
            <span class="c1"># we do all set_nsc before passing it for each electrode.</span>
            <span class="n">kw</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;abc&quot;</span><span class="p">[</span><span class="n">se</span><span class="o">.</span><span class="n">semi_inf</span><span class="p">]:</span> <span class="mi">1</span><span class="p">}</span>
            <span class="n">Hdev</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">**</span><span class="n">kw</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">use_tbt_se</span><span class="p">:</span>
                <span class="n">elec_se</span> <span class="o">=</span> <span class="n">PivotSelfEnergy</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">tbtse</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">elec_se</span> <span class="o">=</span> <span class="n">DownfoldSelfEnergy</span><span class="p">(</span>
                    <span class="n">elec</span><span class="p">,</span>
                    <span class="n">se</span><span class="p">,</span>
                    <span class="n">tbt</span><span class="p">,</span>
                    <span class="n">Hdev</span><span class="p">,</span>
                    <span class="n">eta_device</span><span class="o">=</span><span class="n">eta_dev</span><span class="p">,</span>
                    <span class="n">bulk</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">bulk</span><span class="p">,</span>
                    <span class="n">bloch</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">bloch</span><span class="p">,</span>
                <span class="p">)</span>

            <span class="n">elecs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elec_se</span><span class="p">)</span>

        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">Hdev</span><span class="p">,</span> <span class="n">elecs</span><span class="p">,</span> <span class="n">tbt</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">eta_dev</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="DeviceGreen.clear">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.clear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">clear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">keys</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Clean any memory used by this object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">keys</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                    <span class="k">pass</span>  <span class="c1"># ok that key does not exist</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="n">PropertyDict</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Length of Green function matrix.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_elec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a string electrode to the proper linear index&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">iel</span><span class="p">,</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">el</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">elec</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">iel</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">PivotSelfEnergy</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
            <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elec</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">elec</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_serialize_elecs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elecs</span><span class="p">,</span> <span class="n">omit_elecs</span><span class="p">:</span> <span class="n">Optional</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a list/str/int of elecs into a list of ints&quot;&quot;&quot;</span>
        <span class="n">is_all</span> <span class="o">=</span> <span class="n">elecs</span> <span class="ow">is</span> <span class="kc">None</span>  <span class="c1"># TODO change this to something more sensible</span>
        <span class="k">if</span> <span class="n">is_all</span><span class="p">:</span>
            <span class="n">elecs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">)))</span>
        <span class="n">is_single</span> <span class="o">=</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elecs</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_single</span><span class="p">:</span>
            <span class="c1"># ensure it is a list</span>
            <span class="n">elecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">elecs</span><span class="p">]</span>

        <span class="c1"># convert to list of ints</span>
        <span class="n">elecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elecs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_all</span> <span class="ow">and</span> <span class="n">omit_elecs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">omit_elecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serialize_elecs</span><span class="p">(</span><span class="n">omit_elecs</span><span class="p">)</span>
            <span class="n">elecs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">elec</span><span class="p">:</span> <span class="ow">not</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">omit_elecs</span><span class="p">,</span> <span class="n">elecs</span><span class="p">))</span>
            <span class="n">is_single</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">elecs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">is_single</span><span class="p">,</span> <span class="n">elecs</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_elec_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert an electrode index or str to the name of the electrode&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">elec</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">PivotSelfEnergy</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">elec</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">name</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_pivot_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pivot&#39;s a (full) matrix, i.e. not one that is already reduced.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">M</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">,</span> <span class="p">:][:,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_as_cutoff_func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure the cutoff value is transformed into a cut-off function&quot;&quot;&quot;</span>

        <span class="c1"># Removing values is hard, because there may be loads</span>
        <span class="c1"># of values very close to each other.</span>
        <span class="c1"># I.e. a list of:</span>
        <span class="c1"># [1.1e-4, 1.0e-4, 1e-5]</span>
        <span class="c1"># Then they are *all* important to capture the physics.</span>
        <span class="c1"># Hence, the cutoff is a *relative* cutoff to the highest value.</span>
        <span class="c1"># I.e. if the cutoff is 1e-3.</span>
        <span class="c1"># Then all values which are within a factor of 1000 from the highest</span>
        <span class="c1"># value (absolute), will be retained.</span>
        <span class="c1"># This is much more stable for things with low DOS.</span>
        <span class="c1"># Perhaps there should be some way to retrieve these values, to</span>
        <span class="c1"># actually check if it makes physical sense.</span>
        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">cutoff</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">cutoff</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">cutoff_func</span><span class="p">(</span><span class="n">v</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">cutoff</span>
            <span class="n">rel_v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">rel_v</span> <span class="o">&gt;=</span> <span class="n">cutoff</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">cutoff_func</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_check_Ek</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether the stored quantities has already been calculated</span>

<span class="sd">        It does this by checking the internal data-structures stored `E` and `k`</span>
<span class="sd">        values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
                <span class="c1"># we have already prepared the calculation</span>
                <span class="k">return</span> <span class="kc">True</span>

        <span class="c1"># while resetting is not necessary, it can</span>
        <span class="c1"># save a lot of memory since some arrays are not</span>
        <span class="c1"># temporarily stored twice.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">kwargs</span> <span class="o">=</span> <span class="n">kwargs</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="c1"># the imaginary value in the device region</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Ec</span> <span class="o">=</span> <span class="n">E</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">isrealobj</span><span class="p">(</span><span class="n">E</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">Ec</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">eta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>

        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_se</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Pre-calculate all self-energies (and store the Gamma matrices as well).&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_Ek</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;se&quot;</span><span class="p">):</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;tgamma&quot;</span><span class="p">)</span>

        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span>

        <span class="c1"># Create all self-energies (and store the Gamma&#39;s)</span>
        <span class="n">se</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
            <span class="c1"># Insert values</span>
            <span class="n">SE</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">self_energy</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="n">se</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">SE</span><span class="p">)</span>
            <span class="n">gamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">se2broadening</span><span class="p">(</span><span class="n">SE</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">se</span> <span class="o">=</span> <span class="n">se</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare_tgamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_Ek</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;tgamma&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hash</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma_cutoff</span><span class="p">:</span>
                    <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;se&quot;</span><span class="p">)</span>

        <span class="c1"># ensure we have the self-energies</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">tgamma</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="c1"># See Sanz, Mach-Zender paper</span>
        <span class="c1"># Get the sqrt of the level broadening matrix</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">eigh_sqrt</span><span class="p">(</span><span class="n">gam</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">cutoff</span>
            <span class="n">eig</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">eigh</span><span class="p">(</span><span class="n">gam</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">(</span><span class="n">eig</span><span class="p">)</span>
            <span class="n">eig</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">emath</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">eig</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">eig</span> <span class="o">*</span> <span class="n">U</span>

        <span class="k">for</span> <span class="n">gam</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">:</span>
            <span class="n">tgamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">eigh_sqrt</span><span class="p">(</span><span class="n">gam</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma</span> <span class="o">=</span> <span class="n">tgamma</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma_cutoff</span> <span class="o">=</span> <span class="nb">hash</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_prepare</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Pre-calculate the needed quantities for Green function calculation</span>

<span class="sd">        It calculates:</span>

<span class="sd">        - self-energies (and consequently the Gamma matrices)</span>
<span class="sd">        - Splits the inverse-Green function into blocks according</span>
<span class="sd">          to the article.</span>

<span class="sd">          .. math::</span>

<span class="sd">             \mathbf A_i, \mathbf B_i, \mathbf C_i, \tilde\mathbf X_i, \tilde\mathbf Y_i</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_check_Ek</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="s2">&quot;A&quot;</span><span class="p">):</span>
                <span class="k">return</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">clear</span><span class="p">(</span><span class="s2">&quot;tgamma&quot;</span><span class="p">,</span> <span class="s2">&quot;se&quot;</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>

        <span class="n">E</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">E</span>
        <span class="c1"># device region: E + 1j*eta</span>
        <span class="n">Ec</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">Ec</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">k</span>

        <span class="c1"># Prepare the Green function calculation</span>
        <span class="n">invG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span> <span class="o">*</span> <span class="n">Ec</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Hk</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">invG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pivot_matrix</span><span class="p">(</span><span class="n">invG</span><span class="p">)</span><span class="o">.</span><span class="n">tolil</span><span class="p">()</span>

        <span class="c1"># Create all self-energies (and store the Gamma&#39;s)</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="s2">&quot;se&quot;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">elec</span><span class="p">,</span> <span class="n">SE</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">,</span> <span class="n">data</span><span class="o">.</span><span class="n">se</span><span class="p">):</span>
                <span class="n">pvt</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">pvt_dev</span>
                <span class="n">invG</span><span class="p">[</span><span class="n">pvt</span><span class="p">,</span> <span class="n">pvt</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">-=</span> <span class="n">SE</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">gamma</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                <span class="n">pvt</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">pvt_dev</span>
                <span class="c1"># Insert values</span>
                <span class="n">SE</span> <span class="o">=</span> <span class="n">elec</span><span class="o">.</span><span class="n">self_energy</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="n">invG</span><span class="p">[</span><span class="n">pvt</span><span class="p">,</span> <span class="n">pvt</span><span class="o">.</span><span class="n">T</span><span class="p">]</span> <span class="o">-=</span> <span class="n">SE</span>
                <span class="n">gamma</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">elec</span><span class="o">.</span><span class="n">se2broadening</span><span class="p">(</span><span class="n">SE</span><span class="p">))</span>
            <span class="k">del</span> <span class="n">SE</span>
            <span class="n">data</span><span class="o">.</span><span class="n">gamma</span> <span class="o">=</span> <span class="n">gamma</span>
        <span class="c1"># convert to csr format (that&#39;s how will mostly convert it)</span>
        <span class="n">invG</span> <span class="o">=</span> <span class="n">invG</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Now we have all needed to calculate the inverse parts of the Green function</span>
        <span class="n">A</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="n">B</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="n">C</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>

        <span class="c1"># Now we can calculate everything</span>
        <span class="n">cbtd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>

        <span class="n">sl0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="c1"># initial matrix A and C</span>
        <span class="n">iG</span> <span class="o">=</span> <span class="n">invG</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sl0</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">slp</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
            <span class="c1"># rotate slices</span>
            <span class="n">sln</span> <span class="o">=</span> <span class="n">sl0</span>
            <span class="n">sl0</span> <span class="o">=</span> <span class="n">slp</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">iG</span> <span class="o">=</span> <span class="n">invG</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>

            <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sln</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sl0</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
            <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">slp</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="c1"># and final matrix A and B</span>
        <span class="n">iG</span> <span class="o">=</span> <span class="n">invG</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">tocsc</span><span class="p">()</span>
        <span class="n">A</span><span class="p">[</span><span class="n">nbm1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">slp</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>
        <span class="n">B</span><span class="p">[</span><span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iG</span><span class="p">[:,</span> <span class="n">sl0</span><span class="p">]</span><span class="o">.</span><span class="n">toarray</span><span class="p">()</span>

        <span class="c1"># clean-up, not used anymore</span>
        <span class="k">del</span> <span class="n">invG</span><span class="p">,</span> <span class="n">iG</span>

        <span class="c1"># store in the data field</span>
        <span class="n">data</span><span class="o">.</span><span class="n">A</span> <span class="o">=</span> <span class="n">A</span>
        <span class="n">data</span><span class="o">.</span><span class="n">B</span> <span class="o">=</span> <span class="n">B</span>
        <span class="n">data</span><span class="o">.</span><span class="n">C</span> <span class="o">=</span> <span class="n">C</span>

        <span class="c1"># Now do propagation forward, tilde matrices</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nb</span>
        <span class="c1"># \tilde Y</span>
        <span class="n">tY</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># \tilde X</span>
        <span class="n">tX</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="o">-</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="c1"># \tilde Y</span>
            <span class="n">tY</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">C</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># \tilde X</span>
            <span class="n">tX</span><span class="p">[</span><span class="n">p</span><span class="p">]</span> <span class="o">=</span> <span class="n">solve</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">p</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">B</span><span class="p">[</span><span class="n">p</span><span class="p">],</span> <span class="n">overwrite_a</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># store tilde-matrices, now we can fast re-calculate everything as needed.</span>
        <span class="n">data</span><span class="o">.</span><span class="n">tX</span> <span class="o">=</span> <span class="n">tX</span>
        <span class="n">data</span><span class="o">.</span><span class="n">tY</span> <span class="o">=</span> <span class="n">tY</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_matrix_to_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">M</span><span class="p">,</span> <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a matrix `M` into a BTD matrix.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        M :</span>
<span class="sd">            the matrix to convert to a BTD matrix form</span>
<span class="sd">        sparse :</span>
<span class="sd">            whether each block in the BTD matrix may be sparse or not.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">BM</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">BM</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">cast</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">M</span>

        <span class="k">if</span> <span class="n">ssp</span><span class="o">.</span><span class="n">issparse</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">cast</span><span class="p">(</span><span class="n">M</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;to</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)()</span>

        <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">)):</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">M</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]])</span>

        <span class="k">return</span> <span class="n">BM</span>

<div class="viewcode-block" id="DeviceGreen.Sk">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.Sk">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Sk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the overlap matrix in the pivoted device region&quot;&quot;&quot;</span>
        <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;btd&quot;</span><span class="p">:</span>
                <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>

        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pivot_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_btd</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_to_btd</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span></div>


<div class="viewcode-block" id="DeviceGreen.Hk">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.Hk">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Hk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the Hamiltonian matrix in the pivoted device region&quot;&quot;&quot;</span>
        <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s2">&quot;format&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;btd&quot;</span><span class="p">:</span>
                <span class="n">is_btd</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">del</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;format&quot;</span><span class="p">]</span>

        <span class="n">M</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pivot_matrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Hk</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">is_btd</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_matrix_to_btd</span><span class="p">(</span><span class="n">M</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">M</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_get_blocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the blocks that an index belongs to&quot;&quot;&quot;</span>
        <span class="n">block1</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">block2</span> <span class="o">=</span> <span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">block1</span> <span class="o">==</span> <span class="n">block2</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">block1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">blocks</span> <span class="o">=</span> <span class="p">[</span><span class="n">b</span> <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">block1</span><span class="p">,</span> <span class="n">block2</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>
        <span class="k">return</span> <span class="n">blocks</span>

<div class="viewcode-block" id="DeviceGreen.green">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.green">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">green</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;array&quot;</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">BlockMatrix</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the Green function for a given `E` and `k` point</span>

<span class="sd">        The Green function is calculated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf G(E,\mathbf k) = \big[\mathbf S(\mathbf k) E - \mathbf H(\mathbf k)</span>
<span class="sd">                  - \sum \boldsymbol \Sigma(E,\mathbf k)\big]^{-1}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E :</span>
<span class="sd">            the energy to calculate at, may be a complex value.</span>
<span class="sd">        k :</span>
<span class="sd">            k-point to calculate the Green function at</span>
<span class="sd">        format : {&quot;array&quot;, &quot;btd&quot;, &quot;bm&quot;, &quot;bd&quot;, &quot;sparse&quot;}</span>
<span class="sd">            return the matrix in a specific format</span>

<span class="sd">            - array: a regular numpy array (full matrix)</span>
<span class="sd">            - btd: a block-matrix object with only the diagonals and first off-diagonals</span>
<span class="sd">            - bm: a block-matrix object with diagonals and all off-diagonals</span>
<span class="sd">            - bd: a block-matrix object with only diagonals (no off-diagonals)</span>
<span class="sd">            - sparse: a sparse-csr matrix for the sparse elements as found in the Hamiltonian</span>
<span class="sd">        dtype :</span>
<span class="sd">            the data-type of the array.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray or BlockMatrix</span>
<span class="sd">            the Green function matrix, the format depends on `format`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;dense&quot;</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_green_</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.green format not valid input [array|sparse|bm|btd|bd]&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_green_array</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function on a full np.array matrix&quot;&quot;&quot;</span>
        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pvt</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">n</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">sumbs</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">btd</span><span class="p">):</span>
            <span class="n">sl0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbs</span> <span class="o">+</span> <span class="n">bs</span><span class="p">)</span>

            <span class="c1"># Calculate diagonal part</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl0</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

            <span class="c1"># Do above</span>
            <span class="n">next_sum</span> <span class="o">=</span> <span class="n">sumbs</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># Calculate all parts above</span>
                <span class="n">sla</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">next_sum</span> <span class="o">-</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">],</span> <span class="n">next_sum</span><span class="p">)</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sla</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="n">sla</span>
                <span class="n">next_sum</span> <span class="o">-=</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

            <span class="n">sl0</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbs</span> <span class="o">+</span> <span class="n">bs</span><span class="p">)</span>

            <span class="c1"># Step block</span>
            <span class="n">sumbs</span> <span class="o">+=</span> <span class="n">bs</span>

            <span class="c1"># Do below</span>
            <span class="n">next_sum</span> <span class="o">=</span> <span class="n">sumbs</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl0</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
                <span class="c1"># Calculate all parts above</span>
                <span class="n">sla</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">next_sum</span><span class="p">,</span> <span class="n">next_sum</span> <span class="o">+</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sla</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">a</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">sl0</span><span class="p">]</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="n">sla</span>
                <span class="n">next_sum</span> <span class="o">+=</span> <span class="n">btd</span><span class="p">[</span><span class="n">a</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_green_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only in the BTD matrix elements.</span>

<span class="sd">        Stored in a `BlockMatrix` class.&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
            <span class="c1"># Calculate diagonal part</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G11</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

            <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">G11</span>
            <span class="c1"># do above</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G11</span>
            <span class="c1"># do below</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G11</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_green_bm</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the full Green function.</span>

<span class="sd">        Stored in a `BlockMatrix` class.&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_btd</span><span class="p">()</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
            <span class="n">G0</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">G0</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span> <span class="o">@</span> <span class="n">G0</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">bb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>
            <span class="n">G0</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">bb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                <span class="n">G0</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">bb</span><span class="p">]</span> <span class="o">@</span> <span class="n">G0</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">bb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">G0</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_green_bd</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only along the diagonal block matrices.</span>

<span class="sd">        Stored in a `BlockMatrix` class.&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">block_indexer</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="n">BI</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
            <span class="c1"># Calculate diagonal part</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
        <span class="n">BI</span><span class="p">[</span><span class="n">nbm1</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">nbm1</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">nbm1</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_green_sparse</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only where the sparse H and S are non-zero.</span>

<span class="sd">        Stored in a `scipy.sparse.csr_matrix` class.&quot;&quot;&quot;</span>
        <span class="c1"># create a sparse matrix</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">H</span><span class="o">.</span><span class="n">Sk</span><span class="p">(</span><span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># pivot the matrix</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_pivot_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="c1"># Get row and column entries</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">indptr</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Now we have [0 0 0 0 1 1 1 1 2 2 ... no-1 no-1]</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">indices</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">row_b</span><span class="p">,</span> <span class="n">col_b</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">col_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">col_b</span> <span class="o">=</span> <span class="n">row_b</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">row_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">row</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">row_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">col_b</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
            <span class="k">return</span> <span class="n">idx</span><span class="p">[</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">col_b</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="n">sumbsn</span><span class="p">,</span> <span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">b</span><span class="p">,</span> <span class="n">bs</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">btd</span><span class="p">):</span>
            <span class="n">sumbsp</span> <span class="o">=</span> <span class="n">sumbs</span> <span class="o">+</span> <span class="n">bs</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">bsp</span> <span class="o">=</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

            <span class="c1"># Calculate diagonal part</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">GM</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">GM</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">GM</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>

            <span class="c1"># get all entries where G is non-zero</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span><span class="p">))</span>
            <span class="n">G</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">GM</span><span class="p">[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">]</span>

            <span class="c1"># check if we should do block above</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">sumbsn</span><span class="p">,</span> <span class="n">sumbs</span><span class="p">),</span> <span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">GM</span><span class="p">)[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbsn</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">]</span>

            <span class="c1"># check if we should do block below</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">get_idx</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="p">(</span><span class="n">sumbsp</span><span class="p">,</span> <span class="n">sumbsp</span> <span class="o">+</span> <span class="n">bsp</span><span class="p">),</span> <span class="p">(</span><span class="n">sumbs</span><span class="p">,</span> <span class="n">sumbsp</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">G</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">GM</span><span class="p">)[</span><span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbsp</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">sumbs</span><span class="p">]</span>

            <span class="n">bsn</span> <span class="o">=</span> <span class="n">bs</span>
            <span class="n">sumbsn</span> <span class="o">=</span> <span class="n">sumbs</span>
            <span class="n">sumbs</span> <span class="o">+=</span> <span class="n">bs</span>

        <span class="k">return</span> <span class="n">G</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the Green function only on specific (neighboring) diagonal block matrices.</span>

<span class="sd">        Stored in a `np.array` class.&quot;&quot;&quot;</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Find parts we need to calculate</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_blocks</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> green(diagonal) requires maximally 2 blocks&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> green(diagonal) requires spanning only 2 blocks&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">ncols</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="c1"># Find the indices in the block</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cols</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

            <span class="n">b_idx</span> <span class="o">=</span> <span class="n">indices_only</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">+</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">ncols</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">),</span> <span class="n">ncols</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[</span>
                    <span class="p">:,</span> <span class="n">b_idx</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Now calculate the thing (below/above)</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="c1"># Calculate below</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">btd</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">+</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Calculate above</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">blocks</span><span class="p">,</span> <span class="n">G</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cols</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the full Green function column for a subset of columns.</span>

<span class="sd">        Stored in a `np.array` class.&quot;&quot;&quot;</span>
        <span class="c1"># To calculate the full Gf for specific column indices</span>
        <span class="c1"># These indices should maximally be spanning 2 blocks</span>
        <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">ncols</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># Find parts we need to calculate</span>
        <span class="n">blocks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_blocks</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">assert</span> <span class="p">(</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">2</span>
        <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.green(column) requires maximally 2 blocks&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.green(column) requires spanning only 2 blocks&quot;</span>

        <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">ncols</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">A</span>
        <span class="n">B</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">B</span>
        <span class="n">C</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">C</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="n">blocks</span><span class="p">:</span>
            <span class="c1"># Find the indices in the block</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">cols</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">&lt;=</span> <span class="n">cols</span><span class="p">]</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">i</span><span class="p">[</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

            <span class="n">b_idx</span> <span class="o">=</span> <span class="n">indices_only</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">i</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">c_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">ncols</span> <span class="o">-</span> <span class="nb">len</span><span class="p">(</span><span class="n">b_idx</span><span class="p">),</span> <span class="n">ncols</span><span class="p">)</span>

            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">==</span> <span class="n">nbm1</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">])[:,</span> <span class="n">b_idx</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">inv_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">B</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">-</span> <span class="n">C</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">])[</span>
                    <span class="p">:,</span> <span class="n">b_idx</span>
                <span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="c1"># Now calculate above/below</span>

            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">b</span> <span class="o">==</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">and</span> <span class="n">b</span> <span class="o">&lt;</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># Calculate below</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">b</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># Calculate above</span>
                <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
                <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="n">c_idx</span><span class="p">]</span>

        <span class="c1"># Now we can calculate the Gf column above</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl</span>

        <span class="c1"># All blocks below</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nb</span><span class="p">):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">b</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">G</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">slp</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="n">sl</span>

        <span class="k">return</span> <span class="n">G</span>

<div class="viewcode-block" id="DeviceGreen.spectral">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.spectral">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spectral</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="nb">format</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;column&quot;</span><span class="p">,</span> <span class="s2">&quot;propagate&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;column&quot;</span><span class="p">,</span>
        <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">BlockMatrix</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the spectral function for a given `E` and `k` point from a given electrode</span>

<span class="sd">        The spectral function is calculated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf A_{\mathfrak{e}}(E,\mathbf k) = \mathbf G(E,\mathbf k)\boldsymbol\Gamma_{\mathfrak{e}}(E,\mathbf k)</span>
<span class="sd">                   \mathbf G^\dagger(E,\mathbf k)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E :</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        elec : str or int</span>
<span class="sd">           the electrode to calculate the spectral function from</span>
<span class="sd">        k :</span>
<span class="sd">           k-point to calculate the spectral function at</span>
<span class="sd">        format : {&quot;array&quot;, &quot;btd&quot;, &quot;bm&quot;, &quot;bd&quot;}</span>
<span class="sd">           return the matrix in a specific format</span>

<span class="sd">           - array: a regular numpy array (full matrix)</span>
<span class="sd">           - bm: in block-matrix form (full matrix)</span>
<span class="sd">           - btd: a block-matrix object with only the diagonals and first off-diagonals</span>
<span class="sd">           - bd: same as btd, since the off-diagonals are already calculated</span>
<span class="sd">        method :</span>
<span class="sd">           which method to use for calculating the spectral function.</span>
<span class="sd">           Depending on the size of the BTD blocks one may be faster than the</span>
<span class="sd">           other. For large systems you are recommended to time the different methods</span>
<span class="sd">           and stick with the fastest one, they are numerically identical.</span>
<span class="sd">        herm:</span>
<span class="sd">           The spectral function is a Hermitian matrix, by default (True), the methods</span>
<span class="sd">           that can utilize the Hermitian property only calculates the lower triangular</span>
<span class="sd">           part of :math:`\mathbf A`, and then copies the Hermitian to the upper part.</span>
<span class="sd">           By setting this to `False` the entire matrix is explicitly calculated.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        np.ndarray or BlockMatrix</span>
<span class="sd">            the spectral function for a given electrode in the format</span>
<span class="sd">            as specified by `format`. Note that some formats does not calculate</span>
<span class="sd">            the entire spectral function matrix.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># the herm flag is considered useful for testing, there is no need to</span>
        <span class="c1"># play with it. So it isn&#39;t documented.</span>

        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="nb">format</span> <span class="o">=</span> <span class="nb">format</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;dense&quot;</span><span class="p">:</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;array&quot;</span>
        <span class="k">elif</span> <span class="nb">format</span> <span class="o">==</span> <span class="s2">&quot;bd&quot;</span><span class="p">:</span>
            <span class="c1"># the bd also returns the off-diagonal ones since</span>
            <span class="c1"># they are needed to calculate the diagonal terms anyway.</span>
            <span class="nb">format</span> <span class="o">=</span> <span class="s2">&quot;btd&quot;</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_spectral_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_</span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.spectral combination of format+method not recognized </span><span class="si">{</span><span class="nb">format</span><span class="si">}</span><span class="s2">+</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_spectral_column_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spectral function from a column array (`herm` not used)&quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="c1"># Now calculate the full spectral function</span>
        <span class="k">return</span> <span class="n">G</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spectral_column_bm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spectral function from a column array</span>

<span class="sd">        Returns a `BlockMatrix` class with all elements calculated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        herm:</span>
<span class="sd">           if true, only calculate the lower triangular part, and copy</span>
<span class="sd">           the Hermitian part to the upper triangular part.</span>
<span class="sd">           Else, calculate the full matrix via MM.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>

        <span class="n">Gam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>

        <span class="c1"># Now calculate the full spectral function</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">btd</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">return</span> <span class="n">btd</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spectral_column_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Spectral function from a column array</span>

<span class="sd">        Returns a `BlockMatrix` class with only BTD blocks calculated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        herm:</span>
<span class="sd">           if true, only calculate the lower triangular part, and copy</span>
<span class="sd">           the Hermitian part to the upper triangular part.</span>
<span class="sd">           Else, calculate the full matrix via MM.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>

        <span class="n">Gam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>

        <span class="c1"># Now calculate the full spectral function</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">btd</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="n">jb</span><span class="p">):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">=</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># loop columns</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nb</span><span class="p">):</span>
                <span class="n">slj</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                <span class="n">Gj</span> <span class="o">=</span> <span class="n">Gam</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">G</span><span class="p">[</span><span class="n">slj</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">min</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">nb</span><span class="p">)):</span>
                    <span class="n">sli</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">sli</span><span class="p">,</span> <span class="p">:]</span> <span class="o">@</span> <span class="n">Gj</span>

        <span class="k">return</span> <span class="n">btd</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spectral_propagate_array</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Allocate space for the full matrix</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>
        <span class="n">S</span><span class="p">[</span><span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:</span> <span class="n">c</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
        <span class="k">del</span> <span class="n">A</span>

        <span class="c1"># now loop backwards</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">):</span>
            <span class="k">return</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">ib</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]),</span> <span class="nb">slice</span><span class="p">(</span><span class="n">c</span><span class="p">[</span><span class="n">jb</span><span class="p">],</span> <span class="n">c</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># above left</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># below</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="c1"># left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above and left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span>
                        <span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>
                <span class="c1"># below and right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">])]</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span>
                        <span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="c1"># right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span> <span class="o">=</span> <span class="o">-</span><span class="n">S</span><span class="p">[</span><span class="n">gs</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">)]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spectral_propagate_bm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">BM</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">BM</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">nblocks</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>

        <span class="c1"># now loop backwards</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># above left</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># below</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="c1"># above</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="c1"># left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nblocks</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="c1"># above and left</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span>
                        <span class="n">tY</span><span class="p">[</span><span class="n">ib</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>
                <span class="c1"># below and right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nbm1</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span>
                        <span class="n">tX</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
                    <span class="p">)</span>

            <span class="c1"># below right</span>
            <span class="k">for</span> <span class="n">jb</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">ib</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span>
                <span class="c1"># calculate next diagonal</span>
                <span class="k">if</span> <span class="n">jb</span> <span class="o">&lt;</span> <span class="n">nbm1</span><span class="p">:</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">jb</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">jb</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="c1"># right</span>
                <span class="k">for</span> <span class="n">ib</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">jb</span><span class="p">,</span> <span class="n">nbm1</span><span class="p">):</span>
                    <span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">jb</span><span class="p">,</span> <span class="n">ib</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">ib</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BM</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_spectral_propagate_btd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">herm</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BlockMatrix</span><span class="p">:</span>
        <span class="n">btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span>
        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">nbm1</span> <span class="o">=</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="n">BM</span> <span class="o">=</span> <span class="n">BlockMatrix</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">BI</span> <span class="o">=</span> <span class="n">BM</span><span class="o">.</span><span class="n">block_indexer</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="p">:</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]]</span>
            <span class="n">BI</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:]</span>

        <span class="c1"># now loop backwards</span>
        <span class="n">tX</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">tY</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>

        <span class="k">if</span> <span class="n">herm</span><span class="p">:</span>
            <span class="c1"># above</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>
            <span class="c1"># right</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nbm1</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># above</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="n">dtY</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">tY</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">A</span> <span class="o">@</span> <span class="n">dtY</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">dtY</span>
            <span class="c1"># right</span>
            <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nbm1</span><span class="p">):</span>
                <span class="n">A</span> <span class="o">=</span> <span class="o">-</span><span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span>
                <span class="n">BI</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">tX</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">BI</span><span class="p">[</span><span class="n">b</span><span class="p">,</span> <span class="n">b</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">BM</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_coefficient_state_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">U</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;U on input is a fortran-index as returned from eigh or svd</span>

<span class="sd">        Also sorts&quot;&quot;&quot;</span>
        <span class="c1"># Select only the first N components where N is the</span>
        <span class="c1"># number of orbitals in the electrode (there can&#39;t be</span>
        <span class="c1"># any more propagating states anyhow).</span>
        <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">])</span>

        <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">cutoff</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># always retain at least 2 eigen-values</span>
                <span class="c1"># Otherwise we will sometimes get 0 states...</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">coeff</span><span class="p">))[:</span> <span class="nb">min</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="mi">2</span><span class="p">)]</span>

            <span class="c1"># sort it</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">coeff</span><span class="p">[</span><span class="n">idx</span><span class="p">])]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="o">-</span><span class="n">coeff</span><span class="p">)</span>

        <span class="c1"># reduce idx to max N elements</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[:</span><span class="n">N</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">coeff</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">U</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">]</span>

<div class="viewcode-block" id="DeviceGreen.scattering_state">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.scattering_state">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scattering_state</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;svd:gamma&quot;</span><span class="p">,</span> <span class="s2">&quot;svd:A&quot;</span><span class="p">,</span> <span class="s2">&quot;eig&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;svd:gamma&quot;</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the scattering states for a given `E` and `k` point from a given electrode</span>

<span class="sd">        The scattering states are the eigen states of the spectral function:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf A_{\mathfrak e}(E,\mathbf k) \mathbf u_i = 2\pi a_i \mathbf u_i</span>

<span class="sd">        where :math:`a_i` is the DOS carried by the :math:`i`&#39;th scattering</span>
<span class="sd">        state.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E :</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        elec : str or int</span>
<span class="sd">           the electrode to calculate the spectral function from</span>
<span class="sd">        k :</span>
<span class="sd">           k-point to calculate the spectral function at</span>
<span class="sd">        cutoff :</span>
<span class="sd">           Cut off the returned scattering states at some DOS value. Any scattering states</span>
<span class="sd">           with relative eigenvalues (to the largest eigenvalue), lower than `cutoff` are discarded.</span>
<span class="sd">           For example, we keep according to :math:`\epsilon_i/\max(\epsilon_i) &gt; \mathrm{cutoff}`.</span>
<span class="sd">           Values above or close to 0.1 should be used with care.</span>
<span class="sd">           Can be a function, see the details of this class.</span>
<span class="sd">        method :</span>
<span class="sd">           which method to use for calculating the scattering states.</span>
<span class="sd">           Use only the ``eig`` method for testing purposes as it is extremely slow</span>
<span class="sd">           and requires a substantial amount of memory.</span>
<span class="sd">           The ``svd:gamma`` is the fastests while retaining complete precision.</span>
<span class="sd">           The ``svd:A`` may be even faster for very large systems with</span>
<span class="sd">           very little loss of precision, since it diagonalizes :math:`\mathbf A` in</span>
<span class="sd">           the subspace of the electrode `elec` and reduces the propagated part of the spectral</span>
<span class="sd">           matrix.</span>
<span class="sd">        cutoff_elec : float, optional</span>
<span class="sd">           Only used for ``method=svd:A``. The initial block of the spectral function is</span>
<span class="sd">           diagonalized and only eigenvectors with relative eigenvalues</span>
<span class="sd">           ``&gt;=cutoff_elec`` are retained.</span>
<span class="sd">           thus reducing the initial propagated modes. The normalization explained for `cutoff`</span>
<span class="sd">           also applies here.</span>
<span class="sd">           Can be a function, see the details of this class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sisl.physics.electron.StateCElectron</span>
<span class="sd">           the scattering states from the spectral function. The ``scat.state`` contains</span>
<span class="sd">           the scattering state vectors (eigenvectors of the spectral function).</span>
<span class="sd">           ``scat.c`` contains the DOS of the scattering states scaled by :math:`1/(2\pi)`</span>
<span class="sd">           so ensure correct density of states.</span>
<span class="sd">           One may recreate the spectral function with ``scat.outer(matrix=scat.c * 2 * pi)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">)</span>
        <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_scattering_state_</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.scattering_state method is not [full,svd,propagate]&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_scattering_state_eig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_method</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># We know that scattering_state has called prepare!</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spectral</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_cutoff_func</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>

        <span class="c1"># add something to the diagonal (improves diag precision for small states)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">A</span><span class="p">))</span>
        <span class="n">CONST</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">CONST</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">idx</span>

        <span class="c1"># Now diagonalize A</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">eigh_destroy</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
        <span class="c1"># backconvert diagonal</span>
        <span class="n">DOS</span> <span class="o">-=</span> <span class="n">CONST</span>
        <span class="c1"># TODO check with overlap convert with correct magnitude (Tr[A] / 2pi)</span>
        <span class="n">DOS</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;full&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span> <span class="n">E</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span>
        <span class="p">)</span>

        <span class="c1"># always have the first state with the largest values</span>
        <span class="k">return</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_scattering_state_svd_gamma</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_method</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_cutoff_func</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>

        <span class="c1"># This calculation uses the cholesky decomposition of Gamma</span>
        <span class="c1"># combined with SVD of the A column</span>
        <span class="k">if</span> <span class="s2">&quot;sqrth&quot;</span> <span class="ow">in</span> <span class="n">_method</span><span class="p">:</span>
            <span class="n">Gam_sqrt</span> <span class="o">=</span> <span class="n">sqrth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">Gam_sqrt</span> <span class="o">=</span> <span class="n">cholesky</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">],</span> <span class="n">lower</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">LinAlgError</span><span class="p">:</span>
                <span class="c1"># TODO log/warn about reverting to sqrth</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.scattering_state(svd:gamma) failed &quot;</span>
                    <span class="s2">&quot;Cholesky; reverting to Hermitian sqrt.&quot;</span>
                <span class="p">)</span>
                <span class="n">Gam_sqrt</span> <span class="o">=</span> <span class="n">sqrth</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">])</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">A</span> <span class="o">@</span> <span class="n">Gam_sqrt</span>

        <span class="c1"># Perform svd</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_scat_state_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;svd:Gamma&quot;</span><span class="p">,</span>
            <span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span>
            <span class="n">E</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
            <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># always have the first state with the largest values</span>
        <span class="k">return</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_scattering_state_svd_a</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">_method</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">):</span>
        <span class="c1"># Parse the cutoff value</span>
        <span class="c1"># Here we may use 2 values, one for cutting off the initial space</span>
        <span class="c1"># and one for the returned space.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">):</span>
            <span class="n">cutoff</span> <span class="o">=</span> <span class="p">(</span><span class="n">cutoff</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>
        <span class="n">cutoff0</span><span class="p">,</span> <span class="n">cutoff1</span> <span class="o">=</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cutoff</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">cutoff0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;cutoff_elec&quot;</span><span class="p">,</span> <span class="n">cutoff0</span><span class="p">)</span>
        <span class="n">cutoff0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_cutoff_func</span><span class="p">(</span><span class="n">cutoff0</span><span class="p">)</span>
        <span class="n">cutoff1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_cutoff_func</span><span class="p">(</span><span class="n">cutoff1</span><span class="p">)</span>

        <span class="c1"># First we need to calculate diagonal blocks of the spectral matrix</span>
        <span class="c1"># This is basically the same thing as calculating the Gf column</span>
        <span class="c1"># But only in the 1/2 diagonal blocks of Gf</span>
        <span class="n">blocks</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_diag_block</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="c1"># Calculate the spectral function only for the blocks that host the</span>
        <span class="c1"># scattering matrix</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">u</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">u</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># add something to the diagonal (improves diag precision)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">u</span><span class="p">))</span>
        <span class="n">CONST</span> <span class="o">=</span> <span class="mf">0.1</span>
        <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">CONST</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">idx</span>

        <span class="c1"># Calculate eigenvalues</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">eigh_destroy</span><span class="p">(</span><span class="n">u</span><span class="p">)</span>
        <span class="c1"># backconvert diagonal</span>
        <span class="n">DOS</span> <span class="o">-=</span> <span class="n">CONST</span>
        <span class="c1"># TODO check with overlap convert with correct magnitude (Tr[A] / 2pi)</span>
        <span class="n">DOS</span> <span class="o">/=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="c1"># Remove states for cutoff and size</span>
        <span class="c1"># Since there cannot be any addition of states later, we</span>
        <span class="c1"># can do the reduction here.</span>
        <span class="c1"># This will greatly increase performance for very wide systems</span>
        <span class="c1"># since the number of contributing states is generally a fraction</span>
        <span class="c1"># of the total electrode space.</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">cutoff0</span><span class="p">)</span>
        <span class="c1"># Back-convert to retain scale of the vectors before SVD</span>
        <span class="c1"># and also take the sqrt to ensure u u^dagger returns</span>
        <span class="c1"># a sensible value, the 2*pi factor ensures the *original* scale.</span>
        <span class="n">u</span> <span class="o">*=</span> <span class="n">signsqrt</span><span class="p">(</span><span class="n">DOS</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>

        <span class="n">nb</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">)</span>
        <span class="n">cbtd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd_cum0</span>

        <span class="c1"># Create full U</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">u</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">u</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[:</span> <span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">blocks</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">u</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">btd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">u</span>

        <span class="c1"># Propagate A in the full BTD matrix</span>
        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tY</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="n">sln</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">b</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">sln</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">sln</span>

        <span class="n">t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tX</span>
        <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">blocks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nb</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">slp</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">cbtd</span><span class="p">[</span><span class="n">b</span> <span class="o">+</span> <span class="mi">2</span><span class="p">])</span>
            <span class="n">A</span><span class="p">[</span><span class="n">slp</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="n">t</span><span class="p">[</span><span class="n">b</span><span class="p">]</span> <span class="o">@</span> <span class="n">A</span><span class="p">[</span><span class="n">sl</span><span class="p">]</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="n">slp</span>

        <span class="c1"># Perform svd</span>
        <span class="c1"># TODO check with overlap convert with correct magnitude (Tr[A] / 2pi)</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="n">_scat_state_svd</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coefficient_state_reduce</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">cutoff1</span><span class="p">)</span>

        <span class="c1"># Now we have the full u, create it and transpose to get it in C indexing</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="n">method</span><span class="o">=</span><span class="s2">&quot;svd:A&quot;</span><span class="p">,</span>
            <span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span>
            <span class="n">E</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span>
            <span class="n">k</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span>
            <span class="n">cutoff_elec</span><span class="o">=</span><span class="n">cutoff0</span><span class="p">,</span>
            <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff1</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

<div class="viewcode-block" id="DeviceGreen.transmission">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.transmission">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">transmission</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the transmission between an electrode, and one or more other electrodes</span>

<span class="sd">        The transmission function is calculated as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathcal T_{\mathfrak e\to\mathfrak e&#39;}(E,\mathbf k) =</span>
<span class="sd">            \boldsymbol \Gamma_{\mathfrak e&#39;}(E,\mathbf k)</span>
<span class="sd">            \mathbf G(E,\mathbf k)</span>
<span class="sd">            \boldsymbol\Gamma_{\mathfrak e}(E,\mathbf k)</span>
<span class="sd">            \mathbf G^\dagger(E,\mathbf k)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E :</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        elec_from : str or int</span>
<span class="sd">           the electrode to calculate the transmission *from*.</span>
<span class="sd">        elec_to : str or int or list of</span>
<span class="sd">           the electrode(s) to calculate the transmission *to*.</span>
<span class="sd">        k :</span>
<span class="sd">           k-point to calculate the transmission at.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the full column green function</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">is_single</span><span class="p">,</span> <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serialize_elecs</span><span class="p">(</span><span class="n">elec_to</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">)</span>

        <span class="c1"># Prepare calculation @ E and k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get full G in column of &#39;from&#39;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec_from</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="p">)</span>

        <span class="c1"># The gamma matrices</span>
        <span class="n">Gam</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span>

        <span class="c1"># Now calculate the transmission</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="n">Gam_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">Gam_to</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">pvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec_to</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">pvt</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">g</span> <span class="o">@</span> <span class="n">Gam_from</span> <span class="o">@</span> <span class="n">dagger</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

            <span class="c1"># Return the trace of the final quadruple product</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">Gam_to</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span> <span class="o">@</span> <span class="n">A</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span><span class="o">.</span><span class="n">real</span>

        <span class="n">T</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">calc</span><span class="p">(</span><span class="n">Gam</span><span class="p">[</span><span class="n">elec_from</span><span class="p">],</span> <span class="n">elec</span><span class="p">,</span> <span class="n">Gam</span><span class="p">[</span><span class="n">elec</span><span class="p">],</span> <span class="n">G</span><span class="p">)</span> <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">T</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">T</span></div>


<div class="viewcode-block" id="DeviceGreen.scattering_matrix">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.scattering_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">scattering_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="nb">complex</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">cutoff</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateElectron</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateElectron</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculate the scattering matrix (S-matrix) between `elec_from` and `elec_to`</span>

<span class="sd">        The scattering matrix is calculated as</span>

<span class="sd">        .. math::</span>
<span class="sd">               \mathbf S_{\mathfrak e&#39;\mathfrak e}(E, \mathbf) = -\delta_{\alpha\beta} + i</span>
<span class="sd">               \tilde{\boldsymbol\Gamma}_{\mathfrak e&#39;}</span>
<span class="sd">               \mathbf G</span>
<span class="sd">               \tilde{\boldsymbol\Gamma}_{\mathfrak e}</span>

<span class="sd">        Here :math:`\tilde{\boldsymbol\Gamma}` is defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol\Gamma(E,\mathbf k) \mathbf u_i &amp;= \lambda_i \mathbf u_i</span>
<span class="sd">            \\</span>
<span class="sd">            \tilde{\boldsymbol\Gamma}(E,\mathbf k) &amp;= \operatorname{diag}\{ \sqrt{\boldsymbol\lambda} \} \mathbf u</span>

<span class="sd">        Once the scattering matrices have been calculated one can calculate the full transmission</span>
<span class="sd">        function</span>

<span class="sd">        .. math::</span>
<span class="sd">              \mathcal T_{\mathfrak e\to\mathfrak e&#39;}(E, \mathbf k) = \operatorname{Tr}\big[</span>
<span class="sd">              \mathbf S_{\mathfrak e&#39;\mathfrak e }^\dagger</span>
<span class="sd">              \mathbf S_{\mathfrak e&#39;\mathfrak e }\big]</span>

<span class="sd">        The scattering matrix approach can be found in details in</span>
<span class="sd">        :cite:`Sanz2023-gv`.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E :</span>
<span class="sd">           the energy to calculate at, may be a complex value.</span>
<span class="sd">        elec_from : str or int</span>
<span class="sd">           the electrode where the scattering matrix originates from</span>
<span class="sd">        elec_to : str or int or list of</span>
<span class="sd">           where the scattering matrix ends in.</span>
<span class="sd">        k :</span>
<span class="sd">           k-point to calculate the scattering matrix at</span>
<span class="sd">        cutoff :</span>
<span class="sd">           cutoff eigen states of the broadening matrix.</span>
<span class="sd">           The cutoff is based on a relative fraction of the maximum eigen value.</span>
<span class="sd">           that are below this value.</span>
<span class="sd">           For example, we keep according to :math:`\lambda_i/\max(\lambda_i) &gt; \mathrm{cutoff}`.</span>
<span class="sd">           A too high value will remove too many eigen states and results will be wrong.</span>
<span class="sd">           A small value improves precision at the cost of bigger matrices.</span>
<span class="sd">           The :math:`\Gamma` matrix should be positive definite, however, due</span>
<span class="sd">           to the imaginary part of the self-energies it tends to only be *close*</span>
<span class="sd">           to positive definite.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        sisl.physics.electron.StateElectron or tuple[sisl.physics.electron.StateElectron,...]</span>
<span class="sd">           for each `elec_to` a scattering matrix will be returned. Its dimensions will be</span>
<span class="sd">           depending on the `cutoff` value at the cost of precision.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Calculate the full column green function</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">is_single</span><span class="p">,</span> <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serialize_elecs</span><span class="p">(</span><span class="n">elec_to</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">)</span>

        <span class="n">cutoff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_as_cutoff_func</span><span class="p">(</span><span class="n">cutoff</span><span class="p">)</span>
        <span class="c1"># Prepare calculation @ E and k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_tgamma</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">cutoff</span><span class="p">)</span>

        <span class="c1"># Get full G in column of &#39;from&#39;</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_green_column</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec_from</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="c1"># the \tilde \Gamma functions</span>
        <span class="n">tG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">tgamma</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">elec</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec_from</span><span class="p">),</span> <span class="n">E</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">data</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">cutoff</span><span class="o">=</span><span class="n">cutoff</span><span class="p">)</span>

        <span class="c1"># Now calculate the S matrices</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">calc</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">jtgam_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">tgam_to</span><span class="p">,</span> <span class="n">G</span><span class="p">):</span>
            <span class="n">pvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">elec_to</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">pvt</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="n">dagger</span><span class="p">(</span><span class="n">tgam_to</span><span class="p">)</span> <span class="o">@</span> <span class="n">g</span> <span class="o">@</span> <span class="n">jtgam_from</span>
            <span class="k">if</span> <span class="n">elec_from</span> <span class="o">==</span> <span class="n">elec_to</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="n">ret</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">at</span><span class="p">(</span><span class="n">ret</span><span class="p">,</span> <span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateElectron</span><span class="p">(</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">,</span> <span class="n">elec_to</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
            <span class="p">)</span>

        <span class="n">jtgam_from</span> <span class="o">=</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">tG</span><span class="p">[</span><span class="n">elec_from</span><span class="p">]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">calc</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">jtgam_from</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">tG</span><span class="p">[</span><span class="n">elec</span><span class="p">],</span> <span class="n">G</span><span class="p">)</span> <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">is_single</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">S</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">S</span></div>


<div class="viewcode-block" id="DeviceGreen.eigenchannel_from_scattering_matrix">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.eigenchannel_from_scattering_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigenchannel_from_scattering_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">scat_matrix</span><span class="p">:</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateElectron</span><span class="p">,</span>
        <span class="n">ret_out</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">,</span> <span class="o">...</span><span class="p">]]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the eigenchannel from a scattering matrix</span>

<span class="sd">        The energy and k-point is inferred from the `state_matrix` object as returned from</span>
<span class="sd">        `scattering_matrix`.</span>

<span class="sd">        The eigenchannels are the SVD of the scattering matrix in the</span>
<span class="sd">        DOS weighted scattering states:</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state_matrix :</span>
<span class="sd">            the scattering matrix as obtained from `scattering_matrix`</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        T_eig_in : sisl.physics.electron.StateCElectron</span>
<span class="sd">            the transmission eigenchannels as seen from the incoming state, the ``T_eig.c`` contains the transmission</span>
<span class="sd">            eigenvalues.</span>
<span class="sd">        T_eig_out: sisl.physics.electron.StateCElectron</span>
<span class="sd">            the transmission eigenchannels as seen from the outgoing state, the ``T_eig.c`` contains the transmission</span>
<span class="sd">            eigenvalues.</span>
<span class="sd">            Only returned if `ret_out` is true.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tt_eig</span><span class="p">,</span> <span class="n">U</span> <span class="o">=</span> <span class="n">_scat_state_svd</span><span class="p">(</span><span class="n">state_matrix</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">ret_uv</span><span class="o">=</span><span class="n">ret_out</span><span class="p">)</span>
        <span class="c1"># Here there is a wrong pre-factor of 2pi</span>
        <span class="n">tt_eig</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">state_matrix</span><span class="o">.</span><span class="n">info</span><span class="p">}</span>
        <span class="n">SCE</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span>
        <span class="k">if</span> <span class="n">ret_out</span><span class="p">:</span>
            <span class="n">U_in</span> <span class="o">=</span> <span class="n">SCE</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">tt_eig</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
            <span class="c1"># note: V^dagger is returned from svd, so only conj</span>
            <span class="n">U_out</span> <span class="o">=</span> <span class="n">SCE</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">conj</span><span class="p">(</span><span class="n">U</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">tt_eig</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">U_in</span><span class="p">,</span> <span class="n">U_out</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">U</span> <span class="o">=</span> <span class="n">SCE</span><span class="p">(</span><span class="n">U</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">tt_eig</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">U</span></div>


<div class="viewcode-block" id="DeviceGreen.eigenchannel">
<a class="viewcode-back" href="../../../toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.html#sisl_toolbox.btd.DeviceGreen.eigenchannel">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">eigenchannel</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">:</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">,</span> <span class="n">elec_to</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ret_coeff</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span>
        <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">,</span>
        <span class="nb">tuple</span><span class="p">[</span><span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">,</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateElectron</span><span class="p">],</span>
    <span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculate the eigenchannel from scattering states entering electrodes `elec_to`</span>

<span class="sd">        The energy and k-point is inferred from the `state` object as returned from</span>
<span class="sd">        `scattering_state`.</span>

<span class="sd">        The eigenchannels are the eigenstates of the transmission matrix in the</span>
<span class="sd">        DOS weighted scattering states:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf A_{\mathfrak e_{\mathrm{from}} }(E,\mathbf k) \mathbf u_i &amp;= 2\pi a_i \mathbf u_i</span>
<span class="sd">            \\</span>
<span class="sd">            \mathbf t_{\mathbf u} &amp;= \sum \langle \mathbf u | \boldsymbol\Gamma_{ \mathfrak e_{\mathrm{to}} }  | \mathbf u\rangle</span>

<span class="sd">        where the eigenvectors of :math:`\mathbf t_{\mathbf u}` are the coefficients of the</span>
<span class="sd">        DOS weighted scattering states (:math:`\sqrt{2\pi a_i} u_i`) for the individual eigen channels.</span>
<span class="sd">        The eigenvalues are the transmission eigenvalues. Further details may be found in :cite:`Paulsson2007`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        state :</span>
<span class="sd">            the scattering states as obtained from `scattering_state`</span>
<span class="sd">        elec_to : str or int (list or not)</span>
<span class="sd">            which electrodes to consider for the transmission eigenchannel</span>
<span class="sd">            decomposition (the sum in the above equation).</span>
<span class="sd">            Defaults to all but the origin electrode.</span>
<span class="sd">        ret_coeff :</span>
<span class="sd">            return also the scattering state coefficients</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        T_eig : sisl.physics.electron.StateCElectron</span>
<span class="sd">            the transmission eigenchannels, the ``T_eig.c`` contains the transmission</span>
<span class="sd">            eigenvalues.</span>
<span class="sd">        coeff : sisl.physics.electron.StateElectron</span>
<span class="sd">            coefficients of `state` that creates the transmission eigenchannels</span>
<span class="sd">            Only returned if `ret_coeff` is True. There is a one-to-one correspondance</span>
<span class="sd">            between ``coeff`` and ``T_eig`` (with a prefactor of :math:`\sqrt{2\pi}`).</span>
<span class="sd">            This is equivalent to the ``T_eig`` states in the scattering state basis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_prepare_se</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;E&quot;</span><span class="p">],</span> <span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;k&quot;</span><span class="p">],</span> <span class="n">state</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_serialize_elecs</span><span class="p">(</span><span class="n">elec_to</span><span class="p">,</span> <span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;elec&quot;</span><span class="p">])</span>

        <span class="c1"># The sign shouldn&#39;t really matter since the states should always</span>
        <span class="c1"># have a finite DOS, however, for completeness sake we retain the sign.</span>
        <span class="c1"># We scale the vectors by sqrt(DOS/2pi).</span>
        <span class="c1"># This is because the scattering states from self.scattering_state</span>
        <span class="c1"># stores eig(A) / 2pi.</span>
        <span class="n">sqDOS</span> <span class="o">=</span> <span class="n">signsqrt</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">c</span><span class="p">)</span>
        <span class="c1"># Retrieve the scattering states `A` and apply the proper scaling</span>
        <span class="c1"># We need this scaling for the eigenchannel construction anyways.</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">state</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">sqDOS</span>

        <span class="c1"># create short hands</span>
        <span class="n">G</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">gamma</span>

        <span class="c1"># Create the first electrode</span>
        <span class="n">el</span> <span class="o">=</span> <span class="n">elec_to</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="n">u</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="c1"># the summed transmission matrix</span>
        <span class="n">Ut</span> <span class="o">=</span> <span class="n">u</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">@</span> <span class="n">u</span>

        <span class="c1"># same for other electrodes</span>
        <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">[</span><span class="n">el</span><span class="p">]</span><span class="o">.</span><span class="n">pvt_dev</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">u</span> <span class="o">=</span> <span class="n">A</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">Ut</span> <span class="o">+=</span> <span class="n">u</span><span class="o">.</span><span class="n">conj</span><span class="p">()</span><span class="o">.</span><span class="n">T</span> <span class="o">@</span> <span class="n">G</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">@</span> <span class="n">u</span>

        <span class="c1"># TODO currently a factor depends on what is used</span>
        <span class="c1">#      in `scattering_states`, so go check there.</span>
        <span class="c1">#      The state.c contains a factor /(2pi) meaning</span>
        <span class="c1">#      that we should remove that factor here.</span>
        <span class="c1"># diagonalise the transmission matrix tt to get the eigenchannels</span>
        <span class="n">teig</span><span class="p">,</span> <span class="n">Ut</span> <span class="o">=</span> <span class="n">eigh_destroy</span><span class="p">(</span><span class="n">Ut</span><span class="p">)</span>
        <span class="c1"># Reorder Ut to have them descending</span>
        <span class="n">Ut</span> <span class="o">=</span> <span class="n">Ut</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># remove factor /2pi</span>
        <span class="n">teig</span> <span class="o">=</span> <span class="n">teig</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>

        <span class="n">info</span> <span class="o">=</span> <span class="p">{</span><span class="o">**</span><span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">,</span> <span class="s2">&quot;elec_to&quot;</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_elec_name</span><span class="p">(</span><span class="n">e</span><span class="p">)</span> <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">elec_to</span><span class="p">)}</span>

        <span class="c1"># Backtransform A in the basis of Ut to form the eigenchannels</span>
        <span class="n">teig</span> <span class="o">=</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateCElectron</span><span class="p">((</span><span class="n">A</span> <span class="o">@</span> <span class="n">Ut</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">teig</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_coeff</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">teig</span><span class="p">,</span> <span class="n">si</span><span class="o">.</span><span class="n">physics</span><span class="o">.</span><span class="n">StateElectron</span><span class="p">(</span><span class="n">Ut</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">teig</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>