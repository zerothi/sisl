<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.geometry &mdash; sisl 0.1.dev1+g851d78c documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html" class="icon icon-home"> sisl
          </a>
              <div class="version">
                0.1.dev1+g851d78c
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../other.html">Other resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../publications.html">Publications using sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../scripts/scripts.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/ase/index.html">ASE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../visualization/viz_module/index.html">The <code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl.geometry</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.geometry</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="c1"># To check for integers</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">acos</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">import</span> <span class="nn">warnings</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">int32</span><span class="p">,</span> <span class="n">bool_</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dot</span><span class="p">,</span> <span class="n">square</span><span class="p">,</span> <span class="n">sqrt</span><span class="p">,</span> <span class="n">diff</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">floor</span><span class="p">,</span> <span class="n">ceil</span><span class="p">,</span> <span class="n">tile</span><span class="p">,</span> <span class="n">unique</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">argsort</span><span class="p">,</span> <span class="n">split</span><span class="p">,</span> <span class="n">isin</span><span class="p">,</span> <span class="n">concatenate</span>

<span class="kn">from</span> <span class="nn">.orbital</span> <span class="kn">import</span> <span class="n">Orbital</span>
<span class="kn">from</span> <span class="nn">._internal</span> <span class="kn">import</span> <span class="n">set_module</span><span class="p">,</span> <span class="n">singledispatchmethod</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_plot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_array</span> <span class="k">as</span> <span class="n">_a</span>
<span class="kn">from</span> <span class="nn">._math_small</span> <span class="kn">import</span> <span class="n">is_ascending</span><span class="p">,</span> <span class="n">cross3</span>
<span class="kn">from</span> <span class="nn">._indices</span> <span class="kn">import</span> <span class="n">indices_in_sphere_with_dist</span><span class="p">,</span> <span class="n">indices_le</span><span class="p">,</span> <span class="n">indices_gt_le</span>
<span class="kn">from</span> <span class="nn">._indices</span> <span class="kn">import</span> <span class="n">list_index_le</span>
<span class="kn">from</span> <span class="nn">.messages</span> <span class="kn">import</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SislError</span>
<span class="kn">from</span> <span class="nn">._help</span> <span class="kn">import</span> <span class="n">isndarray</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">default_ArgumentParser</span><span class="p">,</span> <span class="n">default_namespace</span><span class="p">,</span> <span class="n">cmd</span><span class="p">,</span> <span class="n">str_spec</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">angle</span><span class="p">,</span> <span class="n">direction</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">lstranges</span><span class="p">,</span> <span class="n">strmap</span>
<span class="kn">from</span> <span class="nn">.utils.mathematics</span> <span class="kn">import</span> <span class="n">fnorm</span>
<span class="kn">from</span> <span class="nn">.quaternion</span> <span class="kn">import</span> <span class="n">Quaternion</span>
<span class="kn">from</span> <span class="nn">.supercell</span> <span class="kn">import</span> <span class="n">SuperCell</span><span class="p">,</span> <span class="n">SuperCellChild</span>
<span class="kn">from</span> <span class="nn">.atom</span> <span class="kn">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atoms</span>
<span class="kn">from</span> <span class="nn">.shape</span> <span class="kn">import</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">Sphere</span><span class="p">,</span> <span class="n">Cube</span>
<span class="kn">from</span> <span class="nn">._namedindex</span> <span class="kn">import</span> <span class="n">NamedIndex</span>
<span class="kn">from</span> <span class="nn">._category</span> <span class="kn">import</span> <span class="n">Category</span><span class="p">,</span> <span class="n">GenericCategory</span>
<span class="kn">from</span> <span class="nn">._dispatcher</span> <span class="kn">import</span> <span class="n">AbstractDispatch</span>
<span class="kn">from</span> <span class="nn">._dispatcher</span> <span class="kn">import</span> <span class="n">ClassDispatcher</span><span class="p">,</span> <span class="n">TypeDispatcher</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;Geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;sgeom&#39;</span><span class="p">]</span>


<span class="c1"># It needs to be here otherwise we can&#39;t use it in these routines</span>
<span class="c1"># Note how we are overwriting the module</span>
<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.geom&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">AtomCategory</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">()</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">is_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Strip off `Atom`</span>
        <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span> <span class="o">==</span> <span class="n">name</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Geometry</span><span class="p">(</span><span class="n">SuperCellChild</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Holds atomic information, coordinates, species, lattice vectors</span>

<span class="sd">    The `Geometry` class holds information regarding atomic coordinates,</span>
<span class="sd">    the atomic species, the corresponding lattice-vectors.</span>

<span class="sd">    It enables the interaction and conversion of atomic structures via</span>
<span class="sd">    simple routine methods.</span>

<span class="sd">    All lengths are assumed to be in units of Angstrom, however, as</span>
<span class="sd">    long as units are kept same the exact units are irrespective.</span>

<span class="sd">    .. code:: python</span>

<span class="sd">       &gt;&gt;&gt; square = Geometry([[0.5, 0.5, 0.5]], Atom(1),</span>
<span class="sd">       ...                   sc=SuperCell([1, 1, 10], nsc=[3, 3, 1]))</span>
<span class="sd">       &gt;&gt;&gt; print(square)</span>
<span class="sd">       Geometry{na: 1, no: 1,</span>
<span class="sd">        Atoms{species: 1,</span>
<span class="sd">         Atom{H, Z: 1, mass(au): 1.00794, maxR: -1.00000,</span>
<span class="sd">          Orbital{R: -1.00000, q0: 0.0}</span>
<span class="sd">         }: 1,</span>
<span class="sd">        },</span>
<span class="sd">        maxR: -1.00000,</span>
<span class="sd">        SuperCell{volume: 1.0000e+01, nsc: [3 3 1]}</span>
<span class="sd">       }</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz : array_like</span>
<span class="sd">        atomic coordinates</span>
<span class="sd">        ``xyz[i, :]`` is the atomic coordinate of the i&#39;th atom.</span>
<span class="sd">    atoms : array_like or Atoms</span>
<span class="sd">        atomic species retrieved from the `PeriodicTable`</span>
<span class="sd">    sc : SuperCell</span>
<span class="sd">        the unit-cell describing the atoms in a periodic</span>
<span class="sd">        super-cell</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    An atomic cubic lattice of Hydrogen atoms</span>

<span class="sd">    &gt;&gt;&gt; xyz = [[0, 0, 0],</span>
<span class="sd">    ...        [1, 1, 1]]</span>
<span class="sd">    &gt;&gt;&gt; sc = SuperCell([2,2,2])</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz, Atom(&#39;H&#39;), sc)</span>

<span class="sd">    The following estimates the lattice vectors from the</span>
<span class="sd">    atomic coordinates, although possible, it is not recommended</span>
<span class="sd">    to be used.</span>

<span class="sd">    &gt;&gt;&gt; xyz = [[0, 0, 0],</span>
<span class="sd">    ...        [1, 1, 1]]</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz, Atom(&#39;H&#39;))</span>

<span class="sd">    Conversion of geometries to other projects instances can be done via</span>
<span class="sd">    sisl&#39;s dispatch functionality</span>

<span class="sd">    &gt;&gt;&gt; g.to.ase()</span>
<span class="sd">    Atoms(...)</span>

<span class="sd">    converts to an ASE ``Atoms`` object. See ``sisl/geometry.py`` for details</span>
<span class="sd">    on how to add more conversion methods.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Atoms : contained atoms `self.atoms`</span>
<span class="sd">    Atom : contained atoms are each an object of this</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Geometry.__init__"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="c1"># Create the geometry coordinate</span>
        <span class="c1"># We need flatten to ensure a copy</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Default value</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">)</span>

        <span class="c1"># Create the local Atoms object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>

        <span class="c1"># Assign a group specifier</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">NamedIndex</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">NamedIndex</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__init_sc</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span></div>

    <span class="c1"># Define a dispatcher for converting and requesting</span>
    <span class="c1"># new Geometries</span>
    <span class="c1">#  Geometry.new(&quot;run.fdf&quot;) will invoke Geometry.read(&quot;run.fdf&quot;)</span>
    <span class="n">new</span> <span class="o">=</span> <span class="n">ClassDispatcher</span><span class="p">(</span><span class="s2">&quot;new&quot;</span><span class="p">,</span>
                          <span class="c1"># both the instance and the type will use the type dispatcher</span>
                          <span class="n">instance_dispatcher</span><span class="o">=</span><span class="n">TypeDispatcher</span><span class="p">,</span>
                          <span class="n">obj_getattr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span>
                          <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">())</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span>
                              <span class="ne">AttributeError</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">.new does not implement &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                                              <span class="sa">f</span><span class="s2">&quot;dispatcher, are you using it incorrectly?&quot;</span><span class="p">))</span>
                          <span class="p">),</span>
    <span class="p">)</span>

    <span class="c1"># Define a dispatcher for converting Geometries</span>
    <span class="c1">#  Geometry().to.ase() will convert to an ase.Atoms object</span>
    <span class="n">to</span> <span class="o">=</span> <span class="n">ClassDispatcher</span><span class="p">(</span><span class="s2">&quot;to&quot;</span><span class="p">,</span>
                         <span class="c1"># Do not allow calling this from a class</span>
                         <span class="n">type_dispatcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                         <span class="n">obj_getattr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span>
                         <span class="p">(</span><span class="n">_</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="p">())</span><span class="o">.</span><span class="n">throw</span><span class="p">(</span>
                             <span class="ne">AttributeError</span><span class="p">((</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">.to does not implement &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; &quot;</span>
                                             <span class="sa">f</span><span class="s2">&quot;dispatcher, are you using it incorrectly?&quot;</span><span class="p">))</span>
                         <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Initializes the supercell by *calculating* the size if not supplied</span>

<span class="sd">        If the supercell has not been passed we estimate the unit cell size</span>
<span class="sd">        by calculating the bond-length in each direction for a square</span>
<span class="sd">        Cartesian coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We still need the *default* super cell for</span>
        <span class="c1"># estimating the supercell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># First create an initial guess for the supercell</span>
        <span class="c1"># It HAS to be VERY large to not interact</span>
        <span class="n">closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">5.</span><span class="p">))[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We could not find any atoms very close,</span>
            <span class="c1"># hence we simply return and now it becomes</span>
            <span class="c1"># the users responsibility</span>

            <span class="c1"># We create a molecule box with +10 A in each direction</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">10.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">M</span><span class="o">-</span><span class="n">m</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">sc_cart</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Initialize cartesian direction</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.</span>

            <span class="c1"># Get longest distance between atoms</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">closest</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># Project onto the direction</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">cart</span><span class="p">))</span>

            <span class="c1"># Remove all below .4</span>
            <span class="n">tmp_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;=</span> <span class="mf">.4</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We have a success</span>
                <span class="c1"># Add the bond-distance in the Cartesian direction</span>
                <span class="c1"># to the maximum distance in the same direction</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_dist</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">dd</span><span class="p">[</span><span class="n">tmp_idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default to LARGE array so as no</span>
                <span class="c1"># interaction occurs (it may be 2D)</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">10.</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">)</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="c1"># Re-set the supercell to the newly found one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc_cart</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atoms</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Atoms for the geometry (`Atoms` object) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The named index specifier &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">q0</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Total initial charge in this geometry (sum of q0 in all atoms) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">q0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The mass of all atoms as an array &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">mass</span>

<div class="viewcode-block" id="Geometry.maxR"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.maxR">[docs]</a>    <span class="k">def</span> <span class="nf">maxR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">all</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Maximum orbital range of the atoms &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">maxR</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span></div>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">na</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Number of atoms in geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">na_s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Number of supercell atoms &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Number of atoms in geometry &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Number of orbitals &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">no</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">no_s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Number of supercell orbitals &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">firsto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The first orbital on the corresponding atom &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">firsto</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">lasto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; The last orbital on the corresponding atom &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">lasto</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; List of orbitals per atom &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span>

    <span class="c1">## End size of geometry</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">fxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns geometry coordinates in fractional coordinates &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Specify geometry coordinates &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">add_name</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">add_name</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Geometry coordinates (allows supercell indices) &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@__getitem__</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na_s</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>

    <span class="nd">@__getitem__</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="o">...</span><span class="p">,</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span> <span class="nf">_sanitize_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Converts an `atoms` to index under given inputs</span>

<span class="sd">        `atoms` may be one of the following:</span>

<span class="sd">        - boolean array -&gt; nonzero()[0]</span>
<span class="sd">        - name -&gt; self._names[name]</span>
<span class="sd">        - `Atom` -&gt; self.atoms.index(atom)</span>
<span class="sd">        - range/list/ndarray -&gt; ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayl</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="n">atoms</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">atoms</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">AtomCategory</span><span class="p">)</span>
    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GenericCategory</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
        <span class="c1"># First do categorization</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">categorize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">def</span> <span class="nf">m</span><span class="p">(</span><span class="n">cat</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># we are using NullCategory == None</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ia</span>
        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">fromiterl</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">cat</span><span class="p">))</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># First do categorization</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">AtomCategory</span><span class="o">.</span><span class="n">kw</span><span class="p">(</span><span class="o">**</span><span class="n">atoms</span><span class="p">))</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># This is perhaps a bit weird since a shape could</span>
        <span class="c1"># extend into the supercell.</span>
        <span class="c1"># Since the others only does this for unit-cell atoms</span>
        <span class="c1"># then it seems natural to also do that here...</span>
        <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span> <span class="nf">_sanitize_orbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Converts an `orbital` to index under given inputs</span>

<span class="sd">        `orbital` may be one of the following:</span>

<span class="sd">        - boolean array -&gt; nonzero()[0]</span>
<span class="sd">        - dict -&gt; {atom: sub_orbital}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayl</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">orbitals</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ndarray</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orbitals</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">):</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">dict</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; A dict has atoms as keys &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atom</span><span class="p">],</span> <span class="n">orbs</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">conv</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">orbs</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">orbs</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">items</span><span class="p">()))</span>

<div class="viewcode-block" id="Geometry.as_primary"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.as_primary">[docs]</a>    <span class="k">def</span> <span class="nf">as_primary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na_primary</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ret_super</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Try and reduce the geometry to the primary unit-cell comprising `na_primary` atoms</span>

<span class="sd">        This will basically try and find the tiling/repetitions required for the geometry to only have</span>
<span class="sd">        `na_primary` atoms in the unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na_primary : int</span>
<span class="sd">           number of atoms in the primary unit cell</span>
<span class="sd">        axes : array_like, optional</span>
<span class="sd">           only search the given directions for supercells, default to all directions</span>
<span class="sd">        ret_super : bool, optional</span>
<span class="sd">           also return the number of supercells used in each direction</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geometry</span>
<span class="sd">             the primary unit cell</span>
<span class="sd">        SuperCell</span>
<span class="sd">             the tiled supercell numbers used to find the primary unit cell (only if `ret_super` is true)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SislError</span>
<span class="sd">             If the algorithm fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">na</span> <span class="o">%</span> <span class="n">na_primary</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.as_primary requires the number of atoms to be divisable by the &#39;</span>
                             <span class="s1">&#39;total number of atoms.&#39;</span><span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="n">n_supercells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">//</span> <span class="n">na_primary</span>
        <span class="k">if</span> <span class="n">n_supercells</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Return a copy of self</span>
            <span class="k">if</span> <span class="n">ret_super</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Now figure out the repetitions along each direction</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span>
        <span class="c1"># Move to 0</span>
        <span class="n">fxyz</span> <span class="o">-=</span> <span class="n">fxyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Shift a little bit in to account for inaccuracies.</span>
        <span class="n">fxyz</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="p">(</span><span class="n">fxyz</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">fxyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.01</span>

        <span class="c1"># Default guess to 1 along all directions</span>
        <span class="n">supercell</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">n_supercells</span>
        <span class="k">while</span> <span class="n">n_bin</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>

            <span class="c1"># Create bins</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_bin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Loop directions where we need to check</span>
            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">supercell</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># A histogram should yield an equal splitting for each bins</span>
                <span class="c1"># if the geometry is a n_bin repetition along the i&#39;th direction.</span>
                <span class="c1"># Hence if diff == 0 for all elements we have a match.</span>
                <span class="n">diff_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">diff_bin</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">supercell</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_bin</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_supercells</span><span class="p">:</span>
                        <span class="c1"># For geometries with more than 1 atom in the primary unit cell</span>
                        <span class="c1"># we can get false positives (each layer can be split again)</span>
                        <span class="c1"># We will search again the max-value supercell</span>
                        <span class="n">i_max</span> <span class="o">=</span> <span class="n">supercell</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">supercell</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>
                        <span class="n">supercell</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Quick escape if hit the correct number of supercells</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_supercells</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">n_bin</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># Check that the number of supercells match</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_supercells</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.as_primary could not determine the optimal supercell.&#39;</span><span class="p">)</span>

        <span class="c1"># Cut down the supercell (TODO this does not correct the number of supercell connections!)</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">supercell</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Now we need to find the atoms that are in the primary cell</span>
        <span class="c1"># We do this by finding all coordinates within the primary unit-cell</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">sc</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># Move to 0 and shift in 0.05 Ang in each direction</span>
        <span class="n">fxyz</span> <span class="o">-=</span> <span class="n">fxyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Find minimal distance in each direction</span>
        <span class="n">sc_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">supercell</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_fxyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sc_idx</span><span class="p">:</span>
            <span class="n">s_fxyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">min_fxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_fxyz</span><span class="p">[(</span><span class="n">s_fxyz</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">fxyz</span> <span class="o">+=</span> <span class="n">min_fxyz</span> <span class="o">*</span> <span class="mf">0.05</span>

        <span class="c1"># Find all fractional indices that are below 1</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">fxyz</span> <span class="o">&lt;</span> <span class="mf">1.</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_super</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geom</span><span class="p">,</span> <span class="n">supercell</span>
        <span class="k">return</span> <span class="n">geom</span></div>

<div class="viewcode-block" id="Geometry.reorder"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.reorder">[docs]</a>    <span class="k">def</span> <span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reorders atoms according to first occurence in the geometry</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is an in-place operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.reduce"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.reduce">[docs]</a>    <span class="k">def</span> <span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Remove all atoms not currently used in the ``self.atoms`` object</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is an in-place operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">in_place</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rij"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.rij">[docs]</a>    <span class="k">def</span> <span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ja</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Distance between atom `ia` and `ja`, atoms can be in super-cell indices</span>

<span class="sd">        Returns the distance between two atoms:</span>

<span class="sd">        .. math::</span>
<span class="sd">            r_{ij} = |r_j - r_i|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : int or array_like</span>
<span class="sd">           atomic index of first atom</span>
<span class="sd">        ja : int or array_like</span>
<span class="sd">           atomic indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">ja</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">.5</span>

        <span class="k">return</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">R</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.Rij"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.Rij">[docs]</a>    <span class="k">def</span> <span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ja</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Vector between atom `ia` and `ja`, atoms can be in super-cell indices</span>

<span class="sd">        Returns the vector between two atoms:</span>

<span class="sd">        .. math::</span>
<span class="sd">            R_{ij} = r_j - r_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : int or array_like</span>
<span class="sd">           atomic index of first atom</span>
<span class="sd">        ja : int or array_like</span>
<span class="sd">           atomic indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
        <span class="n">xj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ja</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ja</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xj</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[:]</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">xj</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span>

        <span class="k">return</span> <span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="Geometry.orij"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.orij">[docs]</a>    <span class="k">def</span> <span class="nf">orij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals1</span><span class="p">,</span> <span class="n">orbitals2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Distance between orbital `orbitals1` and `orbitals2`, orbitals can be in super-cell indices</span>

<span class="sd">        Returns the distance between two orbitals:</span>

<span class="sd">        .. math::</span>
<span class="sd">            r_{ij} = |r_j - r_i|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals1 : int or array_like</span>
<span class="sd">           orbital index of first orbital</span>
<span class="sd">        orbitals2 : int or array_like</span>
<span class="sd">           orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals2</span><span class="p">))</span></div>

<div class="viewcode-block" id="Geometry.oRij"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.oRij">[docs]</a>    <span class="k">def</span> <span class="nf">oRij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals1</span><span class="p">,</span> <span class="n">orbitals2</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Vector between orbital `orbitals1` and `orbitals2`, orbitals can be in super-cell indices</span>

<span class="sd">        Returns the vector between two orbitals:</span>

<span class="sd">        .. math::</span>
<span class="sd">            R_{ij} = r_j - r_i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals1 : int or array_like</span>
<span class="sd">           orbital index of first orbital</span>
<span class="sd">        orbitals2 : int or array_like</span>
<span class="sd">           orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals2</span><span class="p">))</span></div>

<div class="viewcode-block" id="Geometry.read"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.read">[docs]</a>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Reads geometry from the `Sile` using `Sile.read_geometry`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile : Sile, str or pathlib.Path</span>
<span class="sd">            a `Sile` object which will be used to read the geometry</span>
<span class="sd">            if it is a string it will create a new sile using `get_sile`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        write : writes a `Geometry` to a given `Sile`/file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This only works because, they *must*</span>
        <span class="c1"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="kn">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sile</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fh</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.write"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.write">[docs]</a>    <span class="k">def</span> <span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sile</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Writes geometry to the `Sile` using `sile.write_geometry`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile : Sile, str or pathlib.Path</span>
<span class="sd">            a `Sile` object which will be used to write the geometry</span>
<span class="sd">            if it is a string it will create a new sile using `get_sile`</span>
<span class="sd">        *args, **kwargs:</span>
<span class="sd">            Any other args will be passed directly to the</span>
<span class="sd">            underlying routine</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        read : reads a `Geometry` from a given `Sile`/file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This only works because, they *must*</span>
        <span class="c1"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="kn">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
            <span class="n">sile</span><span class="o">.</span><span class="n">write_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="n">fh</span><span class="o">.</span><span class="n">write_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; str of the object &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="sa">f</span><span class="s1">&#39;</span><span class="se">{{</span><span class="s1">na: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s1">, no: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="si">}</span><span class="s1">,</span><span class="se">\n</span><span class="s1"> &#39;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1"> &#39;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">s</span> <span class="o">+</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1"> maxR: </span><span class="si">{0:.5f}</span><span class="s1">,</span><span class="se">\n</span><span class="s1"> </span><span class="si">{1}</span><span class="se">\n</span><span class="s1">}}&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="p">)))</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; A simple, short string representation. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> na=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s2">, no=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="si">}</span><span class="s2">, nsc=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

<div class="viewcode-block" id="Geometry.iter"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.iter">[docs]</a>    <span class="k">def</span> <span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; An iterator over all atomic indices</span>

<span class="sd">        This iterator is the same as:</span>

<span class="sd">        &gt;&gt;&gt; for ia in range(len(self)):</span>
<span class="sd">        ...    &lt;do something&gt;</span>

<span class="sd">        or equivalently</span>

<span class="sd">        &gt;&gt;&gt; for ia in self:</span>
<span class="sd">        ...    &lt;do something&gt;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter_species : iterate across indices and atomic species</span>
<span class="sd">        iter_orbitals : iterate across atomic indices and orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>

    <span class="fm">__iter__</span> <span class="o">=</span> <span class="nb">iter</span>

<div class="viewcode-block" id="Geometry.iter_species"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_species">[docs]</a>    <span class="k">def</span> <span class="nf">iter_species</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Iterator over all atoms (or a subset) and species as a tuple in this geometry</span>

<span class="sd">        &gt;&gt;&gt; for ia, a, idx_specie in self.iter_species():</span>
<span class="sd">        ...     isinstance(ia, int) == True</span>
<span class="sd">        ...     isinstance(a, Atom) == True</span>
<span class="sd">        ...     isinstance(idx_specie, int) == True</span>

<span class="sd">        with ``ia`` being the atomic index, ``a`` the `Atom` object, ``idx_specie``</span>
<span class="sd">        is the index of the specie</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">           only loop on the given atoms, default to all atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter : iterate over atomic indices</span>
<span class="sd">        iter_orbitals : iterate across atomic indices and orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.iter_orbitals"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_orbitals">[docs]</a>    <span class="k">def</span> <span class="nf">iter_orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="p">:</span> <span class="nb">bool</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an iterator over all atoms and their associated orbitals</span>

<span class="sd">        &gt;&gt;&gt; for ia, io in self.iter_orbitals():</span>

<span class="sd">        with ``ia`` being the atomic index, ``io`` the associated orbital index on atom ``ia``.</span>
<span class="sd">        Note that ``io`` will start from ``0``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">           only loop on the given atoms, default to all atoms</span>
<span class="sd">        local : bool, optional</span>
<span class="sd">           whether the orbital index is the global index, or the local index relative to</span>
<span class="sd">           the atom it resides on.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        ia</span>
<span class="sd">           atomic index</span>
<span class="sd">        io</span>
<span class="sd">           orbital index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter : iterate over atomic indices</span>
<span class="sd">        iter_species : iterate across indices and atomic species</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">IO</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">IO</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">IO</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IO</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io1</span><span class="p">,</span> <span class="n">io2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">io2</span> <span class="o">-</span> <span class="n">io1</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io1</span><span class="p">,</span> <span class="n">io2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">io1</span><span class="p">,</span> <span class="n">io2</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span></div>

<div class="viewcode-block" id="Geometry.iR"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.iR">[docs]</a>    <span class="k">def</span> <span class="nf">iR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return an integer number of maximum radii (``self.maxR()``) which holds approximately `na` atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na : int, optional</span>
<span class="sd">           number of atoms within the radius</span>
<span class="sd">        iR : int, optional</span>
<span class="sd">           initial `iR` value, which the sphere is estitametd from</span>
<span class="sd">        R : float, optional</span>
<span class="sd">           the value used for atomic range (defaults to ``self.maxR()``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of radius needed to contain `na` atoms. Minimally 2 will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># default block iterator</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iR unable to determine a number of atoms within a sphere with negative radius, is maxR() defined?&quot;</span><span class="p">)</span>

        <span class="c1"># Number of atoms within 20 * R</span>
        <span class="n">naiR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span> <span class="o">*</span> <span class="n">iR</span><span class="p">)))</span>

        <span class="c1"># Convert to na atoms spherical radii</span>
        <span class="n">iR</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">R</span> <span class="o">**</span> <span class="mi">3</span> <span class="o">/</span> <span class="n">naiR</span> <span class="o">*</span> <span class="n">na</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">iR</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.iter_block_rand"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_block_rand">[docs]</a>    <span class="k">def</span> <span class="nf">iter_block_rand</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform the *random* block-iteration by randomly selecting the next center of block &quot;&quot;&quot;</span>

        <span class="c1"># We implement yields as we can then do nested iterators</span>
        <span class="c1"># create a boolean array</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;b&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Reverse the values</span>
            <span class="n">not_passed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_passed</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Figure out how many we need to loop on</span>
        <span class="n">not_passed_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iR</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.iter_block_rand too small iR!&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="c1"># The boundaries (ensure complete overlap)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">0.975</span><span class="p">,</span> <span class="n">iR</span> <span class="o">+</span> <span class="mf">.025</span><span class="p">])</span> <span class="o">*</span> <span class="n">R</span>

        <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span>

        <span class="c1"># loop until all passed are true</span>
        <span class="k">while</span> <span class="n">not_passed_N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># Take a random non-passed element</span>
            <span class="n">all_true</span> <span class="o">=</span> <span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Shuffle should increase the chance of hitting a</span>
            <span class="c1"># completely &quot;fresh&quot; segment, thus we take the most</span>
            <span class="c1"># atoms at any single time.</span>
            <span class="c1"># Shuffling will cut down needed iterations.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">all_true</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">all_true</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">all_true</span>

            <span class="c1"># Now we have found a new index, from which</span>
            <span class="c1"># we want to create the index based stuff on</span>

            <span class="c1"># get all elements within two radii</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
            <span class="c1"># Get unit-cell atoms</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># First extend the search-space (before reducing)</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Only select those who have not been runned yet</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s1">&#39;Internal error, please report to the developers&#39;</span><span class="p">)</span>

            <span class="c1"># Tell the next loop to skip those passed</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Update looped variables</span>
            <span class="n">not_passed_N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Now we want to yield the stuff revealed</span>
            <span class="c1"># all_idx[0] contains the elements that should be looped</span>
            <span class="c1"># all_idx[1] contains the indices that can be searched</span>
            <span class="k">yield</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_passed</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.iter_block_rand error on iterations. Not all atoms have been visited.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.iter_block_shape"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_block_shape">[docs]</a>    <span class="k">def</span> <span class="nf">iter_block_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Perform the *grid* block-iteration by looping a grid &quot;&quot;&quot;</span>

        <span class="c1"># We implement yields as we can then do nested iterators</span>
        <span class="c1"># create a boolean array</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="c1"># Reverse the values</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Figure out how many we need to loop on</span>
        <span class="n">not_passed_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iR</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.iter_block_shape too small iR!&#39;</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we default to the Cube shapes</span>
            <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">1.975</span><span class="p">)),</span>
                  <span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">+</span> <span class="mf">0.025</span><span class="p">)))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="mf">0.01</span><span class="p">),</span> <span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.iter_block_shape, number of Shapes *must* be one or two&#39;</span><span class="p">)</span>

        <span class="c1"># Now create the Grid</span>
        <span class="c1"># convert the radius to a square Grid</span>
        <span class="c1"># We do this by examining the x, y, z coordinates</span>
        <span class="n">xyz_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xyz_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dxyz</span> <span class="o">=</span> <span class="n">xyz_M</span> <span class="o">-</span> <span class="n">xyz_m</span>

        <span class="c1"># Currently iterating different shapes only works for</span>
        <span class="c1"># Sphere and Cube</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dS</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">Cube</span><span class="p">,</span> <span class="n">Sphere</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.iter_block_shape currently only works for &#39;</span>
                                 <span class="s1">&#39;Cube or Sphere objects. Please change sources.&#39;</span><span class="p">)</span>

        <span class="c1"># Retrieve the internal diameter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cube</span><span class="p">):</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge_length</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sphere</span><span class="p">):</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="p">[</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="c1"># Convert to spheres (which probably should be cubes for performance)</span>
            <span class="n">dS</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">toSphere</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dS</span><span class="p">]</span>
            <span class="c1"># Now do the same with spheres</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="p">[</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="mf">0.5</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

        <span class="c1"># Figure out number of segments in each iteration</span>
        <span class="c1"># (minimum 1)</span>
        <span class="n">ixyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">dxyz</span> <span class="o">/</span> <span class="n">ir</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">))</span>

        <span class="c1"># Calculate the steps required for each iteration</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">ixyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Correct the initial position to offset the initial displacement</span>
            <span class="c1"># so that we are at the border.</span>
            <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ir</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">xyz_M</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># This is the case where one of the cell dimensions</span>
                <span class="c1"># is far too great.</span>
                <span class="c1"># In this case ixyz[i] should be 1</span>
                <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz_M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Shorthand function</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span>
        <span class="n">append</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span>

        <span class="c1"># Now we loop in each direction</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>

            <span class="c1"># Create the new center</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">xyz_m</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># Correct in case the iteration steps across the maximum</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="n">xyz_M</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">xyz_M</span><span class="p">)</span>
            <span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">[:]</span>
            <span class="n">dS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">[:]</span>

            <span class="c1"># Now perform the iteration</span>
            <span class="c1"># get all elements within two radii</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span>

            <span class="c1"># Get unit-cell atoms</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># First extend the search-space (before reducing)</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">append</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Only select those who have not been runned yet</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Tell the next loop to skip those passed</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Update looped variables</span>
            <span class="n">not_passed_N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Now we want to yield the stuff revealed</span>
            <span class="c1"># all_idx[0] contains the elements that should be looped</span>
            <span class="c1"># all_idx[1] contains the indices that can be searched</span>
            <span class="k">yield</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_passed</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.iter_block_shape error on iterations. Not all atoms have been visited.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.iter_block"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_block">[docs]</a>    <span class="k">def</span> <span class="nf">iter_block</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">iR</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span><span class="o">=</span><span class="s1">&#39;rand&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Iterator for performance critical loops</span>

<span class="sd">        NOTE: This requires that `R` has been set correctly as the maximum interaction range.</span>

<span class="sd">        I.e. the loop would look like this:</span>

<span class="sd">        &gt;&gt;&gt; for ias, idxs in self.iter_block():</span>
<span class="sd">        ...    for ia in ias:</span>
<span class="sd">        ...        idx_a = self.close(ia, R = R, idx = idxs)</span>

<span class="sd">        This iterator is intended for systems with more than 1000 atoms.</span>

<span class="sd">        Remark that the iterator used is non-deterministic, i.e. any two iterators need</span>
<span class="sd">        not return the same atoms in any way.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iR : int, optional</span>
<span class="sd">            the number of `R` ranges taken into account when doing the iterator</span>
<span class="sd">        R : float, optional</span>
<span class="sd">            enables overwriting the local R quantity. Defaults to ``self.maxR()``</span>
<span class="sd">        atoms : array_like, optional</span>
<span class="sd">            enables only effectively looping a subset of the full geometry</span>
<span class="sd">        method : {&#39;rand&#39;, &#39;sphere&#39;, &#39;cube&#39;}</span>
<span class="sd">            select the method by which the block iteration is performed.</span>
<span class="sd">            Possible values are:</span>

<span class="sd">             `rand`: a spherical object is constructed with a random center according to the internal atoms</span>
<span class="sd">             `sphere`: a spherical equispaced shape is constructed and looped</span>
<span class="sd">             `cube`: a cube shape is constructed and looped</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            current list of atoms currently searched</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            atoms that needs searching</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">iR</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.iter_block too small iR!&#39;</span><span class="p">)</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;rand&#39;</span> <span class="ow">or</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;random&#39;</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block_rand</span><span class="p">(</span><span class="n">iR</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>

            <span class="c1"># Create shapes</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;sphere&#39;</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sphere</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">0.975</span><span class="p">)),</span>
                      <span class="n">Sphere</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="n">iR</span> <span class="o">+</span> <span class="mf">0.025</span><span class="p">)))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;cube&#39;</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iR</span> <span class="o">-</span> <span class="mf">0.975</span><span class="p">)),</span>
                      <span class="n">Cube</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iR</span> <span class="o">+</span> <span class="mf">0.025</span><span class="p">)))</span>

            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block_shape</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.copy"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.copy">[docs]</a>    <span class="k">def</span> <span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; A copy of the object. &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">),</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
        <span class="n">g</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="Geometry.overlap"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.overlap">[docs]</a>    <span class="k">def</span> <span class="nf">overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">eps</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">),</span> <span class="n">offset_other</span><span class="o">=</span><span class="p">(</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate the overlapping indices between two geometries</span>

<span class="sd">        Find equivalent atoms (in the primary unit-cell only) in two geometries.</span>
<span class="sd">        This routine finds which atoms have the same atomic positions in `self` and `other`.</span>

<span class="sd">        Note that this will return duplicate overlapping atoms if one atoms lies within `eps`</span>
<span class="sd">        of more than 1 atom in `other`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry</span>
<span class="sd">           Geometry to compare with `self`</span>
<span class="sd">        eps : float, optional</span>
<span class="sd">           atoms within this distance will be considered *equivalent*</span>
<span class="sd">        offset : list of float, optional</span>
<span class="sd">           offset for `self.xyz` before comparing</span>
<span class="sd">        offset_other : list of float, optional</span>
<span class="sd">           offset for `other.xyz` before comparing</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gr22 = sisl.geom.graphene().tile(2, 0).tile(2, 1)</span>
<span class="sd">        &gt;&gt;&gt; gr44 = gr22.tile(2, 0).tile(2, 1)</span>
<span class="sd">        &gt;&gt;&gt; offset = np.array([0.2, 0.4, 0.4])</span>
<span class="sd">        &gt;&gt;&gt; gr22 = gr22.translate(offset)</span>
<span class="sd">        &gt;&gt;&gt; idx = np.arange(len(gr22))</span>
<span class="sd">        &gt;&gt;&gt; np.random.shuffle(idx)</span>
<span class="sd">        &gt;&gt;&gt; gr22 = gr22.sub(idx)</span>
<span class="sd">        &gt;&gt;&gt; idx22, idx44 = gr22.overlap(gr44, offset=-offset)</span>
<span class="sd">        &gt;&gt;&gt; assert idx22 == np.arange(len(gr22))</span>
<span class="sd">        &gt;&gt;&gt; assert idx44 == idx</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_self : numpy.ndarray of int</span>
<span class="sd">             indices in `self` that are equivalent with `idx_other`</span>
<span class="sd">        idx_other : numpy.ndarray of int</span>
<span class="sd">             indices in `other` that are equivalent with `idx_self`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sanitize `other`</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">s_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset_other</span><span class="p">))</span>
        <span class="n">idx_self</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self_extend</span> <span class="o">=</span> <span class="n">idx_self</span><span class="o">.</span><span class="n">extend</span>
        <span class="n">idx_other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">other_extend</span> <span class="o">=</span> <span class="n">idx_other</span><span class="o">.</span><span class="n">extend</span>

        <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_xyz</span><span class="p">):</span>
            <span class="c1"># only search in the primary unit-cell</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="n">eps</span><span class="p">,))</span>
            <span class="n">self_extend</span><span class="p">([</span><span class="n">ia</span><span class="p">]</span> <span class="o">*</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">other_extend</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">idx_self</span><span class="p">),</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">idx_other</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.sort"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.sort">[docs]</a>    <span class="k">def</span> <span class="nf">sort</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span> <span class="o">|</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Geometry</span><span class="p">,</span> <span class="n">List</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sort atoms in a nested fashion according to various criteria</span>

<span class="sd">        There are many ways to sort a `Geometry`.</span>
<span class="sd">        - by Cartesian coordinates, `axis`</span>
<span class="sd">        - by lattice vectors, `lattice`</span>
<span class="sd">        - by user defined vectors, `vector`</span>
<span class="sd">        - by grouping atoms, `group`</span>
<span class="sd">        - by a user defined function, `func`</span>
<span class="sd">        - by a user defined function using internal sorting algorithm, `func_sort`</span>

<span class="sd">        - a combination of the above in arbitrary order</span>

<span class="sd">        Additionally one may sort ascending or descending.</span>

<span class="sd">        This method allows nested sorting based on keyword arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">           only perform sorting algorithm for subset of atoms. This is *NOT* a positional dependent</span>
<span class="sd">           argument. All sorting algorithms will _only_ be performed on these atoms.</span>
<span class="sd">           Default, all atoms will be sorted.</span>
<span class="sd">        ret_atoms : bool, optional</span>
<span class="sd">           return a list of list for the groups of atoms that have been sorted.</span>
<span class="sd">        axis : int or tuple of int, optional</span>
<span class="sd">           sort coordinates according to Cartesian coordinates, if a tuple of</span>
<span class="sd">           ints is passed it will be equivalent to ``sort(axis0=axis[0], axis1=axis[1])``.</span>
<span class="sd">           This behaves differently than `numpy.lexsort`!</span>
<span class="sd">        lattice : int or tuple of int, optional</span>
<span class="sd">           sort coordinates according to lattice vectors, if a tuple of</span>
<span class="sd">           ints is passed it will be equivalent to ``sort(lattice0=lattice[0], lattice1=lattice[1])``.</span>
<span class="sd">           Note that before sorting we multiply the fractional coordinates by the length of the</span>
<span class="sd">           lattice vector. This ensures that `atol` is meaningful for both `axis` and `lattice` since</span>
<span class="sd">           they will be on the same order of magnitude.</span>
<span class="sd">           This behaves differently than `numpy.lexsort`!</span>
<span class="sd">        vector : (3, ), optional</span>
<span class="sd">           sort along a user defined vector, similar to `lattice` but with a user defined</span>
<span class="sd">           direction. Note that `lattice` sorting and `vector` sorting are *only* equivalent</span>
<span class="sd">           when the lattice vector is orthogonal to the other lattice vectors.</span>
<span class="sd">        group : {&#39;Z&#39;, &#39;symbol&#39;, &#39;tag&#39;, &#39;species&#39;} or (str, ...), optional</span>
<span class="sd">           group together a set of atoms by various means.</span>
<span class="sd">           `group` may be one of the listed strings.</span>
<span class="sd">           For ``&#39;Z&#39;`` atoms will be grouped in atomic number</span>
<span class="sd">           For ``&#39;symbol&#39;`` atoms will be grouped by their atomic symbol.</span>
<span class="sd">           For ``&#39;tag&#39;`` atoms will be grouped by their atomic tag.</span>
<span class="sd">           For ``&#39;species&#39;`` atoms will be sorted according to their specie index.</span>
<span class="sd">           If a tuple/list is passed the first item is described. All subsequent items are a</span>
<span class="sd">           list of groups, where each group comprises elements that should be sorted on an</span>
<span class="sd">           equal footing. If one of the groups is None, that group will be replaced with all</span>
<span class="sd">           non-mentioned elements. See examples.</span>
<span class="sd">        func : callable or list-like of callable, optional</span>
<span class="sd">           pass a sorting function which should have an interface like ``func(geometry, atoms, **kwargs)``.</span>
<span class="sd">           The first argument is the geometry to sort. The 2nd argument is a list of indices in</span>
<span class="sd">           the current group of sorted atoms. And ``**kwargs`` are any optional arguments</span>
<span class="sd">           currently collected, i.e. `ascend`, `atol` etc.</span>
<span class="sd">           The function should return either a list of atoms, or a list of list of atoms (in which</span>
<span class="sd">           case the atomic indices have been split into several groups that will be sorted individually</span>
<span class="sd">           for subsequent sorting methods).</span>
<span class="sd">           In either case the returned indices must never hold any other indices but the ones passed</span>
<span class="sd">           as ``atoms``.</span>
<span class="sd">           If a list/tuple of functions, they will be processed in that order.</span>
<span class="sd">        func_sort : callable or list-like of callable, optional</span>
<span class="sd">           pass a function returning a 1D array corresponding to all atoms in the geometry.</span>
<span class="sd">           The interface should simply be: ``func(geometry)``.</span>
<span class="sd">           Those values will be passed down to the internal sorting algorithm.</span>
<span class="sd">           To be compatible with `atol` the returned values from `func_sort` should</span>
<span class="sd">           be on the scale of coordinates (in Ang).</span>
<span class="sd">        ascend, descend : bool, optional</span>
<span class="sd">            control ascending or descending sorting for all subsequent sorting methods.</span>
<span class="sd">            Default ``ascend=True``.</span>
<span class="sd">        atol : float, optional</span>
<span class="sd">            absolute tolerance when sorting numerical arrays for subsequent sorting methods.</span>
<span class="sd">            When a selection of sorted coordinates are grouped via `atol`, we ensure such</span>
<span class="sd">            a group does not alter its indices. I.e. the group is *always* ascending indices.</span>
<span class="sd">            Note this may have unwanted side-effects if `atol` is very large compared</span>
<span class="sd">            to the difference between atomic coordinates.</span>
<span class="sd">            Default ``1e-9``.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The order of arguments is also the sorting order. ``sort(axis=0, lattice=0)`` is different</span>
<span class="sd">        from ``sort(lattice=0, axis=0)``</span>

<span class="sd">        All arguments may be suffixed with integers. This allows multiple keyword arguments</span>
<span class="sd">        to control sorting algorithms</span>
<span class="sd">        in different order. It also allows changing of sorting settings between different calls.</span>
<span class="sd">        Note that the integers have no relevance to the order of execution!</span>
<span class="sd">        See examples.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        geometry : Geometry</span>
<span class="sd">            sorted geometry</span>
<span class="sd">        index : list of list of indices</span>
<span class="sd">            indices that would sort the original structure to the output, only returned if `ret_atoms` is True</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = sisl.geom.bilayer(top_atoms=sisl.Atom[5, 7], bottom_atoms=sisl.Atom(6))</span>
<span class="sd">        &gt;&gt;&gt; geom = geom.tile(5, 0).repeat(7, 1)</span>

<span class="sd">        Sort according to :math:`x` coordinate</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(axis=0)</span>

<span class="sd">        Sort according to :math:`z`, then :math:`x` for each group created from first sort</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(axis=(2, 0))</span>

<span class="sd">        Sort according to :math:`z`, then first lattice vector</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(axis=2, lattice=0)</span>

<span class="sd">        Sort according to :math:`z` (ascending), then first lattice vector (descending)</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(axis=2, ascend=False, lattice=0)</span>

<span class="sd">        Sort according to :math:`z` (descending), then first lattice vector (ascending)</span>
<span class="sd">        Note how integer suffixes has no importance.</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(ascend1=False, axis=2, ascend0=True, lattice=0)</span>

<span class="sd">        Sort only atoms ``range(1, 5)`` first by :math:`z`, then by first lattice vector</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(axis=2, lattice=0, atoms=np.arange(1, 5))</span>

<span class="sd">        Sort two groups of atoms ``[range(1, 5), range(5, 10)]`` (individually) by :math:`z` coordinate</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(axis=2, atoms=[np.arange(1, 5), np.arange(5, 10)])</span>

<span class="sd">        The returned sorting indices may be used for manual sorting. Note</span>
<span class="sd">        however, that this requires one to perform a sorting for all atoms.</span>
<span class="sd">        In such a case the following sortings are equal.</span>

<span class="sd">        &gt;&gt;&gt; geom0, atoms0 = geom.sort(axis=2, lattice=0, ret_atoms=True)</span>
<span class="sd">        &gt;&gt;&gt; _, atoms1 = geom.sort(axis=2, ret_atoms=True)</span>
<span class="sd">        &gt;&gt;&gt; geom1, atoms1 = geom.sort(lattice=0, atoms=atoms1, ret_atoms=True)</span>
<span class="sd">        &gt;&gt;&gt; geom2 = geom.sub(np.concatenate(atoms0))</span>
<span class="sd">        &gt;&gt;&gt; geom3 = geom.sub(np.concatenate(atoms1))</span>
<span class="sd">        &gt;&gt;&gt; assert geom0 == geom1</span>
<span class="sd">        &gt;&gt;&gt; assert geom0 == geom2</span>
<span class="sd">        &gt;&gt;&gt; assert geom0 == geom3</span>

<span class="sd">        Default sorting is equivalent to ``axis=(0, 1, 2)``</span>

<span class="sd">        &gt;&gt;&gt; assert geom.sort() == geom.sort(axis=(0, 1, 2))</span>

<span class="sd">        Sort along a user defined vector ``[2.2, 1., 0.]``</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(vector=[2.2, 1., 0.])</span>

<span class="sd">        Integer specification has no influence on the order of operations.</span>
<span class="sd">        It is _always_ the keyword argument order that determines the operation.</span>

<span class="sd">        &gt;&gt;&gt; assert geom.sort(axis2=1, axis0=0, axis1=2) == geom.sort(axis=(1, 0, 2))</span>

<span class="sd">        Sort by atomic numbers</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(group=&#39;Z&#39;) # 5, 6, 7</span>

<span class="sd">        One may group several elements together on an equal footing (``None`` means all non-mentioned elements)</span>
<span class="sd">        The order of the groups are important (the first two are _not_ equal, the last three _are_ equal)</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(group=(&#39;symbol&#39;, &#39;C&#39;), axis=2) # C will be sorted along z</span>
<span class="sd">        &gt;&gt;&gt; geom.sort(axis=1, atoms=&#39;C&#39;, axis1=2) # all along y, then C sorted along z</span>
<span class="sd">        &gt;&gt;&gt; geom.sort(group=(&#39;symbol&#39;, &#39;C&#39;, None)) # C, [B, N]</span>
<span class="sd">        &gt;&gt;&gt; geom.sort(group=(&#39;symbol&#39;, None, &#39;C&#39;)) # [B, N], C</span>
<span class="sd">        &gt;&gt;&gt; geom.sort(group=(&#39;symbol&#39;, [&#39;N&#39;, &#39;B&#39;], &#39;C&#39;)) # [B, N], C (B and N unaltered order)</span>
<span class="sd">        &gt;&gt;&gt; geom.sort(group=(&#39;symbol&#39;, [&#39;B&#39;, &#39;N&#39;], &#39;C&#39;)) # [B, N], C (B and N unaltered order)</span>

<span class="sd">        A group based sorting can use *anything* that can be fetched from the `Atom` object, </span>
<span class="sd">        sort first according to mass, then for all with the same mass, sort according to atomic</span>
<span class="sd">        tag:</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(group0=&#39;mass&#39;, group1=&#39;tag&#39;)</span>

<span class="sd">        A too high `atol` may have unexpected side-effects. This is because of the way</span>
<span class="sd">        the sorting algorithm splits the sections for nested sorting.</span>
<span class="sd">        So for coordinates with a continuous displacement the sorting may break and group</span>
<span class="sd">        a large range into 1 group. Consider the following array to be split in groups</span>
<span class="sd">        while sorting.</span>

<span class="sd">        An example would be a linear chain with a middle point with a much shorter distance.</span>

<span class="sd">        &gt;&gt;&gt; x = np.arange(5) * 0.1</span>
<span class="sd">        &gt;&gt;&gt; x[3:] -= 0.095</span>
<span class="sd">        y = z = np.zeros(5)</span>
<span class="sd">        geom = si.Geometry(np.stack((x, y, z), axis=1))</span>
<span class="sd">        &gt;&gt;&gt; geom.xyz[:, 0]</span>
<span class="sd">        [0.    0.1   0.2   0.205 0.305]</span>

<span class="sd">        In this case a high tolerance (``atol&gt;0.005``) would group atoms 2 and 3</span>
<span class="sd">        together</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(atol=0.01, axis=0, ret_atoms=True)[1]</span>
<span class="sd">        [[0], [1], [2, 3], [4]]</span>

<span class="sd">        However, a very low tolerance will not find these two as atoms close</span>
<span class="sd">        to each other.</span>

<span class="sd">        &gt;&gt;&gt; geom.sort(atol=0.001, axis=0, ret_atoms=True)[1]</span>
<span class="sd">        [[0], [1], [2], [3], [4]]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need a way to easily handle nested lists</span>
        <span class="c1"># This small class handles lists and allows appending nested lists</span>
        <span class="c1"># while flattening them.</span>
        <span class="k">class</span> <span class="nc">NestedList</span><span class="p">:</span>
            <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;_idx&#39;</span><span class="p">,</span> <span class="p">)</span>
            <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">idx</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">)):</span>
                        <span class="k">for</span> <span class="n">ix</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">sort</span><span class="p">)</span>
                        <span class="k">return</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">NestedList</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">idx</span><span class="p">))</span>
            <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span>
            <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_idx</span><span class="p">)</span>
            <span class="k">def</span> <span class="nf">ravel</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">def</span> <span class="nf">tolist</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_idx</span>
            <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">empty</span><span class="se">}}</span><span class="s2">&quot;</span>
                <span class="n">out</span> <span class="o">=</span> <span class="s1">&#39;,</span><span class="se">\n</span><span class="s1"> &#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">tolist</span><span class="p">()),</span> <span class="bp">self</span><span class="p">))</span>
                <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{\n</span><span class="s2"> </span><span class="si">{</span><span class="n">out</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>

        <span class="k">def</span> <span class="nf">_sort</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; We do not sort according to lexsort &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># no values to sort</span>
                <span class="k">return</span> <span class="n">atoms</span>

            <span class="c1"># control ascend vs descending</span>
            <span class="n">ascend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;ascend&#39;</span><span class="p">]</span>
            <span class="n">atol</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;atol&#39;</span><span class="p">]</span>

            <span class="n">new_atoms</span> <span class="o">=</span> <span class="n">NestedList</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># no need for complexity</span>
                    <span class="n">new_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                    <span class="k">continue</span>

                <span class="c1"># Sort values</span>
                <span class="n">jdx</span> <span class="o">=</span> <span class="n">atom</span><span class="p">[</span><span class="n">argsort</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">atom</span><span class="p">])]</span>
                <span class="k">if</span> <span class="n">ascend</span><span class="p">:</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">jdx</span><span class="p">])</span> <span class="o">&gt;</span> <span class="n">atol</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">jdx</span> <span class="o">=</span> <span class="n">jdx</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                    <span class="n">d</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">val</span><span class="p">[</span><span class="n">jdx</span><span class="p">])</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">atol</span>
                <span class="n">new_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">split</span><span class="p">(</span><span class="n">jdx</span><span class="p">,</span> <span class="n">d</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">),</span> <span class="n">sort</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new_atoms</span>

        <span class="c1"># Functions allowed by external users</span>
        <span class="n">funcs</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">def</span> <span class="nf">_axis</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Cartesian coordinate sort &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="p">(</span><span class="n">axis</span><span class="p">,)</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">],</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">atoms</span>
        <span class="n">funcs</span><span class="p">[</span><span class="s2">&quot;axis&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_axis</span>

        <span class="k">def</span> <span class="nf">_lattice</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            We scale the fractional coordinates with the lattice vector length.</span>
<span class="sd">            This ensures `atol` has a meaningful size for very large structures.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="nb">int</span><span class="p">):</span>
                <span class="n">lattice</span> <span class="o">=</span> <span class="p">(</span><span class="n">lattice</span><span class="p">,)</span>
            <span class="n">fxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span>
            <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">lattice</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">_sort</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[:,</span> <span class="n">ax</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">length</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">atoms</span>
        <span class="n">funcs</span><span class="p">[</span><span class="s2">&quot;lattice&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_lattice</span>

        <span class="k">def</span> <span class="nf">_vector</span><span class="p">(</span><span class="n">vector</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Calculate fraction of positions along a vector and sort along it.</span>
<span class="sd">            We first normalize the vector to ensure that `atol` is meaningful</span>
<span class="sd">            for very large structures (ensures scale is on the order of Ang).</span>

<span class="sd">            A vector projection will only be equivalent to lattice projection</span>
<span class="sd">            when a lattice vector is orthogonal to the other lattice vectors.</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Ensure we are using a copied data array</span>
            <span class="n">vector</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># normalize</span>
            <span class="n">vector</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">vector</span><span class="p">)</span>
            <span class="c1"># Perform a . b^ == scalar projection</span>
            <span class="k">return</span> <span class="n">_sort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">vector</span><span class="p">),</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">funcs</span><span class="p">[</span><span class="s2">&quot;vector&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_vector</span>

        <span class="k">def</span> <span class="nf">_funcs</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            User defined function (tuple/list of function)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">def</span> <span class="nf">_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">):</span>
                <span class="n">nl</span> <span class="o">=</span> <span class="n">NestedList</span><span class="p">()</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                    <span class="c1"># TODO add check that</span>
                    <span class="c1">#  res = func(...) in a</span>
                    <span class="c1"># A user *may* remove an atom from the sorting here (but</span>
                    <span class="c1"># that negates all sorting of that atom)</span>
                    <span class="n">nl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">nl</span>

            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">funcs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">_func</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">atoms</span>
        <span class="n">funcs</span><span class="p">[</span><span class="s2">&quot;func&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_funcs</span>

        <span class="k">def</span> <span class="nf">_func_sort</span><span class="p">(</span><span class="n">funcs</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            User defined function, but using internal sorting</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">callable</span><span class="p">(</span><span class="n">funcs</span><span class="p">):</span>
                <span class="n">funcs</span> <span class="o">=</span> <span class="p">[</span><span class="n">funcs</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">func</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="n">_sort</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">atoms</span>
        <span class="n">funcs</span><span class="p">[</span><span class="s2">&quot;func_sort&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_func_sort</span>

        <span class="k">def</span> <span class="nf">_group_vals</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">groups</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            vals should be of size len(self) and be parsable</span>
<span class="sd">            by numpy</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="n">NestedList</span><span class="p">()</span>

            <span class="c1"># Create unique list of values</span>
            <span class="n">uniq_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">vals</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># fake the groups argument</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="p">[[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">uniq_vals</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Check if one of the elements of group is None</span>
                <span class="c1"># In this case we replace it with the missing rest</span>
                <span class="c1"># of the missing unique items</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">none_idx</span> <span class="o">=</span> <span class="n">groups</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

                    <span class="c1"># we have a None (ensure we use a list, tuples are</span>
                    <span class="c1"># immutable)</span>
                    <span class="n">groups</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">groups</span><span class="p">)</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">none_idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

                    <span class="n">uniq_groups</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">concatenate</span><span class="p">(</span><span class="n">groups</span><span class="p">))</span>
                    <span class="c1"># add a new group that is in uniq_vals, but not in uniq_groups</span>
                    <span class="n">rest</span> <span class="o">=</span> <span class="n">uniq_vals</span><span class="p">[</span><span class="n">isin</span><span class="p">(</span><span class="n">uniq_vals</span><span class="p">,</span> <span class="n">uniq_groups</span><span class="p">,</span> <span class="n">invert</span><span class="o">=</span><span class="kc">True</span><span class="p">)]</span>
                    <span class="n">groups</span><span class="p">[</span><span class="n">none_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">rest</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="c1"># there is no None in the list</span>
                    <span class="k">pass</span>

            <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                <span class="c1"># reduce search</span>
                <span class="n">at_vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[</span><span class="n">at</span><span class="p">]</span>
                <span class="c1"># loop group values</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                    <span class="c1"># retain original indexing</span>
                    <span class="n">nl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">[</span><span class="n">isin</span><span class="p">(</span><span class="n">at_vals</span><span class="p">,</span> <span class="n">group</span><span class="p">)])</span>
            <span class="k">return</span> <span class="n">nl</span>

        <span class="k">def</span> <span class="nf">_group</span><span class="p">(</span><span class="n">method_group</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">            Group based sorting is based on a named identification.</span>

<span class="sd">            group: str or tuple of (str, list of lists)</span>

<span class="sd">            symbol: order by symbol (most cases same as Z)</span>
<span class="sd">            Z: order by atomic number</span>
<span class="sd">            tag: order by atom tag (should be the same as specie)</span>
<span class="sd">            specie/species: order by specie (in order of contained in the Geometry)</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="c1"># Create new list</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="n">NestedList</span><span class="p">()</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_group</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">method_group</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method_group</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">in_groups</span> <span class="o">=</span> <span class="n">method_group</span>

                <span class="c1"># Ensure all groups are lists</span>
                <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">NoneType</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">in_groups</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">NoneType</span><span class="p">)):</span>
                        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">group</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># a special case where group is a list of lists</span>
                <span class="c1"># i.e. [[0, 1, 2], [3, 4, 5]]</span>
                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">method_group</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                        <span class="n">nl</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">at</span><span class="p">[</span><span class="n">isin</span><span class="p">(</span><span class="n">at</span><span class="p">,</span> <span class="n">idx</span><span class="p">)])</span>
                <span class="k">return</span> <span class="n">nl</span>

            <span class="c1"># See if the attribute exists for the atoms</span>
            <span class="k">if</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;species&quot;</span><span class="p">:</span>
                <span class="c1"># this one has two spelling options!</span>
                <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;specie&quot;</span>

            <span class="c1"># now get them through `getattr`</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="p">):</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>

            <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="n">vals</span> <span class="o">=</span> <span class="p">[</span><span class="nb">getattr</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.sort group only supports attributes that can be fetched from Atom objects, some are [Z, species, tag, symbol, mass, ...] and more&quot;</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">_group_vals</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">vals</span><span class="p">),</span> <span class="n">groups</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">funcs</span><span class="p">[</span><span class="s2">&quot;group&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">_group</span>

        <span class="k">def</span> <span class="nf">stripint</span><span class="p">(</span><span class="n">s</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot; Remove integers from end of string -&gt; Allow multiple arguments &quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="ow">in</span> <span class="s1">&#39;0123456789&#39;</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">stripint</span><span class="p">(</span><span class="n">s</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">return</span> <span class="n">s</span>

        <span class="c1"># Now perform cumultative sort function</span>
        <span class="c1"># Our point is that we would like to allow users to do consecutive sorting</span>
        <span class="c1"># based on different keys</span>

        <span class="c1"># We also allow specific keys for specific methods</span>
        <span class="n">func_kw</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">func_kw</span><span class="p">[</span><span class="s1">&#39;ascend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">func_kw</span><span class="p">[</span><span class="s1">&#39;atol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1e-9</span>

        <span class="k">def</span> <span class="nf">update_flag</span><span class="p">(</span><span class="n">kw</span><span class="p">,</span> <span class="n">arg</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;ascending&#39;</span><span class="p">,</span> <span class="s1">&#39;ascend&#39;</span><span class="p">]:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;ascend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">arg</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;descending&#39;</span><span class="p">,</span> <span class="s1">&#39;descend&#39;</span><span class="p">]:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;ascend&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">val</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">elif</span> <span class="n">arg</span> <span class="o">==</span> <span class="s1">&#39;atol&#39;</span><span class="p">:</span>
                <span class="n">kw</span><span class="p">[</span><span class="s1">&#39;atol&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="c1"># Default to all atoms</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">NestedList</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>
        <span class="n">ret_atoms</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;ret_atoms&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="c1"># In case the user just did geometry.sort, it will default to sort x, y, z</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;axis&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">key_int</span><span class="p">,</span> <span class="n">method</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="n">key</span> <span class="o">=</span> <span class="n">stripint</span><span class="p">(</span><span class="n">key_int</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">update_flag</span><span class="p">(</span><span class="n">func_kw</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
                <span class="k">continue</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">funcs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.sort unrecognized keyword &#39;</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&#39; (&#39;</span><span class="si">{</span><span class="n">key_int</span><span class="si">}</span><span class="s2">&#39;)&quot;</span><span class="p">)</span>
            <span class="c1"># call sorting algorithm and retrieve new grouped sorting</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">funcs</span><span class="p">[</span><span class="n">key</span><span class="p">](</span><span class="n">method</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="o">**</span><span class="n">func_kw</span><span class="p">)</span>

        <span class="c1"># convert to direct list</span>
        <span class="n">atoms_flat</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Ensure that all atoms are present</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms_flat</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="n">all_atoms</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="n">all_atoms</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">atoms_flat</span><span class="p">)]</span> <span class="o">=</span> <span class="n">atoms_flat</span><span class="p">[:]</span>
            <span class="n">atoms_flat</span> <span class="o">=</span> <span class="n">all_atoms</span>

        <span class="k">if</span> <span class="n">ret_atoms</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms_flat</span><span class="p">),</span> <span class="n">atoms</span><span class="o">.</span><span class="n">tolist</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms_flat</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.optimize_nsc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.optimize_nsc">[docs]</a>    <span class="k">def</span> <span class="nf">optimize_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Optimize the number of supercell connections based on ``self.maxR()``</span>

<span class="sd">        After this routine the number of supercells may not necessarily be the same.</span>

<span class="sd">        This is an in-place operation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int or array_like, optional</span>
<span class="sd">           only optimize the specified axis (default to all)</span>
<span class="sd">        R : float, optional</span>
<span class="sd">           the maximum connection radius for each atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="mf">0.00001</span>
            <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span>
                 <span class="s2">&quot;.optimize_nsc could not determine the radius from the &quot;</span>
                 <span class="s2">&quot;internal atoms (defaulting to zero radius).&quot;</span><span class="p">)</span>

        <span class="n">ic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span>
        <span class="n">nrc</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">ic</span><span class="p">)</span>
        <span class="n">idiv</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">nrc</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">R</span><span class="p">),</span> <span class="mf">1.1</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">imcell</span> <span class="o">=</span> <span class="n">ic</span> <span class="o">*</span> <span class="n">idiv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># We know this is the maximum</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># We need to subtract one to ensure we are not taking into account</span>
        <span class="c1"># too big supercell connections.</span>
        <span class="c1"># I don&#39;t think we need anything other than this.</span>
        <span class="c1"># However, until I am sure that this wouldn&#39;t change, regardless of the</span>
        <span class="c1"># cell. I will keep it.</span>
        <span class="n">Rimcell</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">imcell</span><span class="p">)[</span><span class="n">axis</span><span class="p">]</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">Rimcell</span><span class="p">)</span> <span class="o">+</span> <span class="n">ceil</span><span class="p">(</span><span class="n">Rimcell</span> <span class="o">%</span> <span class="mf">0.5</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># Since for 1 it is not sure that it is a connection or not, we limit the search by</span>
        <span class="c1"># removing it.</span>
        <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">],</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">axis</span><span class="p">:</span>
            <span class="c1"># Initialize the isc for this direction</span>
            <span class="c1"># (note we do not take non-orthogonal directions</span>
            <span class="c1">#  into account)</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="c1"># Initialize the actual number of supercell connections</span>
            <span class="c1"># along this direction.</span>
            <span class="n">prev_isc</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">while</span> <span class="n">prev_isc</span> <span class="o">==</span> <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># Try next supercell connection</span>
                <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">prev_isc</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                        <span class="k">break</span>

            <span class="c1"># Save the reached supercell connection</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_isc</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">nsc</span></div>

<div class="viewcode-block" id="Geometry.sub"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.sub">[docs]</a>    <span class="k">def</span> <span class="nf">sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create a new `Geometry` with a subset of this `Geometry`</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like</span>
<span class="sd">            indices/boolean of all atoms to be removed</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SuperCell.fit : update the supercell according to a reference supercell</span>
<span class="sd">        remove : the negative of this routine, i.e. remove a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:],</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="Geometry.sub_orbital"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.sub_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">sub_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Retain only a subset of the orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        This allows one to retain only a given subset of geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or Atom</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atoms` that are retained in the geometry, the list of</span>
<span class="sd">            orbitals will be sorted.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Future implementations may allow one to re-arange orbitals using this method.</span>

<span class="sd">        When using this method the internal species list will be populated by another specie</span>
<span class="sd">        that is named after the orbitals removed. This is to distinguish different atoms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; # a Carbon atom with 2 orbitals</span>
<span class="sd">        &gt;&gt;&gt; C = sisl.Atom(&#39;C&#39;, [1., 2.])</span>
<span class="sd">        &gt;&gt;&gt; # an oxygen atom with 3 orbitals</span>
<span class="sd">        &gt;&gt;&gt; O = sisl.Atom(&#39;O&#39;, [1., 2., 2.4])</span>
<span class="sd">        &gt;&gt;&gt; geometry = sisl.Geometry([[0] * 3, [1] * 3]], 2, [C, O])</span>

<span class="sd">        Now ``geometry`` is a geometry with 2 different species and 6 atoms (3 of each).</span>
<span class="sd">        They are ordered ``[C, O, C, O, C, O]``. In the following we</span>
<span class="sd">        will note species that are different from the original by a ``&#39;`` in the list.</span>

<span class="sd">        Retain 2nd orbital on the 2nd atom: ``[C, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(1, 1)</span>

<span class="sd">        Retain 2nd orbital on 1st and 2nd atom: ``[C&#39;, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital([0, 1], 1)</span>

<span class="sd">        Retain 2nd orbital on the 1st atom and 3rd orbital on 4th atom: ``[C&#39;, O, C, O&#39;, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(0, 1).sub_orbital(3, 2)</span>

<span class="sd">        Retain 2nd orbital on all atoms equivalent to the first atom: ``[C&#39;, O, C&#39;, O, C&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(obj.geometry.atoms[0], 1)</span>

<span class="sd">        Retain 1st orbital on 1st atom, and 2nd orbital on 3rd and 5th atom: ``[C&#39;, O, C&#39;&#39;, O, C&#39;&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(0, 0).sub_orbital([2, 4], 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        remove_orbital : removing a set of orbitals (opposite of this)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">specie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_specie</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_specie</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_specie</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># At this point we are sure that uniq_specie is *only* one specie!</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">old_atom_specie</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie_index</span><span class="p">(</span><span class="n">old_atom</span><span class="p">)</span>
        <span class="n">old_atom_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span> <span class="o">==</span> <span class="n">old_atom_specie</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.sub_orbital trying to retain 0 orbitals on a given atom. This is not allowed!&quot;</span><span class="p">)</span>

        <span class="c1"># create the new atom</span>
        <span class="n">new_atom</span> <span class="o">=</span> <span class="n">old_atom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="c1"># Rename the new-atom to &lt;&gt;_1_2 for orbital == [1, 2]</span>
        <span class="n">new_atom</span><span class="o">.</span><span class="n">_tag</span> <span class="o">+=</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">))</span>

        <span class="c1"># There are now 2 cases.</span>
        <span class="c1">#  1. we replace all atoms of a given specie</span>
        <span class="c1">#  2. we replace a subset of atoms of a given specie</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_atom_count</span><span class="p">:</span>
            <span class="c1"># We catch the warning about reducing the number of orbitals!</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s1">&#39;ignore&#39;</span><span class="p">)</span>
                <span class="c1"># this is in-place operation and we don&#39;t need to worry about</span>
                <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">replace_atom</span><span class="p">(</span><span class="n">old_atom</span><span class="p">,</span> <span class="n">new_atom</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we have to add the new one (in case it does not exist)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_atom_specie</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie_index</span><span class="p">(</span><span class="n">new_atom</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">new_atom_specie</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">nspecie</span>
                <span class="c1"># the above checks that it is indeed a new atom</span>
                <span class="n">geom</span><span class="o">.</span><span class="n">_atoms</span><span class="o">.</span><span class="n">_atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_atom</span><span class="p">)</span>
            <span class="c1"># transfer specie index</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_specie</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_atom_specie</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_update_orbitals</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">geom</span></div>

<div class="viewcode-block" id="Geometry.remove"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.remove">[docs]</a>    <span class="k">def</span> <span class="nf">remove</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Remove atoms from the geometry.</span>

<span class="sd">        Indices passed *MUST* be unique.</span>

<span class="sd">        Negative indices are wrapped and thus works.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like</span>
<span class="sd">            indices/boolean of all atoms to be removed</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sub : the negative of this routine, i.e. retain a subset of atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">),</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.remove_orbital"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.remove_orbital">[docs]</a>    <span class="k">def</span> <span class="nf">remove_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Remove a subset of orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        For more detailed examples, please see the equivalent (but opposite) method</span>
<span class="sd">        `sub_orbital`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or Atom</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atoms` that are removed from the geometry.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sub_orbital : retaining a set of orbitals (see here for examples)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specie index of the atom (convert to list of indices)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">specie</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_specie</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">specie</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_specie</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_specie</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">remove_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="c1"># We know np.all(geom.atoms[atom] == old_atom)</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_atom</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># now call sub_orbital</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.unrepeat"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.unrepeat">[docs]</a>    <span class="k">def</span> <span class="nf">unrepeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Unrepeats the geometry similarly as `untile`</span>

<span class="sd">        Please see `untile` for argument details, the algorithm and arguments are the same however,</span>
<span class="sd">        this is the opposite of `repeat`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.untile"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.untile">[docs]</a>    <span class="k">def</span> <span class="nf">untile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">segment</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; A subset of atoms from the geometry by cutting the geometry into `reps` parts along the direction `axis`.</span>

<span class="sd">        This will effectively change the unit-cell in the `axis` as-well</span>
<span class="sd">        as removing ``self.na/reps`` atoms.</span>
<span class="sd">        It requires that ``self.na % reps == 0``.</span>

<span class="sd">        REMARK: You need to ensure that all atoms within the first</span>
<span class="sd">        cut out region are within the primary unit-cell.</span>

<span class="sd">        Doing ``geom.untile(2, 1).tile(2, 1)``, could for symmetric setups,</span>
<span class="sd">        be equivalent to a no-op operation. A ``UserWarning`` will be issued</span>
<span class="sd">        if this is not the case.</span>

<span class="sd">        This method may be regarded as the opposite of `tile`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">            number of times the structure will be cut (untiled)</span>
<span class="sd">        axis : int</span>
<span class="sd">            the axis that will be cut</span>
<span class="sd">        segment : int, optional</span>
<span class="sd">            returns the i&#39;th segment of the untiled structure</span>
<span class="sd">            Currently the atomic coordinates are not translated,</span>
<span class="sd">            this may change in the future.</span>
<span class="sd">        rtol : (tolerance for checking tiling, see `numpy.allclose`)</span>
<span class="sd">        atol : (tolerance for checking tiling, see `numpy.allclose`)</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; g = sisl.geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; gxyz = g.tile(4, 0).tile(3, 1).tile(2, 2)</span>
<span class="sd">        &gt;&gt;&gt; G = gxyz.untile(2, 2).untile(3, 1).untile(4, 0)</span>
<span class="sd">        &gt;&gt;&gt; np.allclose(g.xyz, G.xyz)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : opposite method of this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">%</span> <span class="n">reps</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.untile &#39;</span>
                             <span class="sa">f</span><span class="s1">&#39;cannot be cut into </span><span class="si">{</span><span class="n">reps</span><span class="si">}</span><span class="s1"> different &#39;</span>
                             <span class="s1">&#39;pieces. Please check your geometry and input.&#39;</span><span class="p">)</span>
        <span class="c1"># Truncate to the correct segments</span>
        <span class="n">lseg</span> <span class="o">=</span> <span class="n">segment</span> <span class="o">%</span> <span class="n">reps</span>
        <span class="c1"># Cut down cell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
        <span class="c1"># List of atoms</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">//</span> <span class="n">reps</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">n</span> <span class="o">*</span> <span class="n">lseg</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">off</span><span class="p">,</span> <span class="n">off</span> <span class="o">+</span> <span class="n">n</span><span class="p">))</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">rtol</span><span class="o">=</span><span class="n">rtol</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The cut structure cannot be re-created by tiling</span><span class="se">\n</span><span class="s2">&quot;</span>
                 <span class="s2">&quot;The tolerance between the coordinates can be altered using rtol, atol&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>

<div class="viewcode-block" id="Geometry.tile"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.tile">[docs]</a>    <span class="k">def</span> <span class="nf">tile</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Tile the geometry to create a bigger one</span>

<span class="sd">        The atomic indices are retained for the base structure.</span>

<span class="sd">        Tiling and repeating a geometry will result in the same geometry.</span>
<span class="sd">        The *only* difference between the two is the final ordering of the atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">           number of tiles (repetitions)</span>
<span class="sd">        axis : int</span>
<span class="sd">           direction of tiling, 0, 1, 2 according to the cell-direction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1.)</span>
<span class="sd">        &gt;&gt;&gt; g = geom.tile(2,axis=0)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [[0.   0.   0. ]</span>
<span class="sd">         [0.5  0.   0. ]</span>
<span class="sd">         [1.   0.   0. ]</span>
<span class="sd">         [1.5  0.   0. ]]</span>
<span class="sd">        &gt;&gt;&gt; g = geom.tile(2,0).tile(2,axis=1)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [[0.   0.   0. ]</span>
<span class="sd">         [0.5  0.   0. ]</span>
<span class="sd">         [1.   0.   0. ]</span>
<span class="sd">         [1.5  0.   0. ]</span>
<span class="sd">         [0.   1.   0. ]</span>
<span class="sd">         [0.5  1.   0. ]</span>
<span class="sd">         [1.   1.   0. ]</span>
<span class="sd">         [1.5  1.   0. ]]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        repeat : equivalent but different ordering of final structure</span>
<span class="sd">        cut : opposite method of this</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.tile requires a repetition above 0&#39;</span><span class="p">)</span>

        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Our first repetition *must* be with</span>
        <span class="c1"># the former coordinate</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
        <span class="c1"># We may use broadcasting rules instead of repeating stuff</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="n">nr</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="c1"># Correct the unit-cell offsets</span>
        <span class="n">xyz</span> <span class="o">+=</span> <span class="n">nr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Create the geometry and return it (note the smaller atoms array</span>
        <span class="c1"># will also expand via tiling)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">reps</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.repeat"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.repeat">[docs]</a>    <span class="k">def</span> <span class="nf">repeat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create a repeated geometry</span>

<span class="sd">        The atomic indices are *NOT* retained from the base structure.</span>

<span class="sd">        The expansion of the atoms are basically performed using this</span>
<span class="sd">        algorithm:</span>

<span class="sd">        &gt;&gt;&gt; ja = 0</span>
<span class="sd">        &gt;&gt;&gt; for ia in range(self.na):</span>
<span class="sd">        ...     for id,r in args:</span>
<span class="sd">        ...        for i in range(r):</span>
<span class="sd">        ...           ja = ia + cell[id,:] * i</span>

<span class="sd">        For geometries with a single atom this routine returns the same as</span>
<span class="sd">        `tile`.</span>

<span class="sd">        Tiling and repeating a geometry will result in the same geometry.</span>
<span class="sd">        The *only* difference between the two is the final ordering of the atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps : int</span>
<span class="sd">           number of repetitions</span>
<span class="sd">        axis : int</span>
<span class="sd">           direction of repetition, 0, 1, 2 according to the cell-direction</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1)</span>
<span class="sd">        &gt;&gt;&gt; g = geom.repeat(2,axis=0)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [[0.   0.   0. ]</span>
<span class="sd">         [1.   0.   0. ]</span>
<span class="sd">         [0.5  0.   0. ]</span>
<span class="sd">         [1.5  0.   0. ]]</span>
<span class="sd">        &gt;&gt;&gt; g = geom.repeat(2,0).repeat(2,1)</span>
<span class="sd">        &gt;&gt;&gt; print(g.xyz) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [[0.   0.   0. ]</span>
<span class="sd">         [0.   1.   0. ]</span>
<span class="sd">         [1.   0.   0. ]</span>
<span class="sd">         [1.   1.   0. ]</span>
<span class="sd">         [0.5  0.   0. ]</span>
<span class="sd">         [0.5  1.   0. ]</span>
<span class="sd">         [1.5  0.   0. ]</span>
<span class="sd">         [1.5  1.   0. ]]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : equivalent but different ordering of final structure</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">reps</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.repeat requires a repetition above 0&#39;</span><span class="p">)</span>

        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c1"># Our first repetition *must* be with</span>
        <span class="c1"># the former coordinate</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># We may use broadcasting rules instead of repeating stuff</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">nr</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span>
        <span class="n">nr</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Correct the unit-cell offsets along `i`</span>
            <span class="n">xyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="n">nr</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">xyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Create the geometry and return it</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">reps</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;tile&#39;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Implement easy tile/repeat function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : int or tuple or list or (tuple, str) or (list, str)</span>
<span class="sd">           a tuple/list may be of length 2 or 3. A length of 2 corresponds</span>
<span class="sd">           to tuple[0] == *number of multiplications*, tuple[1] is the</span>
<span class="sd">           axis.</span>
<span class="sd">           A length of 3 corresponds to each of the directions.</span>
<span class="sd">           An optional string may be used to specify the `tile` or `repeat` function.</span>
<span class="sd">           The default is the `tile` function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geometry = Geometry([0.] * 3, sc=[1.5, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; geometry * 2 == geometry.tile(2, 0).tile(2, 1).tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * [2, 1, 2] == geometry.tile(2, 0).tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * [2, 2] == geometry.tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 1, 2], &#39;repeat&#39;) == geometry.repeat(2, 0).repeat(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 1, 2], &#39;r&#39;) == geometry.repeat(2, 0).repeat(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 0], &#39;r&#39;) == geometry.repeat(2, 0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 2], &#39;r&#39;) == geometry.repeat(2, 2)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : specific method to enlarge the geometry</span>
<span class="sd">        repeat : specific method to enlarge the geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simple form</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>

        <span class="c1"># Error in argument, fall-back</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Look-up table</span>
        <span class="n">method_tbl</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;r&#39;</span><span class="p">:</span> <span class="s1">&#39;repeat&#39;</span><span class="p">,</span>
            <span class="s1">&#39;repeat&#39;</span><span class="p">:</span> <span class="s1">&#39;repeat&#39;</span><span class="p">,</span>
            <span class="s1">&#39;t&#39;</span><span class="p">:</span> <span class="s1">&#39;tile&#39;</span><span class="p">,</span>
            <span class="s1">&#39;tile&#39;</span><span class="p">:</span> <span class="s1">&#39;tile&#39;</span>
        <span class="p">}</span>

        <span class="c1"># Determine the type</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># either</span>
            <span class="c1">#  (r, axis)</span>
            <span class="c1">#  ((...), method</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">method_tbl</span><span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#  r</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1">#  (r, axis)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1">#  (r, r, r)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiplying a geometry got an unexpected value: </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Default to repeating the atomic structure &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s1">&#39;repeat&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.angle"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.angle">[docs]</a>    <span class="k">def</span> <span class="nf">angle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="nb">dir</span><span class="o">=</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">ref</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; The angle between atom `atoms` and the direction `dir`, with possibility of a reference coordinate `ref`</span>

<span class="sd">        The calculated angle can be written as this</span>

<span class="sd">        .. math::</span>
<span class="sd">            \alpha = \arccos \frac{(\mathrm{atom} - \mathrm{ref})\cdot \mathrm{dir}}</span>
<span class="sd">            {|\mathrm{atom}-\mathrm{ref}||\mathrm{dir}|}</span>

<span class="sd">        and thus lies in the interval :math:`[0 ; \pi]` as one cannot distinguish orientation without</span>
<span class="sd">        additional vectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like</span>
<span class="sd">           indices/boolean of all atoms where angles should be calculated on</span>
<span class="sd">        dir : str, int or array_like, optional</span>
<span class="sd">           the direction from which the angle is calculated from, default to ``x``.</span>
<span class="sd">           An integer specifies the corresponding lattice vector as the direction.</span>
<span class="sd">        ref : int or array_like, optional</span>
<span class="sd">           the reference point from which the vectors are drawn, default to origin</span>
<span class="sd">           An integer species an atomic index.</span>
<span class="sd">        rad : bool, optional</span>
<span class="sd">           whether the returned value is in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">abc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="c1"># Normalize so we don&#39;t have to have this in the</span>
        <span class="c1"># below formula</span>
        <span class="nb">dir</span> <span class="o">=</span> <span class="nb">dir</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">xi</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ref</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">-=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">ref</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ang</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">@</span> <span class="nb">dir</span> <span class="o">/</span> <span class="n">nx</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">rad</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ang</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rotate"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.rotate">[docs]</a>    <span class="k">def</span> <span class="nf">rotate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">angle</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="s1">&#39;abc+xyz&#39;</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Rotate geometry around vector and return a new geometry</span>

<span class="sd">        Per default will the entire geometry be rotated, such that everything</span>
<span class="sd">        is aligned as before rotation.</span>

<span class="sd">        However, by supplying ``only = &#39;abc|xyz&#39;`` one can designate which</span>
<span class="sd">        part of the geometry that will be rotated.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        angle : float</span>
<span class="sd">             the angle in degrees to rotate the geometry. Set the ``rad``</span>
<span class="sd">             argument to use radians.</span>
<span class="sd">        v     : int or str or array_like</span>
<span class="sd">             the normal vector to the rotated plane, i.e.</span>
<span class="sd">             v = [1,0,0] will rotate the ``yz`` plane</span>
<span class="sd">        origin : int or array_like, optional</span>
<span class="sd">             the origin of rotation. Anything but [0, 0, 0] is equivalent</span>
<span class="sd">             to a `self.move(-origin).rotate(...).move(origin)`.</span>
<span class="sd">             If this is an `int` it corresponds to the atomic index.</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">             only rotate the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be rotated.</span>
<span class="sd">        only : {&#39;abc+xyz&#39;, &#39;xyz&#39;, &#39;abc&#39;}</span>
<span class="sd">             which coordinate subject should be rotated,</span>
<span class="sd">             if ``abc`` is in this string the cell will be rotated</span>
<span class="sd">             if ``xyz`` is in this string the coordinates will be rotated</span>
<span class="sd">        rad : bool, optional</span>
<span class="sd">             if ``True`` the angle is provided in radians (rather than degrees)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Quaternion : class to rotate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">,</span> <span class="mf">0.</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Only rotate the unique values</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">abc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span><span class="o">*</span><span class="mi">3</span><span class="p">))</span>

        <span class="c1"># Ensure the normal vector is normalized... (flatten == copy)</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">vn</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">vn</span><span class="p">)</span>

        <span class="c1"># Rotate by direct call</span>
        <span class="k">if</span> <span class="s1">&#39;a&#39;</span> <span class="ow">in</span> <span class="n">only</span> <span class="ow">or</span> <span class="s1">&#39;b&#39;</span> <span class="ow">in</span> <span class="n">only</span> <span class="ow">or</span> <span class="s1">&#39;c&#39;</span> <span class="ow">in</span> <span class="n">only</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="n">rad</span><span class="p">,</span> <span class="n">only</span><span class="o">=</span><span class="n">only</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Copy</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;xyz&#39;</span> <span class="ow">in</span> <span class="n">only</span><span class="p">:</span>
            <span class="c1"># Prepare quaternion...</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">angle</span><span class="p">,</span> <span class="n">vn</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="n">rad</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">/=</span> <span class="n">q</span><span class="o">.</span><span class="n">norm</span><span class="p">()</span>
            <span class="c1"># subtract and add origin, before and after rotation</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">origin</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span> <span class="o">+</span> <span class="n">origin</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.rotate_miller"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.rotate_miller">[docs]</a>    <span class="k">def</span> <span class="nf">rotate_miller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Align Miller direction along ``v``</span>

<span class="sd">        Rotate geometry and cell such that the Miller direction</span>
<span class="sd">        points along the Cartesian vector ``v``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create normal vector to miller direction and cartesian</span>
        <span class="c1"># direction</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                        <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                        <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
        <span class="n">cp</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>

        <span class="n">lm</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">lm</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
        <span class="n">lv</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">lv</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span>

        <span class="c1"># Now rotate the angle between them</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lm</span> <span class="o">*</span> <span class="n">lv</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">cp</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.translate"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.translate">[docs]</a>    <span class="k">def</span> <span class="nf">translate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">cell</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Translates the geometry by `v`</span>

<span class="sd">        One can translate a subset of the atoms by supplying `atoms`.</span>

<span class="sd">        Returns a copy of the structure translated by `v`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        v : float or array_like</span>
<span class="sd">             the value or vector to displace all atomic coordinates</span>
<span class="sd">             It should just be broad-castable with the geometry&#39;s coordinates.</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">             only displace the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be displaced</span>
<span class="sd">        cell : bool, optional</span>
<span class="sd">             If True the supercell also gets enlarged by the vector</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">cell</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">set_supercell</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">v</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">g</span></div>
    <span class="n">move</span> <span class="o">=</span> <span class="n">translate</span>

<div class="viewcode-block" id="Geometry.translate2uc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.translate2uc">[docs]</a>    <span class="k">def</span> <span class="nf">translate2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translates atoms in the geometry into the unit cell</span>

<span class="sd">        One can translate a subset of the atoms or axes by appropriate arguments.</span>

<span class="sd">        When coordinates are lying on one of the edges, they may move to the other</span>
<span class="sd">        side of the unit-cell due to small rounding errors.</span>
<span class="sd">        In such situations you are encouraged to shift all coordinates by a small</span>
<span class="sd">        amount to remove numerical errors, in the following case we have atomic</span>
<span class="sd">        coordinates lying close to the lower side of each lattice vector.</span>

<span class="sd">        &gt;&gt;&gt; geometry.move(1e-8).translate2uc().move(-1e-8)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">             only translate the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be translated</span>
<span class="sd">        axes : int or array_like, optional</span>
<span class="sd">             only translate certain lattice directions, defaults to all</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span>
        <span class="c1"># move to unit-cell</span>
        <span class="n">fxyz</span><span class="p">[:,</span> <span class="n">axes</span><span class="p">]</span> <span class="o">%=</span> <span class="mi">1</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># convert back</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fxyz</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fxyz</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="Geometry.swap"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.swap">[docs]</a>    <span class="k">def</span> <span class="nf">swap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms_a</span><span class="p">,</span> <span class="n">atoms_b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Swap a set of atoms in the geometry and return a new one</span>

<span class="sd">        This can be used to reorder elements of a geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms_a : array_like</span>
<span class="sd">             the first list of atomic coordinates</span>
<span class="sd">        atoms_b : array_like</span>
<span class="sd">             the second list of atomic coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms_a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms_a</span><span class="p">)</span>
        <span class="n">atoms_b</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms_b</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">xyz</span><span class="p">[</span><span class="n">atoms_a</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms_b</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">xyz</span><span class="p">[</span><span class="n">atoms_b</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms_a</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">atoms_a</span><span class="p">,</span> <span class="n">atoms_b</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="Geometry.swapaxes"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.swapaxes">[docs]</a>    <span class="k">def</span> <span class="nf">swapaxes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis_a</span><span class="p">,</span> <span class="n">axis_b</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;cell+xyz&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Swap the axis for the atomic coordinates and the cell vectors</span>

<span class="sd">        If ``swapaxes(0,1)`` it returns the 0 and 1 values</span>
<span class="sd">        swapped in the ``cell`` variable.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis_a : int</span>
<span class="sd">           axis 1, swaps with `b`</span>
<span class="sd">        axis_b : int</span>
<span class="sd">           axis 2, swaps with `a`</span>
<span class="sd">        what : {&#39;cell+xyz&#39;, &#39;cell&#39;, &#39;xyz&#39;}</span>
<span class="sd">           decide what to swap, if `&#39;cell&#39;` is in `what` then</span>
<span class="sd">           the cell axis are swapped.</span>
<span class="sd">           if `&#39;xyz&#39;` is in `what` then</span>
<span class="sd">           the xyz (Cartesian) axis are swapped.</span>
<span class="sd">           Both may be in `what`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;xyz&quot;</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="n">xyz</span><span class="p">[:,</span> <span class="n">axis_a</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">axis_b</span><span class="p">]</span>
            <span class="n">xyz</span><span class="p">[:,</span> <span class="n">axis_b</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">axis_a</span><span class="p">]</span>
        <span class="k">if</span> <span class="s2">&quot;cell&quot;</span> <span class="ow">in</span> <span class="n">what</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">swapaxes</span><span class="p">(</span><span class="n">axis_a</span><span class="p">,</span> <span class="n">axis_b</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.center"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.center">[docs]</a>    <span class="k">def</span> <span class="nf">center</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;xyz&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the center of the geometry</span>

<span class="sd">        By specifying `what` one can control whether it should be:</span>

<span class="sd">        * ``xyz|position``: Center of coordinates (default)</span>
<span class="sd">        * ``mm:xyz`` or ``mm(xyz)``: Center of minimum/maximum of coordinates</span>
<span class="sd">        * ``mass``: Center of mass</span>
<span class="sd">        * ``mass:pbc``: Center of mass using periodicity, if the point 0, 0, 0 is returned it</span>
<span class="sd">            may likely be because of a completely periodic system with no true center of mass</span>
<span class="sd">        * ``cell``: Center of cell</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like</span>
<span class="sd">            list of atomic indices to find center of</span>
<span class="sd">        what : {&#39;xyz&#39;, &#39;mm:xyz&#39;, &#39;mass&#39;, &#39;mass:pbc&#39;, &#39;cell&#39;}</span>
<span class="sd">            determine which center to calculate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s2">&quot;cell&quot;</span> <span class="o">==</span> <span class="n">what</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">center</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="k">if</span> <span class="s2">&quot;mass:pbc&quot;</span> <span class="o">==</span> <span class="n">what</span><span class="p">:</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">mass</span>
            <span class="n">sum_mass</span> <span class="o">=</span> <span class="n">mass</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># the periodic center of mass is determined by transfering all</span>
            <span class="c1"># coordinates onto a circle -&gt; fxyz * 2pi</span>
            <span class="c1"># Then we mass average the circle angles for each of the fractional</span>
            <span class="c1"># coordinates, and transform back into the cartesian coordinate system</span>
            <span class="n">theta</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">fxyz</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
            <span class="c1"># construct angles</span>
            <span class="n">avg_cos</span> <span class="o">=</span> <span class="p">(</span><span class="n">mass</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">sum_mass</span>
            <span class="n">avg_sin</span> <span class="o">=</span> <span class="p">(</span><span class="n">mass</span> <span class="o">@</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">))</span> <span class="o">/</span> <span class="n">sum_mass</span>
            <span class="n">avg_theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="o">-</span><span class="n">avg_sin</span><span class="p">,</span> <span class="o">-</span><span class="n">avg_cos</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span>
            <span class="k">return</span> <span class="n">avg_theta</span> <span class="o">@</span> <span class="n">g</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span>

        <span class="k">if</span> <span class="s2">&quot;mass&quot;</span> <span class="o">==</span> <span class="n">what</span><span class="p">:</span>
            <span class="n">mass</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">mass</span>
            <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">mass</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mass</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;mm:xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;mm(xyz)&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">if</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.center could not understand option &#39;what&#39; got </span><span class="si">{</span><span class="n">what</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.append"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.append">[docs]</a>    <span class="k">def</span> <span class="nf">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Appends two structures along `axis`</span>

<span class="sd">        This will automatically add the ``self.cell[axis,:]`` to all atomic</span>
<span class="sd">        coordiates in the `other` structure before appending.</span>

<span class="sd">        The basic algorithm is this:</span>

<span class="sd">        &gt;&gt;&gt; oxa = other.xyz + self.cell[axis,:][None,:]</span>
<span class="sd">        &gt;&gt;&gt; self.xyz = np.append(self.xyz,oxa)</span>
<span class="sd">        &gt;&gt;&gt; self.cell[axis,:] += other.cell[axis,:]</span>

<span class="sd">        NOTE: The cell appended is only in the axis that</span>
<span class="sd">        is appended, which means that the other cell directions</span>
<span class="sd">        need not conform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry or SuperCell</span>
<span class="sd">            Other geometry class which needs to be appended</span>
<span class="sd">            If a `SuperCell` only the super cell will be extended</span>
<span class="sd">        axis : int</span>
<span class="sd">            Cell direction to which the `other` geometry should be</span>
<span class="sd">            appended.</span>
<span class="sd">        offset : {&#39;none&#39;, &#39;min&#39;, (3,)}</span>
<span class="sd">            By default appending two structures will simply use the coordinates,</span>
<span class="sd">            as is.</span>
<span class="sd">            With &#39;min&#39;, the routine will shift both the structures along the cell</span>
<span class="sd">            axis of `self` such that they coincide at the first atom, lastly one</span>
<span class="sd">            may use a specified offset to manually select how `other` is displaced.</span>
<span class="sd">            NOTE: That `self.cell[axis, :]` will be added to `offset` if `other` is</span>
<span class="sd">            a geometry.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        insert : insert a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="c1"># Only extend the supercell.</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires offset to be (3,) for supercell input&quot;</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sanitize output</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">offset</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
                    <span class="c1"># We want to align at the minimum position along the `axis`</span>
                    <span class="n">min_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">min_other_f</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span> <span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">min_f</span> <span class="o">-</span> <span class="n">min_other_f</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.append requires align keyword to be one of [none, min, (3,)]&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.prepend"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.prepend">[docs]</a>    <span class="k">def</span> <span class="nf">prepend</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Prepend two structures along `axis`</span>

<span class="sd">        This will automatically add the ``self.cell[axis,:]`` to all atomic</span>
<span class="sd">        coordiates in the `other` structure before appending.</span>

<span class="sd">        The basic algorithm is this:</span>

<span class="sd">        &gt;&gt;&gt; oxa = other.xyz</span>
<span class="sd">        &gt;&gt;&gt; self.xyz = np.append(oxa, self.xyz + other.cell[axis,:][None,:])</span>
<span class="sd">        &gt;&gt;&gt; self.cell[axis,:] += other.cell[axis,:]</span>

<span class="sd">        NOTE: The cell prepended is only in the axis that</span>
<span class="sd">        is prependend, which means that the other cell directions</span>
<span class="sd">        need not conform.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry or SuperCell</span>
<span class="sd">            Other geometry class which needs to be prepended</span>
<span class="sd">            If a `SuperCell` only the super cell will be extended</span>
<span class="sd">        axis : int</span>
<span class="sd">            Cell direction to which the `other` geometry should be</span>
<span class="sd">            prepended</span>
<span class="sd">        offset : {&#39;none&#39;, &#39;min&#39;, (3,)}</span>
<span class="sd">            By default appending two structures will simply use the coordinates,</span>
<span class="sd">            as is.</span>
<span class="sd">            With &#39;min&#39;, the routine will shift both the structures along the cell</span>
<span class="sd">            axis of `other` such that they coincide at the first atom, lastly one</span>
<span class="sd">            may use a specified offset to manually select how `self` is displaced.</span>
<span class="sd">            NOTE: That `other.cell[axis, :]` will be added to `offset` if `other` is</span>
<span class="sd">            a geometry.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        insert : insert a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="c1"># Only extend the supercell.</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.prepend requires offset to be (3,) for supercell input&quot;</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sanitize output</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">offset</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="n">offset</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">offset</span> <span class="o">==</span> <span class="s1">&#39;none&#39;</span><span class="p">:</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">offset</span> <span class="o">==</span> <span class="s1">&#39;min&#39;</span><span class="p">:</span>
                    <span class="c1"># We want to align at the minimum position along the `axis`</span>
                    <span class="n">min_f</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">fxyz</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">min_other_f</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)[:,</span> <span class="n">axis</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
                    <span class="n">offset</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">min_f</span> <span class="o">-</span> <span class="n">min_other_f</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">.prepend requires align keyword to be one of [none, min, (3,)]&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">offset</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">prepend</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_names</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="n">other</span><span class="p">))</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.add"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.add">[docs]</a>    <span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Merge two geometries (or a Geometry and SuperCell) by adding the two atoms together</span>

<span class="sd">        If `other` is a Geometry only the atoms gets added, to also add the supercell vectors</span>
<span class="sd">        simply do ``geom.add(other).add(other.sc)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry or SuperCell</span>
<span class="sd">            Other geometry class which is added</span>
<span class="sd">        offset : (3,), optional</span>
<span class="sd">            offset in geometry of `other` when adding the atoms. Only if `other` is</span>
<span class="sd">            of instance `Geometry`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        insert : insert a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span> <span class="o">+</span> <span class="n">other</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">names</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span><span class="o">.</span><span class="n">merge</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_names</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="n">names</span><span class="o">=</span><span class="n">names</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.insert"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.insert">[docs]</a>    <span class="k">def</span> <span class="nf">insert</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Inserts other atoms right before index</span>

<span class="sd">        We insert the `geometry` `Geometry` before `atom`.</span>
<span class="sd">        Note that this will not change the unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int</span>
<span class="sd">           the atomic index at which the other geometry is inserted</span>
<span class="sd">        other : Geometry</span>
<span class="sd">           the other geometry to be inserted</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        attach : attach a geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.insert requires only 1 atomic index for insertion.&quot;</span><span class="p">)</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Merge two geometries (or geometry and supercell)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self, b : Geometry or SuperCell or tuple or list</span>
<span class="sd">           when adding a Geometry with a Geometry it defaults to using `add` function</span>
<span class="sd">           with the LHS retaining the cell-vectors.</span>
<span class="sd">           a tuple/list may be of length 2 with the first element being a Geometry and the second</span>
<span class="sd">           being an integer specifying the lattice vector where it is appended.</span>
<span class="sd">           One may also use a `SuperCell` instead of a `Geometry` which behaves similarly.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; A + B == A.add(B)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 1) == A.append(B, 1)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 2) == A.append(B, 2)</span>
<span class="sd">        &gt;&gt;&gt; (A, 1) + B == A.append(B, 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">SuperCell</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Merge two geometries (or geometry and supercell)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self, b : Geometry or SuperCell or tuple or list</span>
<span class="sd">           when adding a Geometry with a Geometry it defaults to using `add` function</span>
<span class="sd">           with the LHS retaining the cell-vectors.</span>
<span class="sd">           a tuple/list may be of length 2 with the first element being a Geometry and the second</span>
<span class="sd">           being an integer specifying the lattice vector where it is appended.</span>
<span class="sd">           One may also use a `SuperCell` instead of a `Geometry` which behaves similarly.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; A + B == A.add(B)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 1) == A.append(B, 1)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 2) == A.append(B, 2)</span>
<span class="sd">        &gt;&gt;&gt; (A, 1) + B == A.append(B, 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">SuperCell</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">b</span>

<div class="viewcode-block" id="Geometry.attach"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.attach">[docs]</a>    <span class="k">def</span> <span class="nf">attach</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">other_atom</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Attaches another `Geometry` at the `atom` index with respect to `other_atom` using different methods.</span>

<span class="sd">        The attached geometry will be inserted at the end of the geometry via `add`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int</span>
<span class="sd">           atomic index which is the base position of the attachment. The distance</span>
<span class="sd">           between `atom` and `other_atom` is `dist`.</span>
<span class="sd">        other : Geometry</span>
<span class="sd">           the other Geometry to attach at the given point. In this case `dist` from</span>
<span class="sd">           `atom`.</span>
<span class="sd">        other_atom : int</span>
<span class="sd">           the index of the atom in `other` that is inserted at `atom`.</span>
<span class="sd">        dist : array_like or float or str, optional</span>
<span class="sd">           the distance (in `Ang`) between the attached coordinates.</span>
<span class="sd">           If `dist` is `array_like` it should be the vector between</span>
<span class="sd">           the atoms;</span>
<span class="sd">           if `dist` is `float` the argument `axis` is required</span>
<span class="sd">           and the vector will be calculated along the corresponding latticevector;</span>
<span class="sd">           else if `dist` is `str` this will correspond to the</span>
<span class="sd">           `method` argument of the `Atom.radius` class of the two</span>
<span class="sd">           atoms. Here `axis` is also required.</span>
<span class="sd">        axis : int</span>
<span class="sd">           specify the direction of the lattice vectors used.</span>
<span class="sd">           Not used if `dist` is an array-like argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="c1"># We have a single rational number</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.attach, `axis` has not been specified, please specify the axis when using a distance&quot;</span><span class="p">)</span>

            <span class="c1"># Now calculate the vector that we should have</span>
            <span class="c1"># between the atoms</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dist</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># We have a single rational number</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.attach, `axis` has not been specified, please specify the axis when using a distance&quot;</span><span class="p">)</span>

            <span class="c1"># This is the empirical distance between the atoms</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">other_atom</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The user *must* have supplied a vector</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="c1"># Now create a copy of the other geometry</span>
        <span class="c1"># so that we move it...</span>
        <span class="c1"># Translate to origin, then back to position in new cell</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">other_atom</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># We do not know how to handle the lattice-vectors,</span>
        <span class="c1"># so we will do nothing...</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.replace"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.replace">[docs]</a>    <span class="k">def</span> <span class="nf">replace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create a new geometry from `self` and replace `atoms` with `other`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int, optional</span>
<span class="sd">            atoms in `self` to be removed and replaced by other</span>
<span class="sd">            `other` will be placed in the geometry at the lowest index of `atoms`</span>
<span class="sd">        other : Geometry</span>
<span class="sd">            the other Geometry to insert instead, the unit-cell will not</span>
<span class="sd">            be used.</span>
<span class="sd">        offset : (3,), optional</span>
<span class="sd">            the offset for `other` when adding its coordinates, default to no offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find lowest value in atoms</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># remove atoms, preparing for inserting new geometry</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="c1"># insert new positions etc.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>

<div class="viewcode-block" id="Geometry.reverse"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.reverse">[docs]</a>    <span class="k">def</span> <span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns a reversed geometry</span>

<span class="sd">        Also enables reversing a subset of the atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">             only reverse the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be reversed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span></div>

<div class="viewcode-block" id="Geometry.mirror"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.mirror">[docs]</a>    <span class="k">def</span> <span class="nf">mirror</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">point</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Mirrors the atomic coordinates about a plane given by its normal vector</span>

<span class="sd">        This will typically move the atomic coordinates outside of the unit-cell.</span>
<span class="sd">        This method should be used with care.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;xy&#39;/&#39;z&#39;, ..., &#39;ab&#39;, ..., v}</span>
<span class="sd">           mirror the structure about a Cartesian direction (``x``, ``y``, ``z``),</span>
<span class="sd">           plane (``xy``, ``xz``, ``yz``) or about user defined vectors (``v``).</span>
<span class="sd">           A vector may also be specified by ``&#39;ab&#39;`` which is the vector normal</span>
<span class="sd">           to the plane spanned by the first and second lattice vector.</span>
<span class="sd">           or user defined vector (`v`) which is defining a plane.</span>
<span class="sd">        atoms : array_like, optional</span>
<span class="sd">           only mirror a subset of atoms</span>
<span class="sd">        point: (3,), optional</span>
<span class="sd">           mirror coordinates around the plane that intersects the *method* vector</span>
<span class="sd">           and this point</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; out = geom.mirror(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; out.xyz[:, 0]</span>
<span class="sd">        [0.  -1.42]</span>
<span class="sd">        &gt;&gt;&gt; out = geom.mirror(&#39;x&#39;, point=(1.42/2, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; out.xyz[:, 0]</span>
<span class="sd">        [1.42  0.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;xy&#39;</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;yz&#39;</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;xz&#39;</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;a&#39;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;b&#39;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;c&#39;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ab&#39;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">cross3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;ac&#39;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">cross3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;bc&#39;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">cross3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.mirror unrecognized &#39;method&#39; value&quot;</span><span class="p">)</span>

        <span class="c1"># it has to be an array of length 3</span>
        <span class="c1"># Mirror about a user defined vector</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># project onto vector</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># convert coordinates</span>
        <span class="c1"># first subtract the projection, then its mirror position</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">vp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">method</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span></div>

<div class="viewcode-block" id="Geometry.axyz"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.axyz">[docs]</a>    <span class="k">def</span> <span class="nf">axyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the atomic coordinates in the supercell of a given atom.</span>

<span class="sd">        The ``Geometry[...]`` slicing is calling this function with appropriate options.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like</span>
<span class="sd">          atom(s) from which we should return the coordinates, the atomic indices</span>
<span class="sd">          may be in supercell format.</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">            Returns the atomic coordinates shifted according to the integer</span>
<span class="sd">            parts of the cell. Defaults to the unit-cell</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1.)</span>
<span class="sd">        &gt;&gt;&gt; print(geom.axyz(isc=[1,0,0])) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [[1.   0.   0. ]</span>
<span class="sd">         [1.5  0.   0. ]]</span>

<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], sc=1.)</span>
<span class="sd">        &gt;&gt;&gt; print(geom.axyz(0)) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        [0.  0.  0.]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="c1"># If only atoms has been specified</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get offsets from atomic indices (note that this will be per atom)</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="c1"># Neither of atoms, or isc are `None`, we add the offset to all coordinates</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.scale"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.scale">[docs]</a>    <span class="k">def</span> <span class="nf">scale</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;abc&quot;</span><span class="p">,</span> <span class="n">scale_atoms</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Scale coordinates and unit-cell to get a new geometry with proper scaling</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        scale : float or array-like of floats with shape (3,)</span>
<span class="sd">           the scale factor for the new geometry (lattice vectors, coordinates</span>
<span class="sd">           and the atomic radii are scaled).</span>
<span class="sd">        what: {&quot;abc&quot;, &quot;xyz&quot;}</span>
<span class="sd">           If three different scale factors are provided, whether each scaling factor</span>
<span class="sd">           is to be applied on the corresponding lattice vector (&quot;abc&quot;) or on the</span>
<span class="sd">           corresponding cartesian coordinate (&quot;xyz&quot;).</span>
<span class="sd">        scale_atoms : bool</span>
<span class="sd">           whether atoms (basis) should be scaled as well.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure we are dealing with a numpy array</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># scaling with a scalar is equivalent to scaling</span>
            <span class="c1"># cartesian coordinates</span>
            <span class="n">what</span> <span class="o">=</span> <span class="s2">&quot;xyz&quot;</span>

        <span class="c1"># Scale the supercell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="n">what</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;xyz&quot;</span><span class="p">:</span>
            <span class="c1"># It is faster to rescale coordinates by simply multiplying them by the scale</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="n">max_scale</span> <span class="o">=</span> <span class="n">scale</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">elif</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;abc&quot;</span><span class="p">:</span>
            <span class="c1"># Scale the coordinates by keeping fractional coordinates the same</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span> <span class="o">@</span> <span class="n">sc</span><span class="o">.</span><span class="n">cell</span>

            <span class="k">if</span> <span class="n">scale_atoms</span><span class="p">:</span>
                <span class="c1"># To rescale atoms, we need to know the span of each cartesian coordinate before and</span>
                <span class="c1"># after the scaling, and scale the atoms according to the coordinate that has</span>
                <span class="c1"># been scaled by the largest factor.</span>
                <span class="n">prev_verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">prev_span</span> <span class="o">=</span> <span class="n">prev_verts</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">prev_verts</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">scaled_verts</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">vertices</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">scaled_span</span> <span class="o">=</span> <span class="n">scaled_verts</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">scaled_verts</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">max_scale</span> <span class="o">=</span> <span class="p">(</span><span class="n">scaled_span</span> <span class="o">/</span> <span class="n">prev_span</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">scale_atoms</span><span class="p">:</span>
            <span class="c1"># Atoms are rescaled to the maximum scale factor</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">scale</span><span class="p">(</span><span class="n">max_scale</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.within_sc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.within_sc">[docs]</a>    <span class="k">def</span> <span class="nf">within_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Indices of atoms in a given supercell within a given shape from a given coordinate</span>

<span class="sd">        This returns a set of atomic indices which are within a</span>
<span class="sd">        sphere of radius ``R``.</span>

<span class="sd">        If R is a tuple/list/array it will return the indices:</span>
<span class="sd">        in the ranges:</span>

<span class="sd">        &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapes : Shape or list of Shape</span>
<span class="sd">            A list of increasing shapes that define the extend of the geometric</span>
<span class="sd">            volume that is searched.</span>
<span class="sd">            It is vital that::</span>

<span class="sd">               shapes[0] in shapes[1] in shapes[2] ...</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">            The super-cell which the coordinates are checked in. Defaults to ``[0, 0, 0]``</span>
<span class="sd">        atoms : array_like, optional</span>
<span class="sd">            List of atoms that will be considered. This can</span>
<span class="sd">            be used to only take out a certain atoms.</span>
<span class="sd">        atoms_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `idx` variable (`idx` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If True this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If True this method will return the distance to the center of the shapes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shape</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center of the shape (only for true `ret_rij`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that `shapes` is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapes</span><span class="p">]</span>
        <span class="n">nshapes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

        <span class="c1"># Convert to actual array</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If idx is None, then idx_xyz cannot be used!</span>
            <span class="c1"># So we force it to None</span>
            <span class="n">atoms_xyz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Get shape centers</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[:]</span>
        <span class="c1"># Get the supercell offset</span>
        <span class="n">soff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)[:]</span>

        <span class="c1"># Get atomic coordinate in principal cell</span>
        <span class="k">if</span> <span class="n">atoms_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">soff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For extremely large systems re-using the</span>
            <span class="c1"># idx_xyz is faster than indexing</span>
            <span class="c1"># a very large array</span>
            <span class="c1"># However, this idx_xyz should not</span>
            <span class="c1"># be offset by any supercell</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">atoms_xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">soff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Get indices and coordinates of the largest shape</span>
        <span class="c1"># The largest part of the calculation are to calculate</span>
        <span class="c1"># the content in the largest shape.</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
        <span class="c1"># Reduce search space</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">xa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This is because of the pre-check of the distance checks</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">ix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Quick return if there are no entries...</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Calculate distance</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">xa</span> <span class="o">-</span> <span class="n">off</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Create the initial lists that we will build up</span>
        <span class="c1"># Then finally, we will return the reversed lists</span>

        <span class="c1"># Quick return</span>
        <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atoms</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO Check that all shapes coincide with the following shapes</span>

        <span class="c1"># Now we create a list of indices which coincide</span>
        <span class="c1"># in each of the shapes</span>
        <span class="c1"># Do a reduction on each of the list elements</span>
        <span class="n">ixS</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">atoms</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cum</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Update elements to remove in next loop</span>
            <span class="n">cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cum</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">ixS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Do for the first shape</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]]</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]])</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nshapes</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.close_sc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.close_sc">[docs]</a>    <span class="k">def</span> <span class="nf">close_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_ia</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Indices of atoms in a given supercell within a given radius from a given coordinate</span>

<span class="sd">        This returns a set of atomic indices which are within a</span>
<span class="sd">        sphere of radius `R`.</span>

<span class="sd">        If `R` is a tuple/list/array it will return the indices:</span>
<span class="sd">        in the ranges:</span>

<span class="sd">        &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia : array_like of floats or int</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        isc : (3,), optional</span>
<span class="sd">            Integer super-cell offsets in which the coordinates are checked in.</span>
<span class="sd">            I.e. ``isc=[0, 0, 0]`` is the primary cell (default).</span>
<span class="sd">        R : float or array_like, optional</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If `R` is an array it will return the indices:</span>
<span class="sd">            in the ranges ``( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )``.</span>
<span class="sd">            If a single float it will return ``x &lt;= R``.</span>
<span class="sd">        atoms : array_like of int, optional</span>
<span class="sd">            List of atoms that will be considered. This can</span>
<span class="sd">            be used to only take out a certain atoms.</span>
<span class="sd">        atoms_xyz : array_like of float, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `atoms` variable (`atoms` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If True this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If True this method will return the distance</span>
<span class="sd">            for each of the couplings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shells of radius `R`</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center coordinate (only for true `ret_rij`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Maximum distance queried</span>
        <span class="n">max_R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Convert to actual array</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If atoms is None, then atoms_xyz cannot be used!</span>
            <span class="n">atoms_xyz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">):</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">xyz_ia</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">xyz_ia</span>

        <span class="c1"># Calculate the complete offset</span>
        <span class="n">foff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)[:]</span> <span class="o">-</span> <span class="n">off</span><span class="p">[:]</span>

        <span class="c1"># Get atomic coordinate in principal cell</span>
        <span class="k">if</span> <span class="n">atoms_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="n">foff</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For extremely large systems re-using the</span>
            <span class="c1"># atoms_xyz is faster than indexing</span>
            <span class="c1"># a very large array</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">atoms_xyz</span> <span class="o">+</span> <span class="n">foff</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Immediately downscale by easy checking</span>
        <span class="c1"># This will reduce the computation of the vector-norm</span>
        <span class="c1"># which is the main culprit of the time-consumption</span>
        <span class="c1"># This abstraction will _only_ help very large</span>
        <span class="c1"># systems.</span>
        <span class="c1"># For smaller ones this will actually be a slower</span>
        <span class="c1"># method..</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">indices_in_sphere_with_dist</span><span class="p">(</span><span class="n">dxa</span><span class="p">,</span> <span class="n">max_R</span><span class="p">)</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">indices_in_sphere_with_dist</span><span class="p">(</span><span class="n">dxa</span><span class="p">,</span> <span class="n">max_R</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">ix</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Create default return</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="mi">0</span><span class="p">])]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="mi">0</span><span class="p">])]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">))</span>

            <span class="c1"># Quick return if there are</span>
            <span class="c1"># no entries...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">off</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">dxa</span>  <span class="c1"># just because this array could be very big...</span>

        <span class="c1"># Check whether we only have one range to check.</span>
        <span class="c1"># If so, we need not reduce the index space</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ascending</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.close_sc proximity checks for several &quot;</span>
                             <span class="s2">&quot;quantities at a time requires ascending R values.&quot;</span><span class="p">)</span>

        <span class="c1"># The more neigbours you wish to find the faster this becomes</span>
        <span class="c1"># We only do &quot;one&quot; heavy duty search,</span>
        <span class="c1"># then we immediately reduce search space to this subspace</span>
        <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">]]]</span>
        <span class="n">r_app</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
            <span class="n">r_appx</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
            <span class="n">r_appd</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="c1"># Search in the sub-space</span>
                <span class="c1"># Notice that this sub-space reduction will never</span>
                <span class="c1"># allow the same indice to be in two ranges (due to</span>
                <span class="c1"># numerics)</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appx</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appd</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appx</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appd</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>

<div class="viewcode-block" id="Geometry.bond_correct"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.bond_correct">[docs]</a>    <span class="k">def</span> <span class="nf">bond_correct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;calc&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Corrects the bond between `ia` and the `atoms`.</span>

<span class="sd">        Corrects the bond-length between atom `ia` and `atoms` in such</span>
<span class="sd">        a way that the atomic radius is preserved.</span>
<span class="sd">        I.e. the sum of the bond-lengths minimizes the distance matrix.</span>

<span class="sd">        Only atom `ia` is moved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia : int</span>
<span class="sd">            The atom to be displaced according to the atomic radius</span>
<span class="sd">        atoms : array_like or int</span>
<span class="sd">            The atom(s) from which the radius should be reduced.</span>
<span class="sd">        method : str, float, optional</span>
<span class="sd">            If str will use that as lookup in `Atom.radius`.</span>
<span class="sd">            Else it will be the new bond-length.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Decide which algorithm to choose from</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># signal a list of atoms</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">algo</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>

            <span class="c1"># We have a single atom</span>
            <span class="c1"># Get bond length in the closest direction</span>
            <span class="c1"># A bond-length HAS to be below 10</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.</span><span class="p">),</span> <span class="n">atoms</span><span class="o">=</span><span class="n">algo</span><span class="p">,</span>
                                     <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Convert to unitcell atom (and get the one atom)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Calculate the bond vector</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">c</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If it is a number, we use that.</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># get radius</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> \
                      <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

            <span class="c1"># Update the coordinate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">bv</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">rad</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s1">&#39;Changing bond-length dependent on several lacks implementation.&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.within"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.within">[docs]</a>    <span class="k">def</span> <span class="nf">within</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shapes</span><span class="p">,</span>
               <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
               <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_isc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Indices of atoms in the entire supercell within a given shape from a given coordinate</span>

<span class="sd">        This heavily relies on the `within_sc` method.</span>

<span class="sd">        Note that if a connection is made in a neighbouring super-cell</span>
<span class="sd">        then the atomic index is shifted by the super-cell index times</span>
<span class="sd">        number of atoms.</span>
<span class="sd">        This allows one to decipher super-cell atoms from unit-cell atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapes : Shape, list of Shape</span>
<span class="sd">        atoms : array_like, optional</span>
<span class="sd">            List of indices for atoms that are to be considered</span>
<span class="sd">        atoms_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `atoms` variable (`atoms` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If true this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If true this method will return the distances from the `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_isc : bool, optional</span>
<span class="sd">            If true this method will return the supercell offsets for each of the couplings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shape</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center of the shape (only for true `ret_rij`)</span>
<span class="sd">        isc</span>
<span class="sd">            supercell indices of the couplings (only for true `ret_isc`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that `shapes` is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapes</span><span class="p">]</span>
        <span class="n">nshapes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">ixyz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">irij</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
            <span class="n">iisc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>

        <span class="c1"># number of special returns</span>
        <span class="n">n_ret</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">def</span> <span class="nf">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="n">isc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>

            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">sret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_sc</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:],</span>
                                  <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">,</span>
                                  <span class="n">ret_xyz</span><span class="o">=</span><span class="n">ret_xyz</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="n">ret_rij</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This is to &quot;fake&quot; the return</span>
                <span class="c1"># of a list (we will do indexing!)</span>
                <span class="n">sret</span> <span class="o">=</span> <span class="p">[</span><span class="n">sret</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># we have a list of arrays (nshapes &gt; 1)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We can add it to the list (nshapes == 1)</span>
                <span class="c1"># We add the atomic offset for the supercell index</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ret</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Geometry.close"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.close">[docs]</a>    <span class="k">def</span> <span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xyz_ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
              <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">ret_isc</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Indices of atoms in the entire supercell within a given radius from a given coordinate</span>

<span class="sd">        This heavily relies on the `close_sc` method.</span>

<span class="sd">        Note that if a connection is made in a neighbouring super-cell</span>
<span class="sd">        then the atomic index is shifted by the super-cell index times</span>
<span class="sd">        number of atoms.</span>
<span class="sd">        This allows one to decipher super-cell atoms from unit-cell atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia : coordinate/index</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        R : (None), float/tuple of float</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If `R` is an array it will return the indices:</span>
<span class="sd">            in the ranges:</span>

<span class="sd">            &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )</span>

<span class="sd">            If a single float it will return:</span>

<span class="sd">            &gt;&gt;&gt; x &lt;= R</span>

<span class="sd">        atoms : array_like, optional</span>
<span class="sd">            List of indices for atoms that are to be considered</span>
<span class="sd">        atoms_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `atoms` variable (`atoms` must also be passed)</span>
<span class="sd">        ret_xyz : bool, optional</span>
<span class="sd">            If true this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij : bool, optional</span>
<span class="sd">            If true this method will return the distances from the `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_isc : bool, optional</span>
<span class="sd">            If true this method will return the lattice offset from `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shells of radius `R`</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center coordinate (only for true `ret_rij`)</span>
<span class="sd">        isc</span>
<span class="sd">            integer lattice offsets for the couplings (related to `rij` without atomic coordinates)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Convert inedx coordinate to point</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">xyz_ia</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">):</span>
            <span class="n">xyz_ia</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">ixyz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">irij</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
            <span class="n">iisc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">)</span>

        <span class="c1"># number of special returns</span>
        <span class="n">n_ret</span> <span class="o">=</span> <span class="n">i</span>

        <span class="k">def</span> <span class="nf">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="n">isc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>

            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">sret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                                 <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">,</span>
                                 <span class="n">ret_xyz</span><span class="o">=</span><span class="n">ret_xyz</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="n">ret_rij</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># This is to &quot;fake&quot; the return</span>
                <span class="c1"># of a list (we will do indexing!)</span>
                <span class="n">sret</span> <span class="o">=</span> <span class="p">[</span><span class="n">sret</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># we have a list of arrays (len(R) &gt; 1)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We can add it to the list (len(R) == 1)</span>
                <span class="c1"># We add the atomic offset for the supercell index</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nR</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ret</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>

<div class="viewcode-block" id="Geometry.a2transpose"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.a2transpose">[docs]</a>    <span class="k">def</span> <span class="nf">a2transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms1</span><span class="p">,</span> <span class="n">atoms2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Transposes connections from `atoms1` to `atoms2` such that supercell connections are transposed</span>

<span class="sd">        When handling supercell indices it is useful to get the *transposed* connection. I.e. if you have</span>
<span class="sd">        a connection from site ``i`` (in unit cell indices) to site ``j`` (in supercell indices) it may be</span>
<span class="sd">        useful to get the equivalent supercell connection such for site ``j`` (in unit cell indices) to</span>
<span class="sd">        site ``i`` (in supercell indices) such that they correspond to the transposed coupling.</span>

<span class="sd">        Note that since this transposes couplings the indices returned are always expanded to the full</span>
<span class="sd">        length if either of the inputs are a single index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gr = geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; atoms = gr.close(0, 1.5)</span>
<span class="sd">        &gt;&gt;&gt; atoms</span>
<span class="sd">        array([0, 1, 5, 9], dtype=int32)</span>
<span class="sd">        &gt;&gt;&gt; gr.a2transpose(0, atoms)</span>
<span class="sd">        (array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms1 : array_like</span>
<span class="sd">            atomic indices must have same length as `atoms2` or length 1</span>
<span class="sd">        atoms2 : array_like, optional</span>
<span class="sd">            atomic indices must have same length as `atoms1` or length 1.</span>
<span class="sd">            If not present then only `atoms1` will be returned in transposed indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        atoms2 : array_like</span>
<span class="sd">            transposed indices for atoms2 (only returned if `atoms2` is not None)</span>
<span class="sd">        atoms1 : array_like</span>
<span class="sd">            transposed indices for atoms1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check whether they have the same size, if so then do not pre-process</span>
        <span class="n">atoms1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we only need to transpose atoms1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms1</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
            <span class="k">return</span> <span class="n">atoms1</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="n">atoms2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">atoms2</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">atoms1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># typical case where atoms1 is a single number</span>
            <span class="n">atoms1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">atoms1</span><span class="p">,</span> <span class="n">atoms2</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">atoms2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">atoms2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">atoms2</span><span class="p">,</span> <span class="n">atoms1</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.a2transpose only allows length 1 or same length arrays.&quot;</span><span class="p">)</span>

        <span class="c1"># Now convert atoms</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span>
        <span class="n">isc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms1</span><span class="p">)</span>
        <span class="n">isc2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms2</span><span class="p">)</span>

        <span class="n">atoms1</span> <span class="o">=</span> <span class="n">atoms1</span> <span class="o">%</span> <span class="n">na</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc2</span><span class="p">)</span> <span class="o">*</span> <span class="n">na</span>
        <span class="n">atoms2</span> <span class="o">=</span> <span class="n">atoms2</span> <span class="o">%</span> <span class="n">na</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc1</span><span class="p">)</span> <span class="o">*</span> <span class="n">na</span>
        <span class="k">return</span> <span class="n">atoms2</span><span class="p">,</span> <span class="n">atoms1</span></div>

<div class="viewcode-block" id="Geometry.o2transpose"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.o2transpose">[docs]</a>    <span class="k">def</span> <span class="nf">o2transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orb1</span><span class="p">,</span> <span class="n">orb2</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Transposes connections from `orb1` to `orb2` such that supercell connections are transposed</span>

<span class="sd">        When handling supercell indices it is useful to get the *transposed* connection. I.e. if you have</span>
<span class="sd">        a connection from site ``i`` (in unit cell indices) to site ``J`` (in supercell indices) it may be</span>
<span class="sd">        useful to get the equivalent supercell connection such for site ``j`` (in unit cell indices) to</span>
<span class="sd">        site ``I`` (in supercell indices) such that they correspond to the transposed coupling.</span>

<span class="sd">        Note that since this transposes couplings the indices returned are always expanded to the full</span>
<span class="sd">        length if either of the inputs are a single index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gr = geom.graphene() # one orbital per site</span>
<span class="sd">        &gt;&gt;&gt; atoms = gr.close(0, 1.5)</span>
<span class="sd">        &gt;&gt;&gt; atoms</span>
<span class="sd">        array([0, 1, 5, 9], dtype=int32)</span>
<span class="sd">        &gt;&gt;&gt; gr.o2transpose(0, atoms)</span>
<span class="sd">        (array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orb1 : array_like</span>
<span class="sd">            orbital indices must have same length as `orb2` or length 1</span>
<span class="sd">        orb2 : array_like, optional</span>
<span class="sd">            orbital indices must have same length as `orb1` or length 1.</span>
<span class="sd">            If not present then only `orb1` will be returned in transposed indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        orb2 : array_like</span>
<span class="sd">            transposed indices for orb2 (only returned if `orb2` is not None)</span>
<span class="sd">        orb1 : array_like</span>
<span class="sd">            transposed indices for orb1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check whether they have the same size, if so then do not pre-process</span>
        <span class="n">orb1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orb1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orb2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we only need to transpose orb1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orb1</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
            <span class="k">return</span> <span class="n">orb1</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="n">orb2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orb2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orb1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">orb2</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">orb1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># typical case where orb1 is a single number</span>
            <span class="n">orb1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">orb1</span><span class="p">,</span> <span class="n">orb2</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">orb2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">orb2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">orb2</span><span class="p">,</span> <span class="n">orb1</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.o2transpose only allows length 1 or same length arrays.&quot;</span><span class="p">)</span>

        <span class="c1"># Now convert orbs</span>
        <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_index</span>
        <span class="n">isc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orb1</span><span class="p">)</span>
        <span class="n">isc2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orb2</span><span class="p">)</span>

        <span class="n">orb1</span> <span class="o">=</span> <span class="n">orb1</span> <span class="o">%</span> <span class="n">no</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc2</span><span class="p">)</span> <span class="o">*</span> <span class="n">no</span>
        <span class="n">orb2</span> <span class="o">=</span> <span class="n">orb2</span> <span class="o">%</span> <span class="n">no</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc1</span><span class="p">)</span> <span class="o">*</span> <span class="n">no</span>
        <span class="k">return</span> <span class="n">orb2</span><span class="p">,</span> <span class="n">orb1</span></div>

<div class="viewcode-block" id="Geometry.a2o"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.a2o">[docs]</a>    <span class="k">def</span> <span class="nf">a2o</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an orbital index of the first orbital of said atom.</span>
<span class="sd">        This is particularly handy if you want to create</span>
<span class="sd">        TB models with more than one orbital per atom.</span>

<span class="sd">        Note that this will preserve the super-cell offsets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like</span>
<span class="sd">             Atomic indices</span>
<span class="sd">        all : bool, optional</span>
<span class="sd">             ``False``, return only the first orbital corresponding to the atom,</span>
<span class="sd">             ``True``, returns list of the full atom(s), will always return a 1D array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we must not alter `atoms` as it may come from outside</span>
        <span class="n">off</span><span class="p">,</span> <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">is_integral</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span>
        <span class="n">off</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">oe</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Create ranges</span>
        <span class="k">if</span> <span class="n">is_integral</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">oe</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">array_arange</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">oe</span><span class="p">)</span></div>

<div class="viewcode-block" id="Geometry.o2a"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.o2a">[docs]</a>    <span class="k">def</span> <span class="nf">o2a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Atomic index corresponding to the orbital indicies.</span>

<span class="sd">        Note that this will preserve the super-cell offsets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals : array_like</span>
<span class="sd">             List of orbital indices to return the atoms for</span>
<span class="sd">        unique : bool, optional</span>
<span class="sd">             If True only return the unique atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># must only be 1 number (an Integral)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">orbitals</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">orbitals</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

        <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">orbitals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()),</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">list_index_le</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">isc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">isc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span></div>

<div class="viewcode-block" id="Geometry.uc2sc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.uc2sc">[docs]</a>    <span class="k">def</span> <span class="nf">uc2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns atom from unit-cell indices to supercell indices, possibly removing dublicates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like or int</span>
<span class="sd">           the atomic unit-cell indices to be converted to supercell indices</span>
<span class="sd">        unique : bool, optional</span>
<span class="sd">           If True the returned indices are unique and sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span></div>
    <span class="n">auc2sc</span> <span class="o">=</span> <span class="n">uc2sc</span>

<div class="viewcode-block" id="Geometry.sc2uc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.sc2uc">[docs]</a>    <span class="k">def</span> <span class="nf">sc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns atoms from supercell indices to unit-cell indices, possibly removing dublicates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like or int</span>
<span class="sd">           the atomic supercell indices to be converted to unit-cell indices</span>
<span class="sd">        unique : bool, optional</span>
<span class="sd">           If True the returned indices are unique and sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span></div>
    <span class="n">asc2uc</span> <span class="o">=</span> <span class="n">sc2uc</span>

<div class="viewcode-block" id="Geometry.osc2uc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.osc2uc">[docs]</a>    <span class="k">def</span> <span class="nf">osc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Orbitals from supercell indices to unit-cell indices, possibly removing dublicates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals : array_like or int</span>
<span class="sd">           the orbital supercell indices to be converted to unit-cell indices</span>
<span class="sd">        unique : bool, optional</span>
<span class="sd">           If True the returned indices are unique and sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orbitals</span></div>

<div class="viewcode-block" id="Geometry.ouc2sc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.ouc2sc">[docs]</a>    <span class="k">def</span> <span class="nf">ouc2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Orbitals from unit-cell indices to supercell indices, possibly removing dublicates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals : array_like or int</span>
<span class="sd">           the orbital unit-cell indices to be converted to supercell indices</span>
<span class="sd">        unique : bool, optional</span>
<span class="sd">           If True the returned indices are unique and sorted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="p">(</span><span class="n">orbitals</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">orbitals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">+</span>
                    <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">ndim</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orbitals</span></div>

<div class="viewcode-block" id="Geometry.a2isc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.a2isc">[docs]</a>    <span class="k">def</span> <span class="nf">a2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Super-cell indices for a specific/list atom</span>

<span class="sd">        Returns a vector of 3 numbers with integers.</span>
<span class="sd">        Any multi-dimensional input will be flattened before return.</span>

<span class="sd">        The returned indices will thus always be a 2D matrix or a 1D vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span></div>

    <span class="c1"># This function is a bit weird, it returns a real array,</span>
    <span class="c1"># however, there should be no ambiguity as it corresponds to th</span>
    <span class="c1"># offset and &quot;what else&quot; is there to query?</span>
<div class="viewcode-block" id="Geometry.a2sc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.a2sc">[docs]</a>    <span class="k">def</span> <span class="nf">a2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell offset for a specific atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span></div>

<div class="viewcode-block" id="Geometry.o2isc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.o2isc">[docs]</a>    <span class="k">def</span> <span class="nf">o2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell index for a specific orbital.</span>

<span class="sd">        Returns a vector of 3 numbers with integers.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="Geometry.o2sc"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.o2sc">[docs]</a>    <span class="k">def</span> <span class="nf">o2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell offset for a specific orbital.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orbitals</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">__plot__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">supercell</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                 <span class="n">atom_indices</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Plot the geometry in a specified ``matplotlib.Axes`` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : array_like, optional</span>
<span class="sd">           only plot a subset of the axis, defaults to all axis</span>
<span class="sd">        supercell : bool, optional</span>
<span class="sd">           If `True` also plot the supercell structure</span>
<span class="sd">        atom_indices : bool, optional</span>
<span class="sd">           if true, also add atomic numbering in the plot (0-based)</span>
<span class="sd">        axes : bool or matplotlib.Axes, optional</span>
<span class="sd">           the figure axes to plot in (if ``matplotlib.Axes`` object).</span>
<span class="sd">           If `True` it will create a new figure to plot in.</span>
<span class="sd">           If `False` it will try and grap the current figure and the current axes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Default dictionary for passing to newly created figures</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

        <span class="n">colors</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">num</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">nspecie</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">colors</span> <span class="o">=</span> <span class="n">colors</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">specie</span><span class="p">]</span>
        <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s1">&#39;s&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">area</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">area</span><span class="p">[:]</span> <span class="o">*=</span> <span class="mi">20</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">/</span> <span class="n">area</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>

        <span class="c1"># Ensure we have a new 3D Axes3D</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s1">&#39;projection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;3d&#39;</span>

        <span class="c1"># The Geometry determines the axes, then we pass it to supercell.</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_axes</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="o">**</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># Start by plotting the supercell</span>
        <span class="k">if</span> <span class="n">supercell</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">__plot__</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">axes</span><span class="o">=</span><span class="n">axes</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Create short-hand</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>

        <span class="k">if</span> <span class="n">axes</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;Axes3D&#39;</span><span class="p">):</span>
            <span class="c1"># We should plot in 3D plots</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">s</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom_indices</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
                    <span class="n">axes</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">loc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">s</span><span class="o">=</span><span class="n">area</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">colors</span><span class="p">,</span> <span class="n">alpha</span><span class="o">=</span><span class="mf">0.8</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">atom_indices</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">loc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">xyz</span><span class="p">):</span>
                    <span class="n">axes</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">loc</span><span class="p">[</span><span class="n">axis</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">loc</span><span class="p">[</span><span class="n">axis</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">verticalalignment</span><span class="o">=</span><span class="s1">&#39;bottom&#39;</span><span class="p">)</span>

        <span class="n">axes</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">)</span>
        <span class="n">axes</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="s1">&#39;Ang&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">axes</span>

<div class="viewcode-block" id="Geometry.equal"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.equal">[docs]</a>    <span class="k">def</span> <span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Whether two geometries are the same (optional not check of the orbital radius)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Geometry</span>
<span class="sd">            the other Geometry to check against</span>
<span class="sd">        R : bool, optional</span>
<span class="sd">            if True also check if the orbital radii are the same (see `Atom.equal`)</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            tolerance for checking the atomic coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">same</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">sc</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">tol</span><span class="p">)</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">same</span></div>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.sparserij"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.sparserij">[docs]</a>    <span class="k">def</span> <span class="nf">sparserij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">na_iR</span><span class="o">=</span><span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;rand&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return the sparse matrix with all distances in the matrix</span>

<span class="sd">        The sparse matrix will only be defined for the elements which have</span>
<span class="sd">        orbitals overlapping with other atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, numpy.float64</span>
<span class="sd">           the data-type of the sparse matrix</span>
<span class="sd">        na_iR : int, 1000</span>
<span class="sd">           number of atoms within the sphere for speeding</span>
<span class="sd">           up the `iter_block` loop.</span>
<span class="sd">        method : str, optional</span>
<span class="sd">           see `iter_block` for details</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseAtom</span>
<span class="sd">           sparse matrix with all rij elements</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter_block : the method for looping the atoms</span>
<span class="sd">        distance : create a list of distances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">.sparse_geometry</span> <span class="kn">import</span> <span class="n">SparseAtom</span>
        <span class="n">rij</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get R</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">())</span>
        <span class="n">iR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iR</span><span class="p">(</span><span class="n">na_iR</span><span class="p">)</span>

        <span class="c1"># Do the loop</span>
        <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="n">iR</span><span class="o">=</span><span class="n">iR</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">):</span>

            <span class="c1"># Get all the indexed atoms...</span>
            <span class="c1"># This speeds up the searching for</span>
            <span class="c1"># coordinates...</span>
            <span class="n">atoms_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Loop the atoms inside</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="n">rij</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>
                <span class="n">rij</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rij</span></div>

<div class="viewcode-block" id="Geometry.distance"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.distance">[docs]</a>    <span class="k">def</span> <span class="nf">distance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;average&#39;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Calculate the distances for all atoms in shells of radius `tol` within `max_R`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : int or array_like, optional</span>
<span class="sd">           only create list of distances from the given atoms, default to all atoms</span>
<span class="sd">        R : float, optional</span>
<span class="sd">           the maximum radius to consider, default to ``self.maxR()``.</span>
<span class="sd">           To retrieve all distances for atoms within the supercell structure</span>
<span class="sd">           you can pass `numpy.inf`.</span>
<span class="sd">        tol : float or array_like, optional</span>
<span class="sd">           the tolerance for grouping a set of atoms.</span>
<span class="sd">           This parameter sets the shell radius for each shell.</span>
<span class="sd">           I.e. the returned distances between two shells will be maximally</span>
<span class="sd">           ``2*tol``, but only if atoms are within two consecutive lists.</span>
<span class="sd">           If this is a list, the shells will be of unequal size.</span>

<span class="sd">           The first shell size will be ``tol * .5`` or ``tol[0] * .5`` if `tol` is a list.</span>

<span class="sd">        method : {&#39;average&#39;, &#39;mode&#39;, &#39;&lt;numpy.func&gt;&#39;, func}</span>
<span class="sd">           How the distance in each shell is determined.</span>
<span class="sd">           A list of distances within each shell is gathered and the equivalent</span>
<span class="sd">           method will be used to extract a single quantity from the list of</span>
<span class="sd">           distances in the shell.</span>
<span class="sd">           If `&#39;mode&#39;` is chosen it will use `scipy.stats.mode`.</span>
<span class="sd">           If a string is given it will correspond to ``getattr(numpy, method)``,</span>
<span class="sd">           while any callable function may be passed. The passed function</span>
<span class="sd">           will only be passed a list of unsorted distances that needs to be</span>
<span class="sd">           processed.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([0]*3, Atom(1, R=1.), sc=SuperCell(1., nsc=[5, 5, 1]))</span>
<span class="sd">        &gt;&gt;&gt; geom.distance() # use geom.maxR() # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        array([1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(tol=[0.5, 0.4, 0.3, 0.2])</span>
<span class="sd">        array([1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(R=2, tol=[0.5, 0.4, 0.3, 0.2]) # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        array([1.        ,  1.41421356,  2.        ])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(R=2, tol=[0.5, 0.7]) # the R = 1 and R = 2 ** .5 gets averaged # doctest: +NORMALIZE_WHITESPACE</span>
<span class="sd">        array([1.20710678,  2.        ])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           an array of positive numbers yielding the distances from the atoms in reduced form</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sparserij : return a sparse matrix will all distances between atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out maximum distance</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                                 <span class="s2">&quot;.distance cannot determine the `R` parameter. &quot;</span>
                                 <span class="s2">&quot;The internal `maxR()` is negative and thus not set. &quot;</span>
                                 <span class="s2">&quot;Set an explicit value for `R`.&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
            <span class="n">maxR</span> <span class="o">=</span> <span class="n">fnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="c1"># These loops could be leveraged if we look at angles...</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span>
                                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span>
                                   <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">sc</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">ii</span> <span class="o">+</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">jj</span> <span class="o">+</span> \
                        <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">kk</span>
                    <span class="n">maxR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxR</span><span class="p">,</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">o</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">R</span> <span class="o">&gt;</span> <span class="n">maxR</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">maxR</span>

        <span class="c1"># Convert to list</span>
        <span class="n">tol</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Now we are in a position to determine the sizes</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">.5</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">.55</span><span class="p">,</span> <span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">tol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="c1"># The first tolerance, is for it-self, the second</span>
            <span class="c1"># has to have the first tolerance as the field</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">cumsumd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">tol</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">dR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">:</span>
                <span class="c1"># Now finalize dR by ensuring all remaining segments are captured</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">tol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">dR</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">dR</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">dR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">.55</span><span class="p">,</span> <span class="n">t</span><span class="p">)))</span>

            <span class="c1"># Reduce to the largest value above R</span>
            <span class="c1"># This ensures that R, truly is the largest considered element</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">dR</span><span class="p">[:(</span><span class="n">dR</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Now we can figure out the list of atoms in each shell</span>
        <span class="c1"># First create the initial lists of shell atoms</span>
        <span class="c1"># The inner shell will never be used, because it should correspond</span>
        <span class="c1"># to the atom it-self.</span>
        <span class="n">shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">dR</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rlist</span><span class="p">)</span>

        <span class="c1"># Now parse all of the shells with the correct routine</span>
        <span class="c1"># First we grap the routine:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;median&#39;</span><span class="p">:</span>
                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;mode&#39;</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">scipy.stats</span> <span class="kn">import</span> <span class="n">mode</span>
                <span class="k">def</span> <span class="nf">func</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">mode</span><span class="p">(</span><span class="n">lst</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.distance `method` got wrong input value.&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># Reduce lists</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">)):</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Reduce elements</span>
            <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

        <span class="c1"># Convert to flattened numpy array and ensure shape</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">shells</span><span class="p">)</span>
        <span class="n">d</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">return</span> <span class="n">d</span></div>

<div class="viewcode-block" id="Geometry.within_inf"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.within_inf">[docs]</a>    <span class="k">def</span> <span class="nf">within_inf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">tol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Find all atoms within a provided supercell</span>

<span class="sd">        Note this function is rather different from `close` and `within`.</span>
<span class="sd">        Specifically this routine is returning *all* indices for the infinite</span>
<span class="sd">        periodic system (where ``self.nsc &gt; 1`` or `periodic` is true).</span>

<span class="sd">        Atomic coordinates lying on the boundary of the supercell will be duplicated</span>
<span class="sd">        on the neighbouring supercell images. Thus performing `geom.within_inf(geom.sc)`</span>
<span class="sd">        may result in more atoms than in the structure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The name of this function may change. Currently it should only be used</span>
<span class="sd">        internally in sisl.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sc : SuperCell or SuperCellChild</span>
<span class="sd">            the supercell in which this geometry should be expanded into.</span>
<span class="sd">        periodic : list of bool</span>
<span class="sd">            explicitly define the periodic directions, by default the periodic</span>
<span class="sd">            directions are only where ``self.nsc &gt; 1``.</span>
<span class="sd">        tol : float, optional</span>
<span class="sd">            length tolerance for the fractional coordinates to be on a duplicate site (in Ang).</span>
<span class="sd">            This allows atoms within `tol` of the cell boundaries to be taken as *inside* the</span>
<span class="sd">            cell.</span>
<span class="sd">        origin : (3,) of float, optional</span>
<span class="sd">            origin that is the basis for comparison, default to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           unit-cell atomic indices which are inside the `sc` cell</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           atomic coordinates for the `ia` atoms (including supercell offsets)</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           integer supercell offsets for `ia` atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">periodic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">periodic</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Our first task is to construct a geometry large</span>
        <span class="c1"># enough to fully encompass the supercell</span>

        <span class="c1"># 1. Number of times each lattice vector must be expanded to fit</span>
        <span class="c1">#    inside the &quot;possibly&quot; larger `sc`.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">tile_max</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Intrinsic offset (when atomic coordinates are outside primary unit-cell)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tile_min</span> <span class="o">&lt;</span> <span class="n">tmp</span><span class="p">,</span> <span class="n">tile_min</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">tile_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tmp</span> <span class="o">&lt;</span> <span class="n">tile_max</span><span class="p">,</span> <span class="n">tile_max</span><span class="p">,</span> <span class="n">tmp</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tmp</span>

        <span class="c1"># 1a) correct for origin displacement</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tile_min</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tile_min</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">))</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">tile_min</span> <span class="o">&lt;</span> <span class="n">idx</span><span class="p">,</span> <span class="n">tile_min</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># 2. Reduce tiling along non-periodic directions</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">periodic</span><span class="p">,</span> <span class="n">tile_min</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="n">tile_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">periodic</span><span class="p">,</span> <span class="n">tile_max</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># 3. Find the *new* origin according to the *negative* tilings.</span>
        <span class="c1">#    This is important for skewed cells as the placement of the new</span>
        <span class="c1">#    larger geometry has to be shifted to have sc inside</span>
        <span class="n">big_origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_min</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># The xyz geometry that fully encompass the (possibly) larger supercell</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">tile_max</span> <span class="o">-</span> <span class="n">tile_min</span>
        <span class="n">full_geom</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span> <span class="o">*</span> <span class="n">tile</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">big_origin</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Now we have to figure out all atomic coordinates within</span>
        <span class="n">cuboid</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">toCuboid</span><span class="p">()</span>

        <span class="c1"># Make sure that full_geom doesn&#39;t return coordinates outside the unit cell</span>
        <span class="c1"># for non periodic directions</span>
        <span class="n">full_geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">([</span><span class="n">full_geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">if</span> <span class="n">periodic</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)])</span>

        <span class="c1"># Now retrieve all atomic coordinates from the full geometry</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">full_geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">full_geom</span><span class="o">.</span><span class="n">na_s</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">cuboid</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">full_geom</span>

        <span class="c1"># Figure out supercell connections in the smaller indices</span>
        <span class="c1"># Since we have shifted all coordinates into the primary unit cell we</span>
        <span class="c1"># are sure that these fxyz are [0:1[</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Since there are numerical errors for the above operation</span>
        <span class="c1"># we *have* to account for possible sign-errors</span>
        <span class="c1"># This is done by a length tolerance</span>
        <span class="n">ftol</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">fxyz</span> <span class="o">-</span> <span class="n">ftol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Now we can extract the indices where the two are non-matching.</span>
        <span class="c1"># At these indices we have some &quot;errors&quot; that we have to fix and</span>
        <span class="c1"># thus select the correct isc.</span>
        <span class="n">idx_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">isc</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">fxyz</span> <span class="o">+</span> <span class="n">ftol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="c1"># For these indices we can use the nearest integer as that</span>
        <span class="c1"># selects the closest. floor will ONLY be wrong for -0.0000, 0.99999, ...</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">idx_diff</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[</span><span class="n">idx_diff</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Convert indices to unit-cell indices and also return coordinates and</span>
        <span class="c1"># infinite supercell indices</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc2uc</span><span class="p">(</span><span class="n">idx</span><span class="p">),</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">isc</span></div>

<div class="viewcode-block" id="Geometry.apply"><a class="viewcode-back" href="../../api/generated/sisl.Geometry.html#sisl.Geometry.apply">[docs]</a>    <span class="k">def</span> <span class="nf">apply</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">mapper</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">segments</span><span class="o">=</span><span class="s2">&quot;atoms&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Apply a function `func` to the data along axis `axis` using the method specified</span>

<span class="sd">        This can be useful for applying conversions from orbital data to atomic data through</span>
<span class="sd">        sums or other functions.</span>

<span class="sd">        The data may be of any shape but it is expected the function can handle arguments as</span>
<span class="sd">        ``func(data, axis=axis)``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        data : array_like</span>
<span class="sd">            the data to be converted</span>
<span class="sd">        func :</span>
<span class="sd">            a callable function that transforms the data in some way</span>
<span class="sd">        mapper : func, optional</span>
<span class="sd">            a function transforming the `segments` into some other segments that</span>
<span class="sd">            is present in `data`.</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            axis selector for `data` along which `func` will be applied</span>
<span class="sd">        segments : {&quot;atoms&quot;, &quot;orbitals&quot;, &quot;all&quot;} or iterator, optional</span>
<span class="sd">            which segments the `mapper` will recieve, if atoms, each atom</span>
<span class="sd">            index will be passed to the `mapper(ia)`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>

<span class="sd">        This will likely be moved to a separate function since it in principle has nothing to</span>
<span class="sd">        do with the Geometry class.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Convert orbital data into summed atomic data</span>

<span class="sd">        &gt;&gt;&gt; g = sisl.geom.diamond(atoms=sisl.Atom(6, R=(1, 2)))</span>
<span class="sd">        &gt;&gt;&gt; orbital_data = np.random.rand(10, g.no, 3)</span>
<span class="sd">        &gt;&gt;&gt; atomic_data = g.apply(orbital_data, np.sum, mapper=g.a2o, axis=1)</span>

<span class="sd">        The same can be accomblished by passing an explicit segment iterator,</span>
<span class="sd">        note that ``iter(g) == range(g.na)``</span>

<span class="sd">        &gt;&gt;&gt; atomic_data = g.apply(orbital_data, np.sum, mapper=g.a2o, axis=1,</span>
<span class="sd">        ...                       segments=iter(g))</span>

<span class="sd">        To only take out every 2nd orbital:</span>

<span class="sd">        &gt;&gt;&gt; alternate_data = g.apply(orbital_data, np.sum, mapper=lambda idx: idx[::2], axis=1,</span>
<span class="sd">        ...                          segments=&quot;all&quot;)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">segments</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">segments</span> <span class="o">==</span> <span class="s2">&quot;atoms&quot;</span><span class="p">:</span>
                <span class="n">segments</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">segments</span> <span class="o">==</span> <span class="s2">&quot;orbitals&quot;</span><span class="p">:</span>
                <span class="n">segments</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">segments</span> <span class="o">==</span> <span class="s2">&quot;all&quot;</span><span class="p">:</span>
                <span class="n">segments</span> <span class="o">=</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="si">}</span><span class="s2">.apply got wrong argument &#39;segments&#39;=</span><span class="si">{</span><span class="n">segments</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># handle the data</span>
        <span class="n">new_data</span> <span class="o">=</span> <span class="p">[</span>
            <span class="c1"># execute func on the segmented data</span>
            <span class="n">func</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">take</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">mapper</span><span class="p">(</span><span class="n">segment</span><span class="p">),</span> <span class="n">axis</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="c1"># loop each segment</span>
            <span class="k">for</span> <span class="n">segment</span> <span class="ow">in</span> <span class="n">segments</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">new_data</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span></div>

    <span class="c1"># Create pickling routines</span>
    <span class="k">def</span> <span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the state of this object &quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">d</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span> <span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Re-create the state of this object &quot;&quot;&quot;</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">()</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;atoms&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s1">&#39;xyz&#39;</span><span class="p">],</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_ArgumentParser_args_single</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Returns the options for `Geometry.ArgumentParser` in case they are the only options &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s1">&#39;limit_arguments&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
                <span class="s1">&#39;short&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
                <span class="s1">&#39;positional_out&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="p">}</span>

    <span class="c1"># Hook into the Geometry class to create</span>
    <span class="c1"># an automatic ArgumentParser which makes actions</span>
    <span class="c1"># as the options are read.</span>
    <span class="nd">@default_ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Manipulate a Geometry object in sisl.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ArgumentParser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Create and return a group of argument parsers which manipulates it self `Geometry`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parser : ArgumentParser, optional</span>
<span class="sd">           in case the arguments should be added to a specific parser. It defaults</span>
<span class="sd">           to create a new.</span>
<span class="sd">        limit_arguments : bool, optional</span>
<span class="sd">           If ``False`` additional options will be created which are similar to other options.</span>
<span class="sd">           For instance ``--repeat-x &lt;&gt;`` which is equivalent to ``--repeat &lt;&gt; x``.</span>
<span class="sd">           Default `True`.</span>
<span class="sd">        short : bool, optional</span>
<span class="sd">           Create short options for a selected range of options.</span>
<span class="sd">        positional_out : bool, optional</span>
<span class="sd">           If ``True``, adds a positional argument which acts as --out. This may be handy if only the geometry is in the argument list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limit_args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;limit_arguments&#39;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">short</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;short&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">short</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">opts</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">args</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">opts</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;--&quot;</span><span class="p">)]</span>

        <span class="c1"># We limit the import to occur here</span>
        <span class="kn">import</span> <span class="nn">argparse</span>

        <span class="c1"># The first thing we do is adding the geometry to the NameSpace of the</span>
        <span class="c1"># parser.</span>
        <span class="c1"># This will enable custom actions to interact with the geometry in a</span>
        <span class="c1"># straight forward manner.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="n">default_namespace</span><span class="p">(</span>
            <span class="n">_geometry</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
            <span class="n">_stored_geometry</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create actions</span>
        <span class="k">class</span> <span class="nc">Format</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geom_fmt</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--format&#39;</span><span class="p">),</span> <span class="n">action</span><span class="o">=</span><span class="n">Format</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;.8f&#39;</span><span class="p">,</span>
                   <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Specify output format for coordinates.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">MoveOrigin</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">no_value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--origin&#39;</span><span class="p">,</span> <span class="s1">&#39;-O&#39;</span><span class="p">),</span> <span class="n">action</span><span class="o">=</span><span class="n">MoveOrigin</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                   <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Move all atoms such that the smallest value along each Cartesian direction will be at the origin.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">MoveCenterOf</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="s1">&#39;xyz&#39;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--center-of&#39;</span><span class="p">,</span> <span class="s1">&#39;-co&#39;</span><span class="p">),</span>
                       <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;mass:pbc&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;mm:xyz&quot;</span><span class="p">],</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">MoveCenterOf</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Move coordinates to the center of the designated choice.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">MoveUnitCell</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;translate&#39;</span><span class="p">,</span> <span class="s1">&#39;tr&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">]:</span>
                    <span class="c1"># Simple translation</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">tmp</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;mod&#39;</span><span class="p">]:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span>
                    <span class="c1"># Change all coordinates using the reciprocal cell and move to unit-cell (% 1.)</span>
                    <span class="n">fxyz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">fxyz</span> <span class="o">%</span> <span class="mf">1.</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">fxyz</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--unit-cell&#39;</span><span class="p">,</span> <span class="s1">&#39;-uc&#39;</span><span class="p">),</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;translate&#39;</span><span class="p">,</span> <span class="s1">&#39;tr&#39;</span><span class="p">,</span> <span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;mod&#39;</span><span class="p">],</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">MoveUnitCell</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Moves the coordinates into the unit-cell by translation or the mod-operator&#39;</span><span class="p">)</span>

        <span class="c1"># Rotation</span>
        <span class="k">class</span> <span class="nc">Rotation</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Convert value[0] to the direction</span>
                <span class="c1"># The rotate function expects degree</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate&#39;</span><span class="p">,</span> <span class="s1">&#39;-R&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">Rotation</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around given axis. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">RotationX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate-x&#39;</span><span class="p">,</span> <span class="s1">&#39;-Rx&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">RotationX</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around first cell vector. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">RotationY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate-y&#39;</span><span class="p">,</span> <span class="s1">&#39;-Ry&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">RotationY</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around second cell vector. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">RotationZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">ang</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--rotate-z&#39;</span><span class="p">,</span> <span class="s1">&#39;-Rz&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;ANGLE&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">RotationZ</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate geometry around third cell vector. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">)</span>

        <span class="c1"># Reduce size of geometry</span>
        <span class="k">class</span> <span class="nc">ReduceSub</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Get atomic indices</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--sub&#39;</span><span class="p">,</span> <span class="s1">&#39;-s&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;RNG&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">ReduceSub</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Removes specified atoms, can be complex ranges.&#39;</span><span class="p">)</span>

        <span class="c1"># Swaps atoms</span>
        <span class="k">class</span> <span class="nc">AtomSwap</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Get atomic indices</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;swapping atoms requires equal number of LHS and RHS atomic ranges&#39;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--swap&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;A&#39;</span><span class="p">,</span> <span class="s1">&#39;B&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">AtomSwap</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Swaps groups of atoms (can be complex ranges). The groups must be of equal length.&#39;</span><span class="p">)</span>

        <span class="c1"># Add an atom</span>
        <span class="k">class</span> <span class="nc">AtomAdd</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create an atom from the input</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)],</span> <span class="n">atoms</span><span class="o">=</span><span class="n">Atom</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--add&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;COORD&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">AtomAdd</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Adds an atom, coordinate is comma separated (in Ang). Z is the atomic number.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">Translate</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create an atom from the input</span>
                <span class="k">if</span> <span class="s1">&#39;,&#39;</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--translate&#39;</span><span class="p">,</span> <span class="s1">&#39;-t&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;COORD&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">Translate</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Translates the coordinates via a comma separated list (in Ang).&#39;</span><span class="p">)</span>

        <span class="c1"># Periodicly increase the structure</span>
        <span class="k">class</span> <span class="nc">PeriodRepeat</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat&#39;</span><span class="p">,</span> <span class="s1">&#39;-r&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeat</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry in the specified direction.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">PeriodRepeatX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat-x&#39;</span><span class="p">,</span> <span class="s1">&#39;-rx&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatX</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry along the first cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodRepeatY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat-y&#39;</span><span class="p">,</span> <span class="s1">&#39;-ry&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatY</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry along the second cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodRepeatZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--repeat-z&#39;</span><span class="p">,</span> <span class="s1">&#39;-rz&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatZ</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Repeats the geometry along the third cell vector.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">ReduceUnrepeat</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">unrepeat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--unrepeat&#39;</span><span class="p">,</span> <span class="s1">&#39;-ur&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;REPS&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">ReduceUnrepeat</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Unrepeats the geometry into `reps` parts along the unit-cell direction `dir` (opposite of --repeat).&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">PeriodTile</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">PeriodTile</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry in the specified direction.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>
            <span class="k">class</span> <span class="nc">PeriodTileX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile-x&#39;</span><span class="p">,</span> <span class="s1">&#39;-tx&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileX</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry along the first cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodTileY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile-y&#39;</span><span class="p">,</span> <span class="s1">&#39;-ty&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileY</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry along the second cell vector.&#39;</span><span class="p">)</span>

            <span class="k">class</span> <span class="nc">PeriodTileZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--tile-z&#39;</span><span class="p">,</span> <span class="s1">&#39;-tz&#39;</span><span class="p">),</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;TIMES&#39;</span><span class="p">,</span>
                           <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileZ</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Tiles the geometry along the third cell vector.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">ReduceUntile</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--untile&#39;</span><span class="p">,</span> <span class="s1">&#39;--cut&#39;</span><span class="p">,</span> <span class="s1">&#39;-ut&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s1">&#39;REPS&#39;</span><span class="p">,</span> <span class="s1">&#39;DIR&#39;</span><span class="p">),</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">ReduceUntile</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Untiles the geometry into `reps` parts along the unit-cell direction `dir` (opposite of --tile).&#39;</span><span class="p">)</span>

        <span class="c1"># Sort</span>
        <span class="k">class</span> <span class="nc">Sort</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># call geometry.sort(...) using appropriate keywords (and ordered dict)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">opts</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;;&#39;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">opt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">opts</span><span class="p">):</span>
                    <span class="c1"># Split for equal</span>
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;=&#39;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">opt</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">opt</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">opt</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span>
                    <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;t&#39;</span><span class="p">,</span> <span class="s1">&#39;true&#39;</span><span class="p">]:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;f&#39;</span><span class="p">,</span> <span class="s1">&#39;false&#39;</span><span class="p">]:</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">elif</span> <span class="n">opt</span> <span class="ow">in</span> <span class="p">[</span><span class="s1">&#39;atol&#39;</span><span class="p">]:</span>
                        <span class="c1"># float values</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s1">&#39;group&#39;</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># it must be a range/tuple</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

                    <span class="c1"># we always add integers to allow users to use the same keywords on commandline</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">opt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--sort&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">metavar</span><span class="o">=</span><span class="s1">&#39;SORT&#39;</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">Sort</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Semi-colon separated options for sort, please always encapsulate in quotation [&quot;axis=0;descend;lattice=(1, 2);group=Z&quot;].&#39;</span><span class="p">)</span>

        <span class="c1"># Print some common information about the</span>
        <span class="c1"># geometry (to stdout)</span>
        <span class="k">class</span> <span class="nc">PrintInfo</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>

            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">no_value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># We fake that it has been stored...</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_geometry</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--info&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
                       <span class="n">action</span><span class="o">=</span><span class="n">PrintInfo</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Print, to stdout, some regular information about the geometry.&#39;</span><span class="p">)</span>

        <span class="k">class</span> <span class="nc">Out</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="c1"># If the vector, exists, we should write it</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_geom_fmt&#39;</span><span class="p">):</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;fmt&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geom_fmt</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_vector&#39;</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_vector&#39;</span><span class="p">)</span>
                    <span class="n">vs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_vector_scale&#39;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">vs</span><span class="p">:</span>
                            <span class="n">vs</span> <span class="o">=</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
                            <span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Scaling vector by: </span><span class="si">{</span><span class="n">vs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">vs</span> <span class="o">=</span> <span class="mf">1.</span>

                    <span class="c1"># Store the vectors with the scaling</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">vs</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># Issue to the namespace that the geometry has been written, at least once.</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_geometry</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s1">&#39;--out&#39;</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">),</span> <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
                       <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the geometry (at its current invocation) to the out file.&#39;</span><span class="p">)</span>

        <span class="c1"># If the user requests positional out arguments, we also add that.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;positional_out&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;out&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
                           <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Store the geometry (at its current invocation) to the out file.&#39;</span><span class="p">)</span>

        <span class="c1"># We have now created all arguments</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">namespace</span>


<span class="n">new_dispatch</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">new</span>
<span class="n">to_dispatch</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">to</span>


<span class="c1"># Define base-class for this</span>
<span class="k">class</span> <span class="nc">GeometryNewDispatcher</span><span class="p">(</span><span class="n">AbstractDispatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Base dispatcher from class passing arguments to Geometry class</span>

<span class="sd">    This forwards all `__call__` calls to `dispatch`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># Bypass regular Geometry to be returned as is</span>
<span class="k">class</span> <span class="nc">GeometryNewGeometryDispatcher</span><span class="p">(</span><span class="n">GeometryNewDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geom</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Return geometry as-is (no copy), for sanitization purposes &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">geom</span>
<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Geometry</span><span class="p">,</span> <span class="n">GeometryNewGeometryDispatcher</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeometryNewAseDispatcher</span><span class="p">(</span><span class="n">GeometryNewDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aseg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert an ``ase`` object into a `Geometry` &quot;&quot;&quot;</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">pbc</span> <span class="ow">in</span> <span class="n">aseg</span><span class="o">.</span><span class="n">pbc</span><span class="p">]</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="n">GeometryNewAseDispatcher</span><span class="p">)</span>

<span class="c1"># currently we can&#39;t ensure the ase Atoms type</span>
<span class="c1"># to get it by type(). That requires ase to be importable.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">ase</span> <span class="kn">import</span> <span class="n">Atoms</span> <span class="k">as</span> <span class="n">ase_Atoms</span>
    <span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ase_Atoms</span><span class="p">,</span> <span class="n">GeometryNewAseDispatcher</span><span class="p">)</span>
    <span class="c1"># ensure we don&#39;t pollute name-space</span>
    <span class="k">del</span> <span class="n">ase_Atoms</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">GeometryNewpymatgenDispatcher</span><span class="p">(</span><span class="n">GeometryNewDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Convert a ``pymatgen`` structure/molecule object into a `Geometry` &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pymatgen.core</span> <span class="kn">import</span> <span class="n">Structure</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">struct</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="n">Z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">species</span><span class="p">)</span>
            <span class="n">xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">Structure</span><span class="p">):</span>
            <span class="c1"># we also have the lattice</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
            <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span> <span class="c1"># really, this is unknown</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">15.</span>
            <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;pymatgen&quot;</span><span class="p">,</span> <span class="n">GeometryNewpymatgenDispatcher</span><span class="p">)</span>

<span class="c1"># currently we can&#39;t ensure the pymatgen classes</span>
<span class="c1"># to get it by type(). That requires pymatgen to be importable.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">pymatgen.core</span> <span class="kn">import</span> <span class="n">Molecule</span> <span class="k">as</span> <span class="n">pymatgen_Molecule</span>
    <span class="kn">from</span> <span class="nn">pymatgen.core</span> <span class="kn">import</span> <span class="n">Structure</span> <span class="k">as</span> <span class="n">pymatgen_Structure</span>
    <span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">pymatgen_Molecule</span><span class="p">,</span> <span class="n">GeometryNewpymatgenDispatcher</span><span class="p">)</span>
    <span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">pymatgen_Structure</span><span class="p">,</span> <span class="n">GeometryNewpymatgenDispatcher</span><span class="p">)</span>
    <span class="c1"># ensure we don&#39;t pollute name-space</span>
    <span class="k">del</span> <span class="n">pymatgen_Molecule</span><span class="p">,</span> <span class="n">pymatgen_Structure</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span> <span class="nc">GeometryNewFileDispatcher</span><span class="p">(</span><span class="n">GeometryNewDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot; Defer the `Geometry.read` method by passing down arguments &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">GeometryNewFileDispatcher</span><span class="p">)</span>
<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">GeometryNewFileDispatcher</span><span class="p">)</span>
<span class="c1"># see sisl/__init__.py for new_dispatch.register(BaseSile, GeometryNewFileDispatcher)</span>


<span class="k">class</span> <span class="nc">GeometryToDispatcher</span><span class="p">(</span><span class="n">AbstractDispatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Base dispatcher from class passing from Geometry class &quot;&quot;&quot;</span>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_ensure_object</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="nb">type</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Dispatcher on </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2"> must not be called on the class.&quot;</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeometryToAseDispatcher</span><span class="p">(</span><span class="n">GeometryToDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">ase</span> <span class="kn">import</span> <span class="n">Atoms</span> <span class="k">as</span> <span class="n">ase_Atoms</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_object</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ase_Atoms</span><span class="p">(</span><span class="n">symbols</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="n">positions</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
                         <span class="n">cell</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span> <span class="n">pbc</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="n">GeometryToAseDispatcher</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeometryTopymatgenDispatcher</span><span class="p">(</span><span class="n">GeometryToDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">from</span> <span class="nn">pymatgen.core</span> <span class="kn">import</span> <span class="n">Lattice</span><span class="p">,</span> <span class="n">Structure</span><span class="p">,</span> <span class="n">Molecule</span>
        <span class="kn">from</span> <span class="nn">sisl.atom</span> <span class="kn">import</span> <span class="n">PeriodicTable</span>

        <span class="c1"># ensure we have an object</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_object</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>

        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="c1"># get atomic letters and coordinates</span>
        <span class="n">PT</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">PT</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">Z</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">Z</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">):</span>
            <span class="c1"># we define a molecule</span>
            <span class="k">return</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Structure</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;pymatgen&quot;</span><span class="p">,</span> <span class="n">GeometryTopymatgenDispatcher</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeometryToSileDispatcher</span><span class="p">(</span><span class="n">GeometryToDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_object</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="n">GeometryToSileDispatcher</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;path&quot;</span><span class="p">,</span> <span class="n">GeometryToSileDispatcher</span><span class="p">)</span>
<span class="c1"># to do geom.to[Path](path)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">GeometryToSileDispatcher</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">GeometryToSileDispatcher</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GeometryToDataframeDispatcher</span><span class="p">(</span><span class="n">GeometryToDispatcher</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_obj</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ensure_object</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>

        <span class="c1"># Now create data-frame</span>
        <span class="c1"># Currently we will populate it with</span>
        <span class="c1"># - xyz</span>
        <span class="c1"># - symbol</span>
        <span class="c1"># - Z</span>
        <span class="c1"># - tag</span>
        <span class="c1"># - R</span>
        <span class="c1"># - mass</span>
        <span class="c1"># - valence q</span>
        <span class="c1"># - norbs</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">T</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">Z</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">mass</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">maxR</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">q0</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;norbitals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;dataframe&quot;</span><span class="p">,</span> <span class="n">GeometryToDataframeDispatcher</span><span class="p">)</span>

<span class="c1"># Remove references</span>
<span class="k">del</span> <span class="n">new_dispatch</span><span class="p">,</span> <span class="n">to_dispatch</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sgeom</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">argv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ret_geometry</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot; Main script for sgeom.</span>

<span class="sd">    This routine may be called with `argv` and/or a `Sile` which is the geometry at hand.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    geom : Geometry or BaseSile</span>
<span class="sd">       this may either be the geometry, as-is, or a `Sile` which contains</span>
<span class="sd">       the geometry.</span>
<span class="sd">    argv : list of str</span>
<span class="sd">       the arguments passed to sgeom</span>
<span class="sd">    ret_geometry : bool, optional</span>
<span class="sd">       whether the function should return the geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

    <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="kn">import</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">BaseSile</span>

    <span class="c1"># The geometry-file *MUST* be the first argument</span>
    <span class="c1"># (except --help|-h)</span>
    <span class="n">exe</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># We cannot create a separate ArgumentParser to retrieve a positional arguments</span>
    <span class="c1"># as that will grab the first argument for an option!</span>

    <span class="c1"># Start creating the command-line utilities that are the actual ones.</span>
    <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This manipulation utility is highly advanced and one should note that the ORDER of</span>
<span class="s2">options is determining the final structure. For instance:</span>

<span class="s2">   </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2"> geom.xyz --repeat 2 x --repeat 2 y</span>

<span class="s2">is NOT equivalent to:</span>

<span class="s2">   </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2"> geom.xyz --repeat 2 y --repeat 2 x</span>

<span class="s2">This may be unexpected but enables one to do advanced manipulations.</span>

<span class="s2">Additionally, in between arguments, one may store the current state of the geometry</span>
<span class="s2">by writing to a standard file.</span>

<span class="s2">   </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2"> geom.xyz --repeat 2 y geom_repy.xyz --repeat 2 x geom_repy_repx.xyz</span>

<span class="s2">will create two files:</span>
<span class="s2">   geom_repy.xyz</span>
<span class="s2">will only be repeated 2 times along the second lattice vector, while:</span>
<span class="s2">   geom_repy_repx.xyz</span>
<span class="s2">will be repeated 2 times along the second lattice vector, and then the first</span>
<span class="s2">lattice vector.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">argv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--help&#39;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># no arguments</span>
        <span class="c1"># fake a help</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;--help&#39;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Ensure that the arguments have pre-pended spaces</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">argv_negative_fix</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">exe</span><span class="p">,</span>
                                <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span><span class="p">,</span>
                                <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">)</span>

    <span class="c1"># Add default sisl version stuff</span>
    <span class="n">cmd</span><span class="o">.</span><span class="n">add_sisl_version_cite_arg</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># First read the input &quot;Sile&quot;</span>
    <span class="n">stdout_geom</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">isfile</span>
        <span class="n">argv</span><span class="p">,</span> <span class="n">input_file</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_input</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stdout_geom</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract specification of the input file</span>
            <span class="n">i_file</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">str_spec</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">i_file</span><span class="p">):</span>
                <span class="n">geometry</span> <span class="o">=</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="kn">from</span> <span class="nn">.messages</span> <span class="kn">import</span> <span class="n">info</span>
                <span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot find file &#39;</span><span class="si">{</span><span class="n">input_file</span><span class="si">}</span><span class="s2">&#39;!&quot;</span><span class="p">)</span>
                <span class="n">geometry</span> <span class="o">=</span> <span class="n">Geometry</span>
                <span class="n">stdout_geom</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
        <span class="c1"># Do nothing, the geometry is already created</span>
        <span class="k">pass</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="c1"># Store the input file...</span>
        <span class="n">input_file</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">file</span>

    <span class="c1"># Do the argument parser</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ArgumentParser_args_single</span><span class="p">())</span>

    <span class="c1"># Now the arguments should have been populated</span>
    <span class="c1"># and we will sort out if the input options</span>
    <span class="c1"># is only a help option.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_input_file&#39;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s1">&#39;_input_file&#39;</span><span class="p">,</span> <span class="n">input_file</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Now try and figure out the actual arguments</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_arguments</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                                        <span class="n">argumentparser</span><span class="o">=</span><span class="n">p</span><span class="p">,</span>
                                        <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span><span class="p">)</span>

    <span class="c1"># We are good to go!!!</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">_geometry</span>

    <span class="k">if</span> <span class="n">stdout_geom</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">_stored_geometry</span><span class="p">:</span>
        <span class="c1"># We should write out the information to the stdout</span>
        <span class="c1"># This is merely for testing purposes and may not be used for anything.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Cell:&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{:10.6f}</span><span class="s1"> </span><span class="si">{:10.6f}</span><span class="s1"> </span><span class="si">{:10.6f}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;SuperCell:&#39;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;  </span><span class="si">{:d}</span><span class="s1"> </span><span class="si">{:d}</span><span class="s1"> </span><span class="si">{:d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">nsc</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; </span><span class="si">{:&gt;10s}</span><span class="s1"> </span><span class="si">{:&gt;10s}</span><span class="s1"> </span><span class="si">{:&gt;10s}</span><span class="s1">  </span><span class="si">{:&gt;3s}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">,</span> <span class="s1">&#39;Z&#39;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39; </span><span class="si">{1:10.6f}</span><span class="s1"> </span><span class="si">{2:10.6f}</span><span class="s1"> </span><span class="si">{3:10.6f}</span><span class="s1">  </span><span class="si">{0:3d}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
                                                                  <span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]))</span>

    <span class="k">if</span> <span class="n">ret_geometry</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2023, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>