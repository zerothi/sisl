<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl._core.grid &mdash; sisl 0.1-b0feb0c</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=19f00094" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=61a4c737" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=87e54e7c" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="../../../_static/jquery.js?v=5d32c60e"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script src="../../../_static/documentation_options.js?v=81cd38e2"></script>
        <script src="../../../_static/doctools.js?v=9a2dae69"></script>
        <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
        <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
        <script src="../../../_static/copybutton.js?v=f281be69"></script>
        <script src="../../../_static/tabs.js?v=3ee01567"></script>
        <script>let toggleHintShow = 'Click to show';</script>
        <script>let toggleHintHide = 'Click to hide';</script>
        <script>let toggleOpenOnPrint = 'true';</script>
        <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
        <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
              <div class="version">
                0.1-b0feb0c
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/viz_module/index.html"><code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code></a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/ase/index.html">ASE</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development details</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../changelog/index.html">Release notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Similar solutions</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">References</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl._core.grid</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl._core.grid</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span> <span class="nn">__future__</span> <span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">from</span> <span class="nn">math</span> <span class="kn">import</span> <span class="n">pi</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Real</span>
<span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">add</span><span class="p">,</span> <span class="n">asarray</span><span class="p">,</span> <span class="n">cos</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">floor</span><span class="p">,</span> <span class="n">int32</span><span class="p">,</span> <span class="n">ogrid</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">take</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">zoom</span> <span class="k">as</span> <span class="n">ndimage_zoom</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">SparseEfficiencyWarning</span>
<span class="kn">from</span> <span class="nn">scipy.sparse</span> <span class="kn">import</span> <span class="n">diags</span> <span class="k">as</span> <span class="n">sp_diags</span>

<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>
<span class="kn">from</span> <span class="nn">sisl._dispatch_class</span> <span class="kn">import</span> <span class="n">_Dispatchs</span>
<span class="kn">from</span> <span class="nn">sisl._dispatcher</span> <span class="kn">import</span> <span class="n">AbstractDispatch</span><span class="p">,</span> <span class="n">ClassDispatcher</span><span class="p">,</span> <span class="n">TypeDispatcher</span>
<span class="kn">from</span> <span class="nn">sisl._help</span> <span class="kn">import</span> <span class="n">dtype_complex_to_real</span><span class="p">,</span> <span class="n">wrap_filterwarnings</span>
<span class="kn">from</span> <span class="nn">sisl._internal</span> <span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span> <span class="nn">sisl.messages</span> <span class="kn">import</span> <span class="n">deprecate_argument</span><span class="p">,</span> <span class="n">deprecation</span>
<span class="kn">from</span> <span class="nn">sisl.shape</span> <span class="kn">import</span> <span class="n">Shape</span>
<span class="kn">from</span> <span class="nn">sisl.utils</span> <span class="kn">import</span> <span class="p">(</span>
    <span class="n">cmd</span><span class="p">,</span>
    <span class="n">default_ArgumentParser</span><span class="p">,</span>
    <span class="n">default_namespace</span><span class="p">,</span>
    <span class="n">direction</span><span class="p">,</span>
    <span class="n">import_attr</span><span class="p">,</span>
    <span class="n">str_spec</span><span class="p">,</span>
    <span class="n">strseq</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span> <span class="nn">sisl.utils.mathematics</span> <span class="kn">import</span> <span class="n">fnorm</span>

<span class="kn">from</span> <span class="nn">.geometry</span> <span class="kn">import</span> <span class="n">Geometry</span>
<span class="kn">from</span> <span class="nn">.lattice</span> <span class="kn">import</span> <span class="n">BoundaryCondition</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">,</span> <span class="n">LatticeChild</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Grid&quot;</span><span class="p">,</span> <span class="s2">&quot;sgrid&quot;</span><span class="p">]</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Grid</span><span class="p">(</span>
    <span class="n">LatticeChild</span><span class="p">,</span>
    <span class="n">_Dispatchs</span><span class="p">,</span>
    <span class="n">dispatchs</span><span class="o">=</span><span class="p">[</span>
        <span class="n">ClassDispatcher</span><span class="p">(</span><span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="n">obj_getattr</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">instance_dispatcher</span><span class="o">=</span><span class="n">TypeDispatcher</span><span class="p">),</span>
        <span class="n">ClassDispatcher</span><span class="p">(</span><span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="n">obj_getattr</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">type_dispatcher</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="n">when_subclassing</span><span class="o">=</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Real-space grid information with associated geometry.</span>

<span class="sd">    This grid object handles cell vectors and divisions of said grid.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    shape : float or (3,) of int</span>
<span class="sd">        the shape of the grid. A ``float`` specifies the grid spacing in Angstrom, while</span>
<span class="sd">        a list of integers specifies the exact grid size.</span>
<span class="sd">    bc : list of int (3, 2) or (3, ), optional</span>
<span class="sd">        the boundary conditions for each of the cell&#39;s planes. Default to periodic BC.</span>
<span class="sd">    lattice :</span>
<span class="sd">        the lattice that this grid represents. `lattice` has precedence if both `geometry` and `lattice`</span>
<span class="sd">        has been specified. Defaults to ``[1, 1, 1]``.</span>
<span class="sd">    dtype : numpy.dtype, optional</span>
<span class="sd">        the data-type of the grid, default to `numpy.float64`.</span>
<span class="sd">    geometry :</span>
<span class="sd">        associated geometry with the grid. If `lattice` has not been passed the lattice will</span>
<span class="sd">        be taken from this geometry.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; grid1 = Grid(0.1, lattice=10)</span>
<span class="sd">    &gt;&gt;&gt; grid2 = Grid(0.1, lattice=Lattice(10))</span>
<span class="sd">    &gt;&gt;&gt; grid3 = Grid(0.1, lattice=Lattice([10] * 3))</span>
<span class="sd">    &gt;&gt;&gt; grid1 == grid2</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; grid1 == grid3</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; grid = Grid(0.1, lattice=10, dtype=np.complex128)</span>
<span class="sd">    &gt;&gt;&gt; grid == grid1</span>
<span class="sd">    False</span>

<span class="sd">    It is possible to provide a geometry *and* a different lattice to make a smaller (or bigger) lattice</span>
<span class="sd">    based on a geometry. This might be useful when creating wavefunctions or expanding densities to grids.</span>
<span class="sd">    Here we create a square grid based on a hexagonal graphene lattice. Expanding wavefunctions from</span>
<span class="sd">    this ``geometry`` will automatically convert to the ``lattice`` size.</span>
<span class="sd">    &gt;&gt;&gt; lattice = Lattice(10) # square lattice 10x10x10 Ang</span>
<span class="sd">    &gt;&gt;&gt; geometry = geom.graphene()</span>
<span class="sd">    &gt;&gt;&gt; grid = Grid(0.1, lattice=lattice, geometry=geometry)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1">#: Constant for defining a periodic boundary condition (deprecated, use Lattice.BC.PERIODIC)</span>
    <span class="n">PERIODIC</span> <span class="o">=</span> <span class="n">BoundaryCondition</span><span class="o">.</span><span class="n">PERIODIC</span>
    <span class="c1">#: Constant for defining a Neumann boundary condition (deprecated, use Lattice.BC.NEUMANN)</span>
    <span class="n">NEUMANN</span> <span class="o">=</span> <span class="n">BoundaryCondition</span><span class="o">.</span><span class="n">NEUMANN</span>
    <span class="c1">#: Constant for defining a Dirichlet boundary condition (deprecated, use Lattice.BC.DIRICHLET)</span>
    <span class="n">DIRICHLET</span> <span class="o">=</span> <span class="n">BoundaryCondition</span><span class="o">.</span><span class="n">DIRICHLET</span>
    <span class="c1">#: Constant for defining an open boundary condition (deprecated, use Lattice.BC.OPEN)</span>
    <span class="n">OPEN</span> <span class="o">=</span> <span class="n">BoundaryCondition</span><span class="o">.</span><span class="n">OPEN</span>

<div class="viewcode-block" id="Grid.__init__">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.__init__">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;sc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lattice&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument sc has been deprecated in favor of lattice, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;bc&quot;</span><span class="p">,</span>
        <span class="kc">None</span><span class="p">,</span>
        <span class="s2">&quot;argument bc has been deprecated (removed) in favor of the boundary conditions in Lattice, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shape</span><span class="p">,</span>
        <span class="n">bc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">lattice</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Lattice</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">geometry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Geometry</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Create the atomic structure in the grid, if possible</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">bc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">bc</span> <span class="o">=</span> <span class="p">[[</span><span class="bp">self</span><span class="o">.</span><span class="n">PERIODIC</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">d</span> <span class="o">/</span> <span class="n">shape</span><span class="p">)))</span>

        <span class="c1"># Create the grid</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_grid</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Create the grid boundary conditions</span>
        <span class="k">if</span> <span class="n">bc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">set_boundary_condition</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.set_bc">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.set_bc">[docs]</a>
    <span class="nd">@deprecation</span><span class="p">(</span>
        <span class="s2">&quot;Grid.set_bc is deprecated since boundary conditions are moved to Lattice (see github issue #626)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_bc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">set_boundary_condition</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.set_boundary">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.set_boundary">[docs]</a>
    <span class="nd">@deprecation</span><span class="p">(</span>
        <span class="s2">&quot;Grid.set_boundary is deprecated since boundary conditions are moved to Lattice (see github issue #626)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_boundary</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">set_boundary_condition</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.set_boundary_condition">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.set_boundary_condition">[docs]</a>
    <span class="nd">@deprecation</span><span class="p">(</span>
        <span class="s2">&quot;Grid.set_boundary_condition is deprecated since boundary conditions are moved to Lattice (see github issue #626)&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">set_boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bc</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">set_boundary_condition</span><span class="p">(</span><span class="n">bc</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Grid value at `key`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Updates the grid contained&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="k">def</span> <span class="nf">_is_commensurate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine whether the contained geometry and lattice are commensurate&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="c1"># ideally this should be checked that they are integer equivalent</span>
        <span class="n">l_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">length</span>
        <span class="n">g_len</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">length</span>
        <span class="n">reps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">l_len</span><span class="p">,</span> <span class="n">g_len</span><span class="p">)):</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">&gt;=</span> <span class="n">g</span><span class="p">:</span>
                <span class="n">reps</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span> <span class="o">/</span> <span class="n">g</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">reps</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">reps</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mf">1e-5</span><span class="p">)</span>

<div class="viewcode-block" id="Grid.set_geometry">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.set_geometry">[docs]</a>
    <span class="k">def</span> <span class="nf">set_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">also_lattice</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sets the `Geometry` for the grid.</span>

<span class="sd">        Setting the `Geometry` for the grid is a possibility</span>
<span class="sd">        to attach atoms to the grid.</span>

<span class="sd">        It is not a necessary entity, so passing `None` is a viable option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : Geometry or None</span>
<span class="sd">            specify the new geometry in the `Grid`. If ``None`` will</span>
<span class="sd">            remove the geometry (but not the lattice)</span>
<span class="sd">        also_lattice : bool, optional</span>
<span class="sd">            whether to also set the lattice for the grid according to the</span>
<span class="sd">            lattice of the `geometry`, if ``False`` it will keep the lattice</span>
<span class="sd">            as it was.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Fake geometry</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span>
            <span class="k">if</span> <span class="n">also_lattice</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.fill">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.fill">[docs]</a>
    <span class="k">def</span> <span class="nf">fill</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Fill the grid with this value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        val : numpy.dtype</span>
<span class="sd">           all grid-points will have this value after execution</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">val</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.interp">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.interp">[docs]</a>
    <span class="k">def</span> <span class="nf">interp</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Interpolate grid values to a new resolution (retaining lattice vectors)</span>

<span class="sd">        It uses the `scipy.ndimage.zoom`, which creates a finer or</span>
<span class="sd">        more spaced grid using spline interpolation.</span>
<span class="sd">        The lattice vectors remains unchanged.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shape : int, array_like of len 3</span>
<span class="sd">            the new shape of the grid.</span>
<span class="sd">        order : int 0-5, optional</span>
<span class="sd">            the order of the spline interpolation.</span>
<span class="sd">            1 means linear, 2 quadratic, etc...</span>
<span class="sd">        mode: {&#39;wrap&#39;, &#39;mirror&#39;, &#39;constant&#39;, &#39;reflect&#39;, &#39;nearest&#39;}</span>
<span class="sd">            determines how to compute the borders of the grid.</span>
<span class="sd">            The default is ``&#39;wrap&#39;``, which accounts for periodic conditions.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">            optional arguments passed to the interpolation algorithm</span>
<span class="sd">            The interpolation routine is `scipy.ndimage.zoom`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.ndimage.zoom : method used for interpolation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># For backwards compatibility</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;method&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Maybe the method was passed as a positional argument</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">order</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="n">order</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">order</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;linear&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># And now we do the actual interpolation</span>
        <span class="c1"># Calculate the zoom_factors</span>
        <span class="n">zoom_factors</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span>

        <span class="c1"># Apply the scipy.ndimage.zoom function and return a new grid</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">ndimage_zoom</span><span class="p">,</span> <span class="n">zoom_factors</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="n">order</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.isosurface">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.isosurface">[docs]</a>
    <span class="k">def</span> <span class="nf">isosurface</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">level</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">step_size</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculates the isosurface for a given value</span>

<span class="sd">        It uses `skimage.measure.marching_cubes`, so you need to have scikit-image installed.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        level:</span>
<span class="sd">            contour value to search for isosurfaces in the grid.</span>
<span class="sd">            If not given or None, the average of the min and max of the grid is used.</span>
<span class="sd">        step_size:</span>
<span class="sd">            step size in voxels. Larger steps yield faster but coarser results.</span>
<span class="sd">            The result will always be topologically correct though.</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            optional arguments passed directly to `skimage.measure.marching_cubes`</span>
<span class="sd">            for the calculation of isosurfaces.</span>

<span class="sd">        Returns</span>
<span class="sd">        ----------</span>
<span class="sd">        numpy array of shape (V, 3)</span>
<span class="sd">            Verts. Spatial coordinates for V unique mesh vertices.</span>

<span class="sd">        numpy array of shape (n_faces, 3)</span>
<span class="sd">            Faces. Define triangular faces via referencing vertex indices from verts.</span>
<span class="sd">            This algorithm specifically outputs triangles, so each face has exactly three indices.</span>

<span class="sd">        numpy array of shape (V, 3)</span>
<span class="sd">            Normals. The normal direction at each vertex, as calculated from the data.</span>

<span class="sd">        numpy array of shape (V, 3)</span>
<span class="sd">            Values. Gives a measure for the maximum value of the data in the local region near each vertex.</span>
<span class="sd">            This can be used by visualization tools to apply a colormap to the mesh.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        skimage.measure.marching_cubes : method used to calculate the isosurface.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="kn">import</span> <span class="nn">skimage.measure</span>
        <span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ModuleNotFoundError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.isosurface requires scikit-image to be installed&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">iscomplexobj</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.isosurface requires real grid values.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Run the marching cubes algorithm to calculate the vertices and faces</span>
        <span class="c1"># of the requested isosurface.</span>
        <span class="n">verts</span><span class="p">,</span> <span class="o">*</span><span class="n">returns</span> <span class="o">=</span> <span class="n">skimage</span><span class="o">.</span><span class="n">measure</span><span class="o">.</span><span class="n">marching_cubes</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">step_size</span><span class="o">=</span><span class="n">step_size</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
        <span class="p">)</span>

        <span class="c1"># The verts cordinates are in fractional coordinates of unit-length.</span>
        <span class="n">verts</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">index2xyz</span><span class="p">(</span><span class="n">verts</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span><span class="n">verts</span><span class="p">,</span> <span class="o">*</span><span class="n">returns</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.smooth">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.smooth">[docs]</a>
    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="o">=</span><span class="mf">0.7</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;gaussian&quot;</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wrap&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make a smoother grid by applying a filter</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r: float or array-like of len 3, optional</span>
<span class="sd">            the radius of the filter in Angstrom for each axis.</span>
<span class="sd">            If the method is ``&quot;gaussian&quot;``, this is the standard deviation!</span>

<span class="sd">            If a single float is provided, then the same distance will be used for all axes.</span>
<span class="sd">        method: {&#39;gaussian&#39;, &#39;uniform&#39;}</span>
<span class="sd">            the type of filter to apply to smoothen the grid.</span>
<span class="sd">        mode: {&#39;wrap&#39;, &#39;mirror&#39;, &#39;constant&#39;, &#39;reflect&#39;, &#39;nearest&#39;}</span>
<span class="sd">            determines how to compute the borders of the grid.</span>
<span class="sd">            The default is wrap, which accounts for periodic conditions.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        scipy.ndimage.gaussian_filter</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Normalize the radius input to a list of radius</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">r</span> <span class="o">=</span> <span class="p">[</span><span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">r</span><span class="p">]</span>

        <span class="c1"># Calculate the size of the kernel in pixels (in case the</span>
        <span class="c1"># gaussian filter is used, this is the standard deviation)</span>
        <span class="n">pixels_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="n">r</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dcell</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Update the kwargs accordingly</span>
        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;gaussian&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;sigma&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixels_r</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;uniform&quot;</span><span class="p">:</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">pixels_r</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># This should raise an import error if the method does not exist</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">import_attr</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;scipy.ndimage.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">_filter&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="n">mode</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total number of elements in the grid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Grid shape along the lattice vectors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Data-type used in grid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dkind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The data-type of the grid (in str)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">dtype</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span>

<div class="viewcode-block" id="Grid.set_grid">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.set_grid">[docs]</a>
    <span class="k">def</span> <span class="nf">set_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the internal grid of certain size.&quot;&quot;&quot;</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span>
        <span class="k">if</span> <span class="n">shape</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.set_grid requires shape to be of length 3&quot;</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">_sc_geometry_dict</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal routine for copying the Lattice and Geometry&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;lattice&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dcell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Voxel cell size&quot;&quot;&quot;</span>
        <span class="c1"># Calculate the grid-distribution</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span> <span class="o">/</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">dvolume</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Volume of the grid voxel elements&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">volume</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">size</span>

    <span class="k">def</span> <span class="nf">_copy_sub</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">scale_geometry</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="c1"># First calculate the new shape</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="c1"># Down-scale cell</span>
        <span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">/</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span> <span class="o">*</span> <span class="n">n</span>
        <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;You cannot retain no indices.&quot;</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_sc_geometry_dict</span><span class="p">())</span>
        <span class="c1"># Update cell shape (the cell is smaller now)</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale_geometry</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">fxyz</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">fxyz</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">fxyz</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">geom</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span>

<div class="viewcode-block" id="Grid.cross_section">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.cross_section">[docs]</a>
    <span class="k">def</span> <span class="nf">cross_section</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Takes a cross-section of the grid along axis `axis`</span>

<span class="sd">        Remark: This API entry might change to handle arbitrary</span>
<span class="sd">        cuts via rotation of the axis&quot;&quot;&quot;</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Unknown axis specification in cross_section </span><span class="si">{</span><span class="n">axis</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span></div>


<div class="viewcode-block" id="Grid.sum">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.sum">[docs]</a>
    <span class="k">def</span> <span class="nf">sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sum grid values along axis `axis`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int</span>
<span class="sd">            unit-cell direction to sum across</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">scale_geometry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Calculate sum (retain dimensions)</span>
        <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span></div>


<div class="viewcode-block" id="Grid.average">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.average">[docs]</a>
    <span class="k">def</span> <span class="nf">average</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Average grid values along direction `axis`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axis : int</span>
<span class="sd">            unit-cell direction to average across</span>
<span class="sd">        weights : array_like, optional</span>
<span class="sd">            the weights for the individual axis elements, if boolean it corresponds to 0 and 1</span>
<span class="sd">            for false/true.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        numpy.average : for details regarding the `weights` argument</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_copy_sub</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">scale_geometry</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">weights</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Calculate sum (retain dimensions)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">keepdims</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">/=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">axis</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">,</span> <span class="n">weights</span><span class="o">=</span><span class="n">weights</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.average requires axis to be in [0, 1, 2]&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">grid</span></div>


    <span class="c1"># for compatibility</span>
    <span class="n">mean</span> <span class="o">=</span> <span class="n">average</span>

<div class="viewcode-block" id="Grid.remove_part">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.remove_part">[docs]</a>
    <span class="k">def</span> <span class="nf">remove_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">above</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes parts of the grid via above/below designations.</span>

<span class="sd">        Works exactly opposite to `sub_part`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx : int</span>
<span class="sd">           the index of the grid axis `axis` to be removed</span>
<span class="sd">           for ``above=True`` grid[:idx,...]</span>
<span class="sd">           for ``above=False`` grid[idx:,...]</span>
<span class="sd">        axis : int</span>
<span class="sd">           the axis segment from which we retain the indices `idx`</span>
<span class="sd">        above : bool</span>
<span class="sd">           if ``True`` will retain the grid:</span>
<span class="sd">              ``grid[:idx,...]``</span>
<span class="sd">           else it will retain the grid:</span>
<span class="sd">              ``grid[idx:,...]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_part</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="ow">not</span> <span class="n">above</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.sub_part">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.sub_part">[docs]</a>
    <span class="k">def</span> <span class="nf">sub_part</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">above</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retains parts of the grid via above/below designations.</span>

<span class="sd">        Works exactly opposite to `remove_part`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        idx : int</span>
<span class="sd">           the index of the grid axis `axis` to be retained</span>
<span class="sd">           for ``above=True`` grid[idx:,...]</span>
<span class="sd">           for ``above=False`` grid[:idx,...]</span>
<span class="sd">        axis : int</span>
<span class="sd">           the axis segment from which we retain the indices `idx`</span>
<span class="sd">        above : bool</span>
<span class="sd">           if ``True`` will retain the grid:</span>
<span class="sd">              ``grid[idx:,...]``</span>
<span class="sd">           else it will retain the grid:</span>
<span class="sd">              ``grid[:idx,...]``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">above</span><span class="p">:</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sub</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">sub</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.index2xyz">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.index2xyz">[docs]</a>
    <span class="k">def</span> <span class="nf">index2xyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Real-space coordinates of indices related to the grid</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : array_like</span>
<span class="sd">           indices for grid-positions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           coordinates of the indices with respect to this grid spacing</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">asarray</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dcell</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.index_fold">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.index_fold">[docs]</a>
    <span class="k">def</span> <span class="nf">index_fold</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts indices from *any* placement to only exist in the &quot;primary&quot; grid</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; grid = Grid([10, 10, 10])</span>
<span class="sd">        &gt;&gt;&gt; assert np.all(grid.index_fold([-1, -1, -1]) == 9)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : array_like</span>
<span class="sd">           indices for grid-positions</span>
<span class="sd">        unique : bool, optional</span>
<span class="sd">           if true the returned indices are made unique after having folded the index points</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            all indices are then within the shape of the grid</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        index_truncate : truncate indices by removing indices outside the primary cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">ndim</span>

        <span class="c1"># Convert to internal</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span>
                <span class="n">index</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">%</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">index</span></div>


<div class="viewcode-block" id="Grid.index_truncate">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.index_truncate">[docs]</a>
    <span class="k">def</span> <span class="nf">index_truncate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove indices from *outside* the grid to only retain indices in the &quot;primary&quot; grid</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; grid = Grid([10, 10, 10])</span>
<span class="sd">        &gt;&gt;&gt; assert len(grid.index_truncate([-1, -1, -1])) == 0</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : array_like</span>
<span class="sd">           indices for grid-positions</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            all indices are then within the shape of the grid (others have been removed</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        index_fold : fold indices into the primary cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">index</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">ndim</span>

        <span class="n">index</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">log_and_reduce</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">log_and_reduce</span><span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="p">[</span><span class="n">log_and_reduce</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">index</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">index</span></div>


    <span class="k">def</span> <span class="nf">_index_shape</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal routine for shape-indices&quot;&quot;&quot;</span>
        <span class="c1"># First grab the sphere, subsequent indices will be reduced</span>
        <span class="c1"># by the actual shape</span>
        <span class="n">cuboid</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">Cuboid</span><span class="p">()</span>
        <span class="n">ellipsoid</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">Ellipsoid</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">volume</span> <span class="o">&gt;</span> <span class="n">cuboid</span><span class="o">.</span><span class="n">volume</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_shape_cuboid</span><span class="p">(</span><span class="n">cuboid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_shape_ellipsoid</span><span class="p">(</span><span class="n">ellipsoid</span><span class="p">)</span>

        <span class="c1"># Get min/max</span>
        <span class="n">imin</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">imax</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">idx</span>

        <span class="n">dc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dcell</span>

        <span class="c1"># Now to find the actual points inside the shape</span>
        <span class="c1"># First create all points in the square and then retrieve all indices</span>
        <span class="c1"># within.</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">imax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">iy</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">imax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">iz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">imin</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">imax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
        <span class="n">output_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">ix</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">iy</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">iz</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">rxyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
        <span class="n">ao</span> <span class="o">=</span> <span class="n">add</span><span class="o">.</span><span class="n">outer</span>
        <span class="n">ao</span><span class="p">(</span><span class="n">ao</span><span class="p">(</span><span class="n">ix</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]),</span> <span class="n">iz</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">rxyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">])</span>
        <span class="n">ao</span><span class="p">(</span><span class="n">ao</span><span class="p">(</span><span class="n">ix</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]),</span> <span class="n">iz</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">rxyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">ao</span><span class="p">(</span><span class="n">ao</span><span class="p">(</span><span class="n">ix</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">iy</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]),</span> <span class="n">iz</span> <span class="o">*</span> <span class="n">dc</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">out</span><span class="o">=</span><span class="n">rxyz</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">])</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">shape</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="n">rxyz</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">del</span> <span class="n">rxyz</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="n">output_shape</span><span class="p">)</span>
        <span class="n">i</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">ix</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">iy</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">i</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">iz</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span>
        <span class="n">i</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">idx</span>

        <span class="k">return</span> <span class="n">i</span>

    <span class="k">def</span> <span class="nf">_index_shape_cuboid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cuboid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal routine for cuboid shape-indices&quot;&quot;&quot;</span>
        <span class="c1"># Construct all points on the outer rim of the cuboids</span>
        <span class="n">min_d</span> <span class="o">=</span> <span class="n">fnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dcell</span><span class="p">)</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="c1"># Retrieve cuboids edge-lengths</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">cuboid</span><span class="o">.</span><span class="n">edge_length</span>
        <span class="c1"># Create normalized cuboid vectors (because we expan via the lengths below</span>
        <span class="n">vn</span> <span class="o">=</span> <span class="n">cuboid</span><span class="o">.</span><span class="n">_v</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">cuboid</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">LL</span> <span class="o">=</span> <span class="p">(</span><span class="n">cuboid</span><span class="o">.</span><span class="n">center</span> <span class="o">-</span> <span class="n">cuboid</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">UR</span> <span class="o">=</span> <span class="p">(</span><span class="n">cuboid</span><span class="o">.</span><span class="n">center</span> <span class="o">+</span> <span class="n">cuboid</span><span class="o">.</span><span class="n">_v</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Create coordinates</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">vn</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">min_d</span><span class="p">,</span> <span class="n">min_d</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">vn</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">min_d</span><span class="p">,</span> <span class="n">min_d</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">vn</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="n">min_d</span><span class="p">,</span> <span class="n">min_d</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Now create all sides</span>
        <span class="n">sa</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sb</span> <span class="o">=</span> <span class="n">b</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">def</span> <span class="nf">plane</span><span class="p">(</span><span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">v1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="n">v2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Allocate for the 6 faces of the cuboid</span>
        <span class="n">rxyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="mi">2</span><span class="p">,</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sb</span> <span class="o">+</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sc</span> <span class="o">+</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">sc</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="c1"># Define the LL and UR</span>
        <span class="n">rxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">LL</span>
        <span class="n">rxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">UR</span>

        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">rxyz</span><span class="p">[:,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sb</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">plane</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sb</span>
        <span class="n">rxyz</span><span class="p">[:,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">plane</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="n">i</span> <span class="o">+=</span> <span class="n">sa</span> <span class="o">*</span> <span class="n">sc</span>
        <span class="n">rxyz</span><span class="p">[:,</span> <span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">sb</span> <span class="o">*</span> <span class="n">sc</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="n">plane</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">sa</span><span class="p">,</span> <span class="n">sb</span><span class="p">,</span> <span class="n">sc</span>
        <span class="n">rxyz</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Get all indices of the cuboid planes</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rxyz</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_index_shape_ellipsoid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal routine for ellipsoid shape-indices&quot;&quot;&quot;</span>
        <span class="c1"># Figure out the points on the ellipsoid</span>
        <span class="n">rad1</span> <span class="o">=</span> <span class="n">pi</span> <span class="o">/</span> <span class="mi">180</span>
        <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">ogrid</span><span class="p">[</span><span class="o">-</span><span class="n">pi</span><span class="p">:</span><span class="n">pi</span><span class="p">:</span><span class="n">rad1</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">pi</span><span class="p">:</span><span class="n">rad1</span><span class="p">]</span>

        <span class="n">rxyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">theta</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">phi</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">rxyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">sin</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">phi</span><span class="p">)</span>
        <span class="n">rxyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">cos</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span>
        <span class="n">rxyz</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sin</span><span class="p">(</span><span class="n">theta</span><span class="p">)</span> <span class="o">*</span> <span class="n">phi</span>
        <span class="n">rxyz</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">rxyz</span><span class="p">,</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">_v</span><span class="p">)</span> <span class="o">+</span> <span class="n">ellipsoid</span><span class="o">.</span><span class="n">center</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span>

        <span class="c1"># Get all indices of the ellipsoid circumference</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rxyz</span><span class="p">)</span>

<div class="viewcode-block" id="Grid.index">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.index">[docs]</a>
    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coord</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find the grid index for a given coordinate (possibly only along a given lattice vector `axis`)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        coord : (:, 3) or float or Shape</span>
<span class="sd">            the coordinate of the axis. If a float is passed `axis` is</span>
<span class="sd">            also required in which case it corresponds to the length along the</span>
<span class="sd">            lattice vector corresponding to `axis`.</span>
<span class="sd">            If a Shape a list of coordinates that fits the voxel positions</span>
<span class="sd">            are returned (all internal points also).</span>
<span class="sd">        axis : int, optional</span>
<span class="sd">            the axis direction of the index, or for all axes if none.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coord</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="c1"># We have to do something differently</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_index_shape</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>

        <span class="n">coord</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">coord</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coord</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># float</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.index requires the &quot;</span>
                    <span class="s2">&quot;coordinate to be 3 values when an axis has not &quot;</span>
                    <span class="s2">&quot;been specified.&quot;</span>
                <span class="p">)</span>

            <span class="n">c</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dcell</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span> <span class="o">@</span> <span class="n">c</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
            <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">floor</span><span class="p">(</span><span class="n">coord</span> <span class="o">/</span> <span class="n">c</span><span class="p">))</span>

        <span class="n">icell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span>

        <span class="c1"># Ensure we return values in the same dimensionality</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">coord</span><span class="o">.</span><span class="n">ndim</span>

        <span class="n">shape</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># dot(icell, coord) is the fraction in the</span>
        <span class="c1"># cell. So * l / (l / self.shape) will</span>
        <span class="c1"># give the float of dcell lattice vectors (where l is the length of</span>
        <span class="c1"># each lattice vector)</span>
        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="p">(</span>
                    <span class="n">floor</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">icell</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">shape</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
                    <span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">floor</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">icell</span><span class="p">,</span> <span class="n">coord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">shape</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                    <span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span>
                <span class="p">)</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">floor</span><span class="p">(</span>
                <span class="n">dot</span><span class="p">(</span><span class="n">icell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">coord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">floor</span><span class="p">(</span>
                <span class="n">dot</span><span class="p">(</span><span class="n">icell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:],</span> <span class="n">coord</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
            <span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.read">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.read">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">read</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads grid from the `Sile` using `read_grid`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile : Sile, str or pathlib.Path</span>
<span class="sd">            a `Sile` object which will be used to read the grid</span>
<span class="sd">            if it is a string it will create a new sile using `get_sile`.</span>
<span class="sd">        * : args passed directly to ``read_grid(,**)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This only works because, they *must*</span>
        <span class="c1"># have been imported previously</span>
        <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="kn">import</span> <span class="n">BaseSile</span><span class="p">,</span> <span class="n">get_sile</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sile</span><span class="o">.</span><span class="n">read_grid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sile</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span>
            <span class="n">sile</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">str_spec</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">spec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">spec</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">spec</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;index&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">spec</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fh</span><span class="o">.</span><span class="n">read_grid</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String of object&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{name}</span><span class="s2">{{kind: </span><span class="si">{kind}</span><span class="s2">, shape: [</span><span class="si">{shape[0]}</span><span class="s2"> </span><span class="si">{shape[1]}</span><span class="s2"> </span><span class="si">{shape[2]}</span><span class="s2">],</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">kind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dkind</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_commensurate</span><span class="p">()</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">length</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">length</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">int32</span>
            <span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;commensurate: [</span><span class="si">{</span><span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">l</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="n">l</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="si">}</span><span class="s2">]&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">))</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="se">\n}}</span><span class="s2">&quot;</span>

    <span class="k">def</span> <span class="nf">_check_compatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">msg</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal check for asserting two grids are commensurable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="n">s1</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">s2</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Grids are not compatible, </span><span class="si">{</span><span class="n">s1</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">s2</span><span class="si">}</span><span class="s2">. </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_compatible_copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internally used copy function that also checks whether the two grids are compatible&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatibility</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether two grids are commensurable (no value checks, only grid shape)</span>

<span class="sd">        There will be no check of the values _on_ the grid.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">shape</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether two grids are incommensurable (no value checks, only grid shape)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Take the absolute value of the grid :math:`|\mathrm{grid}|`&quot;&quot;&quot;</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">dtype_complex_to_real</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">a</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add two grid values (or add a single value to all grid values)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if the grids are not compatible (different shapes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compatible_copy</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be added&quot;</span><span class="p">)</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">+</span> <span class="n">other</span>
        <span class="k">return</span> <span class="n">grid</span>

    <span class="k">def</span> <span class="fm">__iadd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add, in-place, values from another grid</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if the grids are not compatible (different shapes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatibility</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be added&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">+=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">+=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Subtract two grid values (or subtract a single value from all grid values)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if the grids are not compatible (different shapes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compatible_copy</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be subtracted&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">np</span><span class="o">.</span><span class="n">subtract</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span>

    <span class="k">def</span> <span class="fm">__isub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Subtract, in-place, values from another grid</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if the grids are not compatible (different shapes)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatibility</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be subtracted&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">-=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">-=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">__div__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__truediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__idiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__itruediv__</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__truediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compatible_copy</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be divided&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">np</span><span class="o">.</span><span class="n">divide</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span>

    <span class="k">def</span> <span class="fm">__itruediv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatibility</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be divided&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">/=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">/=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_compatible_copy</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be multiplied&quot;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">grid</span>

    <span class="k">def</span> <span class="fm">__imul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Grid</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_compatibility</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="s2">&quot;they cannot be multiplied&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">*=</span> <span class="n">other</span><span class="o">.</span><span class="n">grid</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span> <span class="o">*=</span> <span class="n">other</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="c1"># Here comes additional supplementary routines which enables an easy</span>
    <span class="c1"># work-through case with other programs.</span>
<div class="viewcode-block" id="Grid.mgrid">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.mgrid">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">mgrid</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="o">*</span><span class="n">slices</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of indices corresponding to the slices</span>

<span class="sd">        The returned values are equivalent to `numpy.mgrid` but they are returned</span>
<span class="sd">        in a (:, 3) array.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *slices : slice or list of int or int</span>
<span class="sd">            return a linear list of indices that points to the collective slice</span>
<span class="sd">            made by the passed arguments</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            linear indices for each of the sliced values, shape ``(*, 3)``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">slices</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">slices</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">slices</span><span class="p">]</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="n">g</span><span class="o">.</span><span class="n">size</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">indices</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">indices</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">indices</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">g</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="k">del</span> <span class="n">g</span>
        <span class="k">return</span> <span class="n">indices</span></div>


<div class="viewcode-block" id="Grid.pyamg_index">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.pyamg_index">[docs]</a>
    <span class="k">def</span> <span class="nf">pyamg_index</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate `pyamg` matrix indices from a list of grid indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : (:, 3) of int</span>
<span class="sd">            a list of indices of the grid along each grid axis</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            linear indices for the matrix</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        index : query indices from coordinates (directly passable to this method)</span>
<span class="sd">        mgrid : Grid equivalent to `numpy.mgrid`. Grid.mgrid returns indices in shapes (:, 3), contrary to numpy&#39;s `numpy.mgrid`</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if any of the passed indices are below 0 or above the number of elements per axis</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[:])</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">index</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">or</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">index</span> <span class="o">&gt;=</span> <span class="n">grid</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.pyamg_index erroneous values for grid indices&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Skipping factor per element</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">([[</span><span class="n">grid</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">grid</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="mi">1</span><span class="p">]])</span>
        <span class="k">return</span> <span class="p">(</span><span class="n">cp</span> <span class="o">*</span> <span class="n">index</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.pyamg_source">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.pyamg_source">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">pyamg_source</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">pyamg_indices</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fix the source term to `value`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        b : numpy.ndarray</span>
<span class="sd">           a vector containing RHS of :math:`\mathbf A \mathbf x = \mathbf b` for the solution of the grid stencil</span>
<span class="sd">        pyamg_indices : list of int</span>
<span class="sd">           the linear pyamg matrix indices where the value of the grid is fixed. I.e. the indices should</span>
<span class="sd">           correspond to returned quantities from `pyamg_indices`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">b</span><span class="p">[</span><span class="n">pyamg_indices</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span></div>


<div class="viewcode-block" id="Grid.pyamg_fix">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.pyamg_fix">[docs]</a>
    <span class="k">def</span> <span class="nf">pyamg_fix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">pyamg_indices</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Fix values for the stencil to `value`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : `~scipy.sparse.csr_matrix`/`~scipy.sparse.csc_matrix`</span>
<span class="sd">           sparse matrix describing the LHS for the linear system of equations</span>
<span class="sd">        b : numpy.ndarray</span>
<span class="sd">           a vector containing RHS of :math:`\mathbf A \mathbf x = \mathbf b` for the solution of the grid stencil</span>
<span class="sd">        pyamg_indices : list of int</span>
<span class="sd">           the linear pyamg matrix indices where the value of the grid is fixed. I.e. the indices should</span>
<span class="sd">           correspond to returned quantities from `pyamg_indices`.</span>
<span class="sd">        value : float</span>
<span class="sd">           the value of the grid to fix the value at</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">A</span><span class="o">.</span><span class="n">format</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;csc&quot;</span><span class="p">,</span> <span class="s2">&quot;csr&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.pyamg_fix only works for csr/csc sparse matrices&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Clean all couplings between the respective indices and all other data</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">array_arange</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">pyamg_indices</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">pyamg_indices</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="c1"># clean-up</span>
        <span class="k">del</span> <span class="n">s</span>

        <span class="c1"># Specify that these indices are not to be tampered with</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">d</span><span class="p">[</span><span class="n">pyamg_indices</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="c1"># BUG in scipy, sparse matrix += does not do in-place operations</span>
        <span class="c1"># hence we need to overwrite the `A` matrix afterward</span>
        <span class="n">AA</span> <span class="o">=</span> <span class="n">A</span> <span class="o">+</span> <span class="n">sp_diags</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">format</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">d</span>
        <span class="c1"># Restore data in the A array</span>
        <span class="n">A</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">AA</span><span class="o">.</span><span class="n">indices</span>
        <span class="n">A</span><span class="o">.</span><span class="n">indptr</span> <span class="o">=</span> <span class="n">AA</span><span class="o">.</span><span class="n">indptr</span>
        <span class="n">A</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">AA</span><span class="o">.</span><span class="n">data</span>
        <span class="k">del</span> <span class="n">AA</span>
        <span class="n">A</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

        <span class="c1"># force RHS value</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pyamg_source</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">pyamg_indices</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span></div>


<div class="viewcode-block" id="Grid.pyamg_boundary_condition">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.pyamg_boundary_condition">[docs]</a>
    <span class="nd">@wrap_filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">SparseEfficiencyWarning</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">pyamg_boundary_condition</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Attach boundary conditions to the `pyamg` grid-matrix `A` with default boundary conditions as specified for this `Grid`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        A : scipy.sparse.csr_matrix</span>
<span class="sd">           sparse matrix describing the grid</span>
<span class="sd">        b : numpy.ndarray</span>
<span class="sd">           a vector containing RHS of :math:`\mathbf A \mathbf x = \mathbf b` for the solution of the grid stencil</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span> <span class="nf">Neumann</span><span class="p">(</span><span class="n">idx_bc</span><span class="p">,</span> <span class="n">idx_p1</span><span class="p">):</span>
            <span class="c1"># Set all boundary equations to 0</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">array_arange</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">idx_bc</span><span class="p">],</span> <span class="n">A</span><span class="o">.</span><span class="n">indptr</span><span class="p">[</span><span class="n">idx_bc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">A</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># force the boundary cells to equal the neighboring cell</span>
            <span class="n">A</span><span class="p">[</span><span class="n">idx_bc</span><span class="p">,</span> <span class="n">idx_bc</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">A</span><span class="p">[</span><span class="n">idx_bc</span><span class="p">,</span> <span class="n">idx_p1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">A</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>
            <span class="n">b</span><span class="p">[</span><span class="n">idx_bc</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">def</span> <span class="nf">Dirichlet</span><span class="p">(</span><span class="n">idx</span><span class="p">):</span>
            <span class="c1"># Default pyamg Poisson matrix has Dirichlet BC</span>
            <span class="n">b</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">def</span> <span class="nf">Periodic</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">):</span>
            <span class="n">A</span><span class="p">[</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="n">A</span><span class="p">[</span><span class="n">idx2</span><span class="p">,</span> <span class="n">idx1</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">def</span> <span class="nf">sl2idx</span><span class="p">(</span><span class="n">sl</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">pyamg_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mgrid</span><span class="p">(</span><span class="n">sl</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># We have a periodic direction</span>
            <span class="c1"># Create slices</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">g</span><span class="p">)</span> <span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">]</span>

            <span class="c1"># LOWER BOUNDARY</span>
            <span class="n">bci</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">boundary_condition</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="n">sl2idx</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>  <span class="c1"># lower</span>

            <span class="n">bc</span> <span class="o">=</span> <span class="n">bci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">bci</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">PERIODIC</span><span class="p">:</span>
                <span class="n">sl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">sl2idx</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>  <span class="c1"># upper</span>
                <span class="n">Periodic</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">idx2</span>
                <span class="c1"># rest has been parsed as well</span>
                <span class="k">continue</span>

            <span class="k">if</span> <span class="n">bc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NEUMANN</span><span class="p">:</span>
                <span class="c1"># Retrieve next index</span>
                <span class="n">sl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">sl2idx</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>  <span class="c1"># lower + 1</span>
                <span class="n">Neumann</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">idx2</span>
            <span class="k">elif</span> <span class="n">bc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIRICHLET</span><span class="p">:</span>
                <span class="n">Dirichlet</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span>

            <span class="c1"># UPPER BOUNDARY</span>
            <span class="n">bc</span> <span class="o">=</span> <span class="n">bci</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">sl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
            <span class="n">idx1</span> <span class="o">=</span> <span class="n">sl2idx</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>  <span class="c1"># upper</span>

            <span class="k">if</span> <span class="n">bc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">NEUMANN</span><span class="p">:</span>
                <span class="c1"># Retrieve next index</span>
                <span class="n">sl</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">sl2idx</span><span class="p">(</span><span class="n">sl</span><span class="p">)</span>  <span class="c1"># upper - 1</span>
                <span class="n">Neumann</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">)</span>
                <span class="k">del</span> <span class="n">idx2</span>
            <span class="k">elif</span> <span class="n">bc</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">DIRICHLET</span><span class="p">:</span>
                <span class="n">Dirichlet</span><span class="p">(</span><span class="n">idx1</span><span class="p">)</span>

        <span class="n">A</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span></div>


<div class="viewcode-block" id="Grid.topyamg">
<a class="viewcode-back" href="../../../api/generated/sisl.Grid.html#sisl.Grid.topyamg">[docs]</a>
    <span class="nd">@deprecation</span><span class="p">(</span>
        <span class="s2">&quot;Grid.topyamg is deprecated in favor of Grid.to.pyamg&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span> <span class="nf">topyamg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a `pyamg` stencil matrix to be used in pyamg</span>

<span class="sd">        This allows retrieving the grid matrix equivalent of the real-space grid.</span>
<span class="sd">        Subsequently the returned matrix may be used in pyamg for solutions etc.</span>

<span class="sd">        The `pyamg` suite is it-self a rather complicated code with many options.</span>
<span class="sd">        For details we refer to `pyamg &lt;pyamg https://github.com/pyamg/pyamg/&gt;`_.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">           data-type used for the sparse matrix, default to use the grid data-type</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        scipy.sparse.csr_matrix</span>
<span class="sd">            the stencil for the `pyamg` solver</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            RHS of the linear system of equations</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        This example proves the best method for a variety of cases in regards of the 3D Poisson problem:</span>

<span class="sd">        &gt;&gt;&gt; grid = Grid(0.01)</span>
<span class="sd">        &gt;&gt;&gt; A, b = grid.topyamg() # automatically setups the current boundary conditions</span>
<span class="sd">        &gt;&gt;&gt; # add terms etc. to A and/or b</span>
<span class="sd">        &gt;&gt;&gt; import pyamg</span>
<span class="sd">        &gt;&gt;&gt; from scipy.sparse.linalg import cg</span>
<span class="sd">        &gt;&gt;&gt; ml = pyamg.aggregation.smoothed_aggregation_solver(A, max_levels=1000)</span>
<span class="sd">        &gt;&gt;&gt; M = ml.aspreconditioner(cycle=&#39;W&#39;) # pre-conditioner</span>
<span class="sd">        &gt;&gt;&gt; x, info = cg(A, b, tol=1e-12, M=M)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        pyamg_index : convert grid indices into the sparse matrix indices for ``A``</span>
<span class="sd">        pyamg_fix : fixes stencil for indices and fixes the source for the RHS matrix (uses `pyamg_source`)</span>
<span class="sd">        pyamg_source : fix the RHS matrix ``b`` to a constant value</span>
<span class="sd">        pyamg_boundary_condition : setup the sparse matrix ``A`` to given boundary conditions (called in this routine)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span> <span class="nn">pyamg.gallery</span> <span class="kn">import</span> <span class="n">poisson</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># Initially create the CSR matrix</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">poisson</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Now apply the boundary conditions</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pyamg_boundary_condition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span></div>


    <span class="nd">@classmethod</span>
    <span class="k">def</span> <span class="nf">_ArgumentParser_args_single</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the options for `Grid.ArgumentParser` in case they are the only options&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;limit_arguments&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;short&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;positional_out&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># Hook into the Grid class to create</span>
    <span class="c1"># an automatic ArgumentParser which makes actions</span>
    <span class="c1"># as the options are read.</span>
    <span class="nd">@default_ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Manipulate a Grid object in sisl.&quot;</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">ArgumentParser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and return a group of argument parsers which manipulates it self `Grid`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : ArgumentParser, None</span>
<span class="sd">           in case the arguments should be added to a specific parser. It defaults</span>
<span class="sd">           to create a new.</span>
<span class="sd">        limit_arguments : bool, True</span>
<span class="sd">           If `False` additional options will be created which are similar to other options.</span>
<span class="sd">        short : bool, False</span>
<span class="sd">           Create short options for a selected range of options</span>
<span class="sd">        positional_out : bool, False</span>
<span class="sd">           If `True`, adds a positional argument which acts as --out. This may be handy if only the geometry is in the argument list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">short</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;short&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">opts</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">short</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">args</span>
            <span class="k">return</span> <span class="p">[</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="c1"># We limit the import to occur here</span>
        <span class="kn">import</span> <span class="nn">argparse</span>

        <span class="c1"># The first thing we do is adding the Grid to the NameSpace of the</span>
        <span class="c1"># parser.</span>
        <span class="c1"># This will enable custom actions to interact with the grid in a</span>
        <span class="c1"># straight forward manner.</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;_grid&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="s2">&quot;_stored_grid&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="n">default_namespace</span><span class="p">(</span><span class="o">**</span><span class="n">d</span><span class="p">)</span>

        <span class="c1"># Define actions</span>
        <span class="k">class</span> <span class="nc">SetGeometry</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">set_geometry</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;-G&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">SetGeometry</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Define the geometry attached to the Grid.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># subtract another grid</span>
        <span class="c1"># They *MUST* be comensurate.</span>
        <span class="k">class</span> <span class="nc">DiffGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">-=</span> <span class="n">grid</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--diff&quot;</span><span class="p">,</span> <span class="s2">&quot;-d&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DiffGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Subtract another grid (they must be commensurate).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span> <span class="nc">AverageGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">direction</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--average&quot;</span><span class="p">),</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;DIR&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">AverageGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Take the average of the grid along DIR.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span> <span class="nc">SumGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">direction</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--sum&quot;</span><span class="p">),</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;DIR&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">SumGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Take the sum of the grid along DIR.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create-subsets of the grid</span>
        <span class="k">class</span> <span class="nc">SubDirectionGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># The unit-cell direction</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># Figure out whether this is a fractional or</span>
                <span class="c1"># distance in Ang</span>
                <span class="n">is_frac</span> <span class="o">=</span> <span class="s2">&quot;f&quot;</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">strseq</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">is_frac</span><span class="p">:</span>
                        <span class="n">rng</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
                    <span class="c1"># we have bounds</span>
                    <span class="k">if</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">idx1</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">idx1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">idx2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">idx2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="n">rng</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_frac</span><span class="p">:</span>
                        <span class="n">rng</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_frac</span><span class="p">:</span>
                        <span class="n">rng</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">rng</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">sub_part</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--sub&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;COORD&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">SubDirectionGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Reduce the grid by taking a subset of the grid (along DIR).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create-subsets of the grid</span>
        <span class="k">class</span> <span class="nc">RemoveDirectionGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># The unit-cell direction</span>
                <span class="n">axis</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="c1"># Figure out whether this is a fractional or</span>
                <span class="c1"># distance in Ang</span>
                <span class="n">is_frac</span> <span class="o">=</span> <span class="s2">&quot;f&quot;</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">strseq</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
                    <span class="c1"># we have bounds</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">or</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                            <span class="s2">&quot;Can not figure out how to apply mid-removal of grids.&quot;</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">idx1</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">idx1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">idx2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">idx2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rng</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">idx1</span><span class="p">,</span> <span class="n">idx2</span><span class="p">),</span> <span class="n">axis</span><span class="p">)</span>
                    <span class="k">return</span>
                <span class="k">elif</span> <span class="n">rng</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_frac</span><span class="p">:</span>
                        <span class="n">rng</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="nb">abs</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">is_frac</span><span class="p">:</span>
                        <span class="n">rng</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">rng</span>
                    <span class="n">b</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">rng</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">remove_part</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--remove&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;COORD&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">RemoveDirectionGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Reduce the grid by removing a subset of the grid (along DIR).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span> <span class="nc">Tile</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--tile&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Tile</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Tiles the grid in the specified direction.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Scale the grid with this value</span>
        <span class="k">class</span> <span class="nc">ScaleGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">grid</span> <span class="o">*=</span> <span class="n">value</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--scale&quot;</span><span class="p">,</span> <span class="s2">&quot;-S&quot;</span><span class="p">),</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">float</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">ScaleGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Scale grid values with a factor&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Define size of grid</span>
        <span class="k">class</span> <span class="nc">InterpGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">def</span> <span class="nf">_conv_shape</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
                    <span class="k">if</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">length</span> <span class="o">/</span> <span class="nb">float</span><span class="p">(</span><span class="n">value</span><span class="p">)))</span>
                    <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">_conv_shape</span><span class="p">,</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">length</span><span class="p">,</span> <span class="n">values</span><span class="p">[:</span><span class="mi">3</span><span class="p">]))</span>
                <span class="c1"># shorten list for easier arguments</span>
                <span class="n">values</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">3</span><span class="p">:]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--interp&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;NX NY NZ *ORDER *MODE&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">InterpGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Interpolate grid for higher or lower density (minimum 3 arguments)</span>
<span class="s2">Requires at least 3 arguments, number of points along 1st, 2nd and 3rd lattice vector. These may contain a &quot;.&quot; to signal a distance in angstrom of each voxel.</span>
<span class="s2">For instance --interp 0.1 10 100 will result in an interpolated shape of [nint(grid.lattice.length / 0.1), 10, 100].</span>

<span class="s2">The 4th optional argument is the order of interpolation; an integer 0&lt;=i&lt;=5 (default 1)</span>
<span class="s2">The 5th optional argument is the mode to interpolate; wrap/mirror/constant/reflect/nearest</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Smoothen the grid</span>
        <span class="k">class</span> <span class="nc">SmoothGrid</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">values</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="o">.</span><span class="n">smooth</span><span class="p">(</span><span class="o">*</span><span class="n">values</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--smooth&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;*R *METHOD *MODE&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">SmoothGrid</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Smoothen grid values according to methods by applying a filter, all arguments are optional.</span>
<span class="s2">The 1st argument is the radius of the filter for smoothening, a larger value means a larger volume which is agglomerated</span>
<span class="s2">The 2nd argument is the method to use; gaussian/uniform</span>
<span class="s2">The 3rd argument is the mode to use; wrap/mirror/constant/reflect/nearest</span>
<span class="s2">&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span> <span class="nc">PrintInfo</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_grid</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_grid</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--info&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">PrintInfo</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Print, to stdout, some regular information about the grid.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span> <span class="nc">Plot</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_grid</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>

                <span class="n">grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span>

                <span class="n">axs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                    <span class="n">shape</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">shape</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">axs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                            <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                                <span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">length</span><span class="p">[</span><span class="n">ax</span><span class="p">],</span> <span class="n">shape</span><span class="p">,</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span>
                            <span class="p">)</span>
                        <span class="p">)</span>
                        <span class="n">idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ax</span><span class="p">)</span>

                <span class="c1"># Now plot data</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot plot a 3D grid (yet!)&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">X</span><span class="p">,</span> <span class="n">Y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">(</span><span class="o">*</span><span class="n">axs</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">squeeze</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance along </span><span class="si">{</span><span class="s1">&#39;ABC&#39;</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="si">}</span><span class="s2"> [Ang]&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance along </span><span class="si">{</span><span class="s1">&#39;ABC&#39;</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span><span class="si">}</span><span class="s2"> [Ang]&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">axs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Distance along </span><span class="si">{</span><span class="s1">&#39;ABC&#39;</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="si">}</span><span class="s2"> [Ang]&quot;</span><span class="p">)</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Arbitrary unit&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--plot&quot;</span><span class="p">,</span> <span class="s2">&quot;-P&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Plot</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Plot the grid (currently only enabled if at least one dimension has been averaged out&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span> <span class="nc">Out</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="kn">import</span> <span class="n">get_sile</span>

                <span class="n">grid</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_grid</span>

                <span class="c1"># determine whether the write-out file has *write_grid* as a methd</span>
                <span class="c1"># if not, and the grid only have 1 dimension, we allow it to be</span>
                <span class="c1"># written to a datafile</span>
                <span class="n">sile</span> <span class="o">=</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&quot;w&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="s2">&quot;write_grid&quot;</span><span class="p">):</span>
                    <span class="n">grid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
                    <span class="c1"># this means that 2 dimensions have a length of 1</span>
                    <span class="c1"># figure out which dimensions it is and add calculate</span>
                    <span class="c1"># the distance along the lattice vector</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

                    <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span>
                        <span class="mi">0</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">length</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">endpoint</span><span class="o">=</span><span class="kc">False</span>
                    <span class="p">)</span>
                    <span class="n">sile</span><span class="o">.</span><span class="n">write_data</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Either of these two cases are not fullfilled:</span>

<span class="s2">1. </span><span class="si">{</span><span class="n">sile</span><span class="si">}</span><span class="s2"> do not have the `write_grid` method</span>

<span class="s2">2. The grid is not 1D data; averaged or summed along 2 directions.&quot;&quot;&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Issue to the namespace that the grid has been written, at least once.</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_grid</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--out&quot;</span><span class="p">,</span> <span class="s2">&quot;-o&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store the grid (at its current invocation) to the out file.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If the user requests positional out arguments, we also add that.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;positional_out&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="s2">&quot;out&quot;</span><span class="p">,</span>
                <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store the grid (at its current invocation) to the out file.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># We have now created all arguments</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">namespace</span>


<span class="n">new_dispatch</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">new</span>
<span class="n">to_dispatch</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">to</span>


<span class="c1"># Define base-class for this</span>
<span class="k">class</span> <span class="nc">GridNewDispatch</span><span class="p">(</span><span class="n">AbstractDispatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base dispatcher from class passing arguments to Grid class</span>

<span class="sd">    This forwards all `__call__` calls to `dispatch`</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">dispatch</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GridNewGridDispatch</span><span class="p">(</span><span class="n">GridNewDispatch</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return Grid, for sanitization purposes&quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_class</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">grid</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="n">out</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">shape</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">grid</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">out</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">grid</span>


<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Grid</span><span class="p">,</span> <span class="n">GridNewGridDispatch</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GridNewFileDispatch</span><span class="p">(</span><span class="n">GridNewDispatch</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defer the `Grid.read` method by passing down arguments&quot;&quot;&quot;</span>
        <span class="c1"># can work either on class or instance</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_class</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">GridNewFileDispatch</span><span class="p">)</span>
<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">GridNewFileDispatch</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GridToDispatch</span><span class="p">(</span><span class="n">AbstractDispatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base dispatcher from class passing from Grid class&quot;&quot;&quot;</span>


<span class="k">class</span> <span class="nc">GridToSileDispatch</span><span class="p">(</span><span class="n">GridToDispatch</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">grid</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="n">GridToSileDispatch</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span> <span class="n">GridToSileDispatch</span><span class="p">)</span>
<span class="c1"># to do grid.to[Path](path)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">GridToSileDispatch</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">GridToSileDispatch</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">GridTopyamgDispatch</span><span class="p">(</span><span class="n">GridToDispatch</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">()</span>
        <span class="kn">from</span> <span class="nn">pyamg.gallery</span> <span class="kn">import</span> <span class="n">poisson</span>

        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">dtype</span>
        <span class="c1"># Initially create the CSR matrix</span>
        <span class="n">A</span> <span class="o">=</span> <span class="n">poisson</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;csr&quot;</span><span class="p">)</span>
        <span class="n">b</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">A</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">A</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Now apply the boundary conditions</span>
        <span class="n">grid</span><span class="o">.</span><span class="n">pyamg_boundary_condition</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">A</span><span class="p">,</span> <span class="n">b</span>


<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;pyamg&quot;</span><span class="p">,</span> <span class="n">GridTopyamgDispatch</span><span class="p">)</span>


<span class="c1"># Clean up</span>
<span class="k">del</span> <span class="n">new_dispatch</span><span class="p">,</span> <span class="n">to_dispatch</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">def</span> <span class="nf">sgrid</span><span class="p">(</span><span class="n">grid</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">argv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ret_grid</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Main script for sgrid.</span>

<span class="sd">    This routine may be called with `argv` and/or a `Sile` which is the grid at hand.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    grid : Grid or BaseSile</span>
<span class="sd">       this may either be the grid, as-is, or a `Sile` which contains</span>
<span class="sd">       the grid.</span>
<span class="sd">    argv : list of str</span>
<span class="sd">       the arguments passed to sgrid</span>
<span class="sd">    ret_grid : bool, optional</span>
<span class="sd">       whether the function should return the grid</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span> <span class="nn">argparse</span>
    <span class="kn">import</span> <span class="nn">sys</span>
    <span class="kn">from</span> <span class="nn">pathlib</span> <span class="kn">import</span> <span class="n">Path</span>

    <span class="kn">from</span> <span class="nn">sisl.io</span> <span class="kn">import</span> <span class="n">BaseSile</span><span class="p">,</span> <span class="n">get_sile</span>

    <span class="c1"># The file *MUST* be the first argument</span>
    <span class="c1"># (except --help|-h)</span>
    <span class="n">exe</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># We cannot create a separate ArgumentParser to retrieve a positional arguments</span>
    <span class="c1"># as that will grab the first argument for an option!</span>

    <span class="c1"># Start creating the command-line utilities that are the actual ones.</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This manipulation utility is highly advanced and one should note that the ORDER of</span>
<span class="s2">options is determining the final structure. For instance:</span>

<span class="s2">   </span><span class="si">{exe}</span><span class="s2"> Reference.grid.nc --diff Other.grid.nc --sub 0.:0.2f z</span>

<span class="s2">is NOT equivalent to:</span>

<span class="s2">   </span><span class="si">{exe}</span><span class="s2"> Reference.grid.nc --sub 0.:0.2f z --diff Other.grid.nc</span>

<span class="s2">This may be unexpected but enables one to do advanced manipulations.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">argv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;--help&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># no arguments</span>
        <span class="c1"># fake a help</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;--help&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Ensure that the arguments have pre-pended spaces</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">argv_negative_fix</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">exe</span><span class="p">,</span>
        <span class="n">formatter_class</span><span class="o">=</span><span class="n">argparse</span><span class="o">.</span><span class="n">RawDescriptionHelpFormatter</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add default sisl version stuff</span>
    <span class="n">cmd</span><span class="o">.</span><span class="n">add_sisl_version_cite_arg</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># First read the input &quot;Sile&quot;</span>
    <span class="n">stdout_grid</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">grid</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span> <span class="nn">os.path</span> <span class="kn">import</span> <span class="n">isfile</span>

        <span class="n">argv</span><span class="p">,</span> <span class="n">input_file</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_input</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

        <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stdout_grid</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
        <span class="c1"># Store the input file...</span>
        <span class="n">input_file</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">file</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">read_grid</span><span class="p">()</span>

    <span class="c1"># Do the argument parser</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">grid</span><span class="o">.</span><span class="n">_ArgumentParser_args_single</span><span class="p">())</span>

    <span class="c1"># Now the arguments should have been populated</span>
    <span class="c1"># and we will sort out if the input options</span>
    <span class="c1"># is only a help option.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_input_file&quot;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_input_file&quot;</span><span class="p">,</span> <span class="n">input_file</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Now try and figure out the actual arguments</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_arguments</span><span class="p">(</span>
        <span class="n">argv</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">argumentparser</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span>
    <span class="p">)</span>

    <span class="c1"># We are good to go!!!</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">_grid</span>

    <span class="k">if</span> <span class="n">stdout_grid</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">_stored_grid</span><span class="p">:</span>
        <span class="c1"># We should write out the information to the stdout</span>
        <span class="c1"># This is merely for testing purposes and may not be used for anything.</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ret_grid</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2024, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>