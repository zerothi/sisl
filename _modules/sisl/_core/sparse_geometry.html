

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl._core.sparse_geometry &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=e6be679b"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl._core.sparse_geometry</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl._core.sparse_geometry</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Tuple</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">allclose</span><span class="p">,</span>
    <span class="n">argsort</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">,</span>
    <span class="n">delete</span><span class="p">,</span>
    <span class="n">diff</span><span class="p">,</span>
    <span class="n">insert</span><span class="p">,</span>
    <span class="n">int32</span><span class="p">,</span>
    <span class="n">intersect1d</span><span class="p">,</span>
    <span class="n">lexsort</span><span class="p">,</span>
    <span class="n">repeat</span><span class="p">,</span>
    <span class="n">searchsorted</span><span class="p">,</span>
    <span class="n">tile</span><span class="p">,</span>
    <span class="n">unique</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy.lib.mixins</span><span class="w"> </span><span class="kn">import</span> <span class="n">NDArrayOperatorsMixin</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">csr_matrix</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sisl</span><span class="w"> </span><span class="kn">import</span> <span class="n">_array</span> <span class="k">as</span> <span class="n">_a</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._array</span><span class="w"> </span><span class="kn">import</span> <span class="n">array_arange</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">Orbital</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">,</span> <span class="n">deprecate_argument</span><span class="p">,</span> <span class="n">progressbar</span><span class="p">,</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">CellAxes</span><span class="p">,</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">SeqOrScalarFloat</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing._atom</span><span class="w"> </span><span class="kn">import</span> <span class="n">AtomsLike</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing._common</span><span class="w"> </span><span class="kn">import</span> <span class="n">SeqOrScalarInt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">direction</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.ranges</span><span class="w"> </span><span class="kn">import</span> <span class="n">list2str</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">SparseCSR</span><span class="p">,</span> <span class="n">_ncol_to_indptr</span><span class="p">,</span> <span class="n">_to_coo</span><span class="p">,</span> <span class="n">issparse</span><span class="p">,</span> <span class="n">valid_index</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;SparseAtom&quot;</span><span class="p">,</span> <span class="s2">&quot;SparseOrbital&quot;</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_SparseGeometry</span><span class="p">(</span><span class="n">NDArrayOperatorsMixin</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sparse object containing sparse elements for a given geometry.</span>

<span class="sd">    This is a base class intended to be sub-classed because the sparsity information</span>
<span class="sd">    needs to be extracted from the ``_size`` attribute.</span>

<span class="sd">    The sub-classed object _must_ implement the ``_size`` attribute.</span>
<span class="sd">    The sub-classed object may re-implement the ``_cls_kwargs`` routine</span>
<span class="sd">    to pass down keyword arguments when a new class is instantiated.</span>

<span class="sd">    This object contains information regarding the</span>
<span class="sd">     - geometry</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span>
        <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">nnzpr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create sparse object with element between orbitals&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geometry</span>

        <span class="c1"># Initialize the sparsity pattern</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reset</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Associated geometry&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The size of the sparse object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of rows in the basis&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_cls_kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Custom keyword arguments when creating a new instance&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">nnzpr</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The sparsity pattern has all elements removed and everything is reset.</span>

<span class="sd">        The object will be the same as if it had been</span>
<span class="sd">        initialized with the same geometry as it were</span>
<span class="sd">        created with.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim :</span>
<span class="sd">           number of dimensions per element, default to the current number of</span>
<span class="sd">           elements per matrix element.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">           the datatype of the sparse elements</span>
<span class="sd">        nnzpr :</span>
<span class="sd">           number of non-zero elements per row</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># I know that this is not the most efficient way to</span>
        <span class="c1"># access a C-array, however, for constructing a</span>
        <span class="c1"># sparse pattern, it should be faster if memory elements</span>
        <span class="c1"># are closer...</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span>

        <span class="c1"># We check the first atom and its neighbors, we then</span>
        <span class="c1"># select max(5,len(nc) * 4)</span>
        <span class="k">if</span> <span class="n">nnzpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">nnzpr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">nnzpr</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">nnzpr</span> <span class="o">=</span> <span class="mi">8</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">nnzpr</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">nnzpr</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>

        <span class="c1"># query dimension of sparse matrix</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">s</span><span class="p">,</span> <span class="n">s</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="n">nnzpr</span><span class="o">=</span><span class="n">nnzpr</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Denote that one *must* specify all details of the elements</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">empty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keep_nnz</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See :meth:`~sparse.SparseCSR.empty` for details&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">keep_nnz</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dim</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of components per element&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">shape</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Shape of sparse matrix&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Data type of sparse elements&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">dtype</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dkind</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Data type of sparse elements (in str)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">dkind</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of non-zero elements&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">translate2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CellAxes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translates all primary atoms to the unit cell.</span>

<span class="sd">        With this, the coordinates of the geometry are translated to the unit cell</span>
<span class="sd">        and the supercell connections in the matrix are updated accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            only translate the specified atoms. If not specified, all</span>
<span class="sd">            atoms will be translated.</span>
<span class="sd">        axes :</span>
<span class="sd">            only translate certain lattice directions, `None` specifies</span>
<span class="sd">            only the periodic directions</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        SparseOrbital or SparseAtom</span>
<span class="sd">            A new sparse matrix with the updated connections and a new associated geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Sanitize the axes argument</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">pbc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;translate2uc with a bool argument can only be True to signal all axes&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">axes</span><span class="p">))</span>

        <span class="c1"># Sanitize also the atoms argument</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">ats</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ats</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Get the fractional coordinates of the associated geometry</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">fxyz</span>

        <span class="c1"># Get the cell where each atom resides. In fractional coordinates, atoms in the unit cell</span>
        <span class="c1"># are between 0 and 1. Anything else means that the atom resides in a periodic image. For</span>
        <span class="c1"># atoms and axes that the user doesn&#39;t desire the translation, we are going to set the supercell</span>
        <span class="c1"># offset as if it was 0, which will result in them not getting translated.</span>
        <span class="n">current_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">current_sc</span><span class="p">[</span><span class="n">ats</span><span class="p">,</span> <span class="n">axes</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[</span><span class="n">ats</span><span class="p">,</span> <span class="n">axes</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Simply translate the atoms to move all atoms to the unit cell. That is, all atoms</span>
        <span class="c1"># should be moved to supercell (0,0,0).</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_translate_atoms_sc</span><span class="p">(</span><span class="o">-</span><span class="n">current_sc</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_transpose_indices</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">base</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts from supercell indices to supercell transposed indices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        indices :</span>
<span class="sd">            the indices that contains the supercell indices.</span>
<span class="sd">        base :</span>
<span class="sd">            the resulting base orbitals that needs to translated.</span>
<span class="sd">            These defaults to the unit-cell indices of `indices`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span>

        <span class="c1"># transposed offsets</span>
        <span class="n">new_sc_off</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">)</span>

        <span class="c1"># Calculate the row-offsets in the new sparse geometry</span>
        <span class="n">size</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">indices</span> <span class="o">%</span> <span class="n">size</span>

        <span class="n">base</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">base</span>
            <span class="o">+</span> <span class="n">new_sc_off</span><span class="p">[</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">indices</span> <span class="o">//</span> <span class="n">size</span><span class="p">,</span> <span class="p">:])]</span> <span class="o">*</span> <span class="n">size</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">base</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_translate_atoms_sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sc_translations</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translates atoms across supercells.</span>

<span class="sd">        This operation results in new coordinates of the associated geometry</span>
<span class="sd">        and new indices for the matrix elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sc_translations : array of int of shape (na, 3)</span>
<span class="sd">            For each atom, the displacement in number of supercells along each direction.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        SparseOrbital or SparseAtom</span>
<span class="sd">            A new sparse matrix with the updated connections and a new associated geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Make sure that supercell translations is an array of integers</span>
        <span class="n">sc_translations</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">sc_translations</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

        <span class="c1"># Get the row and column of every element in the matrix</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">cols</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="n">n_rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">is_atom</span> <span class="o">=</span> <span class="n">n_rows</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

        <span class="c1"># Find out the unit cell indices for the columns, and the index of the supercell</span>
        <span class="c1"># where they are currently located. This is done by dividing into the number of</span>
        <span class="c1"># columns in the unit cell.</span>
        <span class="c1"># We will do the conversion back to supercell indices when we know their</span>
        <span class="c1"># new location after translation, and also the size of the new auxiliary supercell.</span>
        <span class="n">sc_idx</span><span class="p">,</span> <span class="n">uc_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">cols</span><span class="p">,</span> <span class="n">n_rows</span><span class="p">)</span>

        <span class="c1"># We need the unit cell indices of the column atoms. If this is a SparseAtom object, then</span>
        <span class="c1"># we have already computed them in the previous line. Otherwise, compute them.</span>
        <span class="k">if</span> <span class="n">is_atom</span><span class="p">:</span>
            <span class="c1"># atomic indices</span>
            <span class="n">at_row</span> <span class="o">=</span> <span class="n">rows</span>
            <span class="n">at_col</span> <span class="o">=</span> <span class="n">uc_col</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># orbital indices</span>
            <span class="n">at_row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">rows</span><span class="p">)</span>
            <span class="n">at_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">cols</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

        <span class="c1"># Get the supercell indices of the original positions.</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">sc_idx</span><span class="p">]</span>

        <span class="c1"># We are going to now displace the supercell index of the connections</span>
        <span class="c1"># according to how the two orbitals involved have moved. We store the</span>
        <span class="c1"># result in the same array just to avoid using more memory.</span>
        <span class="n">isc</span> <span class="o">+=</span> <span class="n">sc_translations</span><span class="p">[</span><span class="n">at_row</span><span class="p">]</span> <span class="o">-</span> <span class="n">sc_translations</span><span class="p">[</span><span class="n">at_col</span><span class="p">]</span>

        <span class="c1"># It is possible that once we discover the new locations of the connections</span>
        <span class="c1"># we find out that we need a bigger or smaller auxiliary supercell. Find out</span>
        <span class="c1"># the size of the new auxiliary supercell.</span>
        <span class="n">new_nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">isc</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="c1"># Create a new geometry object with the new auxiliary supercell size.</span>
        <span class="n">new_geometry</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_geometry</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">new_nsc</span><span class="p">)</span>

        <span class="c1"># Update the coordinates of the geometry, according to the cell</span>
        <span class="c1"># displacements.</span>
        <span class="n">new_geometry</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">new_geometry</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">sc_translations</span> <span class="o">@</span> <span class="n">new_geometry</span><span class="o">.</span><span class="n">cell</span>

        <span class="c1"># Find out supercell indices in this new auxiliary supercell</span>
        <span class="n">new_sc</span> <span class="o">=</span> <span class="n">new_geometry</span><span class="o">.</span><span class="n">isc_off</span><span class="p">[</span><span class="n">isc</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">isc</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">isc</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]]</span>

        <span class="c1"># With this, we can compute the new columns</span>
        <span class="n">new_cols</span> <span class="o">=</span> <span class="n">uc_col</span> <span class="o">+</span> <span class="n">new_sc</span> <span class="o">*</span> <span class="n">n_rows</span>

        <span class="c1"># Build the new csr matrix, which will just be a copy of the current one</span>
        <span class="c1"># but updating the column indices. It is possible that there are column</span>
        <span class="c1"># indices that are -1, which are the placeholders for new elements. We make sure</span>
        <span class="c1"># that we update only the indices that are not -1.</span>
        <span class="c1"># We also need to make sure that the shape of the matrix is appropiate</span>
        <span class="c1"># for the size of the new auxiliary cell.</span>
        <span class="n">new_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new_csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">new_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_cols</span>
        <span class="n">new_csr</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">n_rows</span><span class="p">,</span> <span class="n">n_rows</span> <span class="o">*</span> <span class="n">new_geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">new_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Create the new SparseGeometry matrix and associate to it the csr matrix that we have built.</span>
        <span class="n">new_matrix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">new_geometry</span><span class="p">)</span>
        <span class="n">new_matrix</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">new_csr</span>

        <span class="k">return</span> <span class="n">new_matrix</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_translate_cells</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translates all columns in the `old` cell indices to the `new` cell indices</span>

<span class="sd">        Since the physical matrices are stored in a CSR form, with shape ``(no, no * n_s)`` each</span>
<span class="sd">        block of ``(no, no)`` refers to supercell matrices with an offset according to the internal</span>
<span class="sd">        supercell index.</span>
<span class="sd">        This routine may be used to translate from one sorting of the columns to another sorting of the columns.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        old : list of int</span>
<span class="sd">           integer list of supercell indices (all smaller than `n_s`) that the current blocks of matrices</span>
<span class="sd">           belong to.</span>
<span class="sd">        new : list of int</span>
<span class="sd">           integer list of supercell indices (all smaller than `n_s`) that the current blocks of matrices</span>
<span class="sd">           are being transferred to. Must have same length as `old`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">old</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="o">+</span> <span class="s2">&quot;.translate_cells requires input and output indices with &quot;</span>
                <span class="s2">&quot;equal length&quot;</span>
            <span class="p">)</span>

        <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="c1"># Number of elements per matrix</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
        <span class="n">n</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">no</span><span class="p">)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">old</span> <span class="o">*</span> <span class="n">no</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">new</span> <span class="o">*</span> <span class="n">no</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">exclude</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve edges (connections) for all `atoms`</span>

<span class="sd">        The returned edges are unique and sorted (see `numpy.unique`) and are returned</span>
<span class="sd">        in supercell indices (i.e. ``0 &lt;= edge &lt; self.geometry.na_s``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            the edges are returned only for the given atom</span>
<span class="sd">        exclude :</span>
<span class="sd">           remove edges which are in the `exclude` list.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.edges: the underlying routine used for extracting the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Representation of the sparse model&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">dim: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">, non-zero: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="si">}</span><span class="s2">, kind=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dkind</span><span class="si">}</span><span class="se">\n</span><span class="s2"> &quot;</span>
        <span class="k">return</span> <span class="n">s</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">}&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> shape=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">, dim=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="si">}</span><span class="s2">, nnz=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nnz</span><span class="si">}</span><span class="s2">, kind=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">dkind</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Overload attributes from the hosting geometry</span>

<span class="sd">        Any attribute not found in the sparse class will</span>
<span class="sd">        be looked up in the hosting geometry.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">attr</span><span class="p">)</span>

    <span class="c1"># Make the indicis behave on the contained sparse matrix</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Delete elements of the sparse elements&quot;&quot;&quot;</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__contains__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Check whether a sparse index is non-zero&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base_size</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the number of allowed supercells in the sparse geometry</span>

<span class="sd">        If one reduces the number of supercells, *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `Lattice.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Lattice.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># Try first in the new one, then we figure out what to do</span>
        <span class="n">lattice</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">allclose</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">nsc</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="k">return</span>

        <span class="c1"># Create an array of all things that should be translated</span>
        <span class="n">old</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">deleted</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">)</span>
        <span class="n">deleted</span><span class="p">[:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sc_off</span> <span class="ow">in</span> <span class="n">lattice</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># Luckily there are *only* one time wrap-arounds</span>
                <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span>
                <span class="c1"># Now do translation</span>
                <span class="n">old</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
                <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="n">deleted</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="c1"># Not found, i.e. new, so no need to translate</span>
                <span class="k">pass</span>

        <span class="c1"># 1. Ensure that any one of the *old* supercells that</span>
        <span class="c1">#    are now deleted are put in the end</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">deleted</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="c1"># Old index (j)</span>
            <span class="n">old</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">j</span><span class="p">)</span>
            <span class="c1"># Move to the end (*HAS* to be higher than the number of</span>
            <span class="c1"># cells in the new supercell structure)</span>
            <span class="n">new</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">+</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Check that we will translate all indices in the old</span>
        <span class="c1"># sparsity pattern to the new one</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;Not all supercells are accounted for&quot;</span><span class="p">)</span>

        <span class="n">old</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

        <span class="c1"># Assert that there are only unique values</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-unique values in old set_nsc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">new</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-unique values in new set_nsc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s2">&quot;non-valid size of in old set_nsc&quot;</span><span class="p">)</span>

        <span class="c1"># Figure out if we need to do any work</span>
        <span class="n">keep</span> <span class="o">=</span> <span class="p">(</span><span class="n">old</span> <span class="o">!=</span> <span class="n">new</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">keep</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Reduce pivoting work</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">old</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="p">[</span><span class="n">keep</span><span class="p">]</span>

            <span class="c1"># Create the translation tables</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">tile</span><span class="p">([</span><span class="n">base_size</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>

            <span class="n">old</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">old</span> <span class="o">*</span> <span class="n">base_size</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">new</span> <span class="o">*</span> <span class="n">base_size</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">)</span>

            <span class="c1"># Move data to new positions</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">clean</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

            <span class="n">max_n</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">max_n</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># Make sure we delete all column values where we have put fake values</span>
        <span class="n">delete</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">n_s</span> <span class="o">*</span> <span class="n">base_size</span><span class="p">,</span> <span class="nb">max</span><span class="p">(</span><span class="n">max_n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">delete</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">delete_columns</span><span class="p">(</span><span class="n">delete</span><span class="p">,</span> <span class="n">keep_shape</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Ensure the shape is correct</span>
        <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">base_size</span> <span class="o">*</span> <span class="n">lattice</span><span class="o">.</span><span class="n">n_s</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_clean_columns</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">transpose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sort</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create the transposed sparse geometry by interchanging supercell indices</span>

<span class="sd">        Sparse geometries are (typically) relying on symmetry in the supercell picture.</span>
<span class="sd">        Thus when one transposes a sparse geometry one should *ideally* get the same</span>
<span class="sd">        matrix. This is true for the Hamiltonian, density matrix, etc.</span>

<span class="sd">        This routine transposes all rows and columns such that any interaction between</span>
<span class="sd">        row, `r`, and column `c` in a given supercell `(i,j,k)` will be transposed</span>
<span class="sd">        into row `c`, column `r` in the supercell `(-i,-j,-k)`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sort :</span>
<span class="sd">           the returned columns for the transposed structure will be sorted</span>
<span class="sd">           if this is true, default</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The components for each sparse element are not changed in this method.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Force a sparse geometry to be Hermitian:</span>

<span class="sd">        &gt;&gt;&gt; sp = SparseOrbital(...)</span>
<span class="sd">        &gt;&gt;&gt; sp = (sp + sp.transpose()) / 2</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            an equivalent sparse geometry with transposed matrix elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create a temporary copy to put data into</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># clean memory to not crowd memory too much</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Create &quot;DOK&quot; format indices</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="c1"># Number of rows (used for converting to supercell indices)</span>
        <span class="c1"># With this we don&#39;t need to figure out if we are dealing with</span>
        <span class="c1"># atoms or orbitals</span>
        <span class="n">size</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># First extract the sparse matrix in COO format</span>
        <span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">D</span> <span class="o">=</span> <span class="n">_to_coo</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span>

        <span class="n">row</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_transpose_indices</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">row</span><span class="p">)</span>

        <span class="c1"># Now convert columns into unit-cell</span>
        <span class="n">col</span> <span class="o">%=</span> <span class="n">size</span>

        <span class="c1"># Now we can re-create the sparse matrix</span>
        <span class="c1"># All we need is to count the number of non-zeros per column.</span>
        <span class="n">rows</span><span class="p">,</span> <span class="n">nrow</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">rows</span><span class="p">]</span> <span class="o">=</span> <span class="n">nrow</span>
        <span class="k">del</span> <span class="n">rows</span>

        <span class="k">if</span> <span class="n">sort</span><span class="p">:</span>
            <span class="c1"># also sort individual rows for each column</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">lexsort</span><span class="p">((</span><span class="n">row</span><span class="p">,</span> <span class="n">col</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># sort columns to get transposed values.</span>
            <span class="c1"># This will randomize the rows</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="c1"># Our new data will then be</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">row</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">del</span> <span class="n">D</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>

        <span class="c1"># If `sort` we have everything sorted, otherwise it</span>
        <span class="c1"># is not ensured</span>
        <span class="n">T</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="n">sort</span>

        <span class="k">return</span> <span class="n">T</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spalign</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;See :meth:`~sisl.sparse.SparseCSR.align` for details&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SparseCSR</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">eliminate_zeros</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Removes all zero elements from the sparse matrix</span>

<span class="sd">        This is an *in-place* operation.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.eliminate_zeros : method called, see there for parameters</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Create iterations on the non-zero elements</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

    <span class="fm">__iter__</span> <span class="o">=</span> <span class="n">iter_nnz</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">create_construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a simple function for passing to the `construct` function.</span>

<span class="sd">        This is simply to leviate the creation of simplistic</span>
<span class="sd">        functions needed for setting up the sparse elements.</span>

<span class="sd">        Basically this returns a function:</span>

<span class="sd">        &gt;&gt;&gt; def func(self, ia, atoms, atoms_xyz=None):</span>
<span class="sd">        ...     idx = self.geometry.close(ia, R=R, atoms=atoms, atoms_xyz=atoms_xyz)</span>
<span class="sd">        ...     for ix, p in zip(idx, params):</span>
<span class="sd">        ...         self[ia, ix] = p</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This function only works for geometry sparse matrices (i.e. one</span>
<span class="sd">        element per atom). If you have more than one element per atom</span>
<span class="sd">        you have to implement the function your-self.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R : array_like</span>
<span class="sd">           radii parameters for different shells.</span>
<span class="sd">           Must have same length as `params` or one less.</span>
<span class="sd">           If one less it will be extended with ``R[0]/100``</span>
<span class="sd">        params : array_like</span>
<span class="sd">           coupling constants corresponding to the `R`</span>
<span class="sd">           ranges. ``params[0, :]`` are the elements</span>
<span class="sd">           for the all atoms within ``R[0]`` of each atom.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        construct : routine to create the sparse matrix from a generic function (as returned from `create_construct`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">params</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.create_construct got different lengths of &#39;R&#39; and &#39;params&#39;&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">ix</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">params</span><span class="p">):</span>
                <span class="bp">self</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ix</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span>

        <span class="n">func</span><span class="o">.</span><span class="n">R</span> <span class="o">=</span> <span class="n">R</span>
        <span class="n">func</span><span class="o">.</span><span class="n">params</span> <span class="o">=</span> <span class="n">params</span>

        <span class="k">return</span> <span class="n">func</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">construct</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">na_iR</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rand&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Automatically construct the sparse model based on a function that does the setting up of the elements</span>

<span class="sd">        This may be called in two variants.</span>

<span class="sd">        1. Pass a function (`func`), see e.g. ``create_construct``</span>
<span class="sd">           which does the setting up.</span>
<span class="sd">        2. Pass a tuple/list in `func` which consists of two</span>
<span class="sd">           elements, one is ``R`` the radii parameters for</span>
<span class="sd">           the corresponding parameters.</span>
<span class="sd">           The second is the parameters</span>
<span class="sd">           corresponding to the ``R[i]`` elements.</span>
<span class="sd">           In this second case all atoms must only have</span>
<span class="sd">           one orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        func : callable or array_like</span>
<span class="sd">           this function *must* take 4 arguments.</span>
<span class="sd">           1. Is this object (``self``)</span>
<span class="sd">           2. Is the currently examined atom (``ia``)</span>
<span class="sd">           3. Is the currently bounded indices (``idxs``)</span>
<span class="sd">           4. Is the currently bounded indices atomic coordinates (``idxs_xyz``)</span>
<span class="sd">           An example `func` could be:</span>

<span class="sd">           &gt;&gt;&gt; def func(self, ia, atoms, atoms_xyz=None):</span>
<span class="sd">           ...     idx = self.geometry.close(ia, R=[0.1, 1.44], atoms=atoms, atoms_xyz=atoms_xyz)</span>
<span class="sd">           ...     self[ia, idx[0]] = 0</span>
<span class="sd">           ...     self[ia, idx[1]] = -2.7</span>

<span class="sd">        na_iR : int, optional</span>
<span class="sd">           number of atoms within the sphere for speeding</span>
<span class="sd">           up the `iter_block` loop.</span>
<span class="sd">        method : {&#39;rand&#39;, str}</span>
<span class="sd">           method used in `Geometry.iter_block`, see there for details</span>
<span class="sd">        eta : bool, optional</span>
<span class="sd">           whether an ETA will be printed</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        create_construct : a generic function used to create a generic function which this routine requires</span>
<span class="sd">        tile : tiling *after* construct is much faster for very large systems</span>
<span class="sd">        repeat : repeating *after* construct is much faster for very large systems</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">callable</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Passed `func` which is not a function, nor tuple/list of `R, param`&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;Automatically setting a sparse model &quot;</span>
                    <span class="s2">&quot;for systems with atoms having more than 1 &quot;</span>
                    <span class="s2">&quot;orbital *must* be done by your-self. You have to define a corresponding `func`.&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Convert to a proper function</span>
            <span class="n">func</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">create_construct</span><span class="p">(</span><span class="n">func</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">func</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># if the function was created through `create_construct`, then</span>
            <span class="c1"># we have access to the radii used.</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">func</span><span class="o">.</span><span class="n">R</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">except</span> <span class="ne">TypeError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="n">iR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">iR</span><span class="p">(</span><span class="n">na_iR</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>

        <span class="c1"># Create eta-object</span>
        <span class="n">eta</span> <span class="o">=</span> <span class="n">progressbar</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="w"> </span><span class="si">}</span><span class="s2">.construct&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="p">)</span>

        <span class="c1"># Do the loop</span>
        <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">idxs</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="n">iR</span><span class="o">=</span><span class="n">iR</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">):</span>
            <span class="c1"># Get all the indexed atoms...</span>
            <span class="c1"># This speeds up the searching for coordinates...</span>
            <span class="n">idxs_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">[</span><span class="n">idxs</span><span class="p">]</span>

            <span class="c1"># Loop the atoms inside</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
                <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">,</span> <span class="n">idxs</span><span class="p">,</span> <span class="n">idxs_xyz</span><span class="p">)</span>

            <span class="n">eta</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ias</span><span class="p">))</span>

        <span class="n">eta</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">finalized</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether the contained data is finalized and non-used elements have been removed&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalized</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">untile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">prefix</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">reps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">segment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="o">*</span><span class="n">args</span><span class="p">,</span>
        <span class="n">sym</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Untiles a sparse model into a minimum segment, reverse of `tile`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        prefix : {a, o}</span>
<span class="sd">           which quantity to request for the size of the matrix</span>
<span class="sd">        reps :</span>
<span class="sd">           number of untiles that needs to be performed</span>
<span class="sd">        axis :</span>
<span class="sd">           which axis we need to untile (length with be ``1/reps`` along this axis)</span>
<span class="sd">        segment :</span>
<span class="sd">           which segment to return, default to the first segment. For a fully symmetric</span>
<span class="sd">           system there should not be a difference, requesting different segments can</span>
<span class="sd">           be used to assert this is the case.</span>
<span class="sd">        sym :</span>
<span class="sd">           whether to symmetrize before returning</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create new geometry</span>
        <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">(</span><span class="n">record</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="k">as</span> <span class="n">w</span><span class="p">:</span>
            <span class="c1"># Cause all warnings to always be triggered.</span>
            <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;always&quot;</span><span class="p">)</span>
            <span class="c1"># Create new untiled geometry</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="c1"># Check whether the warning exists</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">category</span><span class="p">,</span> <span class="n">SislWarning</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="n">w</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">message</span><span class="p">)</span><span class="si">}</span><span class="se">\n</span><span class="s2">---</span><span class="se">\n</span><span class="s2">&quot;</span>
                        <span class="s2">&quot;The sparse matrix cannot be untiled as the structure &quot;</span>
                        <span class="s2">&quot;cannot be tiled accordingly. ANY use of the model has been &quot;</span>
                        <span class="s2">&quot;relieved from sisl.&quot;</span>
                    <span class="p">)</span>

        <span class="c1"># Now we need to re-create number of supercells</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;n</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">geom_no</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;n</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># orig-orbs</span>
        <span class="n">orig_orbs</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">segment</span> <span class="o">*</span> <span class="n">geom_no</span><span class="p">,</span> <span class="p">(</span><span class="n">segment</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">geom_no</span><span class="p">)</span>

        <span class="c1"># create correct linear offset due to the segment.</span>
        <span class="c1"># Further below we will take out the linear indices by modulo and integer</span>
        <span class="c1"># division operations.</span>
        <span class="n">lsc</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">,</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">reps</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">lsc</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">lsc</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">reps</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">reps</span><span class="p">)</span> <span class="o">-</span> <span class="n">segment</span>
        <span class="n">lsc</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># now we have the *correct* lsc that corresponds to the</span>
        <span class="c1"># sc_off in the cut structure.</span>
        <span class="c1"># We will later down correct the *wrong* indices</span>
        <span class="c1"># since we may have nsc == 1 and cut it X times.</span>
        <span class="c1"># In this case we may find [0, 1, 2, 3, ..., X-1]</span>
        <span class="c1"># which is clearly wrong. In stead we should determine</span>
        <span class="c1"># the correct nsc for the output geometry and convert it to</span>
        <span class="c1">#   [-X//2, ..., 0, ... , X//2] (or close to this)</span>

        <span class="c1"># First we need to figure out how long the interaction range is</span>
        <span class="c1"># in the cut-direction</span>
        <span class="c1"># We initialize to be the same as the parent direction</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># get unique couplings for the orbitals we are cutting out</span>
        <span class="c1"># we ensure the *onsite* columns are also there</span>
        <span class="c1"># create sample sparse pattern so we can figure out the columns</span>
        <span class="c1"># they connect to</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">sub</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">S</span><span class="p">[</span><span class="n">orig_orbs</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">indices</span><span class="p">),</span> <span class="n">orig_orbs</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">S</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.untile couples to no &quot;</span>
                <span class="s2">&quot;matrix elements, an empty sparse model cannot be split.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Figure out the supercell indices of sub</span>
        <span class="n">sub_sc</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">prefix</span><span class="si">}</span><span class="s2">2isc&quot;</span><span class="p">)(</span><span class="n">sub</span><span class="p">)</span>

        <span class="c1"># convert the sub_sc[axis] into the linear index to figure out the</span>
        <span class="c1"># actual number of required nsc</span>
        <span class="n">sub_lsc</span> <span class="o">=</span> <span class="p">(</span><span class="n">sub</span> <span class="o">%</span> <span class="n">no</span> <span class="o">+</span> <span class="n">sub_sc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">*</span> <span class="n">no</span><span class="p">)</span> <span class="o">//</span> <span class="n">geom_no</span> <span class="o">-</span> <span class="n">segment</span>

        <span class="c1"># calculate (sorted) unique linear cells</span>
        <span class="c1"># This is just to figure out how many we are connecting too</span>
        <span class="n">sub_lsc</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">sub_lsc</span><span class="p">)</span>

        <span class="c1"># determine the cut placement</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># no initial supercell, special handling</span>
            <span class="n">dsub_lsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sub_lsc</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">dsub_lsc</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">sub_lsc</span><span class="p">)</span> <span class="o">==</span> <span class="n">reps</span><span class="p">:</span>
                <span class="c1"># the full cut region is touched</span>
                <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">reps</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># here the couplings *touches* each others segments</span>
                <span class="c1"># We have to figure out if the couplings are *for* real</span>
                <span class="c1"># or whether we can easily cut them.</span>
                <span class="k">if</span> <span class="n">reps</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># an un-even number of couplings in total</span>
                    <span class="c1"># this means that the same couplings will be duplicated</span>
                    <span class="c1"># to the right and left.</span>
                    <span class="c1"># Example:</span>
                    <span class="c1">#   [-1 0 1 2] or [0 1 2 3]</span>
                    <span class="c1"># [0] -&gt; [2] positive direction</span>
                    <span class="c1"># [0] &lt;- [2] negative direction</span>
                    <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The elements connecting from the primary unit-cell to the </span><span class="si">{</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span><span class="o">//</span><span class="mi">2</span><span class="si">}</span><span class="s2"> unit-cell will be halved, sym=</span><span class="si">{</span><span class="n">sym</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;The returned matrix will not have symmetric couplings due to sym=</span><span class="si">{</span><span class="n">sym</span><span class="si">}</span><span class="s2"> argument.&quot;</span>

                    <span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.untile matrix has connections crossing &quot;</span>
                        <span class="s2">&quot;the entire unit cell. &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;This may result in wrong behavior due to non-unique matrix elements. </span><span class="si">{</span><span class="n">msg</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># even case</span>
                    <span class="c1">#   [-1 0 1]</span>
                    <span class="c1"># [0] -&gt; [1] positive direction</span>
                    <span class="c1"># [0] &lt;- [-1] negative direction</span>
                    <span class="c1"># or [0 1 2]</span>
                    <span class="c1"># [0] -&gt; [1] positive direction</span>
                    <span class="c1"># [0] &lt;- [2] negative direction</span>
                    <span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.untile may have connections crossing &quot;</span>
                        <span class="s2">&quot;the entire unit cell. &quot;</span>
                        <span class="s2">&quot;This may result in wrong behavior due to non-unique matrix elements.&quot;</span>
                    <span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we have something like</span>
                <span class="c1">#  [0 1 - 3]</span>
                <span class="c1"># meaning that there is a gab in the couplings</span>

                <span class="c1"># remove duplicate neighboring values</span>
                <span class="n">single_sel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sub_lsc</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
                <span class="n">single_sel</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">sub_lsc</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">!=</span> <span class="n">sub_lsc</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">single_sub_lsc</span> <span class="o">=</span> <span class="n">sub_lsc</span><span class="p">[</span><span class="n">single_sel</span><span class="p">]</span>
                <span class="n">axis0</span> <span class="o">=</span> <span class="p">(</span><span class="n">single_sub_lsc</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># initialize</span>
                <span class="n">pos_nsc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">while</span> <span class="n">found</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">single_sub_lsc</span><span class="p">[</span><span class="n">axis0</span> <span class="o">+</span> <span class="n">pos_nsc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">pos_nsc</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">pos_nsc</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">neg_nsc</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">while</span> <span class="n">found</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">single_sub_lsc</span><span class="p">[</span><span class="n">axis0</span> <span class="o">+</span> <span class="n">neg_nsc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="n">neg_nsc</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">neg_nsc</span> <span class="o">-=</span> <span class="mi">1</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>

                <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">pos_nsc</span><span class="p">,</span> <span class="o">-</span><span class="n">neg_nsc</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># correct the linear indices that are *too* high</span>
            <span class="n">hnsc</span> <span class="o">=</span> <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span>
            <span class="n">lsc</span><span class="p">[</span><span class="n">lsc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">hnsc</span><span class="p">,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">-=</span> <span class="n">reps</span>
            <span class="n">lsc</span><span class="p">[</span><span class="n">lsc</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">&lt;</span> <span class="o">-</span><span class="n">hnsc</span><span class="p">,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">+=</span> <span class="n">reps</span>
            <span class="c1"># this will still leave some supercell indices *wrong*</span>
            <span class="c1"># But the algorithm should detect that they are not coupled and</span>
            <span class="c1"># thus should not be queried.</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># *easy* case, we always have supercells so we can&#39;t cut too short</span>
            <span class="c1"># Simply track off the biggest one</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">sub_lsc</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="c1"># Create the to-columns</span>
            <span class="k">if</span> <span class="n">sub_lsc</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">!=</span> <span class="o">-</span><span class="n">sub_lsc</span><span class="o">.</span><span class="n">min</span><span class="p">():</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.untile found inconsistent supercell matrix. &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;The untiled sparse matrix couples to </span><span class="si">{</span><span class="n">sub_lsc</span><span class="si">}</span><span class="s2"> supercells but expected a symmetric set of couplings. &quot;</span>
                    <span class="s2">&quot;This may happen if doing multiple cuts along the same direction, or if the matrix is not correctly constructed.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Update number of super-cells</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Now we have the following items:</span>
        <span class="c1"># 1. sub_sc, the supercell offsets for the connecting orbitals</span>
        <span class="c1"># 2. lsc, containing the linear indices of sub_sc that are directly related</span>
        <span class="c1">#    to the cut structure</span>
        <span class="c1"># 3. geom, which is the cut structure</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">conv</span><span class="p">(</span><span class="n">dim</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">lsc</span>
            <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">dim</span><span class="p">)[</span><span class="n">orig_orbs</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">cols</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">indices</span>

            <span class="c1"># now convert cols</span>
            <span class="n">cols_lsc</span> <span class="o">=</span> <span class="n">lsc</span><span class="p">[</span><span class="n">cols</span> <span class="o">//</span> <span class="n">geom_no</span><span class="p">]</span>

            <span class="n">cols</span> <span class="o">=</span> <span class="n">cols</span> <span class="o">%</span> <span class="n">geom_no</span> <span class="o">+</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">cols_lsc</span><span class="p">)</span> <span class="o">*</span> <span class="n">geom_no</span>

            <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">(</span>
                <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">data</span><span class="p">,</span> <span class="n">cols</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">indptr</span><span class="p">),</span>
                <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom_no</span><span class="p">,</span> <span class="n">geom_no</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">),</span>
                <span class="n">dtype</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="n">Ps</span> <span class="o">=</span> <span class="p">[</span><span class="n">conv</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span> <span class="k">for</span> <span class="n">dim</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">)]</span>
        <span class="n">S</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fromsp</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">Ps</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="k">if</span> <span class="n">sym</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="k">return</span> <span class="n">S</span> <span class="o">+</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">S</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">unrepeat</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sym</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Unrepeats the sparse model into different parts (retaining couplings)</span>

<span class="sd">        Please see `untile` for details, the algorithm and arguments are the same however,</span>
<span class="sd">        this is the opposite of `repeat`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">reps</span><span class="p">)</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">finalize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Finalizes the model</span>

<span class="sd">        Finalizes the model so that all non-used elements are removed. I.e. this simply reduces the memory requirement for the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Adding more elements to the sparse matrix is more time-consuming than for a non-finalized sparse matrix due to the</span>
<span class="sd">        internal data-representation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">tocsr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a :class:`~scipy.sparse.csr_matrix` for the specified dimension</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim :</span>
<span class="sd">           the dimension in the sparse matrix (for non-orthogonal cases the last</span>
<span class="sd">           dimension is the overlap matrix)</span>
<span class="sd">        isc : int, optional</span>
<span class="sd">           the supercell index, or all (if ``isc=None``)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Requesting sub-sparse has not been implemented yet&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">tocsr</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spsame</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two sparse objects and check whether they have the same entries.</span>

<span class="sd">        This does not necessarily mean that the elements are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">spsame</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fromsp</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">geometry</span><span class="p">:</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">P</span><span class="p">:</span> <span class="n">OrSequence</span><span class="p">[</span><span class="n">SparseMatrix</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a sparse model from a preset `Geometry` and a list of sparse matrices</span>

<span class="sd">        The passed sparse matrices are in one of `scipy.sparse` formats.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry :</span>
<span class="sd">           geometry to describe the new sparse geometry</span>
<span class="sd">        P :</span>
<span class="sd">           the new sparse matrices that are to be populated in the sparse</span>
<span class="sd">           matrix</span>
<span class="sd">        **kwargs :</span>
<span class="sd">           any arguments that are directly passed to the `__init__` method</span>
<span class="sd">           of the class.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseGeometry</span>
<span class="sd">             a new sparse matrix that holds the passed geometry and the elements of `P`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure list of * format (to get dimensions)</span>
        <span class="k">if</span> <span class="n">issparse</span><span class="p">(</span><span class="n">P</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="p">[</span><span class="n">P</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="n">P</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">P</span><span class="p">)</span>

        <span class="n">p</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">P</span><span class="p">),</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">fromsp</span><span class="p">(</span><span class="n">P</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">p</span><span class="o">.</span><span class="n">_size</span> <span class="o">!=</span> <span class="n">P</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.fromsp cannot create a new class, the geometry &quot;</span>
                <span class="s2">&quot;and sparse matrices does not have coinciding dimensions size != P[0].shape[0]&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">p</span>

    <span class="c1"># numpy dispatch methods (same priority as SparseCSR!)</span>
    <span class="n">__array_priority__</span> <span class="o">=</span> <span class="mi">14</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__array_ufunc__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># grab the inputs and convert to the respective csr matrices</span>
        <span class="c1"># such that we can defer the call to that function</span>
        <span class="c1"># while converting, also grab the first _SparseGeometry</span>
        <span class="c1"># object such that we may create the output matrix</span>
        <span class="n">sp_inputs</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">obj</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">for</span> <span class="n">inp</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">inp</span><span class="p">,</span> <span class="n">_SparseGeometry</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># simply store a reference to the first argument that is a sparsegeometry</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">inp</span>
                <span class="n">sp_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">sp_inputs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">inp</span><span class="p">)</span>

        <span class="c1"># determine if the user requested output into</span>
        <span class="c1"># a specific container</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;out&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="p">(</span><span class="n">out</span><span class="p">,)</span> <span class="o">=</span> <span class="n">out</span>
            <span class="c1"># ensure the output returns in this field</span>
            <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;out&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">_csr</span><span class="p">,)</span>

        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">__array_ufunc__</span><span class="p">(</span><span class="n">ufunc</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">sp_inputs</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># check that the resulting variable is indeed a sparsecsr</span>
            <span class="k">assert</span> <span class="nb">isinstance</span><span class="p">(</span>
                <span class="n">result</span><span class="p">,</span> <span class="n">SparseCSR</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> (</span><span class="si">{</span><span class="n">ufunc</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">) requires out= to match the resulting operator&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">SparseCSR</span><span class="p">):</span>
            <span class="c1"># return a copy with the sparse result into the output sparse</span>
            <span class="c1"># matrix. If out was not None, the result should already</span>
            <span class="c1"># be stored in it.</span>
            <span class="k">if</span> <span class="n">out</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
                <span class="n">out</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># likely reductions etc.</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">result</span>
        <span class="k">return</span> <span class="n">out</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dictionary with the current state&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;geometry&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span>
            <span class="s2">&quot;csr&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dictionary with the current state&quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;geometry&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geom</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;csr&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">csr</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SparseAtom</span><span class="p">(</span><span class="n">_SparseGeometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sparse object with number of rows equal to the total number of atoms in the `Geometry`&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Elements for the index(s)&quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set or create elements in the sparse data</span>

<span class="sd">        Override set item for slicing operations and enables easy</span>
<span class="sd">        setting of parameters in a sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>

<div class="viewcode-block" id="SparseAtom.nonzero">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.nonzero">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">only_cols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices row and column indices where non-zero elements exists</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           only return the tuples for the requested atoms, default is all atoms</span>
<span class="sd">        only_cols :</span>
<span class="sd">           only return the non-zero columns</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.nonzero : the equivalent function call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">rows</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">only_cols</span><span class="o">=</span><span class="n">only_cols</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseAtom.iter_nnz">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.iter_nnz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            only loop on the non-zero elements coinciding with the atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseAtom.set_nsc">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.set_nsc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the number of allowed supercells in the sparse atom</span>

<span class="sd">        If one reduces the number of supercells *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `Lattice.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Lattice.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseAtom.untile">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.untile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">untile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sym</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Untiles the sparse model into different parts (retaining couplings)</span>

<span class="sd">        Recreates a new sparse object with only the cutted</span>
<span class="sd">        atoms in the structure. This will preserve matrix elements in the supercell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps :</span>
<span class="sd">           number of repetitions the tiling function created (opposite meaning as in `untile`)</span>
<span class="sd">        axis :</span>
<span class="sd">           which axis to untile along</span>
<span class="sd">        segment :</span>
<span class="sd">           which segment to retain. Generally each segment should be equivalent, however</span>
<span class="sd">           requesting individiual segments can help uncover inconsistencies in the sparse matrix</span>
<span class="sd">        *args :</span>
<span class="sd">           arguments passed directly to `Geometry.untile`</span>
<span class="sd">        sym :</span>
<span class="sd">           if True, the algorithm will ensure the returned matrix is symmetrized (i.e.</span>
<span class="sd">           return ``(M + M.transpose())/2``, else return data as is.</span>
<span class="sd">           False should generally only be used for debugging precision of the matrix elements,</span>
<span class="sd">           or if one wishes to check the warnings.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">           keyword arguments passed directly to `Geometry.untile`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Untiling structures with ``nsc == 1`` along `axis` are assumed to have periodic boundary</span>
<span class="sd">        conditions.</span>

<span class="sd">        When untiling structures with ``nsc == 1`` along `axis` it is important to</span>
<span class="sd">        untile *as much as possible*. This is because otherwise the algorithm cannot determine</span>
<span class="sd">        the correct couplings. Therefore to create a geometry of 3 times a unit-cell, one should</span>
<span class="sd">        untile to the unit-cell, and subsequently tile 3 times.</span>

<span class="sd">        Consider for example a system of 4 atoms, each atom connects to its 2 neighbors.</span>
<span class="sd">        Due to the PBC atom 0 will connect to 1 and 3. Untiling this structure in 2 will</span>
<span class="sd">        group couplings of atoms 0 and 1. As it will only see one coupling to the right</span>
<span class="sd">        it will halve the coupling and use the same coupling to the left, which is clearly wrong.</span>

<span class="sd">        In the following the latter is the correct way to do it.</span>

<span class="sd">        &gt;&gt;&gt; SPM.untile(2, 0) != SPM.untile(4, 0).tile(2, 0)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError :</span>
<span class="sd">           in case the matrix elements are not conseuctive when determining the</span>
<span class="sd">           new supercell structure. This may often happen if untiling a matrix</span>
<span class="sd">           too few times, and then untiling it again.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : opposite of this method</span>
<span class="sd">        Geometry.untile : same as this method, see details about parameters here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="s2">&quot;a&quot;</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseAtom.rij">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.rij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a sparse matrix with the distance between atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with distances are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse distance when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="SparseAtom.Rij">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseAtom.html#sisl.SparseAtom.Rij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a sparse matrix with vectors between atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with vectors are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse vector matrix when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span>

        <span class="c1"># Pointers</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span>

        <span class="c1"># Create the output class</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Re-create the sparse matrix data</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="n">ncol</span><span class="p">[</span><span class="n">ia</span><span class="p">])</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">R</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SparseOrbital</span><span class="p">(</span><span class="n">_SparseGeometry</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sparse object with number of rows equal to the total number of orbitals in the `Geometry`&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Elements for the index(s)&quot;&quot;&quot;</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">val</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Set or create elements in the sparse data</span>

<span class="sd">        Override set item for slicing operations and enables easy</span>
<span class="sd">        setting of parameters in a sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># This may be a specification of supercell indices</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="nb">tuple</span><span class="p">):</span>
                <span class="c1"># We guess it is the supercell index</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
                <span class="n">key</span> <span class="o">=</span> <span class="p">[</span><span class="n">el</span> <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="n">key</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">+</span> <span class="n">off</span>
        <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">if</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">2</span> <span class="k">else</span> <span class="n">k</span> <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="n">dd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span>
        <span class="k">if</span> <span class="n">dd</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="n">dd</span><span class="p">,)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_def_dim</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>

<div class="viewcode-block" id="SparseOrbital.edges">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.edges">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">edges</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">exclude</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve edges (connections) for all `atoms`</span>

<span class="sd">        The returned edges are unique and sorted (see `numpy.unique`) and are returned</span>
<span class="sd">        in supercell indices (i.e. ``0 &lt;= edge &lt; self.geometry.no_s``).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            the edges are returned only for the given atom (but by using  all orbitals of the</span>
<span class="sd">            requested atom). The returned edges are also atoms.</span>
<span class="sd">        exclude :</span>
<span class="sd">           remove edges which are in the `exclude` list, this list refers to orbitals.</span>
<span class="sd">        orbitals : int or list of int</span>
<span class="sd">            the edges are returned only for the given orbital. The returned edges are orbitals.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        indices :</span>
<span class="sd">            If `orbitals` is None, the returned indices are atomic indices.</span>
<span class="sd">            Otherwise it will be orbital indices.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.edges: the underlying routine used for extracting the edges</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">exclude</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">exclude</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.edges must have either &#39;atoms&#39; or &#39;orbitals&#39; keyword defined.&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbs</span><span class="p">,</span> <span class="n">exclude</span><span class="p">),</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">exclude</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseOrbital.nonzero">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.nonzero">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">nonzero</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">only_cols</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices row and column indices where non-zero elements exists</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           only return the tuples for the requested atoms, default is all atoms</span>
<span class="sd">           But for *all* orbitals.</span>
<span class="sd">        only_cols :</span>
<span class="sd">           only return then non-zero columns</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        SparseCSR.nonzero : the equivalent function call</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">only_cols</span><span class="o">=</span><span class="n">only_cols</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nonzero</span><span class="p">(</span><span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">,</span> <span class="n">only_cols</span><span class="o">=</span><span class="n">only_cols</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseOrbital.iter_nnz">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.iter_nnz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_nnz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterations of the non-zero elements</span>

<span class="sd">        An iterator on the sparse matrix with, row and column</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; for i, j in self.iter_nnz():</span>
<span class="sd">        ...    self[i, j] # is then the non-zero value</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            only loop on the non-zero elements coinciding with the orbitals</span>
<span class="sd">            on these atoms (not compatible with the `orbitals` keyword)</span>
<span class="sd">        orbitals : int or array_like</span>
<span class="sd">            only loop on the non-zero elements coinciding with the orbital</span>
<span class="sd">            (not compatible with the `atoms` keyword)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">iter_nnz</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseOrbital.set_nsc">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.set_nsc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset the number of allowed supercells in the sparse orbital</span>

<span class="sd">        If one reduces the number of supercells *any* sparse element</span>
<span class="sd">        that references the supercell will be deleted.</span>

<span class="sd">        See `Lattice.set_nsc` for allowed parameters.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Lattice.set_nsc : the underlying called method</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseOrbital.remove_orbital">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.remove_orbital">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a subset of orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        For more detailed examples, please see the equivalent (but opposite) method</span>
<span class="sd">        `sub_orbital`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atoms` that are removed from the sparse matrix.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sub_orbital : retaining a set of orbitals (see here for examples)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specie index of the atom (convert to list of indices)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_species</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_species</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_species</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">remove_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="c1"># We know np.all(geom.atoms[atom] == old_atom)</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_atom</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>

        <span class="c1"># now call sub_orbital</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseOrbital.sub_orbital">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.sub_orbital">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sub_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SeqOrScalarInt</span><span class="p">,</span> <span class="n">Orbital</span><span class="p">]):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Retain only a subset of the orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        This allows one to retain only a given subset of the sparse matrix elements.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals :</span>
<span class="sd">            indices of the orbitals on `atoms` that are retained in the sparse matrix, the list of</span>
<span class="sd">            orbitals will be sorted. One cannot re-arrange matrix elements currently.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Future implementations may allow one to re-arrange orbitals using this method.</span>

<span class="sd">        When using this method the internal species list will be populated by another species</span>
<span class="sd">        that is named after the orbitals removed. This is to distinguish different atoms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; # a Carbon atom with 2 orbitals</span>
<span class="sd">        &gt;&gt;&gt; C = sisl.Atom(&#39;C&#39;, [1., 2.])</span>
<span class="sd">        &gt;&gt;&gt; # an oxygen atom with 3 orbitals</span>
<span class="sd">        &gt;&gt;&gt; O = sisl.Atom(&#39;O&#39;, [1., 2., 2.4])</span>
<span class="sd">        &gt;&gt;&gt; geometry = sisl.Geometry([[0] * 3, [1] * 3]], 2, [C, O])</span>
<span class="sd">        &gt;&gt;&gt; obj = SparseOrbital(geometry).tile(3, 0)</span>
<span class="sd">        &gt;&gt;&gt; # fill in obj data...</span>

<span class="sd">        Now ``obj`` is a sparse geometry with 2 different species and 6 atoms (3 of each).</span>
<span class="sd">        They are ordered ``[C, O, C, O, C, O]``. In the following we</span>
<span class="sd">        will note species that are different from the original by a ``&#39;`` in the list.</span>

<span class="sd">        Retain 2nd orbital on the 2nd atom: ``[C, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(1, 1)</span>

<span class="sd">        Retain 2nd orbital on 1st and 2nd atom: ``[C&#39;, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital([0, 1], 1)</span>

<span class="sd">        Retain 2nd orbital on the 1st atom and 3rd orbital on 4th atom: ``[C&#39;, O, C, O&#39;, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(0, 1).sub_orbital(3, 2)</span>

<span class="sd">        Retain 2nd orbital on all atoms equivalent to the first atom: ``[C&#39;, O, C&#39;, O, C&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(obj.geometry.atoms[0], 1)</span>

<span class="sd">        Retain 1st orbital on 1st atom, and 2nd orbital on 3rd and 5th atom: ``[C&#39;, O, C&#39;&#39;, O, C&#39;&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_obj = obj.sub_orbital(0, 0).sub_orbital([2, 4], 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        remove_orbital : removing a set of orbitals (opposite of this)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_species</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_species</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_species</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># At this point we are sure that uniq_species is *only* one species!</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># Now create the new sparse orbital class</span>
        <span class="n">SG</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>

        <span class="n">rem_orbs</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">old_atom</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">orbitals</span><span class="p">)</span>
        <span class="c1"># Find orbitals to remove (note this HAS to be from the original array)</span>
        <span class="n">rem_orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">),</span> <span class="n">rem_orbs</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Generate a list of orbitals to retain</span>
        <span class="n">sub_idx</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">rem_orbs</span><span class="p">)</span>

        <span class="c1"># Generate full supercell indices</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span>
        <span class="n">sc_off</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">sub_idx</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">sub_idx</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">SG</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">sub_idx</span><span class="p">)</span>

        <span class="c1"># just ensure we are doing the correct thing</span>
        <span class="k">assert</span> <span class="n">SG</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">SG</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>

        <span class="k">return</span> <span class="n">SG</span></div>


<div class="viewcode-block" id="SparseOrbital.untile">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.untile">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">untile</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">reps</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">segment</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sym</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Untiles the sparse model into different parts (retaining couplings)</span>

<span class="sd">        Recreates a new sparse object with only the cutted</span>
<span class="sd">        atoms in the structure. This will preserve matrix elements in the supercell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        reps :</span>
<span class="sd">           number of repetitions the tiling function created (opposite meaning as in `untile`)</span>
<span class="sd">        axis :</span>
<span class="sd">           which axis to untile along</span>
<span class="sd">        segment :</span>
<span class="sd">           which segment to retain. Generally each segment should be equivalent, however</span>
<span class="sd">           requesting individiual segments can help uncover inconsistencies in the sparse matrix</span>
<span class="sd">        *args :</span>
<span class="sd">           arguments passed directly to `Geometry.untile`</span>
<span class="sd">        sym :</span>
<span class="sd">           if True, the algorithm will ensure the returned matrix is symmetrized (i.e.</span>
<span class="sd">           return ``(M + M.transpose())/2``, else return data as is.</span>
<span class="sd">           False should generally only be used for debugging precision of the matrix elements,</span>
<span class="sd">           or if one wishes to check the warnings.</span>
<span class="sd">        **kwargs :</span>
<span class="sd">           keyword arguments passed directly to `Geometry.untile`</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Untiling structures with ``nsc == 1`` along `axis` are assumed to have periodic boundary</span>
<span class="sd">        conditions.</span>

<span class="sd">        When untiling structures with ``nsc == 1`` along `axis` it is important to</span>
<span class="sd">        untile *as much as possible*. This is because otherwise the algorithm cannot determine</span>
<span class="sd">        the correct couplings. Therefore to create a geometry of 3 times a unit-cell, one should</span>
<span class="sd">        untile to the unit-cell, and subsequently tile 3 times.</span>

<span class="sd">        Consider for example a system of 4 atoms, each atom connects to its 2 neighbors.</span>
<span class="sd">        Due to the PBC atom 0 will connect to 1 and 3. Untiling this structure in 2 will</span>
<span class="sd">        group couplings of atoms 0 and 1. As it will only see one coupling to the right</span>
<span class="sd">        it will halve the coupling and use the same coupling to the left, which is clearly wrong.</span>

<span class="sd">        In the following the latter is the correct way to do it.</span>

<span class="sd">        &gt;&gt;&gt; SPM.untile(2, 0) != SPM.untile(4, 0).tile(2, 0)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError :</span>
<span class="sd">           in case the matrix elements are not conseuctive when determining the</span>
<span class="sd">           new supercell structure. This may often happen if untiling a matrix</span>
<span class="sd">           too few times, and then untiling it again.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : opposite of this method</span>
<span class="sd">        Geometry.untile : same as this method, see details about parameters here</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="s2">&quot;o&quot;</span><span class="p">,</span> <span class="n">reps</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">segment</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">sym</span><span class="o">=</span><span class="n">sym</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseOrbital.rij">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.rij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a sparse matrix with the distance between atoms/orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        what : {&#39;orbital&#39;, &#39;atom&#39;}</span>
<span class="sd">            which kind of sparse distance matrix to return, either an atomic distance matrix</span>
<span class="sd">            or an orbital distance matrix. The orbital matrix is equivalent to the atomic</span>
<span class="sd">            one with the same distance repeated for the same atomic orbitals.</span>
<span class="sd">            The default is the same type as the parent class.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with distances are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse distance when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">what</span><span class="p">,</span> <span class="n">dtype</span><span class="p">)</span>
        <span class="n">R</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="SparseOrbital.Rij">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.Rij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a sparse matrix with the vectors between atoms/orbitals</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        what : {&#39;orbital&#39;, &#39;atom&#39;}</span>
<span class="sd">            which kind of sparse vector matrix to return, either an atomic vector matrix</span>
<span class="sd">            or an orbital vector matrix. The orbital matrix is equivalent to the atomic</span>
<span class="sd">            one with the same vectors repeated for the same atomic orbitals.</span>
<span class="sd">            The default is the same type as the parent class.</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the data-type of the sparse matrix.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The returned sparse matrix with vectors are taken from the current sparse pattern.</span>
<span class="sd">        I.e. a subsequent addition of sparse elements will make them inequivalent.</span>
<span class="sd">        It is thus important to *only* create the sparse vector matrix when the sparse</span>
<span class="sd">        structure is completed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># Pointers</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span>

        <span class="k">if</span> <span class="n">what</span> <span class="o">==</span> <span class="s2">&quot;atom&quot;</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">ncol</span><span class="p">))</span>
            <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span>
            <span class="n">o2a</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span>

            <span class="c1"># Orbitals</span>
            <span class="n">orow</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="c1"># Loop on orbitals and atoms</span>
            <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">orow</span><span class="p">,</span> <span class="n">o2a</span><span class="p">(</span><span class="n">orow</span><span class="p">)):</span>
                <span class="n">coln</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">o2a</span><span class="p">(</span><span class="n">col</span><span class="p">[</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span> <span class="p">:</span> <span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span> <span class="o">+</span> <span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">]]))</span>
                <span class="n">R</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">coln</span><span class="p">]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">coln</span><span class="p">)</span>

        <span class="k">elif</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;orb&quot;</span><span class="p">):</span>
            <span class="c1"># We create an *exact* copy of the Rij</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">SparseOrbital</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">oRij</span>

            <span class="c1"># Re-create the sparse matrix data</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalized</span>

            <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                <span class="n">sl</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">],</span> <span class="n">ptr</span><span class="p">[</span><span class="n">io</span><span class="p">]</span> <span class="o">+</span> <span class="n">ncol</span><span class="p">[</span><span class="n">io</span><span class="p">])</span>
                <span class="n">R</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">sl</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">io</span><span class="p">,</span> <span class="n">col</span><span class="p">[</span><span class="n">sl</span><span class="p">])</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.Rij &quot;what&quot; is not one of [atom, orbital].&#39;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">R</span></div>


<div class="viewcode-block" id="SparseOrbital.add">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.add">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="n">Coord</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Add two sparse matrices by adding the parameters to one set. The final matrix will have no couplings between `self` and `other`</span>

<span class="sd">        The final sparse matrix will not have any couplings between `self` and `other`. Not even if they</span>
<span class="sd">        have commensurate overlapping regions. If you want to create couplings you have to use `append` but that</span>
<span class="sd">        requires the structures are commensurate in the coupling region.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : SparseGeometry</span>
<span class="sd">            the other sparse matrix to be added, all atoms will be appended</span>
<span class="sd">        axis :</span>
<span class="sd">            whether a specific axis of the cell will be added to the final geometry.</span>
<span class="sd">            For ``None`` the final cell will be that of `self`, otherwise the lattice</span>
<span class="sd">            vector corresponding to `axis` will be appended.</span>
<span class="sd">        offset :</span>
<span class="sd">            offset in geometry of `other` when adding the atoms.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        append : append two matrices by also adding overlap couplings</span>
<span class="sd">        prepend : see `append`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that the sparse matrices are compatible</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;.add requires other to be of same type: </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="o">+</span> <span class="s2">&quot;.add requires the same datatypes in the two matrices.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="o">+</span> <span class="s2">&quot;.add requires the same number of dimensions in the matrix.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Same effect but also adds the lattice vectors</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>

        <span class="c1"># Now we have the correct geometry, then create the correct</span>
        <span class="c1"># class</span>
        <span class="c1"># New indices and data (the constructor for SparseCSR copies)</span>
        <span class="n">full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="p">:]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># Retrieve the maximum number of orbitals (in the supercell)</span>
        <span class="c1"># This may be used to remove couplings</span>
        <span class="n">full_no_s</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span>

        <span class="c1"># Now we have to transfer the indices to the new sparse pattern</span>

        <span class="c1"># First create a local copy of the columns, then we transfer, and then we collect.</span>
        <span class="n">s_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">transfer_idx</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="c1"># Remove couplings along axis</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Tell the routine to delete these indices</span>
            <span class="n">transfer_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">full_no_s</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="c1"># Same for the other, but correct for deleted supercells and supercells along</span>
        <span class="c1"># disconnected auxiliary cells.</span>
        <span class="n">o_col</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>

        <span class="c1"># Transfer the correct supercells</span>
        <span class="n">o_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">s_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">idx_delete</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">isc</span><span class="p">,</span> <span class="n">sc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">s_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">sc</span><span class="p">))</span>
                <span class="n">o_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                <span class="n">idx_delete</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
        <span class="c1"># o_idx are transferred to s_idx</span>
        <span class="n">transfer_idx</span><span class="p">[</span><span class="n">o_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)[</span><span class="n">s_idx</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="p">)</span>
        <span class="c1"># Remove some columns</span>
        <span class="n">transfer_idx</span><span class="p">[</span><span class="n">idx_delete</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">full_no_s</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Clean-up to not confuse the rest of the algorithm</span>
        <span class="k">del</span> <span class="n">o_idx</span><span class="p">,</span> <span class="n">s_idx</span><span class="p">,</span> <span class="n">idx_delete</span>

        <span class="c1"># Now figure out if the supercells can be kept, at all...</span>
        <span class="c1"># find SC indices in other corresponding to self</span>
        <span class="c1"># o_idx_uc = other.geometry.lattice.sc_index([0] * 3)</span>
        <span class="c1"># o_idx_sc = _a.arangei(other.geometry.lattice.n_s)</span>

        <span class="c1"># Remove couplings along axis</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="n">axis</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:],</span> <span class="n">other</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]):</span>
                <span class="c1"># This will happen in case `axis` is None</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># When axis is not specified and cell parameters</span>
                <span class="c1"># are commensurate, then we will not change couplings</span>
                <span class="k">continue</span>
            <span class="c1"># Tell the routine to delete these indices</span>
            <span class="n">transfer_idx</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">full_no_s</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="c1"># Now we need to decide whether the</span>
        <span class="k">del</span> <span class="n">transfer_idx</span><span class="p">,</span> <span class="n">idx</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">([</span><span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span><span class="p">])</span>

        <span class="c1"># Clean up (they could potentially be very large arrays)</span>
        <span class="k">del</span> <span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span>

        <span class="c1"># Ensure we remove the elements</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_clean_columns</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">full</span></div>


<div class="viewcode-block" id="SparseOrbital.prepend">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.prepend">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;eps&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument eps has been deprecated in favor of atol.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">prepend</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="n">SeqOrScalarFloat</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;See `append` for details</span>

<span class="sd">        This is currently equivalent to:</span>

<span class="sd">        &gt;&gt;&gt; other.append(self, axis, atol, scale)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">other</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">atol</span><span class="p">,</span> <span class="n">scale</span><span class="p">)</span></div>


<div class="viewcode-block" id="SparseOrbital.append">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.append">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;eps&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument eps has been deprecated in favor of atol.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">append</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span> <span class="n">scale</span><span class="p">:</span> <span class="n">SeqOrScalarFloat</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Append `other` along `axis` to construct a new connected sparse matrix</span>

<span class="sd">        This method tries to append two sparse geometry objects together by</span>
<span class="sd">        the following these steps:</span>

<span class="sd">        1. Create the new extended geometry</span>
<span class="sd">        2. Use neighbor cell couplings from `self` as the couplings to `other`</span>
<span class="sd">           This *may* cause problems if the coupling atoms are not exactly equi-positioned.</span>
<span class="sd">           If the coupling coordinates and the coordinates in `other` differ by more than</span>
<span class="sd">           0.01 Ang, a warning will be issued.</span>
<span class="sd">           If this difference is above `atol` the couplings will be removed.</span>

<span class="sd">        When appending sparse matrices made up of atoms, this method assumes that</span>
<span class="sd">        the orbitals on the overlapping atoms have the same orbitals, as well as the</span>
<span class="sd">        same orbital ordering.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; sporb = SparseOrbital(....)</span>
<span class="sd">        &gt;&gt;&gt; sporb2 = sporb.append(sporb, 0)</span>
<span class="sd">        &gt;&gt;&gt; sporbt = sporb.tile(2, 0)</span>
<span class="sd">        &gt;&gt;&gt; sporb2.spsame(sporbt)</span>
<span class="sd">        True</span>

<span class="sd">        To retain couplings only from the *left* sparse matrix, do:</span>

<span class="sd">        &gt;&gt;&gt; sporb = left.append(right, 0, scale=(2, 0))</span>
<span class="sd">        &gt;&gt;&gt; sporb = (sporb + sporb.transpose()) / 2</span>

<span class="sd">        To retain couplings only from the *right* sparse matrix, do:</span>

<span class="sd">        &gt;&gt;&gt; sporb = left.append(right, 0, scale=(0, 2.))</span>
<span class="sd">        &gt;&gt;&gt; sporb = (sporb + sporb.transpose()) / 2</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The current implementation does not preserve the hermiticity of the matrix.</span>
<span class="sd">        If you want to preserve hermiticity of the matrix you have to do the</span>
<span class="sd">        following:</span>

<span class="sd">        &gt;&gt;&gt; sm = (sm + sm.transpose()) / 2</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : object</span>
<span class="sd">            must be an object of the same type as `self`</span>
<span class="sd">        axis :</span>
<span class="sd">            axis to append the two sparse geometries along</span>
<span class="sd">        atol :</span>
<span class="sd">            tolerance that all coordinates *must* be within to allow an append.</span>
<span class="sd">            It is important that this value is smaller than half the distance between</span>
<span class="sd">            the two closests atoms such that there is no ambiguity in selecting</span>
<span class="sd">            equivalent atoms. An internal stricter tolerance is used as a baseline, see above.</span>
<span class="sd">        scale : float or array_like, optional</span>
<span class="sd">            the scale used for the overlapping region. For scalar values it corresponds</span>
<span class="sd">            to passing: ``(scale, scale)``.</span>
<span class="sd">            For array-like input ``scale[0]`` refers to the scale of the matrix elements</span>
<span class="sd">            coupling from `self`, while ``scale[1]`` is the scale of the matrix elements</span>
<span class="sd">            in `other`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        prepend : equivalent scheme as this method</span>
<span class="sd">        add : merge two matrices without considering overlap or commensurability</span>
<span class="sd">        transpose : ensure hermiticity by using this routine</span>
<span class="sd">        replace : replace a sub-set of atoms with another sparse matrix</span>
<span class="sd">        Geometry.append</span>
<span class="sd">        Geometry.prepend</span>
<span class="sd">        SparseCSR.scale_columns : method used to scale the two matrix elements values</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">            if the two geometries are not compatible for either coordinate, orbital or supercell errors</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            a new instance with two sparse matrices joined and appended together</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="nb">type</span><span class="p">(</span><span class="n">other</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires other to be of same type: </span><span class="si">{</span><span class="n">other</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span> <span class="ow">or</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires sparse-geometries to maximally &quot;</span>
                <span class="s2">&quot;have 3 supercells along appending axis.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires sparse-geometries to have the same &quot;</span>
                <span class="s2">&quot;number of supercells along all directions.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">_isc_off</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">_isc_off</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires supercell offsets to be the same.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dtype</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires the same datatypes in the two matrices.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">!=</span> <span class="n">other</span><span class="o">.</span><span class="n">dim</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires the same number of dimensions in the matrix.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">scale</span><span class="p">,</span> <span class="n">scale</span><span class="p">])</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>

        <span class="c1"># Our procedure will be to separate the sparsity patterns into separate chunks</span>
        <span class="c1"># First generate the full geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">axis</span><span class="p">)</span>

        <span class="c1"># create the new sparsity patterns with offset</span>

        <span class="c1"># New indices and data (the constructor for SparseCSR copies)</span>
        <span class="n">full</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dim</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_cls_kwargs</span><span class="p">())</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="p">:]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">))</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># First create a local copy of the columns, then we transfer, and then we collect.</span>
        <span class="n">s_col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># transfer</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">transfer_idx</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">s_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="n">o_col</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># transfer</span>
        <span class="n">transfer_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">transfer_idx</span> <span class="o">+=</span> <span class="p">(</span>
            <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">other</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">transfer_idx</span><span class="o">.</span><span class="n">ravel</span><span class="p">()[</span><span class="n">o_col</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>

        <span class="c1"># Store all column indices</span>
        <span class="k">del</span> <span class="n">transfer_idx</span><span class="p">,</span> <span class="n">idx</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span><span class="p">))</span>

        <span class="c1"># Clean up (they could potentially be very large arrays)</span>
        <span class="k">del</span> <span class="n">s_col</span><span class="p">,</span> <span class="n">o_col</span>

        <span class="c1"># Now everything is contained in 1 sparse matrix.</span>
        <span class="c1"># All matrix elements are as though they are in their own</span>

        <span class="c1"># What needs to be done is to find the overlapping atoms and transfer indices in</span>
        <span class="c1"># both these sparsity patterns to the correct elements.</span>

        <span class="c1"># 1. find overlapping atoms along axis</span>
        <span class="n">idx_s_first</span><span class="p">,</span> <span class="n">idx_o_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>
        <span class="n">idx_s_last</span><span class="p">,</span> <span class="n">idx_o_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
            <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=-</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:],</span>
            <span class="n">offset_other</span><span class="o">=-</span><span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:],</span>
        <span class="p">)</span>

        <span class="c1"># IFF idx_s_* contains duplicates, then we have multiple overlapping atoms which is not</span>
        <span class="c1"># allowed</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_test</span><span class="p">(</span><span class="n">diff</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">diff</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">diff</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires that there is maximally one &quot;</span>
                    <span class="s2">&quot;atom overlapping one other atom in the other structure.&quot;</span>
                <span class="p">)</span>

        <span class="n">_test</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">idx_s_first</span><span class="p">))</span>
        <span class="n">_test</span><span class="p">(</span><span class="n">diff</span><span class="p">(</span><span class="n">idx_s_last</span><span class="p">))</span>
        <span class="c1"># Also ensure that atoms have the same number of orbitals in the two cases</span>
        <span class="k">if</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_s_first</span><span class="p">],</span>
                <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_o_first</span><span class="p">],</span>
            <span class="p">)</span>
        <span class="p">)</span> <span class="ow">or</span> <span class="p">(</span>
            <span class="ow">not</span> <span class="n">allclose</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_s_last</span><span class="p">],</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">idx_o_last</span><span class="p">]</span>
            <span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires the overlapping geometries &quot;</span>
                <span class="s2">&quot;to have the same number of orbitals per atom that is to be replaced.&quot;</span>
            <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_check_edges_and_coordinates</span><span class="p">(</span><span class="n">spgeom</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">err_help</span><span class="p">):</span>
            <span class="c1"># Figure out if we have found all couplings</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">spgeom</span><span class="o">.</span><span class="n">geometry</span>
            <span class="c1"># Find orbitals that we wish to exclude from the orbital connections</span>
            <span class="c1"># This ensures that we only find couplings crossing the supercell boundaries</span>
            <span class="n">irrelevant_sc</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span>
                <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">n_s</span><span class="p">),</span> <span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="p">)</span>
            <span class="n">sc_orbitals</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">n_s</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">exclude</span> <span class="o">=</span> <span class="n">sc_orbitals</span><span class="p">[</span><span class="n">irrelevant_sc</span><span class="p">,</span> <span class="p">:]</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="c1"># get connections and transfer them to the unit-cell</span>
            <span class="n">edges_sc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span>
                <span class="n">spgeom</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">),</span> <span class="n">exclude</span><span class="o">=</span><span class="n">exclude</span><span class="p">),</span> <span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">edges_uc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">edges_sc</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
            <span class="n">edges_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges_uc</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">edges_valid</span><span class="p">):</span>
                <span class="n">edges_uc</span> <span class="o">=</span> <span class="n">edges_sc</span> <span class="o">%</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
                <span class="c1"># Reduce edges to those that are faulty</span>
                <span class="n">edges_valid</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">edges_uc</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="n">edges_sc</span><span class="p">[</span><span class="o">~</span><span class="n">edges_valid</span><span class="p">]</span>
                <span class="c1"># Get supercell offset and unit-cell atom</span>
                <span class="n">isc_off</span><span class="p">,</span> <span class="n">uca</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">errors</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
                <span class="c1"># group atoms for each supercell index</span>
                <span class="c1"># find unique supercell offsets</span>
                <span class="n">sc_off_atoms</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># This will be much faster</span>
                <span class="k">for</span> <span class="n">isc</span> <span class="ow">in</span> <span class="n">unique</span><span class="p">(</span><span class="n">isc_off</span><span class="p">):</span>
                    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">isc_off</span> <span class="o">==</span> <span class="n">isc</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="n">sc_off_atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;</span><span class="si">{k}</span><span class="s2">: </span><span class="si">{v}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="n">k</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">isc</span><span class="p">]),</span>
                            <span class="n">v</span><span class="o">=</span><span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">uca</span><span class="p">[</span><span class="n">idx</span><span class="p">])),</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="n">sc_off_atoms</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">   &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sc_off_atoms</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.append requires matching coupling elements.</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;The following atoms in a </span><span class="si">{</span><span class="n">err_help</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2"> connection of `</span><span class="si">{</span><span class="n">err_help</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="si">}</span><span class="s2">` super-cell &quot;</span>
                    <span class="s2">&quot;are connected from the unit cell, but are not found in matches:</span><span class="se">\n\n</span><span class="s2">&quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;[sc-offset]: atoms</span><span class="se">\n</span><span class="s2">   </span><span class="si">{</span><span class="n">sc_off_atoms</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># setup supercells to look up</span>
        <span class="n">isc_inplace</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="n">isc_inplace</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">isc_forward</span> <span class="o">=</span> <span class="n">isc_inplace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">isc_forward</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">isc_back</span> <span class="o">=</span> <span class="n">isc_inplace</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">isc_back</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="c1"># Check that edges and overlapping atoms are the same (or at least that the</span>
        <span class="c1"># edges are all in the overlapping region)</span>
        <span class="c1"># [self|other]: self sc-connections forward must be on left-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">idx_s_first</span><span class="p">,</span> <span class="n">isc_forward</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;forward&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># [other|self]: other sc-connections forward must be on left-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">idx_o_first</span><span class="p">,</span> <span class="n">isc_forward</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="s2">&quot;forward&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># [other|self]: self sc-connections backward must be on right-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">idx_s_last</span><span class="p">,</span> <span class="n">isc_back</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;self&quot;</span><span class="p">,</span> <span class="s2">&quot;backward&quot;</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># [self|other]: other sc-connections backward must be on right-aligned matching atoms</span>
        <span class="n">_check_edges_and_coordinates</span><span class="p">(</span>
            <span class="n">other</span><span class="p">,</span> <span class="n">idx_o_last</span><span class="p">,</span> <span class="n">isc_back</span><span class="p">,</span> <span class="n">err_help</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;other&quot;</span><span class="p">,</span> <span class="s2">&quot;backward&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Now we have ensured that the overlapping coordinates and the connectivity graph</span>
        <span class="c1"># co-incide and that we can actually perform the merge.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_sc_index_sort</span><span class="p">(</span><span class="n">isc</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="c1"># Now sort so that all indices are corresponding one2one</span>
            <span class="c1"># This is important since two different supercell indices</span>
            <span class="c1"># need not be sorted in the same manner.</span>
            <span class="c1"># This ensures that there is a correspondance between</span>
            <span class="c1"># two different sparse elements</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">axis</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">(</span><span class="n">off</span><span class="p">)]</span>

        <span class="n">idx_iscP</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">_sc_index_sort</span><span class="p">(</span><span class="n">isc_forward</span><span class="p">)]</span>
        <span class="n">idx_isc0</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">_sc_index_sort</span><span class="p">(</span><span class="n">isc_inplace</span><span class="p">)]</span>
        <span class="n">idx_iscM</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">_sc_index_sort</span><span class="p">(</span><span class="n">isc_back</span><span class="p">)]</span>
        <span class="c1"># Clean (for me to know what to do in this code)</span>
        <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">_sc_index_sort</span>

        <span class="c1"># First scale all values</span>
        <span class="n">idx_s_first</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_s_first</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">idx_s_last</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_s_last</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="p">((</span><span class="n">idx_s_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="n">idx_s_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">idx_o_first</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_o_first</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="p">)</span>
        <span class="n">idx_o_last</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx_o_last</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="p">((</span><span class="n">idx_o_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="p">(</span><span class="n">idx_o_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Clean up (they may be very large)</span>
        <span class="k">del</span> <span class="n">col</span>

        <span class="c1"># Now we can easily build from-&gt;to arrays</span>

        <span class="c1"># other[0] -&gt; other[1] changes to other[0] -&gt; full_G[1] | self[1]</span>
        <span class="c1"># self[0] -&gt; self[1] changes to self[0] -&gt; full_G[0] | other[0]</span>
        <span class="c1"># self[0] -&gt; self[-1] changes to self[0] -&gt; full_G[-1] | other[-1]</span>
        <span class="c1"># other[0] -&gt; other[-1] changes to other[0] -&gt; full_G[0] | self[0]</span>
        <span class="n">col_from</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">idx_o_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">idx_s_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">idx_s_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">idx_o_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="n">col_to</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="p">(</span><span class="n">idx_s_first</span> <span class="o">+</span> <span class="n">idx_iscP</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">idx_o_first</span> <span class="o">+</span> <span class="n">idx_isc0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">idx_o_last</span> <span class="o">+</span> <span class="n">idx_iscM</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
                <span class="p">(</span><span class="n">idx_s_last</span> <span class="o">+</span> <span class="n">idx_isc0</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="n">full</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="n">col_from</span><span class="p">,</span> <span class="n">col_to</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">full</span></div>


<div class="viewcode-block" id="SparseOrbital.replace">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.replace">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;eps&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument eps has been deprecated in favor of atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span>
        <span class="n">other</span><span class="p">,</span>
        <span class="n">other_atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.005</span><span class="p">,</span>
        <span class="n">scale</span><span class="p">:</span> <span class="n">SeqOrScalarFloat</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Self</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Replace `atoms` in `self` with `other_atoms` in `other` and retain couplings between them</span>

<span class="sd">        This method replaces a subset of atoms in `self` with</span>
<span class="sd">        another sparse geometry retaining any couplings between them.</span>
<span class="sd">        The algorithm checks whether the coupling atoms have the same number of</span>
<span class="sd">        orbitals. Meaning that atoms in the overlapping region should have the same</span>
<span class="sd">        connections and number of orbitals per atom.</span>
<span class="sd">        It will _not_ check whether the orbitals or atoms _are_ the same, nor the order</span>
<span class="sd">        of the orbitals.</span>

<span class="sd">        The replacement algorithm takes the couplings from ``self -&gt; other`` on atoms</span>
<span class="sd">        belonging to ``self`` and ``other -&gt; self`` from ``other``. This will in some</span>
<span class="sd">        cases mean that the matrix becomes non-symmetric. See in Notes for details on</span>
<span class="sd">        symmetrizing the matrices.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; minimal = SparseOrbital(....)</span>
<span class="sd">        &gt;&gt;&gt; big = minimal.tile(2, 0)</span>
<span class="sd">        &gt;&gt;&gt; big2 = big.replace(np.arange(big.na), minimal)</span>
<span class="sd">        &gt;&gt;&gt; big.spsame(big2)</span>
<span class="sd">        True</span>

<span class="sd">        To ensure hermiticity and using the average of the couplings from ``big`` and</span>
<span class="sd">        ``minimal`` one can do:</span>

<span class="sd">        &gt;&gt;&gt; big2 = big.replace(np.arange(big.na), minimal)</span>
<span class="sd">        &gt;&gt;&gt; big2 = (big2 + big2.transpose()) / 2</span>

<span class="sd">        To retain couplings only from the ``big`` sparse matrix, one should</span>
<span class="sd">        do the following (note the subsequent transposing which ensures hermiticy</span>
<span class="sd">        and is effectively copying couplings from ``big`` to the replaced region.</span>

<span class="sd">        &gt;&gt;&gt; big2 = big.replace(np.arange(big.na), minimal, scale=(2, 0))</span>
<span class="sd">        &gt;&gt;&gt; big2 = (big2 + big2.transpose()) / 2</span>

<span class="sd">        To only retain couplings from the ``minimal`` sparse matrix:</span>

<span class="sd">        &gt;&gt;&gt; big2 = big.replace(np.arange(big.na), minimal, scale=(0, 2))</span>
<span class="sd">        &gt;&gt;&gt; big2 = (big2 + big2.transpose()) / 2</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The current implementation does not preserve the hermiticity of the matrix.</span>
<span class="sd">        If you want to preserve hermiticity of the matrix you have to do the</span>
<span class="sd">        following:</span>

<span class="sd">        &gt;&gt;&gt; sm = (sm + sm.transpose()) / 2</span>

<span class="sd">        Also note that the ordering of the atoms will be ``range(atoms.min()), range(len(other_atoms)), &lt;rest&gt;``.</span>

<span class="sd">        Algorithms that utilizes atomic indices should be careful.</span>

<span class="sd">        When the tolerance `atol` is high, the elements may be more prone to differences in the</span>
<span class="sd">        symmetry elements. A good idea would be to check the difference between the couplings.</span>
<span class="sd">        The below variable ``diff`` will contain the difference ``(self -&gt; other) - (other -&gt; self)``</span>

<span class="sd">        &gt;&gt;&gt; diff = sm - sm.transpose()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            which atoms in `self` that are removed and replaced with ``other.sub(other_atoms)``</span>
<span class="sd">        other : object</span>
<span class="sd">            must be an object of the same type as `self`, a subset is taken from this</span>
<span class="sd">            sparse matrix and combined with `self` to create a new sparse matrix</span>
<span class="sd">        other_atoms :</span>
<span class="sd">            to select a subset of atoms in `other` that are taken out.</span>
<span class="sd">            Defaults to all atoms in `other`.</span>
<span class="sd">        atol :</span>
<span class="sd">            coordinate tolerance for allowing replacement.</span>
<span class="sd">            It is important that this value is at least smaller than half the distance between</span>
<span class="sd">            the two closests atoms such that there is no ambiguity in selecting</span>
<span class="sd">            equivalent atoms.</span>
<span class="sd">        scale :</span>
<span class="sd">            the scale used for the overlapping region. For scalar values it corresponds</span>
<span class="sd">            to passing: ``(scale, scale)``.</span>
<span class="sd">            For array-like input ``scale[0]`` refers to the scale of the matrix elements</span>
<span class="sd">            coupling from `self`, while ``scale[1]`` is the scale of the matrix elements</span>
<span class="sd">            in `other`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        prepend : prepend two sparse matrices, see `append` for details</span>
<span class="sd">        add : merge two matrices without considering overlap or commensurability</span>
<span class="sd">        transpose : may be used to ensure hermiticity (symmetrization of the matrix elements)</span>
<span class="sd">        append : append two sparse matrices</span>
<span class="sd">        Geometry.append</span>
<span class="sd">        Geometry.prepend</span>
<span class="sd">        SparseCSR.scale_columns : method used to scale the two matrix elements values</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        ValueError</span>
<span class="sd">           if the two geometries are not compatible for either coordinate, orbital or supercell errors</span>
<span class="sd">        AssertionError</span>
<span class="sd">           if the two geometries are not compatible for either coordinate, orbital or supercell errors</span>

<span class="sd">        Warns</span>
<span class="sd">        -----</span>
<span class="sd">        SislWarning</span>
<span class="sd">           in case the overlapping atoms are not comprising the same atomic specie.</span>
<span class="sd">           In some cases this may not be a problem.</span>
<span class="sd">           However, care must be taken by the user if this warning is issued.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        object</span>
<span class="sd">            a new instance with two sparse matrices merged together by replacing some atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">scale</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">scale</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">scale</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>

        <span class="c1"># here our connection is defined as what is connected to &quot;in&quot;</span>
        <span class="c1"># and what is connected to &quot;out&quot;</span>
        <span class="c1"># Say 0 -&gt; 1</span>
        <span class="c1"># And `atoms` is [0].</span>
        <span class="c1"># Then in = [0], out = [1]</span>
        <span class="c1"># since atoms connect out to [1]</span>
        <span class="c1"># In certain cases, when `atoms` does not connect *into* itself,</span>
        <span class="c1"># it may be smaller than `atoms`.</span>

        <span class="c1"># figure out the atoms that needs replacement</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_reduced_system</span><span class="p">(</span><span class="n">sp</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;convert the geometry in `sp` to only atoms `atoms` and return the following:</span>

<span class="sd">            1. atoms (sanitized and no order change)</span>
<span class="sd">            2. orbitals (ordered as `atoms`)</span>
<span class="sd">            3. the atoms that are connected to OUT and IN</span>
<span class="sd">            4. the orbitals that are connected to OUT and IN</span>
<span class="sd">            &quot;&quot;&quot;</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">geometry</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">unique</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.replace requires a unique set of atoms&quot;</span>
                <span class="p">)</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># other_orbs = geom.ouc2sc(np.delete(_a.arangei(geom.no), orbs))</span>

            <span class="c1"># Find the orbitals that these atoms connect to such that we can compare</span>
            <span class="c1"># atomic coordinates</span>
            <span class="n">out_connect_orb_sc</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">orbs</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">orbs</span><span class="p">)</span>
            <span class="n">out_connect_orb</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">out_connect_orb_sc</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">out_connect_atom_sc</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">out_connect_orb_sc</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">out_connect_atom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">out_connect_atom_sc</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># figure out connecting back</span>
            <span class="n">atoms_orbs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                <span class="nb">map</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">],</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="p">)</span>
            <span class="n">in_connect_atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">in_connect_orb</span> <span class="o">=</span> <span class="p">[]</span>

            <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">atom_orbs</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_orbs</span><span class="p">):</span>
                <span class="n">edges</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">atom_orbs</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">orbs</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersect1d</span><span class="p">(</span><span class="n">edges</span><span class="p">,</span> <span class="n">out_connect_orb_sc</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">in_connect_atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
                    <span class="n">in_connect_orb</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">atom_orbs</span><span class="p">)</span>

            <span class="n">in_connect_atom</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">in_connect_atom</span><span class="p">)</span>
            <span class="n">in_connect_orb</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">in_connect_orb</span><span class="p">)</span>

            <span class="c1"># create the connection tables</span>
            <span class="n">atom_uc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_atom</span><span class="p">,</span> <span class="n">out_connect_atom</span><span class="p">)</span>
            <span class="n">atom_sc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_atom</span><span class="p">,</span> <span class="n">out_connect_atom_sc</span><span class="p">)</span>
            <span class="n">orb_uc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_orb</span><span class="p">,</span> <span class="n">out_connect_orb</span><span class="p">)</span>
            <span class="n">orb_sc</span> <span class="o">=</span> <span class="n">Connect</span><span class="p">(</span><span class="n">in_connect_orb</span><span class="p">,</span> <span class="n">out_connect_orb_sc</span><span class="p">)</span>
            <span class="n">atom_connect</span> <span class="o">=</span> <span class="n">UCSC</span><span class="p">(</span><span class="n">atom_uc</span><span class="p">,</span> <span class="n">atom_sc</span><span class="p">)</span>
            <span class="n">orb_connect</span> <span class="o">=</span> <span class="n">UCSC</span><span class="p">(</span><span class="n">orb_uc</span><span class="p">,</span> <span class="n">orb_sc</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">Info</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">atom_connect</span><span class="p">,</span> <span class="n">orb_connect</span><span class="p">)</span>

        <span class="n">UCSC</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;UCSC&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;uc&quot;</span><span class="p">,</span> <span class="s2">&quot;sc&quot;</span><span class="p">])</span>
        <span class="n">Connect</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Connect&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;IN&quot;</span><span class="p">,</span> <span class="s2">&quot;OUT&quot;</span><span class="p">])</span>
        <span class="n">Info</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Info&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="s2">&quot;orbitals&quot;</span><span class="p">,</span> <span class="s2">&quot;atom_connect&quot;</span><span class="p">,</span> <span class="s2">&quot;orb_connect&quot;</span><span class="p">])</span>

        <span class="n">sgeom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">s_info</span> <span class="o">=</span> <span class="n">get_reduced_system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atoms</span>  <span class="c1"># sanitized (no order change)</span>

        <span class="n">ogeom</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">o_info</span> <span class="o">=</span> <span class="n">get_reduced_system</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">other_atoms</span><span class="p">)</span>
        <span class="n">other_atoms</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atoms</span>  <span class="c1"># sanitized (no order change)</span>

        <span class="c1"># Get overlapping atoms by their offset</span>
        <span class="c1"># We need to get a 1-1 correspondence between the two connecting geometries</span>
        <span class="c1"># For instance `self` may be ordered differently than `other`.</span>
        <span class="c1"># So we need to figure out how the atoms are arranged in *both* regions.</span>
        <span class="c1"># This is where `atol` comes into play since we have to ensure that the</span>
        <span class="c1"># connecting regions are within some given tolerance.</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">create_geometry</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">atoms</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Create the supercell geometry with coordinates as given&quot;&quot;&quot;</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">uc_atoms</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">uc_atoms</span><span class="p">])</span>

        <span class="c1"># We know that the *IN* connections are in the primary unit-cell</span>
        <span class="c1"># so we don&#39;t need to handle supercell information</span>
        <span class="c1"># Atoms *inside* the replacement region that couples out</span>
        <span class="n">sgeom_in</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>
        <span class="n">ogeom_in</span> <span class="o">=</span> <span class="n">ogeom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">)</span>
        <span class="n">soverlap_in</span><span class="p">,</span> <span class="n">ooverlap_in</span> <span class="o">=</span> <span class="n">sgeom_in</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span>
            <span class="n">ogeom_in</span><span class="p">,</span>
            <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=-</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">offset_other</span><span class="o">=-</span><span class="n">ogeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># Not replacement region, i.e. the IN (above) atoms are connecting to</span>
        <span class="c1"># these atoms:</span>
        <span class="n">sgeom_out</span> <span class="o">=</span> <span class="n">create_geometry</span><span class="p">(</span><span class="n">sgeom</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
        <span class="n">ogeom_out</span> <span class="o">=</span> <span class="n">create_geometry</span><span class="p">(</span><span class="n">ogeom</span><span class="p">,</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span>
        <span class="n">soverlap_out</span><span class="p">,</span> <span class="n">ooverlap_out</span> <span class="o">=</span> <span class="n">sgeom_out</span><span class="o">.</span><span class="n">overlap</span><span class="p">(</span>
            <span class="n">ogeom_out</span><span class="p">,</span>
            <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">,</span>
            <span class="n">offset</span><span class="o">=-</span><span class="n">sgeom_out</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
            <span class="n">offset_other</span><span class="o">=-</span><span class="n">ogeom_out</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="c1"># trigger for errors</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="c1"># Now we have the different geometries around to handle how the merging</span>
        <span class="c1"># process.</span>
        <span class="c1"># Before proceeding we will check whether the dimensions match.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sgeom_in</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">soverlap_in</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ogeom_in</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ooverlap_in</span><span class="p">):</span>
            <span class="c1"># We check that the couplings INTO the replaced atoms</span>
            <span class="c1"># are equivalent.</span>
            <span class="c1"># I.e. # of atoms</span>

            <span class="c1"># figure out which atoms are not connecting</span>
            <span class="n">s_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">soverlap_in</span>
            <span class="p">)</span>
            <span class="n">o_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">ooverlap_in</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">The number of atoms in the replacement region that connects to the surrounding</span>
<span class="s2">atoms are not the same in &#39;self&#39; and &#39;other&#39;.</span>
<span class="s2">This means that the number of connections is not the same.&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">s_diff</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">self: atoms not matched in &#39;other&#39;: </span><span class="si">{</span><span class="n">tmp</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">o_diff</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">other: atoms not matched in &#39;self&#39;: </span><span class="si">{</span><span class="n">tmp</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
            <span class="n">sgeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">],</span> <span class="n">ogeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">tmp_self</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">]))</span>
            <span class="n">tmp_other</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ogeom_in</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">]))</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">Atoms in the replacement region have different number of orbitals on the atoms</span>
<span class="s2">that lie at the border.</span>

<span class="s2">self orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">tmp_self</span><span class="si">}</span>
<span class="s2">other orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">tmp_other</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="c1"># print(&quot;out:&quot;)</span>
        <span class="c1"># print(s_info.atom_connect.uc.OUT)</span>
        <span class="c1"># print(soverlap_out)</span>
        <span class="c1"># print(o_info.atom_connect.uc.OUT)</span>
        <span class="c1"># print(ooverlap_out)</span>

        <span class="c1"># [so]overlap_out are now in the order of [so]_info.atom_connect.out</span>
        <span class="c1"># so we still have to convert them to proper indices if used</span>
        <span class="c1"># We cannot really check the soverlap_out == len(sgeom_out)</span>
        <span class="c1"># in case we have a replaced sparse matrix in the middle of another bigger</span>
        <span class="c1"># sparse matrix.</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">sgeom_out</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">soverlap_out</span><span class="p">)</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">ogeom_out</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ooverlap_out</span><span class="p">):</span>
            <span class="c1"># figure out which atoms are not connecting</span>
            <span class="n">s_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">soverlap_out</span>
            <span class="p">)</span>
            <span class="n">o_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="o">.</span><span class="n">size</span><span class="p">),</span> <span class="n">ooverlap_out</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">or</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">Number of atoms connecting to the replacement region are not the same in &#39;self&#39; and &#39;other&#39;.</span>
<span class="s2">Please ensure this.&quot;&quot;&quot;</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">[</span><span class="n">s_diff</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">self: atoms (in supercell) connecting to &#39;atoms&#39; not matched in &#39;other&#39;: </span><span class="si">{</span><span class="n">tmp</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_diff</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">tmp</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">[</span><span class="n">o_diff</span><span class="p">]))</span>
                <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">other: atoms (in supercell) connecting to &#39;other_atoms&#39; not matched in &#39;self&#39;: </span><span class="si">{</span><span class="n">tmp</span><span class="si">}</span><span class="s2">.&quot;&quot;&quot;</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
            <span class="n">sgeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_out</span><span class="p">],</span> <span class="n">ogeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_out</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">tmp_self</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">sgeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">soverlap_out</span><span class="p">]))</span>
            <span class="n">tmp_other</span> <span class="o">=</span> <span class="n">list2str</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">ogeom_out</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">ooverlap_out</span><span class="p">]))</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">Atoms in the connection region have different number of orbitals on the atoms.</span>

<span class="s2">self orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">tmp_self</span><span class="si">}</span>
<span class="s2">other orbitals:</span>
<span class="s2">   </span><span class="si">{</span><span class="n">tmp_other</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="c1"># we can only ensure the orbitals that connect *out* have the same count</span>
        <span class="c1"># For supercell connections hopping *IN* might be different due to the supercell</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">s_info</span><span class="o">.</span><span class="n">orb_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">o_info</span><span class="o">.</span><span class="n">orb_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">msg</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">msg</span><span class="si">}</span>

<span class="s2">Number of orbitals connecting to replacement region is not consistent</span>
<span class="s2">between &#39;self&#39; and &#39;other&#39;.&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">msg</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="n">msg</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>

        <span class="n">warn_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">S_</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span>
        <span class="n">O_</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span>
        <span class="k">for</span> <span class="n">s_</span><span class="p">,</span> <span class="n">o_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soverlap_in</span><span class="p">,</span> <span class="n">ooverlap_in</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sgeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ogeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]:</span>
                <span class="n">warn_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span>
<span class="s2">Atom &#39;self[</span><span class="si">{</span><span class="n">S_</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39; is not equivalent to &#39;other[</span><span class="si">{</span><span class="n">O_</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39;:</span>
<span class="s2">  </span><span class="si">{</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">  !=  </span><span class="si">{</span><span class="n">ogeom_in</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">warn_msg</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Inequivalent atoms found in replacement region, this may or may not be a problem</span>
<span class="s2">depending on your use case. Please be careful though.</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="n">warn_msg</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="n">S_</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span>
        <span class="n">O_</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span>
        <span class="n">checked1d</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">s_</span><span class="p">,</span> <span class="n">o_</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">soverlap_out</span><span class="p">,</span> <span class="n">ooverlap_out</span><span class="p">):</span>
            <span class="n">uc_s_</span> <span class="o">=</span> <span class="n">S_</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>
            <span class="k">if</span> <span class="n">sgeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span> <span class="o">!=</span> <span class="n">ogeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span> <span class="ow">and</span> <span class="n">checked1d</span><span class="p">[</span><span class="n">uc_s_</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">checked1d</span><span class="p">[</span><span class="n">uc_s_</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="n">warn_msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span>
<span class="s2">Atom &#39;self[</span><span class="si">{</span><span class="n">S_</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39; is not equivalent to &#39;other[</span><span class="si">{</span><span class="n">O_</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">]&#39;:</span>
<span class="s2">  </span><span class="si">{</span><span class="n">sgeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">s_</span><span class="p">]</span><span class="si">}</span><span class="s2">  !=  </span><span class="si">{</span><span class="n">ogeom_out</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">o_</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">warn_msg</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;&quot;&quot;Inequivalent atoms found in connection region, this may or may not be a problem</span>
<span class="s2">depending on your use case. Note indices in the following are supercell indices. Please be careful though.</span><span class="si">{</span><span class="n">warn_msg</span><span class="si">}</span><span class="s2">&quot;&quot;&quot;</span>
            <span class="p">)</span>

        <span class="c1"># clean-up to make it clear that we are not going to use them.</span>
        <span class="k">del</span> <span class="n">sgeom_out</span><span class="p">,</span> <span class="n">ogeom_out</span>

        <span class="c1"># this is where other.sub(other_atoms) gets inserted</span>
        <span class="n">ainsert_idx</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="n">oinsert_idx</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">ainsert_idx</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># this is the indices of the new atoms in the new geometry</span>
        <span class="c1"># self_other_atoms = _a.arangei(ainsert_idx, ainsert_idx + len(other_atoms))</span>

        <span class="c1"># We need to do the replacement in two steps</span>
        <span class="c1"># A. the geometry</span>
        <span class="c1">#    This will insert other at ainsert_idx</span>
        <span class="c1">#    Note that sub(other_atoms) re-arranges the atoms correctly</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">((</span><span class="n">sgeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">sgeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span> <span class="o">-</span> <span class="n">ogeom_in</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">[</span><span class="n">idx</span><span class="p">]]</span>
        <span class="c1"># this will perhaps re-order atoms from other_atoms</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">),</span> <span class="n">offset</span><span class="o">=</span><span class="n">offset</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">sgeom_in</span><span class="p">,</span> <span class="n">ogeom_in</span>
        <span class="c1"># A. DONE</span>

        <span class="c1"># B. Merge the two sparse patterns</span>
        <span class="n">scsr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">scsr</span><span class="o">.</span><span class="n">ncol</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">scsr</span><span class="o">.</span><span class="n">col</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">scsr</span><span class="o">.</span><span class="n">_D</span>
        <span class="c1"># helper function</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">sc</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">ouc2sc</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Our first task is to merge the two sparse patterns.</span>
        <span class="c1"># Delete the *old* values</span>
        <span class="c1"># To ensure that inserting will not leave *empty* values</span>
        <span class="c1"># we first reduce arrays so that the ptr array is not needed</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">scsr</span><span class="o">.</span><span class="n">ptr</span><span class="p">,</span> <span class="n">s_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ptr</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">D</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Do the same reduction for the inserted values</span>
        <span class="n">ocsr</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">ocsr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">o_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">ocsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">o_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">])</span>
        <span class="c1"># we offset the new columns by self.shape[1], in this way we know</span>
        <span class="c1"># which couplings belong to the inserted and the original csr</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">ncol</span><span class="p">[:</span><span class="n">oinsert_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ocsr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">D</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">ncol</span><span class="p">[:</span><span class="n">oinsert_idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(),</span> <span class="n">ocsr</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="n">insert</span><span class="p">(</span><span class="n">ncol</span><span class="p">,</span> <span class="n">oinsert_idx</span><span class="p">,</span> <span class="n">ocsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">o_info</span><span class="o">.</span><span class="n">orbitals</span><span class="p">])</span>

        <span class="c1"># Create the sparse pattern</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">(</span>
            <span class="p">(</span><span class="n">D</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">sgeom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">+</span> <span class="n">ogeom</span><span class="o">.</span><span class="n">no_s</span><span class="p">,</span> <span class="n">D</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span>
        <span class="p">)</span>
        <span class="k">del</span> <span class="n">D</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ncol</span>

        <span class="c1"># Now we have merged the two sparse patterns</span>
        <span class="c1"># But we need to correct the orbital couplings</span>
        <span class="c1"># : *outside* refers to the original sparse pattern (without `atoms`)</span>
        <span class="c1"># : *inside* refers to the inserted sparse pattern (other.sub(other_atoms))</span>
        <span class="c1"># We have to do 1 and 2 simultaneously.</span>
        <span class="c1"># We have to do 3 and 4 simultaneously.</span>
        <span class="c1"># This is because they may have overlapping columns</span>

        <span class="c1"># 1: couplings from *outside* to *outside* (no scale)</span>
        <span class="c1"># 2: couplings from *outside* to *inside* (scaled)</span>
        <span class="c1"># 3: couplings from *inside* to *inside* (no scale)</span>
        <span class="c1"># 4: couplings from *inside* to *outside* (scaled)</span>
        <span class="n">convert</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">assert_unique</span><span class="p">(</span><span class="n">old</span><span class="p">,</span> <span class="n">new</span><span class="p">):</span>
            <span class="n">old</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
            <span class="n">new</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">old</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">unique</span><span class="p">(</span><span class="n">new</span><span class="p">))</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">old</span><span class="p">,</span> <span class="n">new</span>

        <span class="c1"># 1:</span>
        <span class="c1"># print(&quot;1:&quot;)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">sgeom</span><span class="p">)),</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
        <span class="n">new</span><span class="p">[</span><span class="n">ainsert_idx</span><span class="p">:]</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">sgeom</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 2:</span>
        <span class="c1"># print(&quot;2:&quot;)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">s_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">soverlap_in</span><span class="p">]</span>
        <span class="c1"># algorithm to get indices in other_atoms</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">uc</span><span class="o">.</span><span class="n">IN</span><span class="p">[</span><span class="n">ooverlap_in</span><span class="p">]</span>
        <span class="n">tmp</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">[</span><span class="n">searchsorted</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="n">sorter</span><span class="o">=</span><span class="n">tmp</span><span class="p">)]</span> <span class="o">+</span> <span class="n">ainsert_idx</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">sgeom</span><span class="p">,</span> <span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

        <span class="c1"># translate columns</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="o">*</span><span class="n">assert_unique</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
        <span class="c1"># scale columns that connects inside</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>

        <span class="c1"># on to the *inside* 3, 4</span>
        <span class="n">convert</span> <span class="o">=</span> <span class="p">[[],</span> <span class="p">[]]</span>

        <span class="c1"># 3:</span>
        <span class="c1"># print(&quot;3:&quot;)</span>
        <span class="c1"># we have all the *inside* column indices offset by self.shape[1]</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">ogeom</span><span class="p">,</span> <span class="n">other_atoms</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">ainsert_idx</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">other_atoms</span><span class="p">))</span>
        <span class="c1"># print(&quot;old: &quot;, old)</span>
        <span class="c1"># print(&quot;new: &quot;, new)</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>
        <span class="n">rows</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">osc2uc</span><span class="p">(</span><span class="n">new</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># 4:</span>
        <span class="c1"># print(&quot;4:&quot;)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">o_info</span><span class="o">.</span><span class="n">atom_connect</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">OUT</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">atom</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">old</span><span class="p">):</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ogeom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>
            <span class="k">assert</span> <span class="p">(</span>
                <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span>
            <span class="p">),</span> <span class="sa">f</span><span class="s2">&quot;More than 1 atom </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2"> for atom </span><span class="si">{</span><span class="n">atom</span><span class="si">}</span><span class="s2"> = </span><span class="si">{</span><span class="n">ogeom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="n">new</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># print(&quot;old: &quot;, old)</span>
        <span class="c1"># print(&quot;new: &quot;, new)</span>
        <span class="n">old</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">ogeom</span><span class="p">,</span> <span class="n">old</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">new</span> <span class="o">=</span> <span class="n">a2o</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">new</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">old</span><span class="p">)</span>
        <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

        <span class="c1"># translate columns</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">translate_columns</span><span class="p">(</span><span class="o">*</span><span class="n">assert_unique</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>
        <span class="c1"># scale columns that connects inside</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">scale_columns</span><span class="p">(</span><span class="n">convert</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">scale</span><span class="o">=</span><span class="n">scale</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">rows</span><span class="o">=</span><span class="n">rows</span><span class="p">)</span>

        <span class="c1"># ensure we have translated all columns correctly</span>
        <span class="k">assert</span> <span class="n">valid_index</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">()</span>
        <span class="c1"># correct shape of column matrix</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">_shape</span> <span class="o">=</span> <span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_csr</span> <span class="o">=</span> <span class="n">csr</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geom</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="SparseOrbital.prune_range">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.prune_range">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">prune_range</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AtomsLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms_to</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AtomsLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;Self&quot;</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Prune elements coupling further than `R`.</span>

<span class="sd">        Search for connections from `atoms` to `atoms_to` where the distances are</span>
<span class="sd">        further than `R`. If such couplings exists, remove them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        R :</span>
<span class="sd">            the distance at which the couplings are cut</span>
<span class="sd">        atoms :</span>
<span class="sd">            atoms that will be considered in the check.</span>
<span class="sd">            The rows of the couplings that is taken into account.</span>
<span class="sd">        atoms_to :</span>
<span class="sd">            The columns of the couplings that is taken into account.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The transposed couplings are *also* deleted to ensure a symmetric</span>
<span class="sd">        matrix.</span>

<span class="sd">        Currently, one cannot select subset of atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>
        <span class="n">atoms_to</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">auc2sc</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms_to</span><span class="p">))</span>
        <span class="n">atoms_all</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="ow">and</span> <span class="n">atoms_to</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">na_s</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms_all</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.prune_range &quot;</span>
                <span class="s2">&quot;does not work with subsets of atoms.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># change to *not* selected atoms</span>
        <span class="n">atoms_to_exclude</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na_s</span><span class="p">),</span> <span class="n">atoms_to</span><span class="p">)</span>
        <span class="n">orbs_to_exclude</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms_to_exclude</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Now search the couplings</span>
        <span class="n">edges</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">orbs_to_exclude</span><span class="p">)</span>

        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Now we have all edges that couples between atoms and atoms_to.</span>
        <span class="c1"># Determine the distances between the atoms</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">iorbs</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">edges</span><span class="p">)</span>
            <span class="c1"># Select atoms with distances larger than R</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">edges</span><span class="p">[</span><span class="n">dist</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># find orbitals that idx represents</span>
            <span class="n">jorbs</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">uc_jorbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">jorbs</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="n">iorbs</span><span class="p">:</span>
                <span class="k">del</span> <span class="n">out</span><span class="p">[</span><span class="n">io</span><span class="p">,</span> <span class="n">jorbs</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms_all</span><span class="p">:</span>
                    <span class="c1"># this ends up deleting everything...</span>
                    <span class="n">io_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_transpose_indices</span><span class="p">(</span><span class="n">jorbs</span><span class="p">,</span> <span class="n">base</span><span class="o">=</span><span class="n">io</span><span class="p">))</span>
                    <span class="k">del</span> <span class="n">out</span><span class="p">[</span><span class="n">uc_jorbs</span><span class="p">,</span> <span class="n">io_sc</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="SparseOrbital.toSparseAtom">
<a class="viewcode-back" href="../../../api/generated/sisl.SparseOrbital.html#sisl.SparseOrbital.toSparseAtom">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">toSparseAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the sparse object (without data) to a new sparse object with equivalent but reduced sparse pattern</span>

<span class="sd">        This converts the orbital sparse pattern to an atomic sparse pattern.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dim :</span>
<span class="sd">           number of dimensions allocated in the SparseAtom object, default to the same</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">           used data-type for the sparse object. Defaults to the same.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dtype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">dtype</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># Create a conversion vector</span>
        <span class="n">orb2atom</span> <span class="o">=</span> <span class="n">tile</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)),</span> <span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span>
        <span class="n">orb2atom</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">orb2atom</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="n">orb2atom</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="c1"># First convert all rows to the same</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_csr</span>

        <span class="c1"># Now build the new sparse pattern</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">ptr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">col</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">):</span>
            <span class="n">o1</span><span class="p">,</span> <span class="n">o2</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">([</span><span class="n">ia</span><span class="p">,</span> <span class="n">ia</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="nb">all</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="c1"># Get current atomic elements</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">array_arange</span><span class="p">(</span><span class="n">csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[</span><span class="n">o1</span><span class="p">:</span><span class="n">o2</span><span class="p">],</span> <span class="n">n</span><span class="o">=</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">o1</span><span class="p">:</span><span class="n">o2</span><span class="p">])</span>

            <span class="c1"># These are now the atomic columns</span>
            <span class="c1"># Immediately reduce to unique elements</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">orb2atom</span><span class="p">[</span><span class="n">csr</span><span class="o">.</span><span class="n">col</span><span class="p">[</span><span class="n">idx</span><span class="p">]])</span>

            <span class="c1"># Step counters</span>
            <span class="n">col</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="n">acol</span>
            <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">acol</span><span class="p">)</span>

        <span class="c1"># Now we can create the sparse atomic</span>
        <span class="n">col</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">spAtom</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">ptr</span><span class="p">[:]</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="n">ptr</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">),</span> <span class="n">dim</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>
        <span class="n">spAtom</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_finalized</span> <span class="o">=</span> <span class="kc">True</span>  <span class="c1"># unique returns sorted elements</span>
        <span class="k">return</span> <span class="n">spAtom</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>