

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl._core.geometry &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=7b70f75b"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl._core.geometry</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl._core.geometry</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="c1"># To check for integers</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">warnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">OrderedDict</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">singledispatchmethod</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">acos</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">bool_</span><span class="p">,</span>
    <span class="n">ceil</span><span class="p">,</span>
    <span class="n">concatenate</span><span class="p">,</span>
    <span class="n">diff</span><span class="p">,</span>
    <span class="n">dot</span><span class="p">,</span>
    <span class="n">floor</span><span class="p">,</span>
    <span class="n">int32</span><span class="p">,</span>
    <span class="n">ndarray</span><span class="p">,</span>
    <span class="n">sqrt</span><span class="p">,</span>
    <span class="n">square</span><span class="p">,</span>
    <span class="n">tile</span><span class="p">,</span>
    <span class="n">unique</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">csr_matrix</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sisl._array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_a</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._category</span><span class="w"> </span><span class="kn">import</span> <span class="n">Category</span><span class="p">,</span> <span class="n">GenericCategory</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._dispatch_class</span><span class="w"> </span><span class="kn">import</span> <span class="n">_Dispatchs</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._dispatcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">AbstractDispatch</span><span class="p">,</span> <span class="n">ClassDispatcher</span><span class="p">,</span> <span class="n">TypeDispatcher</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._help</span><span class="w"> </span><span class="kn">import</span> <span class="n">has_module</span><span class="p">,</span> <span class="n">isndarray</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._indices</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">indices_gt_le</span><span class="p">,</span>
    <span class="n">indices_in_sphere_with_dist</span><span class="p">,</span>
    <span class="n">indices_le</span><span class="p">,</span>
    <span class="n">list_index_le</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._lib._argparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">SislHelpFormatter</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._math_small</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross3</span><span class="p">,</span> <span class="n">is_ascending</span><span class="p">,</span> <span class="n">xyz_to_spherical_cos_phi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._namedindex</span><span class="w"> </span><span class="kn">import</span> <span class="n">NamedIndex</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">deprecate_argument</span><span class="p">,</span> <span class="n">deprecation</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.shape</span><span class="w"> </span><span class="kn">import</span> <span class="n">Cube</span><span class="p">,</span> <span class="n">Shape</span><span class="p">,</span> <span class="n">Sphere</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">AtomsIndex</span><span class="p">,</span>
    <span class="n">AtomsLike</span><span class="p">,</span>
    <span class="n">CellAxes</span><span class="p">,</span>
    <span class="n">LatticeLike</span><span class="p">,</span>
    <span class="n">OrbitalsIndex</span><span class="p">,</span>
    <span class="n">SileLike</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">angle</span><span class="p">,</span>
    <span class="n">cmd</span><span class="p">,</span>
    <span class="n">default_ArgumentParser</span><span class="p">,</span>
    <span class="n">default_namespace</span><span class="p">,</span>
    <span class="n">direction</span><span class="p">,</span>
    <span class="n">listify</span><span class="p">,</span>
    <span class="n">lstranges</span><span class="p">,</span>
    <span class="n">str_spec</span><span class="p">,</span>
    <span class="n">strmap</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.mathematics</span><span class="w"> </span><span class="kn">import</span> <span class="n">fnorm</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.atom</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atoms</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.lattice</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lattice</span><span class="p">,</span> <span class="n">LatticeChild</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.orbital</span><span class="w"> </span><span class="kn">import</span> <span class="n">Orbital</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;sgeom&quot;</span><span class="p">,</span> <span class="s2">&quot;AtomCategory&quot;</span><span class="p">]</span>

<span class="n">_log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="vm">__name__</span><span class="p">)</span>


<span class="c1"># It needs to be here otherwise we can&#39;t use it in these routines</span>
<span class="c1"># Note how we are overwriting the module</span>
<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.geom&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AtomCategory</span><span class="p">(</span><span class="n">Category</span><span class="p">):</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

<div class="viewcode-block" id="AtomCategory.is_class">
<a class="viewcode-back" href="../../../api/geom/generated/sisl.geom.AtomCategory.html#sisl.AtomCategory.is_class">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="c1"># Strip off `Atom`</span>
        <span class="n">cls_name</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">[</span><span class="mi">4</span><span class="p">:]</span>
        <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">cls_name</span> <span class="o">==</span> <span class="n">name</span>
        <span class="k">return</span> <span class="n">cls_name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="n">name</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Geometry</span><span class="p">(</span>
    <span class="n">LatticeChild</span><span class="p">,</span>
    <span class="n">_Dispatchs</span><span class="p">,</span>
    <span class="n">dispatchs</span><span class="o">=</span><span class="p">[</span>
        <span class="n">ClassDispatcher</span><span class="p">(</span><span class="s2">&quot;new&quot;</span><span class="p">,</span> <span class="n">obj_getattr</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">instance_dispatcher</span><span class="o">=</span><span class="n">TypeDispatcher</span><span class="p">),</span>
        <span class="n">ClassDispatcher</span><span class="p">(</span><span class="s2">&quot;to&quot;</span><span class="p">,</span> <span class="n">obj_getattr</span><span class="o">=</span><span class="s2">&quot;error&quot;</span><span class="p">,</span> <span class="n">type_dispatcher</span><span class="o">=</span><span class="kc">None</span><span class="p">),</span>
    <span class="p">],</span>
    <span class="n">when_subclassing</span><span class="o">=</span><span class="s2">&quot;copy&quot;</span><span class="p">,</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Holds atomic information, coordinates, species, lattice vectors</span>

<span class="sd">    The `Geometry` class holds information regarding atomic coordinates,</span>
<span class="sd">    the atomic species, the corresponding lattice-vectors.</span>

<span class="sd">    It enables the interaction and conversion of atomic structures via</span>
<span class="sd">    simple routine methods.</span>

<span class="sd">    All lengths are assumed to be in units of Angstrom, however, as</span>
<span class="sd">    long as units are kept same the exact units are irrespective.</span>

<span class="sd">    .. code:: python</span>

<span class="sd">       &gt;&gt;&gt; square = Geometry([[0.5, 0.5, 0.5]], Atom(1),</span>
<span class="sd">       ...                   lattice=Lattice([1, 1, 10], nsc=[3, 3, 1]))</span>
<span class="sd">       &gt;&gt;&gt; print(square)</span>
<span class="sd">       Geometry{na: 1, no: 1,</span>
<span class="sd">        Atoms{species: 1,</span>
<span class="sd">         Atom{H, Z: 1, mass(au): 1.00794, maxR: -1.00000,</span>
<span class="sd">          Orbital{R: -1.00000, q0: 0.0}</span>
<span class="sd">         }: 1,</span>
<span class="sd">        },</span>
<span class="sd">        maxR: -1.00000,</span>
<span class="sd">        Lattice{volume: 1.0000e+01, nsc: [3 3 1]}</span>
<span class="sd">       }</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    xyz :</span>
<span class="sd">        atomic coordinates</span>
<span class="sd">        ``xyz[i, :]`` is the atomic coordinate of the i&#39;th atom.</span>
<span class="sd">    atoms :</span>
<span class="sd">        atomic species retrieved from the `PeriodicTable`</span>
<span class="sd">    lattice :</span>
<span class="sd">        the unit-cell describing the atoms in a periodic</span>
<span class="sd">        super-cell</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>

<span class="sd">    An atomic cubic lattice of Hydrogen atoms</span>

<span class="sd">    &gt;&gt;&gt; xyz = [[0, 0, 0],</span>
<span class="sd">    ...        [1, 1, 1]]</span>
<span class="sd">    &gt;&gt;&gt; sc = Lattice([2,2,2])</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz, Atom(&#39;H&#39;), sc)</span>

<span class="sd">    The following estimates the lattice vectors from the</span>
<span class="sd">    atomic coordinates, although possible, it is not recommended</span>
<span class="sd">    to be used.</span>

<span class="sd">    &gt;&gt;&gt; xyz = [[0, 0, 0],</span>
<span class="sd">    ...        [1, 1, 1]]</span>
<span class="sd">    &gt;&gt;&gt; g = Geometry(xyz, Atom(&#39;H&#39;))</span>

<span class="sd">    Conversion of geometries to other projects instances can be done via</span>
<span class="sd">    sisl&#39;s dispatch functionality</span>

<span class="sd">    &gt;&gt;&gt; g.to.ase()</span>
<span class="sd">    Atoms(...)</span>

<span class="sd">    converts to an ASE `ase.Atoms` object.</span>

<span class="sd">    See Also</span>
<span class="sd">    --------</span>
<span class="sd">    Atoms : contained atoms ``self.atoms``</span>
<span class="sd">    Atom : contained atoms are each an object of this</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;sc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;lattice&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument sc has been deprecated in favor of lattice, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">AtomsLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">lattice</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LatticeLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">names</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="c1"># Create the geometry coordinate, be aware that we do not copy!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;C&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Default value</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">)</span>

        <span class="c1"># Create the local Atoms object</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">na</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>

        <span class="c1"># Assign a group specifier</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">names</span><span class="p">,</span> <span class="n">NamedIndex</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">names</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_names</span> <span class="o">=</span> <span class="n">NamedIndex</span><span class="p">(</span><span class="n">names</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_init_lattice</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_init_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lattice</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">LatticeLike</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initializes the supercell by *calculating* the size if not supplied</span>

<span class="sd">        If the supercell has not been passed we estimate the unit cell size</span>
<span class="sd">        by calculating the bond-length in each direction for a square</span>
<span class="sd">        Cartesian coordinate system.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We still need the *default* super cell for</span>
        <span class="c1"># estimating the supercell</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>

        <span class="c1"># First create an initial guess for the supercell</span>
        <span class="c1"># It HAS to be VERY large to not interact</span>
        <span class="n">closest</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.4</span><span class="p">,</span> <span class="mf">5.0</span><span class="p">))[</span><span class="mi">2</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">closest</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># We could not find any atoms very close,</span>
            <span class="c1"># hence we simply return and now it becomes</span>
            <span class="c1"># the users responsibility</span>

            <span class="c1"># We create a molecule box with +10 A in each direction</span>
            <span class="n">m</span><span class="p">,</span> <span class="n">M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">10.0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">M</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="n">sc_cart</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="c1"># Initialize cartesian direction</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">1.0</span>

            <span class="c1"># Get longest distance between atoms</span>
            <span class="n">max_dist</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>

            <span class="n">dist</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">closest</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="p">:][</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
            <span class="c1"># Project onto the direction</span>
            <span class="n">dd</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dot</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">cart</span><span class="p">))</span>

            <span class="c1"># Remove all below .4</span>
            <span class="n">tmp_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">dd</span> <span class="o">&gt;=</span> <span class="mf">0.4</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">tmp_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We have a success</span>
                <span class="c1"># Add the bond-distance in the Cartesian direction</span>
                <span class="c1"># to the maximum distance in the same direction</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">max_dist</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">dd</span><span class="p">[</span><span class="n">tmp_idx</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Default to LARGE array so as no</span>
                <span class="c1"># interaction occurs (it may be 2D)</span>
                <span class="n">sc_cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mf">10.0</span><span class="p">,</span> <span class="n">max_dist</span><span class="p">)</span>
            <span class="n">cart</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Re-set the supercell to the newly found one</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">sc_cart</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atoms</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Atoms associated with the geometry&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The named index specifier&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_names</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q0</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Total initial charge in this geometry (sum of q0 off all atoms)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">q0</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">mass</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The mass of all atoms as an array&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">mass</span>

<div class="viewcode-block" id="Geometry.maxR">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.maxR">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">maxR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maximum orbital range of the atoms&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">maxR</span><span class="p">(</span><span class="nb">all</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">na</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of atoms in geometry&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">na_s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of supercell atoms&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of atoms in geometry in unit cell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">no</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of orbitals in unit cell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">no</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">no_s</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Number of supercell orbitals&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_s</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">firsto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The first orbital on the corresponding atom&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">firsto</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">lasto</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The last orbital on the corresponding atom&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">lasto</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbitals</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">list</span><span class="p">[</span><span class="n">Orbital</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;List of orbitals per atom&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span>

    <span class="c1">## End size of geometry</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns geometry coordinates in fractional coordinates&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Specify geometry coordinates&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">add_name</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="o">.</span><span class="n">add_name</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Geometry coordinates (allows supercell indices)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@__getitem__</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na_s</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="o">*</span><span class="n">atoms</span><span class="p">))</span>

    <span class="nd">@__getitem__</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]][</span><span class="o">...</span><span class="p">,</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>

    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_sanitize_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts an `atoms` to index under given inputs</span>

<span class="sd">        `atoms` may be one of the following:</span>

<span class="sd">        - boolean array -&gt; nonzero()[0]</span>
<span class="sd">        - name -&gt; self._names[name]</span>
<span class="sd">        - `Atom` -&gt; self.atoms.index(atom)</span>
<span class="sd">        - range/list/ndarray -&gt; ndarray</span>
<span class="sd">        - `...` -&gt; ndarray</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayl</span><span class="p">([])</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">atoms</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">AtomCategory</span><span class="p">)</span>
    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">GenericCategory</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms_</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">AtomCategory</span><span class="p">,</span> <span class="n">GenericCategory</span><span class="p">],</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># First do categorization</span>
        <span class="n">cat</span> <span class="o">=</span> <span class="n">atoms_</span><span class="o">.</span><span class="n">categorize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="n">cat</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">c</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cat</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">c</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># we are using NullCategory == None</span>
                    <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">ia</span>

        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">fromiterl</span><span class="p">(</span><span class="n">m</span><span class="p">(</span><span class="n">cat</span><span class="p">))</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms_</span><span class="p">:</span> <span class="nb">dict</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># First do categorization</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">AtomCategory</span><span class="o">.</span><span class="n">kw</span><span class="p">(</span><span class="o">**</span><span class="n">atoms_</span><span class="p">),</span> <span class="n">atoms</span><span class="p">)</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="c1"># This is perhaps a bit weird since a shape could</span>
        <span class="c1"># extend into the supercell.</span>
        <span class="c1"># Since the others only does this for unit-cell atoms</span>
        <span class="c1"># then it seems natural to also do that here...</span>
        <span class="k">return</span> <span class="n">atoms</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>

    <span class="nd">@_sanitize_atoms</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

    <span class="nd">@singledispatchmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_sanitize_orbs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts an `orbital` to index under given inputs</span>

<span class="sd">        `orbital` may be one of the following:</span>

<span class="sd">        - boolean array -&gt; nonzero()[0]</span>
<span class="sd">        - dict -&gt; {atom: sub_orbital}</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="bp">Ellipsis</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayl</span><span class="p">([])</span>
        <span class="k">elif</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">orbitals</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">ndarray</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">bool_</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">flatnonzero</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orbitals</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="nb">slice</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">indices</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="o">*</span><span class="n">orbitals</span><span class="p">)</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">Atom</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">AtomCategory</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">Shape</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="nb">dict</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A dict has atoms as keys&quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">conv</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atom</span><span class="p">],</span> <span class="n">orbs</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="nb">tuple</span><span class="p">(</span><span class="n">conv</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">orbs</span><span class="p">)</span> <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">orbs</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">items</span><span class="p">())</span>
        <span class="p">)</span>

    <span class="nd">@_sanitize_orbs</span><span class="o">.</span><span class="n">register</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="nb">bool</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int64</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.as_primary">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.as_primary">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_primary</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">na_primary</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">ret_super</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Geometry</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">Geometry</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce the geometry to the primary unit-cell comprising `na_primary` atoms</span>

<span class="sd">        This will basically try and find the tiling/repetitions required for the geometry to only have</span>
<span class="sd">        `na_primary` atoms in the unit cell.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na_primary :</span>
<span class="sd">           number of atoms in the primary unit cell</span>
<span class="sd">        axes :</span>
<span class="sd">           only search the given directions for supercells, default to all directions</span>
<span class="sd">        ret_super :</span>
<span class="sd">           also return the number of supercells used in each direction</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geometry</span>
<span class="sd">             the primary unit cell</span>
<span class="sd">        Lattice</span>
<span class="sd">             the tiled supercell numbers used to find the primary unit cell (only if `ret_super` is true)</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SislError</span>
<span class="sd">             If the algorithm fails.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">na</span> <span class="o">%</span> <span class="n">na_primary</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.as_primary requires the number of atoms to be divisable by the &quot;</span>
                <span class="s2">&quot;total number of atoms.&quot;</span>
            <span class="p">)</span>

        <span class="n">axes</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>

        <span class="n">n_supercells</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">//</span> <span class="n">na_primary</span>
        <span class="k">if</span> <span class="n">n_supercells</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Return a copy of self</span>
            <span class="k">if</span> <span class="n">ret_super</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Now figure out the repetitions along each direction</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span>
        <span class="c1"># Move to 0</span>
        <span class="n">fxyz</span> <span class="o">-=</span> <span class="n">fxyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Shift a little bit in to account for inaccuracies.</span>
        <span class="n">fxyz</span> <span class="o">+=</span> <span class="p">(</span><span class="mf">0.5</span> <span class="o">-</span> <span class="p">(</span><span class="n">fxyz</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">fxyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.01</span>

        <span class="c1"># Default guess to 1 along all directions</span>
        <span class="n">supercell</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">n_supercells</span>
        <span class="k">while</span> <span class="n">n_bin</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Create bins</span>
            <span class="n">bins</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n_bin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

            <span class="c1"># Loop directions where we need to check</span>
            <span class="k">for</span> <span class="n">axis</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">supercell</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># A histogram should yield an equal splitting for each bins</span>
                <span class="c1"># if the geometry is a n_bin repetition along the i&#39;th direction.</span>
                <span class="c1"># Hence if diff == 0 for all elements we have a match.</span>
                <span class="n">diff_bin</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">histogram</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[:,</span> <span class="n">axis</span><span class="p">],</span> <span class="n">bins</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

                <span class="k">if</span> <span class="n">diff_bin</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">supercell</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="n">n_bin</span>
                    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">n_supercells</span><span class="p">:</span>
                        <span class="c1"># For geometries with more than 1 atom in the primary unit cell</span>
                        <span class="c1"># we can get false positives (each layer can be split again)</span>
                        <span class="c1"># We will search again the max-value supercell</span>
                        <span class="n">i_max</span> <span class="o">=</span> <span class="n">supercell</span><span class="o">.</span><span class="n">argmax</span><span class="p">()</span>
                        <span class="n">n_bin</span> <span class="o">=</span> <span class="n">supercell</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span>
                        <span class="n">supercell</span><span class="p">[</span><span class="n">i_max</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Quick escape if hit the correct number of supercells</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span> <span class="o">==</span> <span class="n">n_supercells</span><span class="p">:</span>
                <span class="k">break</span>

            <span class="n">n_bin</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="c1"># Check that the number of supercells match</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">supercell</span><span class="p">)</span> <span class="o">!=</span> <span class="n">n_supercells</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.as_primary could not determine the optimal supercell.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Cut down the supercell (TODO this does not correct the number of supercell connections!)</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">supercell</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Now we need to find the atoms that are in the primary cell</span>
        <span class="c1"># We do this by finding all coordinates within the primary unit-cell</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">lattice</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="c1"># Move to 0 and shift in 0.05 Ang in each direction</span>
        <span class="n">fxyz</span> <span class="o">-=</span> <span class="n">fxyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Find minimal distance in each direction</span>
        <span class="n">sc_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">supercell</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">min_fxyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">sc_idx</span><span class="p">:</span>
            <span class="n">s_fxyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
            <span class="n">min_fxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">s_fxyz</span><span class="p">[(</span><span class="n">s_fxyz</span> <span class="o">&lt;</span> <span class="mf">1e-4</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">fxyz</span> <span class="o">+=</span> <span class="n">min_fxyz</span> <span class="o">*</span> <span class="mf">0.05</span>

        <span class="c1"># Find all fractional indices that are below 1</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">fxyz</span> <span class="o">&lt;</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">ind</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_super</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geom</span><span class="p">,</span> <span class="n">supercell</span>
        <span class="k">return</span> <span class="n">geom</span></div>


<div class="viewcode-block" id="Geometry.as_supercell">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.as_supercell">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">as_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new geometry equivalent to ``self * self.nsc``, where the indices are ordered as the supercells</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        `Geometry`</span>
<span class="sd">            the supercell expanded and reordered Geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get total number of atoms</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="c1"># create the big supercell geometry in the simplest (linear) way</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span>

        <span class="c1"># remove nsc, this supercell should hold all information</span>
        <span class="n">sc</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>

        <span class="c1"># get off-set for first atom</span>
        <span class="c1"># this is used to correct the indices created after having shifted</span>
        <span class="c1"># everything</span>
        <span class="n">f0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># translate the supercell such that the 0, 0, 0 (primary cell)</span>
        <span class="c1"># is located at the origin.</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="n">sc</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

        <span class="c1"># Calculate the translation table such that the ordering in `sc` can</span>
        <span class="c1"># be made to look like the `self` supercell indices</span>
        <span class="n">isc_sc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">xyz</span><span class="p">[::</span><span class="n">na</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span> <span class="o">-</span> <span class="n">f0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">isc_self</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="n">na</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">new_sub</span><span class="p">(</span><span class="n">isc</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">isc_sc</span> <span class="o">-</span> <span class="n">isc</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Create the translation table for the indices</span>
        <span class="n">translate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">new_sub</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="k">for</span> <span class="n">isc</span> <span class="ow">in</span> <span class="n">isc_self</span><span class="p">])</span>
        <span class="c1"># make sure all atoms are present</span>
        <span class="n">translate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">translate</span> <span class="o">*</span> <span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>

        <span class="c1"># re-arrange the atoms and return</span>
        <span class="k">return</span> <span class="n">sc</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">translate</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span></div>


<div class="viewcode-block" id="Geometry.reorder">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.reorder">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reorder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reorders atoms according to first occurence in the geometry</span>

<span class="sd">        The atoms gets reordered according to their placement in the geometry.</span>
<span class="sd">        For instance, if the first atom is the 2nd species in the geometry. Then</span>
<span class="sd">        this routine will swap the 2nd and 1st species in the `self.atoms` object.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is an in-place operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">reorder</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.reduce">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.reduce">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove all atoms not currently used in the ``self.atoms`` object</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This is an in-place operation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.rij">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.rij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">ja</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Distance between atom `ia` and `ja`, atoms can be in super-cell indices</span>

<span class="sd">        Returns the distance between two atoms:</span>

<span class="sd">        .. math::</span>
<span class="sd">            r^{IJ} = |\mathbf r^J - \mathbf r^I|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia :</span>
<span class="sd">           atomic index of first atom</span>
<span class="sd">        ja :</span>
<span class="sd">           atomic indices</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orij : distance between two orbitals</span>
<span class="sd">        oRij : vector between two orbitals</span>
<span class="sd">        Rij : vector between two atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">ja</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mf">2.0</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">R</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

        <span class="k">return</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">R</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.Rij">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.Rij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">Rij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">ja</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Vector between atom `ia` and `ja`, atoms can be in super-cell indices</span>

<span class="sd">        Returns the vector between two atoms:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf r^{IJ} = \mathbf r^J - \mathbf r^I</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia :</span>
<span class="sd">           atomic index of first atom</span>
<span class="sd">        ja :</span>
<span class="sd">           atomic indices</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orij : distance between two orbitals</span>
<span class="sd">        oRij : vector between two orbitals</span>
<span class="sd">        rij : distance between two atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>
        <span class="n">xj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ja</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ja</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xj</span><span class="p">[:]</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[:]</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xi</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">xj</span><span class="o">.</span><span class="n">shape</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span>

        <span class="k">return</span> <span class="n">xj</span> <span class="o">-</span> <span class="n">xi</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="Geometry.orij">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.orij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">orij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals1</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">,</span> <span class="n">orbitals2</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Distance between orbital `orbitals1` and `orbitals2`, orbitals can be in super-cell indices</span>

<span class="sd">        Returns the distance between two orbitals:</span>

<span class="sd">        .. math::</span>
<span class="sd">            r^{ij} = |\mathbf r^j - \mathbf r^i|</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals1 :</span>
<span class="sd">           orbital index of first orbital</span>
<span class="sd">        orbitals2 :</span>
<span class="sd">           orbital indices</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        oRij : vector between two orbitals</span>
<span class="sd">        rij : distance between two atoms</span>
<span class="sd">        Rij : vector between two atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals2</span><span class="p">))</span></div>


<div class="viewcode-block" id="Geometry.oRij">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.oRij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">oRij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals1</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">,</span> <span class="n">orbitals2</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Vector between orbital `orbitals1` and `orbitals2`, orbitals can be in super-cell indices</span>

<span class="sd">        Returns the vector between two orbitals:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf r^{ij} = \mathbf r^j - \mathbf r^i</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals1 :</span>
<span class="sd">           orbital index of first orbital</span>
<span class="sd">        orbitals2 :</span>
<span class="sd">           orbital indices</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orij : distance between two orbitals</span>
<span class="sd">        rij : distance between two atoms</span>
<span class="sd">        Rij : vector between two atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Rij</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals1</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals2</span><span class="p">))</span></div>


<div class="viewcode-block" id="Geometry.read">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.read">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="n">sile</span><span class="p">:</span> <span class="n">SileLike</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads geometry from the `Sile` using `Sile.read_geometry`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        sile :</span>
<span class="sd">            a `Sile` object which will be used to read the geometry</span>
<span class="sd">            if it is a string it will create a new sile using `get_sile`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        write : writes a `Geometry` to a given `Sile`/file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># This only works because, they *must*</span>
        <span class="c1"># have been imported previously</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sisl.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseSile</span><span class="p">,</span> <span class="n">get_sile</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">sile</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">fh</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;str of the object&quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">na: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s2">, no: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2"> &quot;</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="n">s</span>
            <span class="o">+</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> maxR: </span><span class="si">{0:.5f}</span><span class="s2">,</span><span class="se">\n</span><span class="s2"> </span><span class="si">{1}</span><span class="se">\n</span><span class="s2">}}&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">(),</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A simple, short string representation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> na=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s2">, no=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="si">}</span><span class="s2">, nsc=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

<div class="viewcode-block" id="Geometry.iter">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.iter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An iterator over all atomic indices</span>

<span class="sd">        This iterator is the same as:</span>

<span class="sd">        &gt;&gt;&gt; for ia in range(len(self)):</span>
<span class="sd">        ...    &lt;do something&gt;</span>

<span class="sd">        or equivalently</span>

<span class="sd">        &gt;&gt;&gt; for ia in self:</span>
<span class="sd">        ...    &lt;do something&gt;</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter_species : iterate across indices and atomic species</span>
<span class="sd">        iter_orbitals : iterate across atomic indices and orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span></div>


    <span class="fm">__iter__</span> <span class="o">=</span> <span class="nb">iter</span>

<div class="viewcode-block" id="Geometry.iter_species">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_species">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_species</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator over all atoms (or a subset) and species as a tuple in this geometry</span>

<span class="sd">        &gt;&gt;&gt; for ia, a, idx_species in self.iter_species():</span>
<span class="sd">        ...     isinstance(ia, int) == True</span>
<span class="sd">        ...     isinstance(a, Atom) == True</span>
<span class="sd">        ...     isinstance(idx_species, int) == True</span>

<span class="sd">        with ``ia`` being the atomic index, ``a`` the `Atom` object, ``idx_species``</span>
<span class="sd">        is the index of the specie</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           only loop on the given atoms, default to all atoms</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter : iterate over atomic indices</span>
<span class="sd">        iter_orbitals : iterate across atomic indices and orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">():</span>
                <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span></div>


<div class="viewcode-block" id="Geometry.iter_orbitals">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_orbitals">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_orbitals</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">local</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns an iterator over all atoms and their associated orbitals</span>

<span class="sd">        &gt;&gt;&gt; for ia, io in self.iter_orbitals():</span>

<span class="sd">        with ``ia`` being the atomic index, ``io`` the associated orbital index on atom ``ia``.</span>
<span class="sd">        Note that ``io`` will start from ``0``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           only loop on the given atoms, default to all atoms</span>
<span class="sd">        local :</span>
<span class="sd">           whether the orbital index is the global index, or the local index relative to</span>
<span class="sd">           the atom it resides on.</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        ia</span>
<span class="sd">           atomic index</span>
<span class="sd">        io</span>
<span class="sd">           orbital index</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter : iterate over atomic indices</span>
<span class="sd">        iter_species : iterate across indices and atomic species</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">IO</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">IO</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">IO</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">IO</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">IO</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">local</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io1</span><span class="p">,</span> <span class="n">io2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">io2</span> <span class="o">-</span> <span class="n">io1</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io1</span><span class="p">,</span> <span class="n">io2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">atoms</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="p">):</span>
                    <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">io1</span><span class="p">,</span> <span class="n">io2</span><span class="p">):</span>
                        <span class="k">yield</span> <span class="n">ia</span><span class="p">,</span> <span class="n">io</span></div>


<div class="viewcode-block" id="Geometry.iR">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.iR">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iR</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">na</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">iR</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return an integer number of maximum radii (``self.maxR()``) which holds approximately `na` atoms</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        na :</span>
<span class="sd">           number of atoms within the radius</span>
<span class="sd">        iR :</span>
<span class="sd">           initial `iR` value, which the sphere is estitametd from</span>
<span class="sd">        R :</span>
<span class="sd">           the value used for atomic range (defaults to ``self.maxR()``)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int</span>
<span class="sd">            number of radius needed to contain `na` atoms. Minimally 2 will be returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>

        <span class="c1"># default block iterator</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iR unable to determine a number of atoms within a sphere with negative radius, is maxR() defined?&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Number of atoms within 20 * R</span>
        <span class="n">naiR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span> <span class="o">*</span> <span class="n">iR</span><span class="p">)))</span>

        <span class="c1"># Convert to na atoms spherical radii</span>
        <span class="n">iR</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">R</span><span class="o">**</span><span class="mi">3</span> <span class="o">/</span> <span class="n">naiR</span> <span class="o">*</span> <span class="n">na</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">max</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">iR</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.iter_block_rand">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_block_rand">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_block_rand</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">iR</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the *random* block-iteration by randomly selecting the next center of block&quot;&quot;&quot;</span>

        <span class="c1"># We implement yields as we can then do nested iterators</span>
        <span class="c1"># create a boolean array</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="c1"># Reverse the values</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Figure out how many we need to loop on</span>
        <span class="n">not_passed_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iR</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block_rand too small iR!&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="c1"># The boundaries (ensure complete overlap)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">iR</span> <span class="o">+</span> <span class="mf">0.501</span><span class="p">])</span> <span class="o">*</span> <span class="n">R</span>

        <span class="c1"># loop until all passed are true</span>
        <span class="k">while</span> <span class="n">not_passed_N</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Take a random non-passed element</span>
            <span class="n">all_true</span> <span class="o">=</span> <span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># Shuffle should increase the chance of hitting a</span>
            <span class="c1"># completely &quot;fresh&quot; segment, thus we take the most</span>
            <span class="c1"># atoms at any single time.</span>
            <span class="c1"># Shuffling will cut down needed iterations.</span>
            <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">shuffle</span><span class="p">(</span><span class="n">all_true</span><span class="p">)</span>
            <span class="c1"># take one element, after shufling, we can take the first</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">all_true</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">all_true</span>

            <span class="c1"># Now we have found a new index, from which</span>
            <span class="c1"># we want to create the index based stuff on</span>

            <span class="c1"># get all elements within two radii</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>

            <span class="c1"># Get unit-cell atoms, we are drawing a circle, and this</span>
            <span class="c1"># circle only encompasses those already in the unit-cell.</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="c1"># If we translated stuff into the unit-cell, we could end up in situations</span>
            <span class="c1"># where the supercell atom is in the circle, but not the UC-equivalent</span>
            <span class="c1"># of that one.</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">na</span><span class="p">]</span>

            <span class="c1"># Only select those who have not been runned yet</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Tell the next loop to skip those passed</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Update looped variables</span>
            <span class="n">not_passed_N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Now we want to yield the stuff revealed</span>
            <span class="c1"># all_idx[0] contains the elements that should be looped</span>
            <span class="c1"># all_idx[1] contains the indices that can be searched</span>
            <span class="k">yield</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_passed</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">))</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block_rand error on iterations. Not all atoms have been visited.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.iter_block_shape">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_block_shape">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_block_shape</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">iR</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Perform the *grid* block-iteration by looping a grid&quot;&quot;&quot;</span>

        <span class="c1"># We implement yields as we can then do nested iterators</span>
        <span class="c1"># create a boolean array</span>
        <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
            <span class="c1"># Reverse the values</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">not_passed</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">na</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Figure out how many we need to loop on</span>
        <span class="n">not_passed_N</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">not_passed</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">iR</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block_shape too small iR!&quot;</span><span class="p">)</span>

        <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="n">shape</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we default to the Cube shapes</span>
            <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cube</span><span class="p">((</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">),</span> <span class="n">Cube</span><span class="p">((</span><span class="n">iR</span> <span class="o">+</span> <span class="mf">1.501</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">shape</span><span class="p">,)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">+=</span> <span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">expand</span><span class="p">(</span><span class="n">R</span><span class="p">),)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block_shape, number of Shapes *must* be one or two&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Now create the Grid</span>
        <span class="c1"># convert the radius to a square Grid</span>
        <span class="c1"># We do this by examining the x, y, z coordinates</span>
        <span class="n">xyz_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">xyz_M</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">dxyz</span> <span class="o">=</span> <span class="n">xyz_M</span> <span class="o">-</span> <span class="n">xyz_m</span>

        <span class="c1"># Currently iterating different shapes only works for</span>
        <span class="c1"># Sphere and Cube</span>
        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dS</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="p">(</span><span class="n">Cube</span><span class="p">,</span> <span class="n">Sphere</span><span class="p">)):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block_shape currently only works for &quot;</span>
                    <span class="s2">&quot;Cube or Sphere objects. Please change sources.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Retrieve the internal diameter</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cube</span><span class="p">):</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">edge_length</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Sphere</span><span class="p">):</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="p">[</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="c1"># Convert to spheres (which probably should be cubes for performance)</span>
            <span class="n">dS</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">Sphere</span><span class="p">()</span> <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="n">dS</span><span class="p">]</span>
            <span class="c1"># Now do the same with spheres</span>
            <span class="n">ir</span> <span class="o">=</span> <span class="p">[</span><span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span> <span class="o">*</span> <span class="mf">0.5</span><span class="o">**</span><span class="mf">0.5</span> <span class="o">*</span> <span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>

        <span class="c1"># Figure out number of segments in each iteration</span>
        <span class="c1"># (minimum 1)</span>
        <span class="n">ixyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">ceil</span><span class="p">(</span><span class="n">dxyz</span> <span class="o">/</span> <span class="n">ir</span> <span class="o">+</span> <span class="mf">0.0001</span><span class="p">))</span>

        <span class="c1"># Calculate the steps required for each iteration</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">/</span> <span class="n">ixyz</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Correct the initial position to offset the initial displacement</span>
            <span class="c1"># so that we are at the border.</span>
            <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="nb">min</span><span class="p">(</span><span class="n">dxyz</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">ir</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

            <span class="k">if</span> <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">xyz_M</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span>
                <span class="c1"># This is the case where one of the cell dimensions</span>
                <span class="c1"># is far too great.</span>
                <span class="c1"># In this case ixyz[i] should be 1</span>
                <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">xyz_M</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz_m</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Shorthand function</span>
        <span class="n">where</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span>

        <span class="c1"># Now we loop in each direction</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="nb">range</span><span class="p">(</span><span class="n">ixyz</span><span class="p">[</span><span class="mi">2</span><span class="p">])):</span>
            <span class="c1"># Create the new center</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">xyz_m</span> <span class="o">+</span> <span class="p">[</span><span class="n">x</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">y</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">z</span> <span class="o">*</span> <span class="n">dxyz</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># Correct in case the iteration steps across the maximum</span>
            <span class="n">center</span> <span class="o">=</span> <span class="n">where</span><span class="p">(</span><span class="n">center</span> <span class="o">&lt;</span> <span class="n">xyz_M</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">xyz_M</span><span class="p">)</span>
            <span class="n">dS</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">[:]</span>
            <span class="n">dS</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">[:]</span>

            <span class="c1"># Now perform the iteration</span>
            <span class="c1"># get all elements within two radii</span>
            <span class="n">all_idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">within</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span>

            <span class="c1"># Get unit-cell atoms, we are drawing a circle, and this</span>
            <span class="c1"># circle only encompasses those already in the unit-cell.</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">union1d</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">),</span>
            <span class="p">)</span>
            <span class="c1"># If we translated stuff into the unit-cell, we could end up in situations</span>
            <span class="c1"># where the supercell atom is in the circle, but not the UC-equivalent</span>
            <span class="c1"># of that one.</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">na</span><span class="p">]</span>

            <span class="c1"># Only select those who have not been runned yet</span>
            <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Tell the next loop to skip those passed</span>
            <span class="n">not_passed</span><span class="p">[</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Update looped variables</span>
            <span class="n">not_passed_N</span> <span class="o">-=</span> <span class="nb">len</span><span class="p">(</span><span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

            <span class="c1"># Now we want to yield the stuff revealed</span>
            <span class="c1"># all_idx[0] contains the elements that should be looped</span>
            <span class="c1"># all_idx[1] contains the indices that can be searched</span>
            <span class="k">yield</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">all_idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">not_passed</span><span class="p">):</span>
            <span class="n">not_passed</span> <span class="o">=</span> <span class="n">not_passed</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block_shape error on iterations. Not all atoms have been visited &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">not_passed</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.iter_block">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.iter_block">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter_block</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">iR</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">20</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rand&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator for performance critical loops</span>

<span class="sd">        NOTE: This requires that `R` has been set correctly as the maximum interaction range.</span>

<span class="sd">        I.e. the loop would look like this:</span>

<span class="sd">        &gt;&gt;&gt; for ias, idxs in self.iter_block():</span>
<span class="sd">        ...    for ia in ias:</span>
<span class="sd">        ...        idx_a = self.close(ia, R = R, idx = idxs)</span>

<span class="sd">        This iterator is intended for systems with more than 1000 atoms.</span>

<span class="sd">        Remark that the iterator used is non-deterministic, i.e. any two iterators need</span>
<span class="sd">        not return the same atoms in any way.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        iR :</span>
<span class="sd">            the number of `R` ranges taken into account when doing the iterator</span>
<span class="sd">        R :</span>
<span class="sd">            enables overwriting the local R quantity. Defaults to ``self.maxR() + 0.001``</span>
<span class="sd">        atoms :</span>
<span class="sd">            enables only effectively looping a subset of the full geometry</span>
<span class="sd">        method : {&#39;rand&#39;, &#39;sphere&#39;, &#39;cube&#39;}</span>
<span class="sd">            select the method by which the block iteration is performed.</span>
<span class="sd">            Possible values are:</span>

<span class="sd">             `rand`: a spherical object is constructed with a random center according to the internal atoms</span>
<span class="sd">             `sphere`: a spherical equispaced shape is constructed and looped</span>
<span class="sd">             `cube`: a cube shape is constructed and looped</span>

<span class="sd">        Yields</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            current list of atoms currently searched</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            atoms that needs searching</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">iR</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block too small iR!&quot;</span><span class="p">)</span>

        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;rand&quot;</span><span class="p">,</span> <span class="s2">&quot;random&quot;</span><span class="p">):</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block_rand</span><span class="p">(</span><span class="n">iR</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">atoms</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;sphere&quot;</span><span class="p">,</span> <span class="s2">&quot;cube&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>

            <span class="c1"># Create shapes</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;sphere&quot;</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span><span class="n">Sphere</span><span class="p">((</span><span class="n">iR</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">),</span> <span class="n">Sphere</span><span class="p">((</span><span class="n">iR</span> <span class="o">+</span> <span class="mf">0.501</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;cube&quot;</span><span class="p">:</span>
                <span class="n">dS</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="n">Cube</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iR</span> <span class="o">-</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">),</span>
                    <span class="c1"># we need an extra R here since it needs to extend on both sides</span>
                    <span class="n">Cube</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">iR</span> <span class="o">+</span> <span class="mf">1.501</span><span class="p">)</span> <span class="o">*</span> <span class="n">R</span><span class="p">),</span>
                <span class="p">)</span>

            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block_shape</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.iter_block got unexpected &#39;method&#39; argument: </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.overlap">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.overlap">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;eps&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument eps has been deprecated in favor of atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">overlap</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">GeometryLikeType</span><span class="p">,</span>
        <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
        <span class="n">offset_other</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the overlapping indices between two geometries</span>

<span class="sd">        Find equivalent atoms (in the primary unit-cell only) in two geometries.</span>
<span class="sd">        This routine finds which atoms have the same atomic positions in `self` and `other`.</span>

<span class="sd">        Note that this will return duplicate overlapping atoms if one atoms lies within `eps`</span>
<span class="sd">        of more than 1 atom in `other`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other :</span>
<span class="sd">           Geometry to compare with `self`</span>
<span class="sd">        atol :</span>
<span class="sd">           atoms within this distance will be considered *equivalent*</span>
<span class="sd">        offset :</span>
<span class="sd">           offset for `self.xyz` before comparing</span>
<span class="sd">        offset_other :</span>
<span class="sd">           offset for `other.xyz` before comparing</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gr22 = sisl.geom.graphene().tile(2, 0).tile(2, 1)</span>
<span class="sd">        &gt;&gt;&gt; gr44 = gr22.tile(2, 0).tile(2, 1)</span>
<span class="sd">        &gt;&gt;&gt; offset = np.array([0.2, 0.4, 0.4])</span>
<span class="sd">        &gt;&gt;&gt; gr22 = gr22.translate(offset)</span>
<span class="sd">        &gt;&gt;&gt; idx = np.arange(len(gr22))</span>
<span class="sd">        &gt;&gt;&gt; np.random.shuffle(idx)</span>
<span class="sd">        &gt;&gt;&gt; gr22 = gr22.sub(idx)</span>
<span class="sd">        &gt;&gt;&gt; idx22, idx44 = gr22.overlap(gr44, offset=-offset)</span>
<span class="sd">        &gt;&gt;&gt; assert idx22 == np.arange(len(gr22))</span>
<span class="sd">        &gt;&gt;&gt; assert idx44 == idx</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        idx_self : numpy.ndarray of int</span>
<span class="sd">             indices in `self` that are equivalent with `idx_other`</span>
<span class="sd">        idx_other : numpy.ndarray of int</span>
<span class="sd">             indices in `other` that are equivalent with `idx_self`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># sanitize `other`</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="n">s_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span> <span class="o">-</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset_other</span><span class="p">))</span>
        <span class="n">idx_self</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">self_extend</span> <span class="o">=</span> <span class="n">idx_self</span><span class="o">.</span><span class="n">extend</span>
        <span class="n">idx_other</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">other_extend</span> <span class="o">=</span> <span class="n">idx_other</span><span class="o">.</span><span class="n">extend</span>

        <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">xyz</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">s_xyz</span><span class="p">):</span>
            <span class="c1"># only search in the primary unit-cell</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="n">atol</span><span class="p">,))</span>
            <span class="n">self_extend</span><span class="p">([</span><span class="n">ia</span><span class="p">]</span> <span class="o">*</span> <span class="n">idx</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
            <span class="n">other_extend</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">idx_self</span><span class="p">),</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">idx_other</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.find_nsc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.find_nsc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">find_nsc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CellAxes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;overlap&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;atoms&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find number of supercells for the geometry, depending on certain criteria</span>

<span class="sd">        This can find the optimal ``nsc`` values for a given method.</span>

<span class="sd">        The important parameter, `method` determines how ``nsc`` is found.</span>
<span class="sd">        The method are shown here, from method that produces the smallest ``nsc``, up</span>
<span class="sd">        to the largest ``nsc``.</span>

<span class="sd">        ``method=atoms``</span>
<span class="sd">            here only the atoms ranges are taken into account, and only</span>
<span class="sd">            whether atoms in the primary unit cell can connect to others in neigboring</span>
<span class="sd">            cells.</span>

<span class="sd">        ``method=cell``</span>
<span class="sd">            only the atoms ranges are taken into account.</span>
<span class="sd">            For instance if a lattice vector is as long as the orbital range</span>
<span class="sd">            it will have 3 supercells (it can only connect to its neighboring</span>
<span class="sd">            cells).</span>

<span class="sd">        ``method=overlap``</span>
<span class="sd">            determine nsc by examining at what range two orbitals overlaps.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes :</span>
<span class="sd">           only discover new ``nsc`` the specified axes (defaults to all)</span>
<span class="sd">        R :</span>
<span class="sd">           the maximum connection radius for each atom, defaults to ``self.maxR()``.</span>
<span class="sd">        method:</span>
<span class="sd">            See discussion above.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray: the found nsc that obeys `method`</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        optimize_nsc: same as this, but equivalent to also doing ``self.set_nsc(self.find_nsc(...))``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">listify</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span> <span class="o">|</span> <span class="n">listify</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># requesting no search space</span>
            <span class="k">return</span> <span class="n">nsc</span>

        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="mf">0.00001</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="s2">&quot;.find_nsc could not determine the radius from the &quot;</span>
                <span class="s2">&quot;internal atoms (defaulting to zero radius).&quot;</span>
            <span class="p">)</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">length</span><span class="p">,</span> <span class="n">angles</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">parameters</span><span class="p">()</span>

        <span class="c1"># TODO check that angles below 60 degrees are</span>
        <span class="c1"># important.</span>

        <span class="c1"># Half-nsc (only 1 direction)</span>
        <span class="n">hsc</span> <span class="o">=</span> <span class="n">nsc</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="c1"># determine the maximum hsc values</span>
        <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">):</span>
            <span class="n">R_actual</span> <span class="o">=</span> <span class="n">R</span>
        <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;overlap&quot;</span><span class="p">,):</span>
            <span class="n">R_actual</span> <span class="o">=</span> <span class="n">R</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.find_nsc got wrong &#39;method&#39; argument, got </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Determine the actual range depending on the actual R</span>
        <span class="n">hsc</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">R_actual</span> <span class="o">/</span> <span class="n">length</span><span class="p">[</span><span class="n">axes</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;atoms&quot;</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">simplefilter</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

                <span class="n">isc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ax</span> <span class="ow">in</span> <span class="n">axes</span><span class="p">:</span>
                    <span class="c1"># Initialize the isc for this direction</span>
                    <span class="c1"># (note we do not take non-orthogonal directions</span>
                    <span class="c1">#  into account)</span>
                    <span class="n">isc</span><span class="p">[:]</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="c1"># Initialize the actual number of supercell connections</span>
                    <span class="c1"># along this direction.</span>
                    <span class="n">prev_isc</span> <span class="o">=</span> <span class="mi">0</span>

                    <span class="k">while</span> <span class="n">prev_isc</span> <span class="o">==</span> <span class="n">isc</span><span class="p">[</span><span class="n">ax</span><span class="p">]:</span>
                        <span class="c1"># Try next supercell connection</span>
                        <span class="n">isc</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">+=</span> <span class="mi">1</span>

                        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>
                            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                                <span class="n">prev_isc</span> <span class="o">=</span> <span class="n">isc</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span>
                                <span class="k">break</span>

                    <span class="n">hsc</span><span class="p">[</span><span class="n">ax</span><span class="p">]</span> <span class="o">=</span> <span class="n">prev_isc</span>

        <span class="n">nsc</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span> <span class="o">=</span> <span class="n">hsc</span><span class="p">[</span><span class="n">axes</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">nsc</span></div>


<div class="viewcode-block" id="Geometry.optimize_nsc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.optimize_nsc">[docs]</a>
    <span class="nd">@deprecation</span><span class="p">(</span>
        <span class="s2">&quot;optimize_nsc is deprecated, update the code to use &#39;find_nsc&#39; and then &#39;set_nsc&#39;&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15.0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16.0&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">optimize_nsc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CellAxes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Optimize the number of supercell connections based on ``self.maxR()``</span>

<span class="sd">        After this routine the number of supercells may not necessarily be the same.</span>

<span class="sd">        This is an in-place operation.</span>

<span class="sd">        Deprecated method!</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        axes :</span>
<span class="sd">           only optimize the specified axes (default to all)</span>
<span class="sd">        R :</span>
<span class="sd">           the maximum connection radius for each atom</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">find_nsc</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;atoms&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nsc</span></div>


<div class="viewcode-block" id="Geometry.sub_orbital">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.sub_orbital">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sub_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Retain only a subset of the orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        This allows one to retain only a given subset of geometry.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals :</span>
<span class="sd">            indices of the orbitals on `atoms` that are retained in the geometry, the list of</span>
<span class="sd">            orbitals will be sorted.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Future implementations may allow one to re-arrange orbitals using this method.</span>

<span class="sd">        When using this method the internal species list will be populated by another specie</span>
<span class="sd">        that is named after the orbitals removed. This is to distinguish different atoms.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; # a Carbon atom with 2 orbitals</span>
<span class="sd">        &gt;&gt;&gt; C = sisl.Atom(&#39;C&#39;, [1., 2.])</span>
<span class="sd">        &gt;&gt;&gt; # an oxygen atom with 3 orbitals</span>
<span class="sd">        &gt;&gt;&gt; O = sisl.Atom(&#39;O&#39;, [1., 2., 2.4])</span>
<span class="sd">        &gt;&gt;&gt; geometry = sisl.Geometry([[0] * 3, [1] * 3]], 2, [C, O])</span>

<span class="sd">        Now ``geometry`` is a geometry with 2 different species and 6 atoms (3 of each).</span>
<span class="sd">        They are ordered ``[C, O, C, O, C, O]``. In the following we</span>
<span class="sd">        will note species that are different from the original by a ``&#39;`` in the list.</span>

<span class="sd">        Retain 2nd orbital on the 2nd atom: ``[C, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(1, 1)</span>

<span class="sd">        Retain 2nd orbital on 1st and 2nd atom: ``[C&#39;, O&#39;, C, O, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital([0, 1], 1)</span>

<span class="sd">        Retain 2nd orbital on the 1st atom and 3rd orbital on 4th atom: ``[C&#39;, O, C, O&#39;, C, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(0, 1).sub_orbital(3, 2)</span>

<span class="sd">        Retain 2nd orbital on all atoms equivalent to the first atom: ``[C&#39;, O, C&#39;, O, C&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(obj.geometry.atoms[0], 1)</span>

<span class="sd">        Retain 1st orbital on 1st atom, and 2nd orbital on 3rd and 5th atom: ``[C&#39;, O, C&#39;&#39;, O, C&#39;&#39;, O]``</span>

<span class="sd">        &gt;&gt;&gt; new_geom = geometry.sub_orbital(0, 0).sub_orbital([2, 4], 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        remove_orbital : removing a set of orbitals (opposite of this)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_species</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_species</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_species</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># At this point we are sure that uniq_species is *only* one specie!</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="n">old_atom_species</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species_index</span><span class="p">(</span><span class="n">old_atom</span><span class="p">)</span>
        <span class="n">old_atom_count</span> <span class="o">=</span> <span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species</span> <span class="o">==</span> <span class="n">old_atom_species</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.sub_orbital trying to retain 0 orbitals on a given atom. This is not allowed!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># create the new atom</span>
        <span class="n">new_atom</span> <span class="o">=</span> <span class="n">old_atom</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="c1"># Rename the new-atom to &lt;&gt;_1_2 for orbital == [1, 2]</span>
        <span class="n">new_atom</span><span class="o">.</span><span class="n">_tag</span> <span class="o">+=</span> <span class="s2">&quot;_&quot;</span> <span class="o">+</span> <span class="s2">&quot;_&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">))</span>

        <span class="c1"># There are now 2 cases.</span>
        <span class="c1">#  1. we replace all atoms of a given specie</span>
        <span class="c1">#  2. we replace a subset of atoms of a given specie</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="n">old_atom_count</span><span class="p">:</span>
            <span class="c1"># We catch the warning about reducing the number of orbitals!</span>
            <span class="k">with</span> <span class="n">warnings</span><span class="o">.</span><span class="n">catch_warnings</span><span class="p">():</span>
                <span class="n">warnings</span><span class="o">.</span><span class="n">filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>
                <span class="c1"># this is in-place operation and we don&#39;t need to worry about</span>
                <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">replace_atom</span><span class="p">(</span><span class="n">old_atom</span><span class="p">,</span> <span class="n">new_atom</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># we have to add the new one (in case it does not exist)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">new_atom_species</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species_index</span><span class="p">(</span><span class="n">new_atom</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">new_atom_species</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">nspecies</span>
                <span class="c1"># the above checks that it is indeed a new atom</span>
                <span class="n">geom</span><span class="o">.</span><span class="n">_atoms</span><span class="o">.</span><span class="n">_atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new_atom</span><span class="p">)</span>
            <span class="c1"># transfer specie index</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_species</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_atom_species</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">_update_orbitals</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">geom</span></div>


<div class="viewcode-block" id="Geometry.remove_orbital">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.remove_orbital">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">remove_orbital</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Remove a subset of orbitals on `atoms` according to `orbitals`</span>

<span class="sd">        For more detailed examples, please see the equivalent (but opposite) method</span>
<span class="sd">        `sub_orbital`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or Atom</span>
<span class="sd">            indices of atoms or `Atom` that will be reduced in size according to `orbitals`</span>
<span class="sd">        orbitals : array_like of int or Orbital</span>
<span class="sd">            indices of the orbitals on `atoms` that are removed from the geometry.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sub_orbital : retaining a set of orbitals (see here for examples)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get specie index of the atom (convert to list of indices)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out if all atoms have the same species</span>
        <span class="n">species</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">species</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="n">uniq_species</span><span class="p">,</span> <span class="n">indices</span> <span class="o">=</span> <span class="n">unique</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">return_inverse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">uniq_species</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># In case there are multiple different species but one wishes to</span>
            <span class="c1"># retain the same orbital index, then we loop on the unique species</span>
            <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">uniq_species</span><span class="o">.</span><span class="n">size</span><span class="p">):</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">indices</span> <span class="o">==</span> <span class="n">i</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># now determine whether it is the whole atom</span>
                <span class="c1"># or only part of the geometry</span>
                <span class="n">new</span> <span class="o">=</span> <span class="n">new</span><span class="o">.</span><span class="n">remove_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">idx</span><span class="p">],</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">new</span>

        <span class="c1"># Get the atom object we wish to reduce</span>
        <span class="c1"># We know np.all(geom.atoms[atom] == old_atom)</span>
        <span class="n">old_atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">orbitals</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span><span class="n">old_atom</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">orb</span><span class="p">)</span> <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbitals</span><span class="p">]</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">old_atom</span><span class="p">)),</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># now call sub_orbital</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_orbital</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;tile&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Implement easy tile/repeat function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : int or tuple or list or (tuple, str) or (list, str)</span>
<span class="sd">           a tuple/list may be of length 2 or 3. A length of 2 corresponds</span>
<span class="sd">           to tuple[0] == *number of multiplications*, tuple[1] is the</span>
<span class="sd">           axis.</span>
<span class="sd">           A length of 3 corresponds to each of the directions.</span>
<span class="sd">           An optional string may be used to specify the `tile` or `repeat` function.</span>
<span class="sd">           The default is the `tile` function.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geometry = Geometry([0.] * 3, lattice=[1.5, 3, 4])</span>
<span class="sd">        &gt;&gt;&gt; geometry * 2 == geometry.tile(2, 0).tile(2, 1).tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * [2, 1, 2] == geometry.tile(2, 0).tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * [2, 2] == geometry.tile(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 1, 2], &#39;repeat&#39;) == geometry.repeat(2, 0).repeat(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 1, 2], &#39;r&#39;) == geometry.repeat(2, 0).repeat(2, 2)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 0], &#39;r&#39;) == geometry.repeat(2, 0)</span>
<span class="sd">        True</span>
<span class="sd">        &gt;&gt;&gt; geometry * ([2, 2], &#39;r&#39;) == geometry.repeat(2, 2)</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        tile : specific method to enlarge the geometry</span>
<span class="sd">        repeat : specific method to enlarge the geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Simple form</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="p">[</span><span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">m</span><span class="p">]</span>

        <span class="c1"># Error in argument, fall-back</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span> <span class="o">*</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Look-up table</span>
        <span class="n">method_tbl</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;repeat&quot;</span><span class="p">:</span> <span class="s2">&quot;repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">:</span> <span class="s2">&quot;tile&quot;</span><span class="p">,</span> <span class="s2">&quot;tile&quot;</span><span class="p">:</span> <span class="s2">&quot;tile&quot;</span><span class="p">}</span>

        <span class="c1"># Determine the type</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1"># either</span>
            <span class="c1">#  (r, axis)</span>
            <span class="c1">#  ((...), method</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">method_tbl</span><span class="p">[</span><span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1">#  r</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="c1">#  (r, axis)</span>
            <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="c1">#  (r, r, r)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="n">g</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">method</span><span class="p">)(</span><span class="n">m</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">i</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Multiplying a geometry got an unexpected value: </span><span class="si">{</span><span class="n">m</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Default to repeating the atomic structure&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="fm">__mul__</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="s2">&quot;repeat&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.angle">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.angle">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">angle</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span>
        <span class="nb">dir</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">ref</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">rad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;The angle between atom `atoms` and the direction `dir`, with possibility of a reference coordinate `ref`</span>

<span class="sd">        The calculated angle can be written as this</span>

<span class="sd">        .. math::</span>
<span class="sd">            \theta = \arccos \frac{(\mathbf r^I - \mathbf{r^{\mathrm{ref}}})\cdot \mathbf{d}}</span>
<span class="sd">            {|\mathbf r^I-\mathbf{r^{\mathrm{ref}}}||\mathbf{d}|}</span>

<span class="sd">        and thus lies in the interval :math:`[0 ; \pi]` as one cannot distinguish orientation without</span>
<span class="sd">        additional vectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           indices/boolean of all atoms where angles should be calculated on</span>
<span class="sd">        dir :</span>
<span class="sd">           the direction from which the angle is calculated from, default to ``x``.</span>
<span class="sd">           An integer specifies the corresponding lattice vector as the direction.</span>
<span class="sd">        ref :</span>
<span class="sd">           the reference point from which the vectors are drawn, default to origin</span>
<span class="sd">           An integer specifies an atomic index.</span>
<span class="sd">        rad :</span>
<span class="sd">           whether the returned value is in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">xi</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)):</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="nb">dir</span><span class="p">,</span> <span class="n">abc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">xyz</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="nb">dir</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>
        <span class="c1"># Normalize so we don&#39;t have to have this in the</span>
        <span class="c1"># below formula</span>
        <span class="nb">dir</span> <span class="o">=</span> <span class="nb">dir</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="nb">dir</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ref</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ref</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">xi</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">ref</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">xi</span> <span class="o">-=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">ref</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">nx</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">xi</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
        <span class="n">ang</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">nx</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">nx</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ang</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">xi</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">@</span> <span class="nb">dir</span> <span class="o">/</span> <span class="n">nx</span><span class="p">[</span><span class="n">idx</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">rad</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ang</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">ang</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.dihedral">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.dihedral">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dihedral</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span>
        <span class="n">rad</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the dihedral angle defined by four atoms.</span>

<span class="sd">        The dihehral angle is defined between 2 half-planes.</span>

<span class="sd">        The first 3 atoms define the first plane</span>
<span class="sd">        The last 3 atoms define the second.</span>

<span class="sd">        The dihedral angle is calculated using this formula:</span>

<span class="sd">        .. math::</span>

<span class="sd">            \mathbf u_0 &amp;= \mathbf r_1 - \mathbf r_0</span>
<span class="sd">            \\</span>
<span class="sd">            \mathbf u_1 &amp;= \mathbf r_2 - \mathbf r_1</span>
<span class="sd">            \\</span>
<span class="sd">            \mathbf u_2 &amp;= \mathbf r_3 - \mathbf r_2</span>
<span class="sd">            \\</span>
<span class="sd">            \phi &amp;= \operatorname{atan2}\Big(</span>
<span class="sd">                 \hat{\mathbf u}_0\cdot</span>
<span class="sd">                (\hat{\mathbf u}_1\times\hat{\mathbf u}_2),</span>
<span class="sd">                (\hat{\mathbf u}_0\times\hat{\mathbf u}_1)\cdot</span>
<span class="sd">                (\hat{\mathbf u}_1\times\hat{\mathbf u}_2)</span>
<span class="sd">                \Big)</span>

<span class="sd">        Where :math:`\hat{\cdot}` means the unit-vector.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           An array of shape `(4,)` or `(*, 4)` representing the indices of 4 atoms forming the dihedral angle</span>
<span class="sd">        rad :</span>
<span class="sd">           whether the returned value is in radians</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">ndim</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">ndim</span>
        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.dihedral requires atoms to be 4 indices&quot;</span>
                <span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">atoms</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.dihedral requires atoms to be (*, 4) indices&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.dihedral requires atoms index of shape (4,) or (*, 4)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># The 2 planes are defined by</span>
        <span class="c1">#  r0, r1, r2</span>
        <span class="c1"># and</span>
        <span class="c1">#  r1, r2, r3</span>
        <span class="c1">#   we know that atoms has a dimension of 2!</span>
        <span class="n">u</span> <span class="o">=</span> <span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># normalize to make algorithm easier</span>
        <span class="n">u</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">u</span><span class="p">)[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>
        <span class="c1"># calculate the two planes normal vector</span>
        <span class="n">n0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cross</span><span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">u</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">])</span>

        <span class="c1"># Prepare arguments for atan2</span>
        <span class="n">y</span> <span class="o">=</span> <span class="p">(</span><span class="n">u</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">n1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">n0</span> <span class="o">*</span> <span class="n">n1</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># see https://en.wikipedia.org/wiki/Dihedral_angle</span>
        <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arctan2</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">rad</span><span class="p">:</span>
            <span class="n">angles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">degrees</span><span class="p">(</span><span class="n">angles</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ndim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">angles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">angles</span></div>


<div class="viewcode-block" id="Geometry.rotate_miller">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.rotate_miller">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">rotate_miller</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Align Miller direction along ``v``</span>

<span class="sd">        Rotate geometry and cell such that the Miller direction</span>
<span class="sd">        points along the Cartesian vector ``v``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create normal vector to miller direction and cartesian</span>
        <span class="c1"># direction</span>
        <span class="n">cp</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                <span class="n">m</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">m</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>
        <span class="n">cp</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">cp</span><span class="p">)</span>

        <span class="n">lm</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
        <span class="n">lm</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">lm</span><span class="p">)</span>
        <span class="n">lv</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">v</span><span class="p">)</span>
        <span class="n">lv</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">lv</span><span class="p">)</span>

        <span class="c1"># Now rotate the angle between them</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">acos</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">lm</span> <span class="o">*</span> <span class="n">lv</span><span class="p">))</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="n">a</span><span class="p">,</span> <span class="n">cp</span><span class="p">],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.translate2uc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.translate2uc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">translate2uc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">int</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Translates atoms in the geometry into the unit cell</span>

<span class="sd">        One can translate a subset of the atoms or axes by appropriate arguments.</span>

<span class="sd">        Warning</span>
<span class="sd">        -------</span>
<span class="sd">        When coordinates are lying on one of the edges, they may move to the other</span>
<span class="sd">        side of the unit-cell due to small rounding errors.</span>
<span class="sd">        In such situations you are encouraged to shift all coordinates by a small</span>
<span class="sd">        amount to remove numerical errors, in the following case we have atomic</span>
<span class="sd">        coordinates lying close to the lower side of each lattice vector.</span>

<span class="sd">        &gt;&gt;&gt; geometry.translate(1e-8).translate2uc().translate(-1e-8)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        By default only the periodic axes (``self.pbc``) will be translated to the UC. If</span>
<span class="sd">        translation is required for all axes, supply them directly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">             only translate the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be translated</span>
<span class="sd">        axes :</span>
<span class="sd">             only translate certain lattice directions, `None` specifies</span>
<span class="sd">             only the directions with supercells, `True` specifies all</span>
<span class="sd">             directions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axes</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">axes</span><span class="p">:</span>
                <span class="n">axes</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="s2">&quot;translate2uc with a bool argument can only be True to signal all axes&quot;</span>
                <span class="p">)</span>
        <span class="n">axes</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">listify</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span> <span class="o">|</span> <span class="n">listify</span>

        <span class="n">fxyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span>
        <span class="c1"># move to unit-cell</span>
        <span class="n">fxyz</span><span class="p">[:,</span> <span class="n">axes</span><span class="p">]</span> <span class="o">%=</span> <span class="mi">1</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="c1"># convert back</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fxyz</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">fxyz</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span>
        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="Geometry.add_vacuum">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.add_vacuum">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">add_vacuum</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">vacuum</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="n">axis</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Add vacuum along the `axis` lattice vector</span>

<span class="sd">        When the vacuum is bigger than the maximum orbital ranges the</span>
<span class="sd">        number of supercells along that axis will be truncated to 1 (de-couple</span>
<span class="sd">        images).</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        vacuum :</span>
<span class="sd">           amount of vacuum added, in Ang</span>
<span class="sd">        axis :</span>
<span class="sd">           the lattice vector to add vacuum along</span>
<span class="sd">        offset :</span>
<span class="sd">            offset in geometry when adding the vacuum.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Geometry : a new geometry with added vacuum</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">new</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">new</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">offset</span><span class="p">)</span>
        <span class="n">new</span><span class="o">.</span><span class="n">set_lattice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">add_vacuum</span><span class="p">(</span><span class="n">vacuum</span><span class="p">,</span> <span class="n">axis</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">vacuum</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span><span class="p">:</span>
            <span class="c1"># only overwrite along axis</span>
            <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">)]</span>
            <span class="n">nsc</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">new</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">new</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge two geometries (or geometry and supercell)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self, b : Geometry or Lattice or tuple or list</span>
<span class="sd">           when adding a Geometry with a Geometry it defaults to using `add` function</span>
<span class="sd">           with the LHS retaining the cell-vectors.</span>
<span class="sd">           a tuple/list may be of length 2 with the first element being a Geometry and the second</span>
<span class="sd">           being an integer specifying the lattice vector where it is appended.</span>
<span class="sd">           One may also use a `Lattice` instead of a `Geometry` which behaves similarly.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; A + B == A.add(B)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 1) == A.append(B, 1)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 2) == A.append(B, 2)</span>
<span class="sd">        &gt;&gt;&gt; (A, 1) + B == A.append(B, 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">Lattice</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">)):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">b</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">b</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge two geometries (or geometry and supercell)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        self, b : Geometry or Lattice or tuple or list</span>
<span class="sd">           when adding a Geometry with a Geometry it defaults to using `add` function</span>
<span class="sd">           with the LHS retaining the cell-vectors.</span>
<span class="sd">           a tuple/list may be of length 2 with the first element being a Geometry and the second</span>
<span class="sd">           being an integer specifying the lattice vector where it is appended.</span>
<span class="sd">           One may also use a `Lattice` instead of a `Geometry` which behaves similarly.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; A + B == A.add(B)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 1) == A.append(B, 1)</span>
<span class="sd">        &gt;&gt;&gt; A + (B, 2) == A.append(B, 2)</span>
<span class="sd">        &gt;&gt;&gt; (A, 1) + B == A.append(B, 1)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        add : add geometries</span>
<span class="sd">        append : appending geometries</span>
<span class="sd">        prepend : prending geometries</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="p">(</span><span class="n">Lattice</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">)):</span>
            <span class="k">return</span> <span class="n">b</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span> <span class="o">+</span> <span class="n">b</span>

<div class="viewcode-block" id="Geometry.attach">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.attach">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">attach</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atom</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">GeometryLike</span><span class="p">,</span>
        <span class="n">other_atom</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">dist</span><span class="o">=</span><span class="s2">&quot;calc&quot;</span><span class="p">,</span>
        <span class="n">axis</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Attaches another `Geometry` at the `atom` index with respect to `other_atom` using different methods.</span>

<span class="sd">        The attached geometry will be inserted at the end of the geometry via `add`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atom : int</span>
<span class="sd">           atomic index which is the base position of the attachment. The distance</span>
<span class="sd">           between `atom` and `other_atom` is `dist`.</span>
<span class="sd">        other : Geometry</span>
<span class="sd">           the other Geometry to attach at the given point. In this case `dist` from</span>
<span class="sd">           `atom`.</span>
<span class="sd">        other_atom : int</span>
<span class="sd">           the index of the atom in `other` that is inserted at `atom`.</span>
<span class="sd">        dist : array_like or float or str, optional</span>
<span class="sd">           the distance (in `Ang`) between the attached coordinates.</span>
<span class="sd">           If `dist` is `array_like` it should be the vector between</span>
<span class="sd">           the atoms;</span>
<span class="sd">           if `dist` is `float` the argument `axis` is required</span>
<span class="sd">           and the vector will be calculated along the corresponding latticevector;</span>
<span class="sd">           else if `dist` is `str` this will correspond to the</span>
<span class="sd">           `method` argument of the `Atom.radius` class of the two</span>
<span class="sd">           atoms. Here `axis` is also required.</span>
<span class="sd">        axis : int</span>
<span class="sd">           specify the direction of the lattice vectors used.</span>
<span class="sd">           Not used if `dist` is an array-like argument.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="c1"># We have a single rational number</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.attach, `axis` has not been specified, please specify the axis when using a distance&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Now calculate the vector that we should have</span>
            <span class="c1"># between the atoms</span>
            <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span> <span class="o">@</span> <span class="n">v</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">dist</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">dist</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># We have a single rational number</span>
            <span class="k">if</span> <span class="n">axis</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.attach, `axis` has not been specified, please specify the axis when using a distance&quot;</span>
                <span class="p">)</span>

            <span class="c1"># This is the empirical distance between the atoms</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">+</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">other_atom</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">axis</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
                <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">axis</span><span class="p">,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>

            <span class="n">v</span> <span class="o">=</span> <span class="n">v</span> <span class="o">/</span> <span class="p">(</span><span class="n">v</span> <span class="o">@</span> <span class="n">v</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">*</span> <span class="n">d</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The user *must* have supplied a vector</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

        <span class="c1"># Now create a copy of the other geometry</span>
        <span class="c1"># so that we move it...</span>
        <span class="c1"># Translate to origin, then back to position in new cell</span>
        <span class="n">o</span> <span class="o">=</span> <span class="n">other</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">other_atom</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atom</span><span class="p">]</span> <span class="o">+</span> <span class="n">v</span><span class="p">)</span>

        <span class="c1"># We do not know how to handle the lattice-vectors,</span>
        <span class="c1"># so we will do nothing...</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">o</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.replace">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.replace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span>
        <span class="n">other</span><span class="p">:</span> <span class="n">GeometryLike</span><span class="p">,</span>
        <span class="n">offset</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new geometry from `self` and replace `atoms` with `other`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            atoms in `self` to be removed and replaced by other</span>
<span class="sd">            `other` will be placed in the geometry at the lowest index of `atoms`</span>
<span class="sd">        other :</span>
<span class="sd">            the other Geometry to insert instead, the unit-cell will not</span>
<span class="sd">            be used.</span>
<span class="sd">        offset :</span>
<span class="sd">            the offset for `other` when adding its coordinates, default to no offset</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Find lowest value in atoms</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">offset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># remove atoms, preparing for inserting new geometry</span>
        <span class="n">out</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

        <span class="c1"># insert new positions etc.</span>
        <span class="n">out</span><span class="o">.</span><span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">out</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span> <span class="o">+</span> <span class="n">offset</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">out</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">out</span></div>


<div class="viewcode-block" id="Geometry.reverse">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.reverse">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">reverse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a reversed geometry</span>

<span class="sd">        Also enables reversing a subset of the atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">             only reverse the given atomic indices, if not specified, all</span>
<span class="sd">             atoms will be reversed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">)</span>
            <span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="p">:]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
            <span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">reverse</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="n">lattice</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.mirror">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.mirror">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">mirror</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">method</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">point</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Mirrors the atomic coordinates about a plane given by its normal vector</span>

<span class="sd">        This will typically move the atomic coordinates outside of the unit-cell.</span>
<span class="sd">        This method should be used with care.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        method : {&#39;xy&#39;/&#39;z&#39;, ..., &#39;ab&#39;, ..., v}</span>
<span class="sd">           mirror the structure about a Cartesian direction (``x``, ``y``, ``z``),</span>
<span class="sd">           plane (``xy``, ``xz``, ``yz``) or about user defined vectors (``v``).</span>
<span class="sd">           A vector may also be specified by ``&#39;ab&#39;`` which is the vector normal</span>
<span class="sd">           to the plane spanned by the first and second lattice vector.</span>
<span class="sd">           or user defined vector (`v`) which is defining a plane.</span>
<span class="sd">        atoms :</span>
<span class="sd">           only mirror a subset of atoms</span>
<span class="sd">        point:</span>
<span class="sd">           mirror coordinates around the plane that intersects the *method* vector</span>
<span class="sd">           and this point</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; out = geom.mirror(&#39;x&#39;)</span>
<span class="sd">        &gt;&gt;&gt; out.xyz[:, 0]</span>
<span class="sd">        [0.  -1.42]</span>
<span class="sd">        &gt;&gt;&gt; out = geom.mirror(&#39;x&#39;, point=(1.42/2, 0, 0))</span>
<span class="sd">        &gt;&gt;&gt; out.xyz[:, 0]</span>
<span class="sd">        [1.42  0.]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="n">point</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">point</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">sorted</span><span class="p">(</span><span class="n">method</span><span class="o">.</span><span class="n">lower</span><span class="p">()))</span>
            <span class="k">if</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;xy&quot;</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;yz&quot;</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;xz&quot;</span><span class="p">):</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;a&quot;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;b&quot;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;c&quot;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ab&quot;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">cross3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;ac&quot;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">cross3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;bc&quot;</span><span class="p">:</span>
                <span class="n">method</span> <span class="o">=</span> <span class="n">cross3</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.mirror unrecognized &#39;method&#39; value&quot;</span>
                <span class="p">)</span>

        <span class="c1"># it has to be an array of length 3</span>
        <span class="c1"># Mirror about a user defined vector</span>
        <span class="n">method</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">method</span><span class="p">)</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">method</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

        <span class="c1"># project onto vector</span>
        <span class="n">vp</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">point</span><span class="p">)</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

        <span class="c1"># convert coordinates</span>
        <span class="c1"># first subtract the projection, then its mirror position</span>
        <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">vp</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">method</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">g</span></div>


<div class="viewcode-block" id="Geometry.axyz">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.axyz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">axyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the atomic coordinates in the supercell from an atomic index.</span>

<span class="sd">        The ``Geometry[...]`` slicing is calling this function with appropriate options.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">          atom(s) from which we should return the coordinates, the atomic indices</span>
<span class="sd">          may be in supercell format.</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">            Returns the atomic coordinates shifted according to the integer</span>
<span class="sd">            parts of the cell. Defaults to the unit-cell.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], lattice=1.)</span>
<span class="sd">        &gt;&gt;&gt; print(geom.axyz(isc=[1,0,0]))</span>
<span class="sd">        [[1.   0.   0. ]</span>
<span class="sd">         [1.5  0.   0. ]]</span>

<span class="sd">        &gt;&gt;&gt; geom = Geometry([[0, 0, 0], [0.5, 0, 0]], lattice=1.)</span>
<span class="sd">        &gt;&gt;&gt; print(geom.axyz(0))</span>
<span class="sd">        [0.  0.  0.]</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        oxyz : orbital coordinates in supercell from an orbital index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

        <span class="c1"># If only atoms has been specified</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get offsets from atomic indices (note that this will be per atom)</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="c1"># Neither of atoms, or isc are `None`, we add the offset to all coordinates</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.oxyz">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.oxyz">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">oxyz</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the orbital coordinates in the supercell from an orbital index.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals :</span>
<span class="sd">          orbital(s) from which we should return the coordinates, the orbital indices</span>
<span class="sd">          may be in supercell format.</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">            Returns the orbital coordinates shifted according to the integer</span>
<span class="sd">            parts of the cell. Defaults to the unit-cell.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        axyz : atomic coordinates in supercell from an atomic index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># If only atoms has been specified</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># get offsets from atomic indices (note that this will be per atom)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">)]</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="c1"># Neither of atoms, or isc are `None`, we add the offset to all coordinates</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">oxyz</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.within_sc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.within_sc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">within_sc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shapes</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ret_xyz</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ret_rij</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices of atoms in a given supercell within a given shape from a given coordinate</span>

<span class="sd">        This returns a set of atomic indices which are within a</span>
<span class="sd">        sphere of radius ``R``.</span>

<span class="sd">        If R is a tuple/list/array it will return the indices:</span>
<span class="sd">        in the ranges:</span>

<span class="sd">        &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapes : Shape or list of Shape</span>
<span class="sd">            A list of increasing shapes that define the extend of the geometric</span>
<span class="sd">            volume that is searched.</span>
<span class="sd">            It is vital that::</span>

<span class="sd">               shapes[0] in shapes[1] in shapes[2] ...</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">            The super-cell which the coordinates are checked in. Defaults to ``[0, 0, 0]``</span>
<span class="sd">        atoms :</span>
<span class="sd">            List of atoms that will be considered. This can</span>
<span class="sd">            be used to only take out a certain atoms.</span>
<span class="sd">        atoms_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `idx` variable (`idx` must also be passed)</span>
<span class="sd">        ret_xyz :</span>
<span class="sd">            If True this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij :</span>
<span class="sd">            If True this method will return the distance to the center of the shapes</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shape</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center of the shape (only for true `ret_rij`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that `shapes` is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapes</span><span class="p">]</span>
        <span class="n">nshapes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

        <span class="c1"># Convert to actual array</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If idx is None, then idx_xyz cannot be used!</span>
            <span class="c1"># So we force it to None</span>
            <span class="n">atoms_xyz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Get shape centers</span>
        <span class="n">off</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">center</span><span class="p">[:]</span>
        <span class="c1"># Get the supercell offset</span>
        <span class="n">soff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)[:]</span>

        <span class="c1"># Get atomic coordinate in principal cell</span>
        <span class="k">if</span> <span class="n">atoms_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">soff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For extremely large systems re-using the</span>
            <span class="c1"># idx_xyz is faster than indexing</span>
            <span class="c1"># a very large array</span>
            <span class="c1"># However, this idx_xyz should not</span>
            <span class="c1"># be offset by any supercell</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">atoms_xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">+</span> <span class="n">soff</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="c1"># Get indices and coordinates of the largest shape</span>
        <span class="c1"># The largest part of the calculation are to calculate</span>
        <span class="c1"># the content in the largest shape.</span>
        <span class="n">ix</span> <span class="o">=</span> <span class="n">shapes</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
        <span class="c1"># Reduce search space</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">xa</span><span class="p">[</span><span class="n">ix</span><span class="p">,</span> <span class="p">:]</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># This is because of the pre-check of the distance checks</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">ix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Quick return if there are no entries...</span>

            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Calculate distance</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">xa</span> <span class="o">-</span> <span class="n">off</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:])</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>

        <span class="c1"># Create the initial lists that we will build up</span>
        <span class="c1"># Then finally, we will return the reversed lists</span>

        <span class="c1"># Quick return</span>
        <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atoms</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># TODO Check that all shapes coincide with the following shapes</span>

        <span class="c1"># Now we create a list of indices which coincide</span>
        <span class="c1"># in each of the shapes</span>
        <span class="c1"># Do a reduction on each of the list elements</span>
        <span class="n">ixS</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([],</span> <span class="n">atoms</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">shapes</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">setdiff1d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cum</span><span class="p">,</span> <span class="n">assume_unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Update elements to remove in next loop</span>
            <span class="n">cum</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">cum</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
            <span class="n">ixS</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

        <span class="c1"># Do for the first shape</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]]</span>
        <span class="n">rc</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">rc</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">:]])</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">rd</span> <span class="o">=</span> <span class="n">rc</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="mi">0</span><span class="p">]]])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nshapes</span><span class="p">):</span>
            <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span><span class="o">.</span><span class="n">ravel</span><span class="p">())</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rc</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="p">:])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="p">[</span><span class="n">rd</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">ixS</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Geometry.close_sc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.close_sc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close_sc</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz_ia</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
        <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ret_xyz</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ret_rij</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices of atoms in a given supercell within a given radius from a given coordinate</span>

<span class="sd">        This returns a set of atomic indices which are within a</span>
<span class="sd">        sphere of radius `R`.</span>

<span class="sd">        If `R` is a tuple/list/array it will return the indices:</span>
<span class="sd">        in the ranges:</span>

<span class="sd">        &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia : array_like of floats or int</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        isc : (3,), optional</span>
<span class="sd">            Integer super-cell offsets in which the coordinates are checked in.</span>
<span class="sd">            I.e. ``isc=[0, 0, 0]`` is the primary cell (default).</span>
<span class="sd">        R : float or array_like, optional</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If `R` is an array it will return the indices:</span>
<span class="sd">            in the ranges ``( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )``.</span>
<span class="sd">            If a single float it will return ``x &lt;= R``.</span>
<span class="sd">        atoms :</span>
<span class="sd">            List of atoms that will be considered. This can</span>
<span class="sd">            be used to only take out a certain atom.</span>
<span class="sd">        atoms_xyz : array_like of float, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `atoms` variable (`atoms` must also be passed)</span>
<span class="sd">        ret_xyz :</span>
<span class="sd">            If True this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij :</span>
<span class="sd">            If True this method will return the distance</span>
<span class="sd">            for each of the couplings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shells of radius `R`</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center coordinate (only for true `ret_rij`)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">maxR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">maxR</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Maximum distance queried</span>
        <span class="n">max_R</span> <span class="o">=</span> <span class="n">R</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">max_R</span> <span class="o">&gt;</span> <span class="n">maxR</span> <span class="o">+</span> <span class="mf">0.1</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.close_sc has been passed an &#39;atoms&#39; argument &quot;</span>
                <span class="s2">&quot;together with an R value larger than the orbital ranges. &quot;</span>
                <span class="s2">&quot;If used together with &#39;sparse-matrix.construct&#39; this can result in wrong couplings.&quot;</span><span class="p">,</span>
                <span class="n">register</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Convert to actual array</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If atoms is None, then atoms_xyz cannot be used!</span>
            <span class="n">atoms_xyz</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">):</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">xyz_ia</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">off</span> <span class="o">=</span> <span class="n">xyz_ia</span>

        <span class="c1"># Calculate the complete offset</span>
        <span class="n">foff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span>

        <span class="c1"># Get distances between `xyz_ia` and `atoms`</span>
        <span class="k">if</span> <span class="n">atoms_xyz</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">+</span> <span class="n">foff</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For extremely large systems re-using the</span>
            <span class="c1"># atoms_xyz is faster than indexing</span>
            <span class="c1"># a very large array</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">atoms_xyz</span> <span class="o">+</span> <span class="n">foff</span>

        <span class="c1"># Immediately downscale by easy checking</span>
        <span class="c1"># This will reduce the computation of the vector-norm</span>
        <span class="c1"># which is the main culprit of the time-consumption</span>
        <span class="c1"># This abstraction will _only_ help very large</span>
        <span class="c1"># systems.</span>
        <span class="c1"># For smaller ones this will actually be a slower</span>
        <span class="c1"># method..</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">indices_in_sphere_with_dist</span><span class="p">(</span><span class="n">dxa</span><span class="p">,</span> <span class="n">max_R</span><span class="p">)</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ix</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="n">indices_in_sphere_with_dist</span><span class="p">(</span><span class="n">dxa</span><span class="p">,</span> <span class="n">max_R</span><span class="p">)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span>
            <span class="n">dxa</span> <span class="o">=</span> <span class="n">dxa</span><span class="p">[</span><span class="n">ix</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">ix</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Create default return</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">R</span><span class="p">]]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">R</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">R</span><span class="p">])</span>

            <span class="c1"># Quick return if there are</span>
            <span class="c1"># no entries...</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">elif</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]]</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">xa</span> <span class="o">=</span> <span class="n">dxa</span> <span class="o">+</span> <span class="n">off</span>
        <span class="k">del</span> <span class="n">dxa</span>  <span class="c1"># just because this array could be very big...</span>

        <span class="c1"># Check whether we only have one range to check.</span>
        <span class="c1"># If so, we need not reduce the index space</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ret</span> <span class="o">=</span> <span class="p">[</span><span class="n">atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">xa</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ascending</span><span class="p">(</span><span class="n">R</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.close_sc proximity checks for several &quot;</span>
                <span class="s2">&quot;quantities at a time requires ascending R values.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># The more neigbours you wish to find the faster this becomes</span>
        <span class="c1"># We only do &quot;one&quot; heavy duty search,</span>
        <span class="c1"># then we immediately reduce search space to this subspace</span>
        <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">]]]</span>
        <span class="n">r_app</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
            <span class="n">r_appx</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">]])</span>
            <span class="n">r_appd</span> <span class="o">=</span> <span class="n">ret</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">append</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">and</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="c1"># Search in the sub-space</span>
                <span class="c1"># Notice that this sub-space reduction will never</span>
                <span class="c1"># allow the same indice to be in two ranges (due to</span>
                <span class="c1"># numerics)</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appx</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appd</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appx</span><span class="p">(</span><span class="n">xa</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
        <span class="k">elif</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
                <span class="n">r_appd</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">R</span><span class="p">)):</span>
                <span class="n">tidx</span> <span class="o">=</span> <span class="n">indices_gt_le</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">R</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                <span class="n">r_app</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="n">tidx</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">ret_xyz</span> <span class="ow">or</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span>
        <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span></div>


<div class="viewcode-block" id="Geometry.bond_correct">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.bond_correct">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bond_correct</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ia</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;calc&quot;</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Corrects the bond between `ia` and the `atoms`.</span>

<span class="sd">        Corrects the bond-length between atom `ia` and `atoms` in such</span>
<span class="sd">        a way that the atomic radius is preserved.</span>
<span class="sd">        I.e. the sum of the bond-lengths minimizes the distance matrix.</span>

<span class="sd">        Only atom `ia` is moved.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ia :</span>
<span class="sd">            The atom to be displaced according to the atomic radius</span>
<span class="sd">        atoms :</span>
<span class="sd">            The atom(s) from which the radius should be reduced.</span>
<span class="sd">        method :</span>
<span class="sd">            If str will use that as lookup in `Atom.radius`.</span>
<span class="sd">            Else it will be the new bond-length.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Decide which algorithm to choose from</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># signal a list of atoms</span>
            <span class="n">algo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">algo</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># We have a single atom</span>
            <span class="c1"># Get bond length in the closest direction</span>
            <span class="c1"># A bond-length HAS to be below 10</span>
            <span class="n">atoms</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span>
                <span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">10.0</span><span class="p">),</span> <span class="n">atoms</span><span class="o">=</span><span class="n">algo</span><span class="p">,</span> <span class="n">ret_xyz</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span>
            <span class="p">)</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># Convert to unitcell atom (and get the one atom)</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">])</span>
            <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>

            <span class="c1"># Calculate the bond vector</span>
            <span class="n">bv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">-</span> <span class="n">c</span>

            <span class="k">try</span><span class="p">:</span>
                <span class="c1"># If it is a number, we use that.</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="c1"># get radius</span>
                <span class="n">rad</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">method</span><span class="p">)</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span><span class="o">.</span><span class="n">radius</span><span class="p">(</span><span class="n">method</span><span class="p">)</span>

            <span class="c1"># Update the coordinate</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">c</span> <span class="o">+</span> <span class="n">bv</span> <span class="o">/</span> <span class="n">d</span> <span class="o">*</span> <span class="n">rad</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="s2">&quot;Changing bond-length dependent on several lacks implementation.&quot;</span>
            <span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.within">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.within">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">within</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">shapes</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ret_xyz</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ret_rij</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ret_isc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices of atoms in the entire supercell within a given shape from a given coordinate</span>

<span class="sd">        This heavily relies on the `within_sc` method.</span>

<span class="sd">        Note that if a connection is made in a neighboring super-cell</span>
<span class="sd">        then the atomic index is shifted by the super-cell index times</span>
<span class="sd">        number of atoms.</span>
<span class="sd">        This allows one to decipher super-cell atoms from unit-cell atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        shapes : Shape, list of Shape</span>
<span class="sd">        atoms :</span>
<span class="sd">            List of indices for atoms that are to be considered</span>
<span class="sd">        atoms_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `atoms` variable (`atoms` must also be passed)</span>
<span class="sd">        ret_xyz :</span>
<span class="sd">            If true this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij :</span>
<span class="sd">            If true this method will return the distances from the `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_isc :</span>
<span class="sd">            If true this method will return the supercell offsets for each of the couplings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shape</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center of the shape (only for true `ret_rij`)</span>
<span class="sd">        isc</span>
<span class="sd">            supercell indices of the couplings (only for true `ret_isc`)</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Ensure that `shapes` is a list</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">shapes</span><span class="p">,</span> <span class="n">Shape</span><span class="p">):</span>
            <span class="n">shapes</span> <span class="o">=</span> <span class="p">[</span><span class="n">shapes</span><span class="p">]</span>
        <span class="n">nshapes</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">shapes</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">ixyz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">irij</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
            <span class="n">iisc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nshapes</span><span class="p">)</span>

        <span class="c1"># number of special returns</span>
        <span class="n">n_ret</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">listify</span> <span class="o">=</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n_ret</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ret_isc</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="n">isc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:]</span>
            <span class="n">sret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_sc</span><span class="p">(</span>
                <span class="n">shapes</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">,</span> <span class="p">:],</span>
                <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span>
                <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">,</span>
                <span class="n">ret_xyz</span><span class="o">=</span><span class="n">ret_xyz</span><span class="p">,</span>
                <span class="n">ret_rij</span><span class="o">=</span><span class="n">ret_rij</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">listify</span><span class="p">:</span>
                <span class="c1"># This is to &quot;fake&quot; the return</span>
                <span class="c1"># of a list (we will do indexing!)</span>
                <span class="n">sret</span> <span class="o">=</span> <span class="p">[</span><span class="n">sret</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># we have a list of arrays (nshapes &gt; 1)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We can add it to the list (nshapes == 1)</span>
                <span class="c1"># We add the atomic offset for the supercell index</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">nshapes</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ret</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Geometry.close">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.close">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">xyz_ia</span><span class="p">,</span>
        <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atoms_xyz</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">ret_xyz</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ret_rij</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">ret_isc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Indices of atoms in the entire supercell within a given radius from a given coordinate</span>

<span class="sd">        This heavily relies on the `close_sc` method.</span>

<span class="sd">        Note that if a connection is made in a neighboring super-cell</span>
<span class="sd">        then the atomic index is shifted by the super-cell index times</span>
<span class="sd">        number of atoms.</span>
<span class="sd">        This allows one to decipher super-cell atoms from unit-cell atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xyz_ia : coordinate/index</span>
<span class="sd">            Either a point in space or an index of an atom.</span>
<span class="sd">            If an index is passed it is the equivalent of passing</span>
<span class="sd">            the atomic coordinate ``close_sc(self.xyz[xyz_ia,:])``.</span>
<span class="sd">        R : (None), float/tuple of float</span>
<span class="sd">            The radii parameter to where the atomic connections are found.</span>
<span class="sd">            If `R` is an array it will return the indices:</span>
<span class="sd">            in the ranges:</span>

<span class="sd">            &gt;&gt;&gt; ( x &lt;= R[0] , R[0] &lt; x &lt;= R[1], R[1] &lt; x &lt;= R[2] )</span>

<span class="sd">            If a single float it will return:</span>

<span class="sd">            &gt;&gt;&gt; x &lt;= R</span>

<span class="sd">        atoms :</span>
<span class="sd">            List of indices for atoms that are to be considered</span>
<span class="sd">        atoms_xyz : array_like, optional</span>
<span class="sd">            The atomic coordinates of the equivalent `atoms` variable (`atoms` must also be passed)</span>
<span class="sd">        ret_xyz :</span>
<span class="sd">            If true this method will return the coordinates</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_rij :</span>
<span class="sd">            If true this method will return the distances from the `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>
<span class="sd">        ret_isc :</span>
<span class="sd">            If true this method will return the lattice offset from `xyz_ia`</span>
<span class="sd">            for each of the couplings.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        index</span>
<span class="sd">            indices of atoms (in supercell indices) within the shells of radius `R`</span>
<span class="sd">        xyz</span>
<span class="sd">            atomic coordinates of the indexed atoms (only for true `ret_xyz`)</span>
<span class="sd">        rij</span>
<span class="sd">            distance of the indexed atoms to the center coordinate (only for true `ret_rij`)</span>
<span class="sd">        isc</span>
<span class="sd">            integer lattice offsets for the couplings (related to `rij` without atomic coordinates)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">nR</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">size</span>

        <span class="c1"># Convert index coordinate to point</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">xyz_ia</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">xyz_ia</span><span class="p">]</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">isndarray</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">):</span>
            <span class="n">xyz_ia</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">xyz_ia</span><span class="p">)</span>

        <span class="n">ret</span> <span class="o">=</span> <span class="p">[[</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
            <span class="n">ixyz</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
            <span class="n">irij</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
            <span class="n">iisc</span> <span class="o">=</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)]</span> <span class="o">*</span> <span class="n">nR</span><span class="p">)</span>

        <span class="c1"># number of special returns</span>
        <span class="n">n_ret</span> <span class="o">=</span> <span class="n">i</span>
        <span class="n">listify</span> <span class="o">=</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">or</span> <span class="p">(</span><span class="n">n_ret</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">ret_isc</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="n">n</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">tile</span><span class="p">(</span><span class="n">isc</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">for</span> <span class="n">s</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">s</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">s</span><span class="p">]</span>
            <span class="n">sret</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close_sc</span><span class="p">(</span>
                <span class="n">xyz_ia</span><span class="p">,</span>
                <span class="n">isc</span><span class="p">,</span>
                <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span>
                <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span>
                <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">,</span>
                <span class="n">ret_xyz</span><span class="o">=</span><span class="n">ret_xyz</span><span class="p">,</span>
                <span class="n">ret_rij</span><span class="o">=</span><span class="n">ret_rij</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">if</span> <span class="n">listify</span><span class="p">:</span>
                <span class="c1"># This is to &quot;fake&quot; the return</span>
                <span class="c1"># of a list (we will do indexing!)</span>
                <span class="n">sret</span> <span class="o">=</span> <span class="p">[</span><span class="n">sret</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">list</span><span class="p">):</span>
                <span class="c1"># we have a list of arrays (len(R) &gt; 1)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
                    <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">x</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="n">i</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
                    <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                        <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                            <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                        <span class="p">)</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># We can add it to the list (len(R) == 1)</span>
                <span class="c1"># We add the atomic offset for the supercell index</span>
                <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">na</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_xyz</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">ixyz</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_rij</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">ret</span><span class="p">[</span><span class="n">irij</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">sret</span><span class="p">[</span><span class="n">irij</span><span class="p">]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">ret_isc</span><span class="p">:</span>
                    <span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">(</span>
                        <span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">iisc</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">isc_tile</span><span class="p">(</span><span class="n">isc</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">sret</span><span class="p">[</span><span class="mi">0</span><span class="p">]))),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span>
                    <span class="p">)</span>

        <span class="k">if</span> <span class="n">nR</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">ret</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">n_ret</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">n_ret</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">ret</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">ret</span></div>


<div class="viewcode-block" id="Geometry.a2transpose">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.a2transpose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">a2transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">atoms1</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">atoms2</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transposes connections from `atoms1` to `atoms2` such that supercell connections are transposed</span>

<span class="sd">        When handling supercell indices it is useful to get the *transposed* connection. I.e. if you have</span>
<span class="sd">        a connection from site ``i`` (in unit cell indices) to site ``j`` (in supercell indices) it may be</span>
<span class="sd">        useful to get the equivalent supercell connection such for site ``j`` (in unit cell indices) to</span>
<span class="sd">        site ``i`` (in supercell indices) such that they correspond to the transposed coupling.</span>

<span class="sd">        Note that since this transposes couplings the indices returned are always expanded to the full</span>
<span class="sd">        length if either of the inputs are a single index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gr = geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; atoms = gr.close(0, 1.5)</span>
<span class="sd">        &gt;&gt;&gt; atoms</span>
<span class="sd">        array([0, 1, 5, 9], dtype=int32)</span>
<span class="sd">        &gt;&gt;&gt; gr.a2transpose(0, atoms)</span>
<span class="sd">        (array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms1 :</span>
<span class="sd">            atomic indices must have same length as `atoms2` or length 1</span>
<span class="sd">        atoms2 :</span>
<span class="sd">            atomic indices must have same length as `atoms1` or length 1.</span>
<span class="sd">            If not present then only `atoms1` will be returned in transposed indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        atoms2 : array_like</span>
<span class="sd">            transposed indices for atoms2 (only returned if `atoms2` is not None)</span>
<span class="sd">        atoms1 : array_like</span>
<span class="sd">            transposed indices for atoms1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check whether they have the same size, if so then do not pre-process</span>
        <span class="n">atoms1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we only need to transpose atoms1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms1</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
            <span class="k">return</span> <span class="n">atoms1</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="n">atoms2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">atoms1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">atoms2</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">atoms1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># typical case where atoms1 is a single number</span>
            <span class="n">atoms1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">atoms1</span><span class="p">,</span> <span class="n">atoms2</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">atoms2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">atoms2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">atoms2</span><span class="p">,</span> <span class="n">atoms1</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.a2transpose only allows length 1 or same length arrays.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Now convert atoms</span>
        <span class="n">na</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span>
        <span class="n">isc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms1</span><span class="p">)</span>
        <span class="n">isc2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms2</span><span class="p">)</span>

        <span class="n">atoms1</span> <span class="o">=</span> <span class="n">atoms1</span> <span class="o">%</span> <span class="n">na</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc2</span><span class="p">)</span> <span class="o">*</span> <span class="n">na</span>
        <span class="n">atoms2</span> <span class="o">=</span> <span class="n">atoms2</span> <span class="o">%</span> <span class="n">na</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc1</span><span class="p">)</span> <span class="o">*</span> <span class="n">na</span>
        <span class="k">return</span> <span class="n">atoms2</span><span class="p">,</span> <span class="n">atoms1</span></div>


<div class="viewcode-block" id="Geometry.o2transpose">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.o2transpose">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">o2transpose</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">orb1</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">,</span> <span class="n">orb2</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">OrbitalsIndex</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transposes connections from `orb1` to `orb2` such that supercell connections are transposed</span>

<span class="sd">        When handling supercell indices it is useful to get the *transposed* connection. I.e. if you have</span>
<span class="sd">        a connection from site ``i`` (in unit cell indices) to site ``J`` (in supercell indices) it may be</span>
<span class="sd">        useful to get the equivalent supercell connection such for site ``j`` (in unit cell indices) to</span>
<span class="sd">        site ``I`` (in supercell indices) such that they correspond to the transposed coupling.</span>

<span class="sd">        Note that since this transposes couplings the indices returned are always expanded to the full</span>
<span class="sd">        length if either of the inputs are a single index.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; gr = geom.graphene() # one orbital per site</span>
<span class="sd">        &gt;&gt;&gt; atoms = gr.close(0, 1.5)</span>
<span class="sd">        &gt;&gt;&gt; atoms</span>
<span class="sd">        array([0, 1, 5, 9], dtype=int32)</span>
<span class="sd">        &gt;&gt;&gt; gr.o2transpose(0, atoms)</span>
<span class="sd">        (array([0, 1, 1, 1], dtype=int32), array([ 0,  0, 14, 10], dtype=int32))</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orb1 :</span>
<span class="sd">            orbital indices must have same length as `orb2` or length 1</span>
<span class="sd">        orb2 :</span>
<span class="sd">            orbital indices must have same length as `orb1` or length 1.</span>
<span class="sd">            If not present then only `orb1` will be returned in transposed indices.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        orb2 : array_like</span>
<span class="sd">            transposed indices for orb2 (only returned if `orb2` is not None)</span>
<span class="sd">        orb1 : array_like</span>
<span class="sd">            transposed indices for orb1</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First check whether they have the same size, if so then do not pre-process</span>
        <span class="n">orb1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orb1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orb2</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># we only need to transpose orb1</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orb1</span><span class="p">))</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
            <span class="k">return</span> <span class="n">orb1</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">+</span> <span class="n">offset</span>

        <span class="n">orb2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orb2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orb1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="n">orb2</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">elif</span> <span class="n">orb1</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>  <span class="c1"># typical case where orb1 is a single number</span>
            <span class="n">orb1</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">orb1</span><span class="p">,</span> <span class="n">orb2</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">orb2</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">orb2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">orb2</span><span class="p">,</span> <span class="n">orb1</span><span class="o">.</span><span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.o2transpose only allows length 1 or same length arrays.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Now convert orbs</span>
        <span class="n">no</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">sc_index</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_index</span>
        <span class="n">isc1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orb1</span><span class="p">)</span>
        <span class="n">isc2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orb2</span><span class="p">)</span>

        <span class="n">orb1</span> <span class="o">=</span> <span class="n">orb1</span> <span class="o">%</span> <span class="n">no</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc2</span><span class="p">)</span> <span class="o">*</span> <span class="n">no</span>
        <span class="n">orb2</span> <span class="o">=</span> <span class="n">orb2</span> <span class="o">%</span> <span class="n">no</span> <span class="o">+</span> <span class="n">sc_index</span><span class="p">(</span><span class="o">-</span><span class="n">isc1</span><span class="p">)</span> <span class="o">*</span> <span class="n">no</span>
        <span class="k">return</span> <span class="n">orb2</span><span class="p">,</span> <span class="n">orb1</span></div>


<div class="viewcode-block" id="Geometry.a2o">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.a2o">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">a2o</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="nb">all</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an orbital index of the first orbital of said atom.</span>
<span class="sd">        This is particularly handy if you want to create</span>
<span class="sd">        TB models with more than one orbital per atom.</span>

<span class="sd">        Note that this will preserve the super-cell offsets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">             Atomic indices</span>
<span class="sd">        all :</span>
<span class="sd">             ``False``, return only the first orbital corresponding to the atom,</span>
<span class="sd">             ``True``, returns list of the full atom(s), will always return a 1D array.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># we must not alter `atoms` as it may come from outside</span>
        <span class="n">off</span><span class="p">,</span> <span class="n">atoms</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="n">is_integral</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">Integral</span><span class="p">)</span>
        <span class="n">off</span> <span class="o">*=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">all</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="n">oe</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span> <span class="o">+</span> <span class="n">off</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Create ranges</span>
        <span class="k">if</span> <span class="n">is_integral</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">ob</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">oe</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">array_arange</span><span class="p">(</span><span class="n">ob</span><span class="p">,</span> <span class="n">oe</span><span class="p">)</span></div>


<div class="viewcode-block" id="Geometry.o2a">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.o2a">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">o2a</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Atomic index corresponding to the orbital indices.</span>

<span class="sd">        Note that this will preserve the super-cell offsets.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals :</span>
<span class="sd">             List of orbital indices to return the atoms for</span>
<span class="sd">        unique :</span>
<span class="sd">             If True only return the unique atoms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">orbitals</span><span class="o">.</span><span class="n">ndim</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># must only be 1 number (an Integral)</span>
            <span class="k">return</span> <span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">orbitals</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span>
                <span class="o">+</span> <span class="p">(</span><span class="n">orbitals</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
            <span class="p">)</span>

        <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">divmod</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">orbitals</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
        <span class="n">a</span> <span class="o">=</span> <span class="n">list_index_le</span><span class="p">(</span><span class="n">orbitals</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="bp">self</span><span class="o">.</span><span class="n">lasto</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">orbitals</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">a</span> <span class="o">+</span> <span class="n">isc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">a</span> <span class="o">+</span> <span class="n">isc</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span></div>


<div class="viewcode-block" id="Geometry.auc2sc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.auc2sc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">auc2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns atom from unit-cell indices to supercell indices, possibly removing duplicates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           the atomic unit-cell indices to be converted to supercell indices</span>
<span class="sd">        unique :</span>
<span class="sd">           If True the returned indices are unique and sorted.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        a2sc : converts atomic indices to supercell offsets</span>
<span class="sd">        o2sc : converts orbital indices to supercell offsets</span>
<span class="sd">        a2isc : convert atomic indices to integer supercell locations</span>
<span class="sd">        o2isc : convert orbital indices to integer supercell locations</span>
<span class="sd">        asc2uc : converts atomic supercell indices to unitcell indices</span>
<span class="sd">        osc2uc : converts orbital supercell indices to unitcell indices</span>
<span class="sd">        ouc2sc : determine *all* supercell indices of passed orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="o">*</span><span class="n">atoms</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span></div>


    <span class="n">uc2sc</span> <span class="o">=</span> <span class="n">deprecation</span><span class="p">(</span>
        <span class="s2">&quot;uc2sc is deprecated, update the code to use the explicit form auc2sc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15.0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16.0&quot;</span><span class="p">,</span>
    <span class="p">)(</span><span class="n">auc2sc</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.asc2uc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.asc2uc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">asc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts atomic supercell indices into their corresponding unit-cell indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            the atomic indices to determine *all* supercell indices of</span>
<span class="sd">        unique :</span>
<span class="sd">            If True the returned indices are unique and sorted.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        a2sc : converts atomic indices to supercell offsets</span>
<span class="sd">        o2sc : converts orbital indices to supercell offsets</span>
<span class="sd">        a2isc : convert atomic indices to integer supercell locations</span>
<span class="sd">        o2isc : convert orbital indices to integer supercell locations</span>
<span class="sd">        auc2sc : determine *all* supercell indices of passed atomic indices</span>
<span class="sd">        ouc2sc : determine *all* supercell indices of passed orbital indices</span>
<span class="sd">        osc2uc : converts orbital supercell indices to unitcell indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">atoms</span></div>


    <span class="n">sc2uc</span> <span class="o">=</span> <span class="n">deprecation</span><span class="p">(</span>
        <span class="s2">&quot;sc2uc is deprecated, update the code to use the explicit form asc2uc&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15.0&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.16.0&quot;</span><span class="p">,</span>
    <span class="p">)(</span><span class="n">asc2uc</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.osc2uc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.osc2uc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">osc2uc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts orbital supercell indices into their corresponding unit-cell indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals :</span>
<span class="sd">            the orbital supercell indices to be converted to unit-cell indices</span>
<span class="sd">        unique :</span>
<span class="sd">            If True the returned indices are unique and sorted.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        a2sc : converts atomic indices to supercell offsets</span>
<span class="sd">        o2sc : converts orbital indices to supercell offsets</span>
<span class="sd">        a2isc : convert atomic indices to integer supercell locations</span>
<span class="sd">        o2isc : convert orbital indices to integer supercell locations</span>
<span class="sd">        auc2sc : determine *all* supercell indices of passed atomic indices</span>
<span class="sd">        asc2uc : converts atomic supercell indices to unitcell indices</span>
<span class="sd">        ouc2sc : determine *all* supercell indices of passed orbital indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orbitals</span></div>


<div class="viewcode-block" id="Geometry.ouc2sc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.ouc2sc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">ouc2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">,</span> <span class="n">unique</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return all supercell indices of any orbital indices</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals :</span>
<span class="sd">            the orbital indices to determine *all* supercell indices of</span>
<span class="sd">        unique :</span>
<span class="sd">            If True the returned indices are unique and sorted.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        a2sc : converts atomic indices to supercell offsets</span>
<span class="sd">        o2sc : converts orbital indices to supercell offsets</span>
<span class="sd">        a2isc : convert atomic indices to integer supercell locations</span>
<span class="sd">        o2isc : convert orbital indices to integer supercell locations</span>
<span class="sd">        auc2sc : determine *all* supercell indices of passed atomic indices</span>
<span class="sd">        asc2uc : converts atomic supercell indices to unitcell indices</span>
<span class="sd">        osc2uc : converts orbital supercell indices to unitcell indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="p">(</span><span class="n">orbitals</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">+</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_s</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="o">*</span><span class="n">orbitals</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span>
        <span class="p">)</span>
        <span class="k">if</span> <span class="n">unique</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">orbitals</span></div>


<div class="viewcode-block" id="Geometry.a2isc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.a2isc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">a2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the supercell indices for some atom(s).</span>

<span class="sd">        Returns a vector of 3 numbers with integers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            atomic indices to extract the supercell locations of</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Any multi-dimensional input will be flattened before return.</span>
<span class="sd">        Hence it will always return a 1D (single atom) or 2D (multiple atoms).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        a2sc : converts atomic indices to supercell offsets</span>
<span class="sd">        o2sc : converts orbital indices to supercell offsets</span>
<span class="sd">        o2isc : convert orbital indices to integer supercell locations</span>
<span class="sd">        auc2sc : determine *all* supercell indices of passed atomic indices</span>
<span class="sd">        ouc2sc : determine *all* supercell indices of passed orbital indices</span>
<span class="sd">        asc2uc : converts atomic supercell indices to unitcell indices</span>
<span class="sd">        osc2uc : converts orbital supercell indices to unitcell indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">na</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="Geometry.a2sc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.a2sc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">a2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the super-cell offset for a specific atom</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">            atomic indices to extract the supercell offsets of</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        o2sc : converts orbital indices to supercell offsets</span>
<span class="sd">        a2isc : convert atomic indices to integer supercell locations</span>
<span class="sd">        o2isc : convert orbital indices to integer supercell locations</span>
<span class="sd">        auc2sc : determine *all* supercell indices of passed atomic indices</span>
<span class="sd">        ouc2sc : determine *all* supercell indices of passed orbital indices</span>
<span class="sd">        asc2uc : converts atomic supercell indices to unitcell indices</span>
<span class="sd">        osc2uc : converts orbital supercell indices to unitcell indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a2isc</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span></div>


<div class="viewcode-block" id="Geometry.o2isc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.o2isc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">o2isc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the super-cell index for a specific orbital.</span>

<span class="sd">        Returns a vector of 3 numbers with integers.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals :</span>
<span class="sd">            orbital indices to extract the supercell locations of</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        a2sc : converts atomic indices to supercell offsets</span>
<span class="sd">        o2sc : converts orbital indices to supercell offsets</span>
<span class="sd">        a2isc : convert atomic indices to integer supercell locations</span>
<span class="sd">        auc2sc : determine *all* supercell indices of passed atomic indices</span>
<span class="sd">        ouc2sc : determine *all* supercell indices of passed orbital indices</span>
<span class="sd">        asc2uc : converts atomic supercell indices to unitcell indices</span>
<span class="sd">        osc2uc : converts orbital supercell indices to unitcell indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">orbitals</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">sc_off</span><span class="p">[</span><span class="n">orbitals</span><span class="p">,</span> <span class="p">:]</span></div>


<div class="viewcode-block" id="Geometry.o2sc">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.o2sc">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">o2sc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">:</span> <span class="n">OrbitalsIndex</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Determine the super-cell offset for a specific orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        orbitals :</span>
<span class="sd">            orbital indices to extract the supercell offsets of</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        a2sc : converts atomic indices to supercell offsets</span>
<span class="sd">        a2isc : convert atomic indices to integer supercell locations</span>
<span class="sd">        o2isc : convert orbital indices to integer supercell locations</span>
<span class="sd">        auc2sc : determine *all* supercell indices of passed atomic indices</span>
<span class="sd">        ouc2sc : determine *all* supercell indices of passed orbital indices</span>
<span class="sd">        asc2uc : converts atomic supercell indices to unitcell indices</span>
<span class="sd">        osc2uc : converts orbital supercell indices to unitcell indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2isc</span><span class="p">(</span><span class="n">orbitals</span><span class="p">))</span></div>


<div class="viewcode-block" id="Geometry.equal">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.equal">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;tol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument tol has been deprecated in favor of atol, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="n">GeometryLike</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether two geometries are the same (optional not check of the orbital radius)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other :</span>
<span class="sd">            the other Geometry to check against</span>
<span class="sd">        R :</span>
<span class="sd">            if True also check if the orbital radii are the same (see `Atom.equal`)</span>
<span class="sd">        atol :</span>
<span class="sd">            tolerance for checking the atomic coordinates</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">same</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">)</span>
        <span class="n">same</span> <span class="o">=</span> <span class="n">same</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">same</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="p">(</span><span class="bp">self</span> <span class="o">==</span> <span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Geometry.sparserij">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.sparserij">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sparserij</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">na_iR</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">method</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;rand&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the sparse matrix with all distances in the matrix</span>
<span class="sd">        The sparse matrix will only be defined for the elements which have</span>
<span class="sd">        orbitals overlapping with other atoms.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        dtype : numpy.dtype, numpy.float64</span>
<span class="sd">           the data-type of the sparse matrix</span>
<span class="sd">        na_iR :</span>
<span class="sd">           number of atoms within the sphere for speeding</span>
<span class="sd">           up the `iter_block` loop.</span>
<span class="sd">        method :</span>
<span class="sd">           see `iter_block` for details</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        SparseAtom</span>
<span class="sd">           sparse matrix with all rij elements</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        iter_block : the method for looping the atoms</span>
<span class="sd">        distance : create a list of distances</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.sparse_geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">SparseAtom</span>

        <span class="n">rij</span> <span class="o">=</span> <span class="n">SparseAtom</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">20</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Get R</span>
        <span class="n">R</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span> <span class="o">+</span> <span class="mf">0.001</span><span class="p">)</span>
        <span class="n">iR</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">iR</span><span class="p">(</span><span class="n">na_iR</span><span class="p">)</span>

        <span class="c1"># Do the loop</span>
        <span class="k">for</span> <span class="n">ias</span><span class="p">,</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_block</span><span class="p">(</span><span class="n">iR</span><span class="o">=</span><span class="n">iR</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">):</span>
            <span class="c1"># Get all the indexed atoms...</span>
            <span class="c1"># This speeds up the searching for</span>
            <span class="c1"># coordinates...</span>
            <span class="n">atoms_xyz</span> <span class="o">=</span> <span class="bp">self</span><span class="p">[</span><span class="n">atoms</span><span class="p">,</span> <span class="p">:]</span>

            <span class="c1"># Loop the atoms inside</span>
            <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">ias</span><span class="p">:</span>
                <span class="n">idx</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span>
                    <span class="n">ia</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">atoms_xyz</span><span class="o">=</span><span class="n">atoms_xyz</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>
                <span class="n">rij</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="n">rij</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="n">idx</span><span class="p">[</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">rij</span></div>


<div class="viewcode-block" id="Geometry.distance">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.distance">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;tol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument tol has been deprecated in favor of atol, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">distance</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">atoms</span><span class="p">:</span> <span class="n">AtomsIndex</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">R</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atol</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]]</span> <span class="o">=</span> <span class="mf">0.1</span><span class="p">,</span>
        <span class="n">method</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span>
            <span class="n">Callable</span><span class="p">[[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]],</span> <span class="nb">float</span><span class="p">],</span>
            <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;average&quot;</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;numpy.method&gt;&quot;</span><span class="p">],</span>
        <span class="p">]</span> <span class="o">=</span> <span class="s2">&quot;average&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the distances for all atoms in shells of radius `tol` within `max_R`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms :</span>
<span class="sd">           only create list of distances from the given atoms, default to all atoms</span>
<span class="sd">        R :</span>
<span class="sd">           the maximum radius to consider, default to ``self.maxR()``.</span>
<span class="sd">           To retrieve all distances for atoms within the supercell structure</span>
<span class="sd">           you can pass `numpy.inf`.</span>
<span class="sd">        atol :</span>
<span class="sd">           the tolerance for grouping a set of atoms.</span>
<span class="sd">           This parameter sets the shell radius for each shell.</span>
<span class="sd">           I.e. the returned distances between two shells will be maximally</span>
<span class="sd">           ``2*atol``, but only if atoms are within two consecutive lists.</span>
<span class="sd">           If this is a list, the shells will be of unequal size.</span>

<span class="sd">           The first shell size will be ``atol * .5`` or ``atol[0] * .5`` if `atol` is a list.</span>

<span class="sd">        method :</span>
<span class="sd">           How the distance in each shell is determined.</span>
<span class="sd">           A list of distances within each shell is gathered and the equivalent</span>
<span class="sd">           method will be used to extract a single quantity from the list of</span>
<span class="sd">           distances in the shell.</span>
<span class="sd">           If `&#39;mode&#39;` is chosen it will use `scipy.stats.mode`.</span>
<span class="sd">           If another string is given it will correspond to ``getattr(numpy, method)``,</span>
<span class="sd">           while any callable function may be passed. The passed function</span>
<span class="sd">           will only be passed a list of unsorted distances that needs to be</span>
<span class="sd">           processed.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Using ``method=&#39;mode&#39;`` requires ``scipy&gt;=1.9``.</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; geom = Geometry([0]*3, Atom(1, R=1.), lattice=Lattice(1., nsc=[5, 5, 1]))</span>
<span class="sd">        &gt;&gt;&gt; geom.distance()</span>
<span class="sd">        array([1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(atol=[0.5, 0.4, 0.3, 0.2])</span>
<span class="sd">        array([1.])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(R=2, atol=[0.5, 0.4, 0.3, 0.2])</span>
<span class="sd">        array([1.        ,  1.41421356,  2.        ])</span>
<span class="sd">        &gt;&gt;&gt; geom.distance(R=2, atol=[0.5, 0.7]) # the R = 1 and R = 2 ** .5 gets averaged</span>
<span class="sd">        array([1.20710678,  2.        ])</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           an array of positive numbers yielding the distances from the atoms in reduced form</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        sparserij : return a sparse matrix will all distances between atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="c1"># Figure out maximum distance</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="s2">&quot;.distance cannot determine the `R` parameter. &quot;</span>
                    <span class="s2">&quot;The internal `maxR()` is negative and thus not set. &quot;</span>
                    <span class="s2">&quot;Set an explicit value for `R`.&quot;</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">):</span>
            <span class="n">maxR</span> <span class="o">=</span> <span class="n">fnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
            <span class="c1"># These loops could be leveraged if we look at angles...</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span>
                <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">//</span> <span class="mi">2</span><span class="p">]</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">k</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">sc</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">,</span> <span class="n">k</span><span class="p">]</span>
                <span class="n">off</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">offset</span><span class="p">(</span><span class="n">sc</span><span class="p">)</span>

                <span class="k">for</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">kk</span> <span class="ow">in</span> <span class="n">product</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]):</span>
                    <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">ii</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">jj</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*</span> <span class="n">kk</span>
                    <span class="n">maxR</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">maxR</span><span class="p">,</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">off</span> <span class="o">+</span> <span class="n">o</span><span class="p">))</span>

            <span class="k">if</span> <span class="n">R</span> <span class="o">&gt;</span> <span class="n">maxR</span><span class="p">:</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">maxR</span>

        <span class="c1"># Convert to list</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">atol</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="c1"># Now we are in a position to determine the sizes</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">atol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="n">atol</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mf">0.55</span><span class="p">,</span> <span class="n">atol</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">atol</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="n">dR</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mf">0.5</span>
            <span class="c1"># The first tolerance, is for it-self, the second</span>
            <span class="c1"># has to have the first tolerance as the field</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">cumsumd</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">dR</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">atol</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>

            <span class="k">if</span> <span class="n">dR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span><span class="p">:</span>
                <span class="c1"># Now finalize dR by ensuring all remaining segments are captured</span>
                <span class="n">t</span> <span class="o">=</span> <span class="n">atol</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

                <span class="n">dR</span> <span class="o">=</span> <span class="n">concatenate</span><span class="p">((</span><span class="n">dR</span><span class="p">,</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">dR</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">t</span><span class="p">,</span> <span class="n">R</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="mf">0.55</span><span class="p">,</span> <span class="n">t</span><span class="p">)))</span>

            <span class="c1"># Reduce to the largest value above R</span>
            <span class="c1"># This ensures that R, truly is the largest considered element</span>
            <span class="n">dR</span> <span class="o">=</span> <span class="n">dR</span><span class="p">[:</span> <span class="p">(</span><span class="n">dR</span> <span class="o">&gt;</span> <span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Now we can figure out the list of atoms in each shell</span>
        <span class="c1"># First create the initial lists of shell atoms</span>
        <span class="c1"># The inner shell will never be used, because it should correspond</span>
        <span class="c1"># to the atom it-self.</span>
        <span class="n">shells</span> <span class="o">=</span> <span class="p">[[]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">dR</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)]</span>

        <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
            <span class="n">_</span><span class="p">,</span> <span class="n">r</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">dR</span><span class="p">,</span> <span class="n">ret_rij</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">rlist</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">r</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">rlist</span><span class="p">)</span>

        <span class="c1"># Now parse all of the shells with the correct routine</span>
        <span class="c1"># First we grap the routine:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;median&quot;</span><span class="p">:</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">median</span><span class="p">(</span><span class="n">lst</span><span class="p">,</span> <span class="n">overwrite_input</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s2">&quot;mode&quot;</span><span class="p">:</span>
                <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.stats</span><span class="w"> </span><span class="kn">import</span> <span class="n">mode</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">lst</span><span class="p">):</span>
                    <span class="c1"># We don&#39;t need keepdims=False, because an array of size 1</span>
                    <span class="c1"># can be broadcasted to a single element.</span>
                    <span class="k">return</span> <span class="n">mode</span><span class="p">(</span><span class="n">lst</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">np</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">AttributeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.distance `method` got wrong input value.&quot;</span>
                    <span class="p">)</span> <span class="kn">from</span><span class="w"> </span><span class="nn">e</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span> <span class="o">=</span> <span class="n">method</span>

        <span class="c1"># Reduce lists</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">shells</span><span class="p">)):</span>
            <span class="n">lst</span> <span class="o">=</span> <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Reduce elements</span>
            <span class="n">shells</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">lst</span><span class="p">)</span>

        <span class="c1"># Convert to flattened numpy array and ensure shape</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">hstack</span><span class="p">(</span><span class="n">shells</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="Geometry.within_inf">
<a class="viewcode-back" href="../../../api/generated/sisl.Geometry.html#sisl.Geometry.within_inf">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;tol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument tol has been deprecated in favor of atol, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">within_inf</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">lattice</span><span class="p">:</span> <span class="n">Lattice</span><span class="p">,</span>
        <span class="n">periodic</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Sequence</span><span class="p">[</span><span class="nb">bool</span><span class="p">],</span> <span class="n">CellAxes</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-5</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="n">Sequence</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">),</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">,</span> <span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Find all atoms within a provided supercell</span>

<span class="sd">        Note this function is rather different from `close` and `within`.</span>
<span class="sd">        Specifically this routine is returning *all* indices for the infinite</span>
<span class="sd">        periodic system. The default periodic directions are ``self.pbc``,</span>
<span class="sd">        unless `periodic` is provided.</span>

<span class="sd">        Atomic coordinates lying on the boundary of the supercell will be duplicated</span>
<span class="sd">        on the neighboring supercell images. Thus performing ``geom.within_inf(geom.lattice)``</span>
<span class="sd">        may result in more atoms than in the structure.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The name of this function may change. Currently it should only be used</span>
<span class="sd">        internally in sisl.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        lattice : LatticeLike</span>
<span class="sd">            the supercell in which this geometry should be expanded into.</span>
<span class="sd">        periodic :</span>
<span class="sd">            explicitly define the periodic directions, by default the periodic</span>
<span class="sd">            directions are only where ``self.pbc``.</span>
<span class="sd">        atol :</span>
<span class="sd">            length tolerance for the coordinates to be on a duplicate site (in Ang).</span>
<span class="sd">            This allows atoms within `atol` of the cell boundaries to be taken as *inside* the</span>
<span class="sd">            cell.</span>
<span class="sd">        origin :</span>
<span class="sd">            origin that is the basis for comparison, default to 0.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           unit-cell atomic indices which are inside the `lattice` cell</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           atomic coordinates for the `ia` atoms (including supercell offsets)</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           integer supercell offsets for `ia` atoms</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="n">new</span><span class="p">(</span><span class="n">lattice</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">periodic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">periodic</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">periodic</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">periodic</span><span class="p">:</span>
                <span class="n">periodic</span> <span class="o">=</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">periodic</span> <span class="o">=</span> <span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">periodic</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">listify</span><span class="p">(</span><span class="n">periodic</span><span class="p">))</span> <span class="o">|</span> <span class="n">listify</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">periodic</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">periodic</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># extract the non-periodic directions</span>
        <span class="n">non_periodic</span> <span class="o">=</span> <span class="nb">filter</span><span class="p">(</span><span class="k">lambda</span> <span class="n">i</span><span class="p">:</span> <span class="n">i</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">periodic</span><span class="p">,</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">))</span> <span class="o">|</span> <span class="n">listify</span>

        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">origin</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Our first task is to construct a geometry large</span>
        <span class="c1"># enough to fully encompass the supercell</span>
        <span class="c1"># The supercell here defines how big `self` needs to be</span>
        <span class="c1"># to be fully located inside `lattice`.</span>

        <span class="c1"># 1. Number of times each lattice vector must be expanded to fit</span>
        <span class="c1">#    inside the &quot;possibly&quot; larger `lattice`.</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">cell</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">tile_max</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Intrinsic offset (when atomic coordinates are outside primary unit-cell)</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">round</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fxyz</span><span class="p">,</span> <span class="n">decimals</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
        <span class="c1"># We don&#39;t collapse this as it is necessary for correcting isc further below</span>
        <span class="n">fxyz_ifloor</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">fxyz</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">fxyz_iceil</span> <span class="o">=</span> <span class="n">ceil</span><span class="p">(</span><span class="n">fxyz</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">tile_min</span><span class="p">,</span> <span class="n">fxyz_ifloor</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">tile_max</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">tile_max</span><span class="p">,</span> <span class="n">fxyz_iceil</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">fxyz</span>

        <span class="c1"># 1a) correct for origin displacement</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">origin</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">tile_min</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">origin</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span>
        <span class="n">tile_min</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">minimum</span><span class="p">(</span><span class="n">tile_min</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># 2. Reduce tiling along non-periodic directions</span>
        <span class="n">tile_min</span><span class="p">[</span><span class="n">non_periodic</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">tile_max</span><span class="p">[</span><span class="n">non_periodic</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="c1"># 3. Find the *new* origin according to the *negative* tilings.</span>
        <span class="c1">#    This is important for skewed cells as the placement of the new</span>
        <span class="c1">#    larger geometry has to be shifted to have lattice inside</span>
        <span class="n">big_origin</span> <span class="o">=</span> <span class="p">(</span><span class="n">tile_min</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="c1"># The xyz geometry that fully encompass the (possibly) larger supercell</span>
        <span class="n">tile</span> <span class="o">=</span> <span class="n">tile_max</span> <span class="o">-</span> <span class="n">tile_min</span>

        <span class="n">full_geom</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span> <span class="o">*</span> <span class="n">tile</span><span class="p">)</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">big_origin</span> <span class="o">-</span> <span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Now we have to figure out all atomic coordinates within</span>
        <span class="n">cuboid</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">Cuboid</span><span class="p">()</span>

        <span class="c1"># Make sure that full_geom doesn&#39;t return coordinates outside the unit cell</span>
        <span class="c1"># for non periodic directions</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">full_geom</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="o">//</span> <span class="mi">2</span>

        <span class="c1"># If we have atoms outside the primary unit-cell in the original</span>
        <span class="c1"># cell, then we should consider an nsc large enough to encompass this</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">nsc</span><span class="p">,</span> <span class="n">fxyz_iceil</span><span class="p">)</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">maximum</span><span class="p">(</span><span class="n">nsc</span><span class="p">,</span> <span class="o">-</span><span class="n">fxyz_ifloor</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">nsc</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="n">nsc</span><span class="p">[</span><span class="n">non_periodic</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">full_geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Now retrieve all atomic coordinates from the full geometry</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">full_geom</span><span class="o">.</span><span class="n">axyz</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="n">full_geom</span><span class="o">.</span><span class="n">na_s</span><span class="p">))</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">cuboid</span><span class="o">.</span><span class="n">within_index</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">idx</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">del</span> <span class="n">full_geom</span>

        <span class="c1"># Figure out supercell connections in the smaller indices</span>
        <span class="c1"># Since we have shifted all coordinates into the primary unit cell we</span>
        <span class="c1"># are sure that these fxyz are [0:1[</span>
        <span class="n">fxyz</span> <span class="o">=</span> <span class="n">xyz</span> <span class="o">@</span> <span class="bp">self</span><span class="o">.</span><span class="n">icell</span><span class="o">.</span><span class="n">T</span>

        <span class="c1"># Since there are numerical errors for the above operation</span>
        <span class="c1"># we *have* to account for possible sign-errors</span>
        <span class="c1"># This is done by a length tolerance</span>
        <span class="n">ftol</span> <span class="o">=</span> <span class="n">atol</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">floor</span><span class="p">(</span><span class="n">fxyz</span> <span class="o">-</span> <span class="n">ftol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Now we can extract the indices where the two are non-matching.</span>
        <span class="c1"># At these indices we have some &quot;errors&quot; that we have to fix and</span>
        <span class="c1"># thus select the correct isc.</span>
        <span class="n">idx_diff</span> <span class="o">=</span> <span class="p">(</span><span class="n">isc</span> <span class="o">-</span> <span class="n">floor</span><span class="p">(</span><span class="n">fxyz</span> <span class="o">+</span> <span class="n">ftol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">))</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

        <span class="c1"># For these indices we can use the nearest integer as that</span>
        <span class="c1"># selects the closest. floor will ONLY be wrong for -0.0000, 0.99999, ...</span>
        <span class="n">isc</span><span class="p">[</span><span class="n">idx_diff</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">fxyz</span><span class="p">[</span><span class="n">idx_diff</span><span class="p">])</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># Convert indices to unit-cell indices and also return coordinates and</span>
        <span class="c1"># infinite supercell indices</span>
        <span class="n">ia</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">asc2uc</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ia</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">isc</span> <span class="o">-</span> <span class="n">fxyz_ifloor</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_orbital_values</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">grid_shape</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">],</span> <span class="n">truncate_with_nsc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculates orbital values for a given grid.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid_shape:</span>
<span class="sd">           the grid shape (i.e. resolution) in which to calculate the orbital values.</span>
<span class="sd">        truncate_with_nsc:</span>
<span class="sd">            if True, only consider atoms within the geometry&#39;s auxiliary cell.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This method does not belong on this geometry. It will be removed eventually.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># We need to import these here to avoid circular imports.</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sisl</span><span class="w"> </span><span class="kn">import</span> <span class="n">Grid</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sisl._sparse_grid</span><span class="w"> </span><span class="kn">import</span> <span class="n">SparseGridOrbitalBZ</span>

        <span class="c1"># In the following we don&#39;t care about division</span>
        <span class="c1"># So 1) save error state, 2) turn off divide by 0, 3) calculate, 4) turn on old error state</span>
        <span class="n">old_err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="n">divide</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">invalid</span><span class="o">=</span><span class="s2">&quot;ignore&quot;</span><span class="p">)</span>

        <span class="c1"># Instead of looping all atoms in the supercell we find the exact atoms</span>
        <span class="c1"># and their supercell indices.</span>
        <span class="n">add_R</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">maxR</span><span class="p">())</span>
        <span class="c1"># Calculate the required additional vectors required to increase the fictitious</span>
        <span class="c1"># supercell by add_R in each direction.</span>
        <span class="c1"># For extremely skewed lattices this will be way too much, hence we make</span>
        <span class="c1"># them square.</span>
        <span class="n">o</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">to</span><span class="o">.</span><span class="n">Cuboid</span><span class="p">(</span><span class="n">orthogonal</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">o</span><span class="o">.</span><span class="n">_v</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">add_R</span><span class="p">),</span> <span class="n">origin</span><span class="o">=</span><span class="n">o</span><span class="o">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">add_R</span><span class="p">)</span>

        <span class="c1"># Retrieve all atoms within the grid supercell</span>
        <span class="c1"># (and the neighbours that connect into the cell)</span>
        <span class="n">IA</span><span class="p">,</span> <span class="n">XYZ</span><span class="p">,</span> <span class="n">ISC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">within_inf</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">periodic</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">)</span>
        <span class="n">XYZ</span> <span class="o">-=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">origin</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Don&#39;t consider atoms that are outside of the geometry&#39;s auxiliary cell.</span>
        <span class="k">if</span> <span class="n">truncate_with_nsc</span><span class="p">:</span>
            <span class="n">mask</span> <span class="o">=</span> <span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">ISC</span><span class="p">)</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nsc</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">IA</span><span class="p">,</span> <span class="n">XYZ</span><span class="p">,</span> <span class="n">ISC</span> <span class="o">=</span> <span class="n">IA</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">XYZ</span><span class="p">[</span><span class="n">mask</span><span class="p">],</span> <span class="n">ISC</span><span class="p">[</span><span class="n">mask</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">xyz2spherical</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">offset</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Calculate the spherical coordinates from indices&quot;&quot;&quot;</span>
            <span class="n">rx</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">ry</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">rz</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">offset</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">xyz_to_spherical_cos_phi</span><span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rz</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rz</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sphere_grid_index</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">center</span><span class="p">,</span> <span class="n">R</span><span class="p">):</span>

            <span class="n">corners</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span><span class="mi">2</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">R</span> <span class="o">+</span> <span class="n">center</span>
            <span class="n">corners</span> <span class="o">=</span> <span class="n">corners</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">corners_i</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">corners</span><span class="p">)</span>

            <span class="n">cmin</span> <span class="o">=</span> <span class="n">corners_i</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">cmax</span> <span class="o">=</span> <span class="n">corners_i</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="n">sh</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span>

            <span class="c1"># direct if-statements are 4-5 times faster than min+max</span>
            <span class="c1"># These subsequent 25 lines are equivalent to:</span>
            <span class="c1"># cmin = np.maximum(0, np.minimum(cmin, sh))</span>
            <span class="c1"># the numpy equivalents are way too slow in this case.</span>
            <span class="k">if</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cmin</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">cmin</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">sh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">cmin</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">cmax</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">cmax</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">cmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">elif</span> <span class="n">sh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]:</span>
                <span class="n">cmax</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sh</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>

            <span class="n">rx</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cmin</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">ry</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cmin</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">rz</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">cmin</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">cmax</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="n">indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="n">rx</span><span class="p">,</span> <span class="n">ry</span><span class="p">,</span> <span class="n">rz</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">T</span>

            <span class="k">return</span> <span class="n">indices</span>

        <span class="c1"># Get the size of the auxiliary supercell needed to store orbital values.</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ISC</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">sp_grid_geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">sp_grid_geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Initialize a fake grid to compute some quantities related to the grid distribution</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">grid_shape</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>

        <span class="c1"># Estimate a top limit on how many values we need to store. We estimate it by expecting</span>
        <span class="c1"># each orbital to fill a sphere of radius R, being R the radius of the orbital. We also</span>
        <span class="c1"># add a margin of 1 voxel so that we don&#39;t underestimate because of rounding.</span>
        <span class="n">dvolume</span> <span class="o">=</span> <span class="n">grid</span><span class="o">.</span><span class="n">dvolume</span>
        <span class="n">margin_R</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">dcell</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">))</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">for</span> <span class="n">atom</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">IA</span><span class="p">)</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
            <span class="n">vol</span> <span class="o">+=</span> <span class="p">(</span><span class="mi">4</span> <span class="o">/</span> <span class="mi">3</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="n">margin_R</span><span class="p">)</span> <span class="o">**</span> <span class="mi">3</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">)</span>

        <span class="n">max_vals</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">vol</span> <span class="o">/</span> <span class="n">dvolume</span><span class="p">)</span>

        <span class="c1"># Array storing all the grid values</span>
        <span class="n">grid_values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="c1"># Orbital indices for each orbital that has a nonzero value in the grid.</span>
        <span class="n">orbital_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="n">max_vals</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># For each value, its index of the grid. Even if the grid is 3 dimensional,</span>
        <span class="c1"># we store the raveled index. That is, a single integer representing the position</span>
        <span class="c1"># of the point. One can always unravel the index if needed.</span>
        <span class="n">grid_indices</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">max_vals</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="c1"># print(</span>
        <span class="c1">#     f&quot;Estimated memory required:&quot;,</span>
        <span class="c1">#     (orbital_indices.size * 32 + grid_values.size * 64 + grid_indices.size * 32) / 8 / 1024 / 1024,</span>
        <span class="c1">#     &quot;MB&quot;</span>
        <span class="c1"># )</span>

        <span class="c1"># Temporal variables that will help us keep track of the construction of the arrays.</span>
        <span class="n">i_value</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">first_orbs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">firsto</span>
        <span class="n">isc_off</span> <span class="o">=</span> <span class="n">sp_grid_geom</span><span class="o">.</span><span class="n">isc_off</span>

        <span class="c1"># Loop over all atoms in the grid-cell</span>
        <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">ia_xyz</span><span class="p">,</span> <span class="n">isc</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">IA</span><span class="p">,</span> <span class="n">XYZ</span><span class="p">,</span> <span class="n">ISC</span><span class="p">):</span>
            <span class="c1"># Get current atom</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>

            <span class="c1"># Get the index of the cell where this atom is in the auxiliary supercell</span>
            <span class="n">index_sc</span> <span class="o">=</span> <span class="n">isc_off</span><span class="p">[</span><span class="n">isc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
            <span class="c1"># And use it to calculate the offset on the orbital index.</span>
            <span class="n">io_offset</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no</span> <span class="o">*</span> <span class="n">index_sc</span>

            <span class="c1"># Extract maximum R</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">maxR</span><span class="p">()</span>

            <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Atom &#39;</span><span class="si">{</span><span class="n">atom</span><span class="si">}</span><span class="s2">&#39; does not have a wave-function, skipping atom.&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="n">sphere_grid_index</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">ia_xyz</span><span class="p">,</span> <span class="n">R</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Get real-space coordinates for the atom</span>
            <span class="n">grid_xyz</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">idx</span><span class="p">,</span> <span class="n">grid</span><span class="o">.</span><span class="n">dcell</span><span class="p">)</span>
            <span class="c1"># Convert them to spherical coordinates</span>
            <span class="n">at_r</span><span class="p">,</span> <span class="n">at_theta</span><span class="p">,</span> <span class="n">at_cos_phi</span> <span class="o">=</span> <span class="n">xyz2spherical</span><span class="p">(</span><span class="n">grid_xyz</span><span class="p">,</span> <span class="n">ia_xyz</span><span class="p">)</span>

            <span class="k">del</span> <span class="n">grid_xyz</span>
            <span class="c1"># Merge the three components of spherical coordinates into one array.</span>
            <span class="n">at_spherical</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">at_r</span><span class="p">,</span> <span class="n">at_theta</span><span class="p">,</span> <span class="n">at_cos_phi</span><span class="p">])</span><span class="o">.</span><span class="n">T</span>

            <span class="c1"># Filter out points where the distance to the atom is less than its max R.</span>
            <span class="n">at_nonzero</span> <span class="o">=</span> <span class="n">at_spherical</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">R</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="p">[</span><span class="n">at_nonzero</span><span class="p">]</span>
            <span class="n">at_spherical</span> <span class="o">=</span> <span class="n">at_spherical</span><span class="p">[</span><span class="n">at_nonzero</span><span class="p">]</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">continue</span>

            <span class="c1"># Ravel multi index to save space. That is, convert the 3D grid index</span>
            <span class="c1"># into a single integer. One can always unravel them if needed.</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span>
                <span class="n">idx</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">idx</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="o">+</span> <span class="n">idx</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="p">)</span>

            <span class="c1"># Loop over the orbitals</span>
            <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom</span><span class="o">.</span><span class="n">orbitals</span><span class="p">):</span>
                <span class="c1"># Get the index of this orbital</span>
                <span class="n">uc_io</span> <span class="o">=</span> <span class="n">first_orbs</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="o">+</span> <span class="n">io</span>

                <span class="n">orb_spherical</span> <span class="o">=</span> <span class="n">at_spherical</span>
                <span class="n">orb_indices</span> <span class="o">=</span> <span class="n">idx</span>

                <span class="c1"># The orbital&#39;s R might not be the maximum R of the atom. In that case,</span>
                <span class="c1"># we don&#39;t need to calculate the values for all the grid points that are within</span>
                <span class="c1"># the atom&#39;s range.</span>
                <span class="k">if</span> <span class="n">R</span> <span class="o">-</span> <span class="n">orb</span><span class="o">.</span><span class="n">R</span> <span class="o">&gt;</span> <span class="mf">1e-6</span><span class="p">:</span>
                    <span class="c1"># Check which coordinates are not within this orbital&#39;s range (the radius is bigger than orbital radius)</span>
                    <span class="n">orb_nonzero</span> <span class="o">=</span> <span class="n">orb_spherical</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">&lt;</span> <span class="n">orb</span><span class="o">.</span><span class="n">R</span>

                    <span class="n">orb_spherical</span> <span class="o">=</span> <span class="n">orb_spherical</span><span class="p">[</span><span class="n">orb_nonzero</span><span class="p">]</span>
                    <span class="n">orb_indices</span> <span class="o">=</span> <span class="n">orb_indices</span><span class="p">[</span><span class="n">orb_nonzero</span><span class="p">]</span>

                <span class="c1"># Number of grid values that we are going to compute for this orbital</span>
                <span class="n">orb_nvals</span> <span class="o">=</span> <span class="n">orb_spherical</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="c1"># If there are no values to add, go to the next orbital</span>
                <span class="k">if</span> <span class="n">orb_nvals</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Compute the psi values for the grid points we are interested in</span>
                <span class="n">psi</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">psi_spher</span><span class="p">(</span><span class="o">*</span><span class="n">orb_spherical</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">cos_phi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

                <span class="c1"># Update the data structure</span>
                <span class="n">values_i</span> <span class="o">=</span> <span class="nb">slice</span><span class="p">(</span><span class="n">i_value</span><span class="p">,</span> <span class="n">i_value</span> <span class="o">+</span> <span class="n">orb_nvals</span><span class="p">)</span>
                <span class="n">grid_values</span><span class="p">[</span><span class="n">values_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">psi</span>
                <span class="n">grid_indices</span><span class="p">[</span><span class="n">values_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">orb_indices</span>
                <span class="n">orbital_indices</span><span class="p">[</span><span class="n">values_i</span><span class="p">]</span> <span class="o">=</span> <span class="n">uc_io</span> <span class="o">+</span> <span class="n">io_offset</span>

                <span class="c1"># Update the index where new values should be stored</span>
                <span class="n">i_value</span> <span class="o">+=</span> <span class="n">orb_nvals</span>

        <span class="c1"># Reset the error code for division</span>
        <span class="n">np</span><span class="o">.</span><span class="n">seterr</span><span class="p">(</span><span class="o">**</span><span class="n">old_err</span><span class="p">)</span>

        <span class="c1"># Cut the arrays to return only the parts that have been filled</span>
        <span class="n">grid_values</span> <span class="o">=</span> <span class="n">grid_values</span><span class="p">[:</span><span class="n">i_value</span><span class="p">]</span>
        <span class="n">grid_indices</span> <span class="o">=</span> <span class="n">grid_indices</span><span class="p">[:</span><span class="n">i_value</span><span class="p">]</span>
        <span class="n">orbital_indices</span> <span class="o">=</span> <span class="n">orbital_indices</span><span class="p">[:</span><span class="n">i_value</span><span class="p">]</span>

        <span class="n">psi_values</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">(</span>
            <span class="p">(</span><span class="n">grid_values</span><span class="p">,</span> <span class="p">(</span><span class="n">grid_indices</span><span class="p">,</span> <span class="n">orbital_indices</span><span class="p">)),</span>
            <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">),</span> <span class="n">sp_grid_geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">SparseGridOrbitalBZ</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span> <span class="n">psi_values</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">sp_grid_geom</span><span class="p">)</span>

    <span class="c1"># Create pickling routines</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the state of this object&quot;&quot;&quot;</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;xyz&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">d</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">d</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-create the state of this object&quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">lattice</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">)</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">()</span>
        <span class="n">atoms</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;atoms&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;xyz&quot;</span><span class="p">],</span> <span class="n">atoms</span><span class="o">=</span><span class="n">atoms</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ArgumentParser_args_single</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the options for `Geometry.ArgumentParser` in case they are the only options&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;limit_arguments&quot;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s2">&quot;short&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s2">&quot;positional_out&quot;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="c1"># Hook into the Geometry class to create</span>
    <span class="c1"># an automatic ArgumentParser which makes actions</span>
    <span class="c1"># as the options are read.</span>
    <span class="nd">@default_ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Manipulate a Geometry object in sisl.&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ArgumentParser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create and return a group of argument parsers which manipulates it self `Geometry`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parser : ArgumentParser, optional</span>
<span class="sd">           in case the arguments should be added to a specific parser. It defaults</span>
<span class="sd">           to create a new.</span>
<span class="sd">        limit_arguments : bool, optional</span>
<span class="sd">           If ``False`` additional options will be created which are similar to other options.</span>
<span class="sd">           For instance ``--repeat-x &lt;&gt;`` which is equivalent to ``--repeat &lt;&gt; x``.</span>
<span class="sd">           Default `True`.</span>
<span class="sd">        short : bool, optional</span>
<span class="sd">           Create short options for a selected range of options.</span>
<span class="sd">        positional_out : bool, optional</span>
<span class="sd">           If ``True``, adds a positional argument which acts as --out. This may be handy if only the geometry is in the argument list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">limit_args</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;limit_arguments&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">short</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;short&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">short</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">opts</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">args</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">opts</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">arg</span> <span class="k">for</span> <span class="n">arg</span> <span class="ow">in</span> <span class="n">args</span> <span class="k">if</span> <span class="n">arg</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;--&quot;</span><span class="p">)]</span>

        <span class="c1"># We limit the import to occur here</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>

        <span class="c1"># The first thing we do is adding the geometry to the NameSpace of the</span>
        <span class="c1"># parser.</span>
        <span class="c1"># This will enable custom actions to interact with the geometry in a</span>
        <span class="c1"># straight forward manner.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="n">g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">namespace</span> <span class="o">=</span> <span class="n">default_namespace</span><span class="p">(</span>
            <span class="n">_geometry</span><span class="o">=</span><span class="n">g</span><span class="p">,</span>
            <span class="n">_stored_geometry</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Create actions</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">Format</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geom_fmt</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--format&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Format</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="s2">&quot;.8f&quot;</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Specify output format for coordinates.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">MoveOrigin</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">no_value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">-=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--origin&quot;</span><span class="p">,</span> <span class="s2">&quot;-O&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">MoveOrigin</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Move all atoms such that the smallest value along each Cartesian direction will be at the origin.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">MoveCenterOf</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">xyz</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="s2">&quot;xyz&quot;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">center</span><span class="p">(</span><span class="n">what</span><span class="o">=</span><span class="n">value</span><span class="p">)</span> <span class="o">-</span> <span class="n">xyz</span>
                <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--center-of&quot;</span><span class="p">,</span> <span class="s2">&quot;-co&quot;</span><span class="p">),</span>
            <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">,</span> <span class="s2">&quot;mass:pbc&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;position&quot;</span><span class="p">,</span> <span class="s2">&quot;cell&quot;</span><span class="p">,</span> <span class="s2">&quot;mm:xyz&quot;</span><span class="p">],</span>
            <span class="n">action</span><span class="o">=</span><span class="n">MoveCenterOf</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Move coordinates to the center of the designated choice.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">MoveUnitCell</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;translate&quot;</span><span class="p">,</span> <span class="s2">&quot;tr&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">):</span>
                    <span class="c1"># Simple translation</span>
                    <span class="n">tmp</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="o">-</span><span class="n">tmp</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">value</span> <span class="o">==</span> <span class="s2">&quot;mod&quot;</span><span class="p">:</span>
                    <span class="n">g</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span>
                    <span class="c1"># Change all coordinates using the reciprocal cell and move to unit-cell (% 1.)</span>
                    <span class="n">fxyz</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">fxyz</span> <span class="o">%</span> <span class="mf">1.0</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dot</span><span class="p">(</span><span class="n">fxyz</span><span class="p">,</span> <span class="n">g</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--unit-cell&quot;</span><span class="p">,</span> <span class="s2">&quot;-uc&quot;</span><span class="p">),</span>
            <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;translate&quot;</span><span class="p">,</span> <span class="s2">&quot;tr&quot;</span><span class="p">,</span> <span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;mod&quot;</span><span class="p">],</span>
            <span class="n">action</span><span class="o">=</span><span class="n">MoveUnitCell</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Moves the coordinates into the unit-cell by translation or the mod-operator&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Rotation</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">Rotation</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Convert value[0] to the direction</span>
                <span class="c1"># The rotate function expects degree</span>
                <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="n">ang</span><span class="p">,</span> <span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;abc+xyz&quot;</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--rotate&quot;</span><span class="p">,</span> <span class="s2">&quot;-R&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;ANGLE&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Rotation</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate coordinates and lattice vectors around given axis (x|y|z|a|b|c). ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">RotationX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="n">ang</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">],</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;abc+xyz&quot;</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--rotate-x&quot;</span><span class="p">,</span> <span class="s2">&quot;-Rx&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ANGLE&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">RotationX</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate coordinates and lattice vectors around x axis. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">RotationY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="n">ang</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">],</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;abc+xyz&quot;</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--rotate-y&quot;</span><span class="p">,</span> <span class="s2">&quot;-Ry&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ANGLE&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">RotationY</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate coordinates and lattice vectors around y axis. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">RotationZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="c1"># The rotate function expects degree</span>
                    <span class="n">ang</span> <span class="o">=</span> <span class="n">angle</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">in_rad</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">rotate</span><span class="p">([</span><span class="n">ang</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">],</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;abc+xyz&quot;</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--rotate-z&quot;</span><span class="p">,</span> <span class="s2">&quot;-Rz&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ANGLE&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">RotationZ</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Rotate coordinates and lattice vectors around z axis. ANGLE defaults to be specified in degree. Prefix with &quot;r&quot; for input in radians.&#39;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># Reduce size of geometry</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">ReduceSub</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Get atomic indices</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--sub&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;RNG&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">ReduceSub</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Retains specified atoms, can be complex ranges.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">ReduceRemove</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Get atomic indices</span>
                <span class="n">rng</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">))</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">rng</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--remove&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;RNG&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">ReduceRemove</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Removes specified atoms, can be complex ranges.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Swaps atoms</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">AtomSwap</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Get atomic indices</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
                <span class="n">b</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">b</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;swapping atoms requires equal number of LHS and RHS atomic ranges&quot;</span>
                    <span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--swap&quot;</span><span class="p">),</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="s2">&quot;B&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">AtomSwap</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Swaps groups of atoms (can be complex ranges). The groups must be of equal length.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Add an atom</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">AtomAdd</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create an atom from the input</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span>
                    <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)],</span> <span class="n">atoms</span><span class="o">=</span><span class="n">Atom</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">g</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--add&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;COORD&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">AtomAdd</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Adds an atom, coordinate is comma separated (in Ang). Z is the atomic number.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">Translate</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create an atom from the input</span>
                <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">xyz</span> <span class="o">=</span> <span class="p">[</span><span class="nb">float</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">()]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">translate</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--translate&quot;</span><span class="p">,</span> <span class="s2">&quot;-t&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;COORD&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Translate</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Translates the coordinates via a comma separated list (in Ang).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Periodicly increase the structure</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">PeriodRepeat</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--repeat&quot;</span><span class="p">,</span> <span class="s2">&quot;-r&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeat</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Repeats the geometry in the specified direction.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">PeriodRepeatX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--repeat-x&quot;</span><span class="p">,</span> <span class="s2">&quot;-rx&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatX</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Repeats the geometry along the first cell vector.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">PeriodRepeatY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--repeat-y&quot;</span><span class="p">,</span> <span class="s2">&quot;-ry&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatY</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Repeats the geometry along the second cell vector.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">PeriodRepeatZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--repeat-z&quot;</span><span class="p">,</span> <span class="s2">&quot;-rz&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">PeriodRepeatZ</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Repeats the geometry along the third cell vector.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">ReduceUnrepeat</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">unrepeat</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--unrepeat&quot;</span><span class="p">,</span> <span class="s2">&quot;-ur&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;REPS&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">ReduceUnrepeat</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Unrepeats the geometry into `reps` parts along the unit-cell direction `dir` (opposite of --repeat).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">PeriodTile</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">r</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--tile&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">PeriodTile</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Tiles the geometry in the specified direction.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">limit_args</span><span class="p">:</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">PeriodTileX</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--tile-x&quot;</span><span class="p">,</span> <span class="s2">&quot;-tx&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileX</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Tiles the geometry along the first cell vector.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">PeriodTileY</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">1</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--tile-y&quot;</span><span class="p">,</span> <span class="s2">&quot;-ty&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileY</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Tiles the geometry along the second cell vector.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

            <span class="k">class</span><span class="w"> </span><span class="nc">PeriodTileZ</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
                <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="mi">2</span><span class="p">)</span>

            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--tile-z&quot;</span><span class="p">,</span> <span class="s2">&quot;-tz&quot;</span><span class="p">),</span>
                <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;TIMES&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">PeriodTileZ</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Tiles the geometry along the third cell vector.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">ReduceUntile</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">s</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">untile</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--untile&quot;</span><span class="p">,</span> <span class="s2">&quot;--cut&quot;</span><span class="p">,</span> <span class="s2">&quot;-ut&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;REPS&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">ReduceUntile</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Untiles the geometry into `reps` parts along the unit-cell direction `dir` (opposite of --tile).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># append another geometry</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">Geometryend</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># Create an atom from the input</span>
                <span class="n">f</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">direction</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_method_pend</span><span class="p">)(</span><span class="n">geom</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">GeometryAppend</span><span class="p">(</span><span class="n">Geometryend</span><span class="p">):</span>
            <span class="n">_method_pend</span> <span class="o">=</span> <span class="s2">&quot;append&quot;</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--append&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;GEOM&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">GeometryAppend</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Appends another Geometry along direction DIR.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">GeometryPrepend</span><span class="p">(</span><span class="n">Geometryend</span><span class="p">):</span>
            <span class="n">_method_pend</span> <span class="o">=</span> <span class="s2">&quot;prepend&quot;</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--prepend&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;GEOM&quot;</span><span class="p">,</span> <span class="s2">&quot;DIR&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">GeometryPrepend</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Prepends another Geometry along direction DIR.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Sort</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">Sort</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># call geometry.sort(...) using appropriate keywords (and ordered dict)</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="n">OrderedDict</span><span class="p">()</span>
                <span class="n">opts</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;;&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">opt</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">opts</span><span class="p">):</span>
                    <span class="c1"># Split for equal</span>
                    <span class="n">opt</span> <span class="o">=</span> <span class="n">opt</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">opt</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">opt</span><span class="p">,</span> <span class="n">val</span> <span class="o">=</span> <span class="n">opt</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">opt</span> <span class="o">=</span> <span class="n">opt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="s2">&quot;True&quot;</span>
                    <span class="k">if</span> <span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;t&quot;</span><span class="p">,</span> <span class="s2">&quot;true&quot;</span><span class="p">):</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="k">elif</span> <span class="n">val</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;f&quot;</span><span class="p">,</span> <span class="s2">&quot;false&quot;</span><span class="p">):</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s2">&quot;atol&quot;</span><span class="p">:</span>
                        <span class="c1"># float values</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">opt</span> <span class="o">==</span> <span class="s2">&quot;group&quot;</span><span class="p">:</span>
                        <span class="k">pass</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="c1"># it must be a range/tuple</span>
                        <span class="n">val</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span><span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">val</span><span class="p">))</span>

                    <span class="c1"># we always add integers to allow users to use the same keywords on commandline</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="n">opt</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">)]</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--sort&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;SORT&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Sort</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Semi-colon separated options for sort, please always encapsulate in quotation [&quot;axes=0;descend;lattice=(1, 2);group=Z&quot;].&#39;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Print some common information about the</span>
        <span class="c1"># geometry (to stdout)</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">PrintInfo</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">no_value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># We fake that it has been stored...</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_geometry</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--info&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">PrintInfo</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Print, to stdout, some regular information about the geometry.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">Out</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">value</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">return</span>
                <span class="c1"># If the vector, exists, we should write it</span>
                <span class="n">kwargs</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_geom_fmt&quot;</span><span class="p">):</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;fmt&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geom_fmt</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_vector&quot;</span><span class="p">):</span>
                    <span class="n">v</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_vector&quot;</span><span class="p">)</span>
                    <span class="n">vs</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_vector_scale&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">vs</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                        <span class="k">if</span> <span class="n">vs</span><span class="p">:</span>
                            <span class="n">vs</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">sqrt</span><span class="p">(</span><span class="n">square</span><span class="p">(</span><span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)))</span>
                            <span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Scaling vector by: </span><span class="si">{</span><span class="n">vs</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">vs</span> <span class="o">=</span> <span class="mf">1.0</span>

                    <span class="c1"># Store the vectors with the scaling</span>
                    <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;data&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span> <span class="o">*</span> <span class="n">vs</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="c1"># Issue to the namespace that the geometry has been written, at least once.</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_stored_geometry</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="o">*</span><span class="n">opts</span><span class="p">(</span><span class="s2">&quot;--out&quot;</span><span class="p">,</span> <span class="s2">&quot;-o&quot;</span><span class="p">),</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store the geometry (at its current invocation) to the out file.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># If the user requests positional out arguments, we also add that.</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;positional_out&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="s2">&quot;out&quot;</span><span class="p">,</span>
                <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;*&quot;</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store the geometry (at its current invocation) to the out file.&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># We have now created all arguments</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">namespace</span>


<span class="n">new_dispatch</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">new</span>
<span class="n">to_dispatch</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">to</span>


<span class="c1"># Define base-class for this</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GeometryNewDispatch</span><span class="p">(</span><span class="n">AbstractDispatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base dispatcher from class passing arguments to Geometry class&quot;&quot;&quot;</span>


<span class="c1"># Bypass regular Geometry to be returned as is</span>
<span class="k">class</span><span class="w"> </span><span class="nc">GeometryNewGeometryDispatch</span><span class="p">(</span><span class="n">GeometryNewDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="n">copy</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensure the object is a Geometry class, for sanitation purposes&quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_class</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="o">!=</span> <span class="n">geometry</span><span class="o">.</span><span class="vm">__class__</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="bp">cls</span><span class="p">(</span>
                <span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">atoms</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
                <span class="n">lattice</span><span class="o">=</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="p">)</span>
            <span class="n">copy</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">geometry</span>


<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Geometry</span><span class="p">,</span> <span class="n">GeometryNewGeometryDispatch</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryNewFileDispatch</span><span class="p">(</span><span class="n">GeometryNewDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Defer the `Geometry.read` method by passing down arguments&quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_class</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">GeometryNewFileDispatch</span><span class="p">)</span>
<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">GeometryNewFileDispatch</span><span class="p">)</span>
<span class="c1"># see sisl/__init__.py for new_dispatch.register(BaseSile, GeometryNewFileDispatcher)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryNewAseDispatch</span><span class="p">(</span><span class="n">GeometryNewDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">aseg</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert an `ase.Atoms` object into a `Geometry`&quot;&quot;&quot;</span>
        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_class</span><span class="p">()</span>
        <span class="n">Z</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_atomic_numbers</span><span class="p">()</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_positions</span><span class="p">()</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">aseg</span><span class="o">.</span><span class="n">get_cell</span><span class="p">()</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span> <span class="k">if</span> <span class="n">pbc</span> <span class="k">else</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">pbc</span> <span class="ow">in</span> <span class="n">aseg</span><span class="o">.</span><span class="n">pbc</span><span class="p">]</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="n">GeometryNewAseDispatch</span><span class="p">)</span>

<span class="c1"># currently we can&#39;t ensure the ase Atoms type</span>
<span class="c1"># to get it by type(). That requires ase to be importable.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">ase</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atoms</span> <span class="k">as</span> <span class="n">ase_Atoms</span>

    <span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ase_Atoms</span><span class="p">,</span> <span class="n">GeometryNewAseDispatch</span><span class="p">)</span>
    <span class="c1"># ensure we don&#39;t pollute name-space</span>
    <span class="k">del</span> <span class="n">ase_Atoms</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryNewpymatgenDispatch</span><span class="p">(</span><span class="n">GeometryNewDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">struct</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a ``pymatgen`` structure/molecule object into a `Geometry`&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Structure</span>

        <span class="bp">cls</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_class</span><span class="p">(</span><span class="n">allow_instance</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="n">Z</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">site</span> <span class="ow">in</span> <span class="n">struct</span><span class="o">.</span><span class="n">sites</span><span class="p">:</span>
            <span class="n">Z</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">specie</span><span class="o">.</span><span class="n">Z</span><span class="p">)</span>
            <span class="n">xyz</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">site</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">xyz</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">struct</span><span class="p">,</span> <span class="n">Structure</span><span class="p">):</span>
            <span class="c1"># we also have the lattice</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">struct</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">matrix</span>
            <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>  <span class="c1"># really, this is unknown</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cell</span> <span class="o">=</span> <span class="n">xyz</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">15.0</span>
            <span class="n">nsc</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">cls</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="n">Z</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;pymatgen&quot;</span><span class="p">,</span> <span class="n">GeometryNewpymatgenDispatch</span><span class="p">)</span>

<span class="c1"># currently we can&#39;t ensure the pymatgen classes</span>
<span class="c1"># to get it by type(). That requires pymatgen to be importable.</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Molecule</span> <span class="k">as</span> <span class="n">pymatgen_Molecule</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Structure</span> <span class="k">as</span> <span class="n">pymatgen_Structure</span>

    <span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">pymatgen_Molecule</span><span class="p">,</span> <span class="n">GeometryNewpymatgenDispatch</span><span class="p">)</span>
    <span class="n">new_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">pymatgen_Structure</span><span class="p">,</span> <span class="n">GeometryNewpymatgenDispatch</span><span class="p">)</span>
    <span class="c1"># ensure we don&#39;t pollute name-space</span>
    <span class="k">del</span> <span class="n">pymatgen_Molecule</span><span class="p">,</span> <span class="n">pymatgen_Structure</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="k">pass</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryToDispatch</span><span class="p">(</span><span class="n">AbstractDispatch</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base dispatcher from class passing from Geometry class&quot;&quot;&quot;</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryToSileDispatch</span><span class="p">(</span><span class="n">GeometryToDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the geometry to a sile with any optional arguments.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; geom = si.geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; geom.to(&quot;hello.xyz&quot;)</span>
<span class="sd">        &gt;&gt;&gt; geom.to(pathlib.Path(&quot;hello.xyz&quot;))</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;str&quot;</span><span class="p">,</span> <span class="n">GeometryToSileDispatch</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;Path&quot;</span><span class="p">,</span> <span class="n">GeometryToSileDispatch</span><span class="p">)</span>
<span class="c1"># to do geom.to[Path](path)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">GeometryToSileDispatch</span><span class="p">)</span>
<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">Path</span><span class="p">,</span> <span class="n">GeometryToSileDispatch</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryToAseDispatch</span><span class="p">(</span><span class="n">GeometryToDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ase</span><span class="o">.</span><span class="n">Atoms</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Conversion of `Geometry` to an `ase.Atoms` object&quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">ase</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atoms</span> <span class="k">as</span> <span class="n">ase_Atoms</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">ase_Atoms</span><span class="p">(</span>
            <span class="n">symbols</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span>
            <span class="n">positions</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="n">cell</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">tolist</span><span class="p">(),</span>
            <span class="n">pbc</span><span class="o">=</span><span class="n">geom</span><span class="o">.</span><span class="n">pbc</span><span class="p">,</span>
            <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
        <span class="p">)</span>


<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">,</span> <span class="n">GeometryToAseDispatch</span><span class="p">)</span>
<span class="k">if</span> <span class="n">has_module</span><span class="p">(</span><span class="s2">&quot;ase&quot;</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">ase</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atoms</span> <span class="k">as</span> <span class="n">ase_Atoms</span>

    <span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">ase_Atoms</span><span class="p">,</span> <span class="n">GeometryToAseDispatch</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">ase_Atoms</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryTopymatgenDispatch</span><span class="p">(</span><span class="n">GeometryToDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pymatgen</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Molecule</span><span class="p">,</span> <span class="n">pymatgen</span><span class="o">.</span><span class="n">core</span><span class="o">.</span><span class="n">Structure</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Conversion of `Geometry` to a `pymatgen` object.</span>

<span class="sd">        Depending on the periodicity, it can be `Molecule` or `Structure`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">pymatgen.core</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lattice</span><span class="p">,</span> <span class="n">Molecule</span><span class="p">,</span> <span class="n">Structure</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">sisl._core</span><span class="w"> </span><span class="kn">import</span> <span class="n">PeriodicTable</span>

        <span class="c1"># ensure we have an object</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">()</span>

        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">cell</span><span class="p">)</span>
        <span class="c1"># get atomic letters and coordinates</span>
        <span class="n">PT</span> <span class="o">=</span> <span class="n">PeriodicTable</span><span class="p">()</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span>
        <span class="n">species</span> <span class="o">=</span> <span class="p">[</span><span class="n">PT</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">Z</span><span class="p">)</span> <span class="k">for</span> <span class="n">Z</span> <span class="ow">in</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">Z</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pbc</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">Structure</span><span class="p">(</span><span class="n">lattice</span><span class="p">,</span> <span class="n">species</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="n">coords_are_cartesian</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># we define a molecule</span>
        <span class="k">return</span> <span class="n">Molecule</span><span class="p">(</span><span class="n">species</span><span class="p">,</span> <span class="n">xyz</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;pymatgen&quot;</span><span class="p">,</span> <span class="n">GeometryTopymatgenDispatch</span><span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">GeometryToDataframeDispatch</span><span class="p">(</span><span class="n">GeometryToDispatch</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">dispatch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pandas</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert the geometry to a `pandas.DataFrame` with values stored in columns&quot;&quot;&quot;</span>

        <span class="kn">import</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">pd</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_object</span><span class="p">()</span>

        <span class="c1"># Now create data-frame</span>
        <span class="c1"># Currently we will populate it with</span>
        <span class="c1"># - xyz</span>
        <span class="c1"># - symbol</span>
        <span class="c1"># - Z</span>
        <span class="c1"># - tag</span>
        <span class="c1"># - R</span>
        <span class="c1"># - mass</span>
        <span class="c1"># - valence q</span>
        <span class="c1"># - norbs</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="o">.</span><span class="n">T</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;x&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;y&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">y</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">z</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">Z</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;mass&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">mass</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">maxR</span><span class="p">(</span><span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">q0</span>
        <span class="n">data</span><span class="p">[</span><span class="s2">&quot;norbitals&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span>

        <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>


<span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="s2">&quot;dataframe&quot;</span><span class="p">,</span> <span class="n">GeometryToDataframeDispatch</span><span class="p">)</span>
<span class="k">if</span> <span class="n">has_module</span><span class="p">(</span><span class="s2">&quot;pandas&quot;</span><span class="p">):</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pandas</span><span class="w"> </span><span class="kn">import</span> <span class="n">DataFrame</span> <span class="k">as</span> <span class="n">pd_DataFrame</span>

    <span class="n">to_dispatch</span><span class="o">.</span><span class="n">register</span><span class="p">(</span><span class="n">pd_DataFrame</span><span class="p">,</span> <span class="n">GeometryToDataframeDispatch</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">pd_DataFrame</span>


<span class="c1"># Clean up</span>
<span class="k">del</span> <span class="n">new_dispatch</span><span class="p">,</span> <span class="n">to_dispatch</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">sgeom</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">argv</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">ret_geometry</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Main script for sgeom.</span>

<span class="sd">    This routine may be called with `argv` and/or a `Sile` which is the geometry at hand.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    geom : Geometry or BaseSile</span>
<span class="sd">       this may either be the geometry, as-is, or a `Sile` which contains</span>
<span class="sd">       the geometry.</span>
<span class="sd">    argv : list of str</span>
<span class="sd">       the arguments passed to sgeom</span>
<span class="sd">    ret_geometry : bool, optional</span>
<span class="sd">       whether the function should return the geometry</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>

    <span class="kn">from</span><span class="w"> </span><span class="nn">sisl.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">BaseSile</span><span class="p">,</span> <span class="n">get_sile</span>

    <span class="c1"># The geometry-file *MUST* be the first argument</span>
    <span class="c1"># (except --help|-h)</span>
    <span class="n">exe</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">.</span><span class="n">name</span>

    <span class="c1"># We cannot create a separate ArgumentParser to retrieve a positional arguments</span>
    <span class="c1"># as that will grab the first argument for an option!</span>

    <span class="c1"># Start creating the command-line utilities that are the actual ones.</span>
    <span class="n">description</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">This manipulation utility is highly advanced and one should note that the ORDER of</span>
<span class="s2">options is determining the final structure. For instance:</span>

<span class="s2">   </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2"> geom.xyz --repeat 2 x --repeat 2 y</span>

<span class="s2">is NOT equivalent to:</span>

<span class="s2">   </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2"> geom.xyz --repeat 2 y --repeat 2 x</span>

<span class="s2">This may be unexpected but enables one to do advanced manipulations.</span>

<span class="s2">Additionally, in between arguments, one may store the current state of the geometry</span>
<span class="s2">by writing to a standard file.</span>

<span class="s2">   </span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2"> geom.xyz --repeat 2 y geom_repy.xyz --repeat 2 x geom_repy_repx.xyz</span>

<span class="s2">will create two files:</span>
<span class="s2">   geom_repy.xyz</span>
<span class="s2">will only be repeated 2 times along the second lattice vector, while:</span>
<span class="s2">   geom_repy_repx.xyz</span>
<span class="s2">will be repeated 2 times along the second lattice vector, and then the first</span>
<span class="s2">lattice vector.</span>
<span class="s2">    &quot;&quot;&quot;</span>

    <span class="k">if</span> <span class="n">argv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;--help&quot;</span><span class="p">]</span>
    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># no arguments</span>
        <span class="c1"># fake a help</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;--help&quot;</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">argv</span> <span class="o">=</span> <span class="n">sys</span><span class="o">.</span><span class="n">argv</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Ensure that the arguments have pre-pended spaces</span>
    <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">argv_negative_fix</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

    <span class="n">p</span> <span class="o">=</span> <span class="n">argparse</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span>
        <span class="n">exe</span><span class="p">,</span>
        <span class="n">formatter_class</span><span class="o">=</span><span class="n">SislHelpFormatter</span><span class="p">,</span>
        <span class="n">description</span><span class="o">=</span><span class="n">description</span><span class="p">,</span>
    <span class="p">)</span>

    <span class="c1"># Add default sisl version stuff</span>
    <span class="n">cmd</span><span class="o">.</span><span class="n">add_sisl_version_cite_arg</span><span class="p">(</span><span class="n">p</span><span class="p">)</span>

    <span class="c1"># First read the input &quot;Sile&quot;</span>
    <span class="n">stdout_geom</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">os.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">isfile</span>

        <span class="n">argv</span><span class="p">,</span> <span class="n">input_file</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_input</span><span class="p">(</span><span class="n">argv</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">input_file</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">stdout_geom</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Extract specification of the input file</span>
            <span class="n">i_file</span><span class="p">,</span> <span class="n">spec</span> <span class="o">=</span> <span class="n">str_spec</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">isfile</span><span class="p">(</span><span class="n">i_file</span><span class="p">):</span>
                <span class="n">geometry</span> <span class="o">=</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">input_file</span><span class="p">)</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Cannot find file &#39;</span><span class="si">{</span><span class="n">input_file</span><span class="si">}</span><span class="s2">&#39;!&quot;</span><span class="p">)</span>
                <span class="n">geometry</span> <span class="o">=</span> <span class="n">Geometry</span>
                <span class="n">stdout_geom</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
        <span class="c1"># Do nothing, the geometry is already created</span>
        <span class="k">pass</span>

    <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
        <span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="c1"># Store the input file...</span>
        <span class="n">input_file</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">file</span>

    <span class="c1"># Do the argument parser</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="o">**</span><span class="n">geometry</span><span class="o">.</span><span class="n">_ArgumentParser_args_single</span><span class="p">())</span>

    <span class="c1"># Now the arguments should have been populated</span>
    <span class="c1"># and we will sort out if the input options</span>
    <span class="c1"># is only a help option.</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_input_file&quot;</span><span class="p">):</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="s2">&quot;_input_file&quot;</span><span class="p">,</span> <span class="n">input_file</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="c1"># Now try and figure out the actual arguments</span>
    <span class="n">p</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">argv</span> <span class="o">=</span> <span class="n">cmd</span><span class="o">.</span><span class="n">collect_arguments</span><span class="p">(</span>
        <span class="n">argv</span><span class="p">,</span> <span class="nb">input</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">argumentparser</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span>
    <span class="p">)</span>

    <span class="c1"># We are good to go!!!</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">p</span><span class="o">.</span><span class="n">parse_args</span><span class="p">(</span><span class="n">argv</span><span class="p">,</span> <span class="n">namespace</span><span class="o">=</span><span class="n">ns</span><span class="p">)</span>
    <span class="n">g</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">_geometry</span>

    <span class="k">if</span> <span class="n">stdout_geom</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">_stored_geometry</span><span class="p">:</span>
        <span class="c1"># We should write out the information to the stdout</span>
        <span class="c1"># This is merely for testing purposes and may not be used for anything.</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Cell:&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">{:10.6f}</span><span class="s2"> </span><span class="si">{:10.6f}</span><span class="s2"> </span><span class="si">{:10.6f}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Lattice:&quot;</span><span class="p">)</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  </span><span class="si">{:d}</span><span class="s2"> </span><span class="si">{:d}</span><span class="s2"> </span><span class="si">{:d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">nsc</span><span class="p">))</span>
        <span class="nb">print</span><span class="p">(</span><span class="s2">&quot; </span><span class="si">{:&gt;10s}</span><span class="s2"> </span><span class="si">{:&gt;10s}</span><span class="s2"> </span><span class="si">{:&gt;10s}</span><span class="s2">  </span><span class="si">{:&gt;3s}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot;x&quot;</span><span class="p">,</span> <span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;Z&quot;</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">g</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span>
                <span class="s2">&quot; </span><span class="si">{1:10.6f}</span><span class="s2"> </span><span class="si">{2:10.6f}</span><span class="s2"> </span><span class="si">{3:10.6f}</span><span class="s2">  </span><span class="si">{0:3d}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                    <span class="n">g</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="o">*</span><span class="n">g</span><span class="o">.</span><span class="n">xyz</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span>
                <span class="p">)</span>
            <span class="p">)</span>

    <span class="k">if</span> <span class="n">ret_geometry</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">g</span>
    <span class="k">return</span> <span class="mi">0</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>