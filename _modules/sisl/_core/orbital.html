

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl._core.orbital &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=e6894c64"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl._core.orbital</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl._core.orbital</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">namedtuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">partial</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">factorial</span> <span class="k">as</span> <span class="n">fact</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">pi</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">math</span><span class="w"> </span><span class="kn">import</span> <span class="n">sqrt</span> <span class="k">as</span> <span class="n">msqrt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">cos</span><span class="p">,</span> <span class="n">sin</span><span class="p">,</span> <span class="n">take</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.special</span><span class="w"> </span><span class="kn">import</span> <span class="n">eval_genlaguerre</span><span class="p">,</span> <span class="n">factorial</span><span class="p">,</span> <span class="n">lpmv</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">cumulative_trapezoid</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">scipy.integrate</span><span class="w"> </span><span class="kn">import</span> <span class="n">cumtrapz</span> <span class="k">as</span> <span class="n">cumulative_trapezoid</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.interpolate</span><span class="w"> </span><span class="kn">import</span> <span class="n">UnivariateSpline</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sisl._array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_a</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.constant</span><span class="w"> </span><span class="kn">import</span> <span class="n">a0</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.shape</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sphere</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.mathematics</span><span class="w"> </span><span class="kn">import</span> <span class="n">cart2spher</span><span class="p">,</span> <span class="n">close</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span>
    <span class="s2">&quot;Orbital&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SphericalOrbital&quot;</span><span class="p">,</span>
    <span class="s2">&quot;AtomicOrbital&quot;</span><span class="p">,</span>
    <span class="s2">&quot;HydrogenicOrbital&quot;</span><span class="p">,</span>
    <span class="s2">&quot;GTOrbital&quot;</span><span class="p">,</span>
    <span class="s2">&quot;STOrbital&quot;</span><span class="p">,</span>
    <span class="s2">&quot;radial_minimize_range&quot;</span><span class="p">,</span>
<span class="p">]</span>


<span class="c1"># Create the factor table for the real spherical harmonics</span>
<span class="k">def</span><span class="w"> </span><span class="nf">_rfact</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">):</span>
    <span class="n">pi4</span> <span class="o">=</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">pi</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">msqrt</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">pi4</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">msqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">pi4</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">))</span> <span class="o">*</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="n">m</span>
    <span class="k">return</span> <span class="n">msqrt</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">pi4</span> <span class="o">*</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span> <span class="o">-</span> <span class="n">m</span><span class="p">)</span> <span class="o">/</span> <span class="n">fact</span><span class="p">(</span><span class="n">l</span> <span class="o">+</span> <span class="n">m</span><span class="p">))</span>


<span class="c1"># This is a tuple of dicts</span>
<span class="c1">#  [0]{0} is l==0, m==0</span>
<span class="c1">#  [1]{-1} is l==1, m==-1</span>
<span class="c1">#  [1]{1} is l==1, m==1</span>
<span class="c1"># and so on.</span>
<span class="c1"># Calculate it up to l == 7 which is the j shell</span>
<span class="c1"># It will never be used, but in case somebody wishes to play with spherical harmonics</span>
<span class="c1"># then why not ;)</span>
<span class="n">_rspher_harm_fact</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">({</span><span class="n">m</span><span class="p">:</span> <span class="n">_rfact</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span> <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">l</span><span class="p">,</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)}</span> <span class="k">for</span> <span class="n">l</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">8</span><span class="p">))</span>
<span class="c1"># Clean-up</span>
<span class="k">del</span> <span class="n">_rfact</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_rspherical_harm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Calculates the real spherical harmonics using :math:`Y_l^m(\theta, \varphi)` with :math:`\mathbf r\to \{r, \theta, \varphi\}`.</span>

<span class="sd">    These real spherical harmonics are via these equations:</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y^m_l(\theta,\varphi) &amp;= -(-1)^m\sqrt{2\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">           P^{m}_l (\cos(\varphi)) \sin(m \theta) &amp; m &lt; 0\\</span>
<span class="sd">        Y^m_l(\theta,\varphi) &amp;= \sqrt{\frac{2l+1}{4\pi}} P^{m}_l (\cos(\varphi)) &amp; m = 0\\</span>
<span class="sd">        Y^m_l(\theta,\varphi) &amp;= \sqrt{2\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">           P^{m}_l (\cos(\varphi)) \cos(m \theta) &amp; m &gt; 0</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    m : int</span>
<span class="sd">       order of the spherical harmonics</span>
<span class="sd">    l : int</span>
<span class="sd">       degree of the spherical harmonics</span>
<span class="sd">    theta : array_like</span>
<span class="sd">       angle in :math:`xy` plane (azimuthal)</span>
<span class="sd">    cos_phi : array_like</span>
<span class="sd">       cos(phi) to angle from :math:`z` axis (polar)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Calculate the associated Legendre polynomial</span>
    <span class="c1"># Since the real spherical harmonics has slight differences</span>
    <span class="c1"># for positive and negative m, we have to implement them individually.</span>
    <span class="c1"># Currently this is a re-write of what Inelastica does and a combination of</span>
    <span class="c1"># learned lessons from Denchar.</span>
    <span class="c1"># As such the choice of these real spherical harmonics is that of Siesta.</span>
    <span class="k">if</span> <span class="n">m</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_rspher_harm_fact</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">m</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_rspher_harm_fact</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">sin</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">theta</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">_rspher_harm_fact</span><span class="p">[</span><span class="n">l</span><span class="p">][</span><span class="n">m</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">lpmv</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">)</span> <span class="o">*</span> <span class="n">cos</span><span class="p">(</span><span class="n">m</span> <span class="o">*</span> <span class="n">theta</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Orbital</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Base class for orbital information.</span>

<span class="sd">    The orbital class is still in an experimental stage and will probably evolve over some time.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    R :</span>
<span class="sd">        maximum radius of interaction.</span>
<span class="sd">        In case of a dict the values will be passed to the `radial_minimize_range`</span>
<span class="sd">        method.</span>
<span class="sd">        Currently allowed arguments are:</span>

<span class="sd">        - ``contains``: R will be selected such that the integrated function ``func``</span>
<span class="sd">            will contain this percentage of the full integral (determined at ``maxR``</span>
<span class="sd">        - ``maxR``: maximum R to search in, default to 100 Ang</span>
<span class="sd">        - ``func``: the function that will be integrated and checked for ``contains``</span>

<span class="sd">        See examples for details.</span>
<span class="sd">        If None the default will be ``{&#39;contains&#39;: 0.9999}``.</span>
<span class="sd">        If a negative number is passed, it will be converted to ``{&#39;contains&#39;:-R}``</span>
<span class="sd">        A dictionary will only make sense if the class has the ``_radial`` function</span>
<span class="sd">        associated.</span>
<span class="sd">    q0 :</span>
<span class="sd">        initial charge</span>
<span class="sd">    tag :</span>
<span class="sd">        user defined tag</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; orb = Orbital(1)</span>
<span class="sd">    &gt;&gt;&gt; orb_tag = Orbital(2, tag=&quot;range=2&quot;)</span>
<span class="sd">    &gt;&gt;&gt; orb.R == orb_tag.R / 2</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; orbq = Orbital(2, 1)</span>
<span class="sd">    &gt;&gt;&gt; orbq.q0</span>
<span class="sd">    1.</span>

<span class="sd">    Optimizing the R range for the radial function integral :math:`\int\mathrm dr radial(r)^2 r ^2`</span>
<span class="sd">    &gt;&gt;&gt; R = {</span>
<span class="sd">    ...    &quot;contains&quot;: 0.9999,</span>
<span class="sd">    ...    &quot;func&quot;: lambda radial, r: (radial(r) * r)**2,</span>
<span class="sd">    ...    &quot;maxR&quot;: 100</span>
<span class="sd">    ... }</span>
<span class="sd">    &gt;&gt;&gt; orb = Orbital(R)</span>

<span class="sd">    The default dictionary if none is passed will be:</span>
<span class="sd">    ``dict(contains=0.9999, func=lambda radial, r: abs(radial(r)), maxR=100)``</span>
<span class="sd">    The optimization problem depends heavily on the ``func`` since the tails are</span>
<span class="sd">    important for real-space quantities.</span>

<span class="sd">    See also</span>
<span class="sd">    --------</span>
<span class="sd">    SphericalOrbital : orbitals with a spherical basis set</span>
<span class="sd">    AtomicOrbital : specification of n, m, l quantum numbers + a spherical basis set</span>
<span class="sd">    HydrogenicOrbital : simplistic orbital model of Hydrogenic-like basis sets</span>
<span class="sd">    GTOrbital : Gaussian-type orbitals</span>
<span class="sd">    STOrbital : Slater-type orbitals</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_R&quot;</span><span class="p">,</span> <span class="s2">&quot;_tag&quot;</span><span class="p">,</span> <span class="s2">&quot;_q0&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">R</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]],</span> <span class="n">q0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize orbital object&quot;&quot;&quot;</span>
        <span class="c1"># Determine if the orbital has a radial function</span>
        <span class="c1"># In which case we can apply the radial discovery</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.9999</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_radial&quot;</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="k">pass</span>
            <span class="k">elif</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># change to a dict</span>
                <span class="n">R</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;contains&quot;</span><span class="p">:</span> <span class="o">-</span><span class="n">R</span><span class="p">}</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                <span class="n">R</span> <span class="o">=</span> <span class="n">radial_minimize_range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_radial</span><span class="p">,</span> <span class="o">**</span><span class="n">R</span><span class="p">)</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cannot optimize R without a radial function.&quot;</span>
            <span class="p">)</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">R</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;contains&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.9999</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_R</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">R</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_q0</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span> <span class="o">=</span> <span class="n">tag</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="bp">self</span><span class="o">.</span><span class="n">_R</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_q0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">R</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Maxmimum radius of orbital&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_R</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">q0</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initial charge&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_q0</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">tag</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Named tag of orbital&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_tag</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A string representation of the object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">R: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">R: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> R=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> R=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

<div class="viewcode-block" id="Orbital.name">
<a class="viewcode-back" href="../../../api/generated/sisl.Orbital.html#sisl.Orbital.name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a named specification of the orbital (`tag`)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span></div>


<div class="viewcode-block" id="Orbital.psi">
<a class="viewcode-back" href="../../../api/generated/sisl.Orbital.html#sisl.Orbital.psi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\phi(\mathbf r)` for Cartesian coordinates&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>


<div class="viewcode-block" id="Orbital.toSphere">
<a class="viewcode-back" href="../../../api/generated/sisl.Orbital.html#sisl.Orbital.toSphere">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">toSphere</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">center</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a sphere with radius equal to the orbital size</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        ~sisl.shape.Sphere</span>
<span class="sd">            sphere with a radius equal to the radius of this orbital</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">Sphere</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">center</span><span class="p">)</span></div>


<div class="viewcode-block" id="Orbital.equal">
<a class="viewcode-back" href="../../../api/generated/sisl.Orbital.html#sisl.Orbital.equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">psi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">radial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two orbitals by comparing their radius, and possibly the radial and psi functions</span>

<span class="sd">        When comparing two orbital radius they are considered *equal* with a precision of 1e-4 Ang.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Orbital</span>
<span class="sd">           comparison orbital</span>
<span class="sd">        psi :</span>
<span class="sd">           also compare that the full psi are the same</span>
<span class="sd">        radial :</span>
<span class="sd">           also compare that the radial parts are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># just check for the same name</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">other</span>

        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="n">same</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">tag</span>
        <span class="n">same</span> <span class="o">&amp;=</span> <span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
        <span class="n">same</span> <span class="o">&amp;=</span> <span class="n">close</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="p">,</span> <span class="n">other</span><span class="o">.</span><span class="n">q0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">same</span><span class="p">:</span>
            <span class="c1"># Quick return</span>
            <span class="k">return</span> <span class="kc">False</span>

        <span class="k">if</span> <span class="n">same</span> <span class="ow">and</span> <span class="n">radial</span><span class="p">:</span>
            <span class="c1"># Ensure they also have the same fill-values</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">500</span><span class="p">)</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">radial</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">same</span> <span class="ow">and</span> <span class="n">psi</span><span class="p">:</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">999</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">xyz</span><span class="p">),</span> <span class="n">other</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">xyz</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">same</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>

<div class="viewcode-block" id="Orbital.toGrid">
<a class="viewcode-back" href="../../../api/generated/sisl.Orbital.html#sisl.Orbital.toGrid">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">toGrid</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">precision</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">atom</span><span class="o">=</span><span class="mi">1</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a Grid with *only* this orbital wavefunction on it</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        precision : float, optional</span>
<span class="sd">           used separation in the `Grid` between voxels (in Ang)</span>
<span class="sd">        c : float or complex, optional</span>
<span class="sd">           coefficient for the orbital</span>
<span class="sd">        R : float, optional</span>
<span class="sd">            box size of the grid (default to the orbital range)</span>
<span class="sd">        dtype : numpy.dtype, optional</span>
<span class="sd">            the used separation in the `Grid` between voxels</span>
<span class="sd">        atom : optional</span>
<span class="sd">            atom associated with the grid; either an atom instance or</span>
<span class="sd">            something that ``Atom(atom)`` would convert to a proper atom.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">R</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span>
        <span class="k">if</span> <span class="n">R</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.toGrid was unable to create &quot;</span>
                <span class="s2">&quot;the orbital grid for plotting, the box size is negative.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Since all these things depend on other elements</span>
        <span class="c1"># we will simply import them here.</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics.electron</span><span class="w"> </span><span class="kn">import</span> <span class="n">wavefunction</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">.atom</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atom</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.geometry</span><span class="w"> </span><span class="kn">import</span> <span class="n">Geometry</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.grid</span><span class="w"> </span><span class="kn">import</span> <span class="n">Grid</span>
        <span class="kn">from</span><span class="w"> </span><span class="nn">.lattice</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lattice</span>

        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">R</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">origin</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="n">R</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">Atom</span><span class="p">):</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">atom</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="n">Atom</span><span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">([</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">)</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">(</span><span class="n">precision</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
        <span class="n">wavefunction</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">c</span><span class="p">),</span> <span class="n">G</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">g</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">G</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the state of this object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="s2">&quot;q0&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="p">,</span> <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-create the state of this object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">],</span> <span class="n">q0</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">])</span>


<span class="n">RadialFuncT</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span>


<span class="k">def</span><span class="w"> </span><span class="nf">radial_minimize_range</span><span class="p">(</span>
    <span class="n">radial_func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">RadialFuncT</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">],</span>
    <span class="n">contains</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
    <span class="n">dr</span><span class="p">:</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">0.01</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">),</span>
    <span class="n">maxR</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mi">100</span><span class="p">,</span>
    <span class="n">func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">RadialFuncT</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
<span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Minimize the maximum radius such that the integrated function `radial_func**2*r**3` contains `contains` of the integrand</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    radial_func : callable</span>
<span class="sd">       the function that returns the radial part</span>
<span class="sd">    contains : float</span>
<span class="sd">       how much of a percentage the squared function should contain @ R</span>
<span class="sd">    dr : tuple of float, optional</span>
<span class="sd">       the precision of the integral. First number is the coarse integral.</span>
<span class="sd">       The second number determines the fine-integral to exactly determine R between</span>
<span class="sd">       coarser points.</span>
<span class="sd">    maxR : float, optional</span>
<span class="sd">       maximally searched ``R``, in case there is no cross-over of the integrand</span>
<span class="sd">       containing `contains` in this range a ``-contains`` will be returned to</span>
<span class="sd">       signal it could not be found</span>
<span class="sd">    func : callable, optional</span>
<span class="sd">        function that is evaluated when doing the `contains` check.</span>
<span class="sd">        I.e. ``trapz(func(radial_func, r)) &gt;= contains``.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Determine the maximum R</span>
    <span class="c1"># We should never expect a radial components above</span>
    <span class="k">assert</span> <span class="n">maxR</span> <span class="o">&gt;</span> <span class="mf">0.05</span><span class="p">,</span> <span class="s2">&quot;maxR too small (&gt; 0.05)&quot;</span>
    <span class="k">assert</span> <span class="n">contains</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;contains too small (&gt; 0)&quot;</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">dr</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;number of sub-divisions is not 2: dr argument&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">func_base</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
        <span class="c1"># finding the best integral function for locating max</span>
        <span class="c1"># R is difficult.</span>
        <span class="c1"># For instance the exact integral of a radial function</span>
        <span class="c1"># is: (f(r) * r)**2</span>
        <span class="c1"># However, locating R that takes 99.99% of the integrand</span>
        <span class="c1"># tends to yield a too low R.</span>
        <span class="c1"># This is send by evaluating f(R) which tends to be 1% of</span>
        <span class="c1"># the maximum f(:). Hence when expanding individual points</span>
        <span class="c1"># in the real space grid one finds non-negligeble points</span>
        <span class="c1"># that are left out. Hence we cannot limit these integration</span>
        <span class="c1"># points.</span>
        <span class="c1"># Instead we use the absolute radial function to better capture</span>
        <span class="c1"># long tails.</span>
        <span class="c1"># Tried functions:</span>
        <span class="c1"># 1. f(r)  -&gt;  problematic when f turns negative</span>
        <span class="c1"># 2. f(r) ** 2 -&gt; yields somewhat short R</span>
        <span class="c1"># 3. f(r) * r -&gt; problematic when f turns negative</span>
        <span class="c1"># 4. (f(r) * r)**2 -&gt; yields too short R</span>
        <span class="c1"># 5. f(r)**2 * r**3 -&gt; much better</span>
        <span class="c1"># 6. abs(f(r)) -&gt; yields a pretty long tail, but should be fine</span>
        <span class="k">return</span> <span class="nb">abs</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">r</span><span class="p">))</span>

    <span class="k">if</span> <span class="n">func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">func</span> <span class="o">=</span> <span class="n">func_base</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">loc</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">integrand</span><span class="p">):</span>
        <span class="c1"># get index location of the boolean index where</span>
        <span class="c1"># all subsequent indices are also of the same type</span>
        <span class="c1"># first we find placements below the integrand, and</span>
        <span class="c1"># then only select ones above the max placement</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">intf</span> <span class="o">&lt;</span> <span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">idx</span> <span class="o">+</span> <span class="p">(</span><span class="n">intf</span><span class="p">[</span><span class="n">idx</span><span class="p">:]</span> <span class="o">&gt;=</span> <span class="n">integrand</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

    <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="n">maxR</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">radial_func</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
    <span class="n">intf</span> <span class="o">=</span> <span class="n">cumulative_trapezoid</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">integrand</span> <span class="o">=</span> <span class="n">intf</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">contains</span>

    <span class="c1"># we&#39;ll accept a containment of 99.99% of the integrand</span>
    <span class="n">loc</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">integrand</span><span class="p">)</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">loc</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">integrand</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>

        <span class="c1"># in the trapezoid integration each point is half contributed</span>
        <span class="c1"># to the previous point and half to the following point.</span>
        <span class="c1"># Here intf[idx-1] is the closed integral from 0:r[idx-1]</span>
        <span class="n">idxm_integrand</span> <span class="o">=</span> <span class="n">intf</span><span class="p">[</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Preset R</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">R</span> <span class="o">-</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">min</span><span class="p">(</span><span class="n">R</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">maxR</span><span class="p">)</span> <span class="o">+</span> <span class="n">dr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">dr</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">radial_func</span><span class="p">,</span> <span class="n">r</span><span class="p">)</span>
        <span class="n">intf</span> <span class="o">=</span> <span class="n">cumulative_trapezoid</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">dx</span><span class="o">=</span><span class="n">dr</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">initial</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="n">idxm_integrand</span>

        <span class="c1"># Find minimum R and focus around this point</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">loc</span><span class="p">(</span><span class="n">intf</span><span class="p">,</span> <span class="n">integrand</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">R</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="o">.</span><span class="n">min</span><span class="p">()]</span>
        <span class="k">return</span> <span class="n">R</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="n">radial_func</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="n">radial_func</span><span class="o">.</span><span class="vm">__name__</span>

    <span class="n">warn</span><span class="p">(</span>
        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2"> failed to detect a proper radius for integration purposes, retaining R=-</span><span class="si">{</span><span class="n">contains</span><span class="si">}</span><span class="s2">&quot;</span>
    <span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="n">contains</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_set_radial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update the internal radial function used as a :math:`f(|\mathbf r|)`</span>

<span class="sd">    This can be called in several ways:</span>

<span class="sd">          set_radial(r, f)</span>
<span class="sd">                which uses ``scipy.interpolate.UnivariateSpline(r, f, k=3, s=0, ext=1, check_finite=False)``</span>
<span class="sd">                to define the interpolation function (see `interp` keyword).</span>
<span class="sd">                Here the maximum radius of the orbital is the maximum `r` value,</span>
<span class="sd">                regardless of ``f(r)`` is zero for smaller `r`.</span>

<span class="sd">          set_radial(func)</span>
<span class="sd">                which sets the interpolation function directly.</span>
<span class="sd">                The maximum orbital range is determined automatically to a precision</span>
<span class="sd">                of 0.0001 AA.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    r, f : numpy.ndarray</span>
<span class="sd">        the radial positions and the radial function values at `r`.</span>
<span class="sd">    func : callable</span>
<span class="sd">        a function which enables evaluation of the radial function. The function should</span>
<span class="sd">        accept a single array and return a single array.</span>
<span class="sd">    interp : callable, optional</span>
<span class="sd">        When two non-keyword arguments are passed this keyword will be used.</span>
<span class="sd">        It is the interpolation function which should return the equivalent of</span>
<span class="sd">        `func`. By using this one can define a custom interpolation routine.</span>
<span class="sd">        It should accept two arguments, ``interp(r, f)`` and return a callable</span>
<span class="sd">        that returns interpolation values.</span>
<span class="sd">        See examples for different interpolation routines.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy import interpolate as interp</span>
<span class="sd">    &gt;&gt;&gt; o = SphericalOrbital(1, lambda x:x)</span>
<span class="sd">    &gt;&gt;&gt; r = np.linspace(0, 4, 300)</span>
<span class="sd">    &gt;&gt;&gt; f = np.exp(-r)</span>
<span class="sd">    &gt;&gt;&gt; def i_univariate(r, f):</span>
<span class="sd">        ...    return interp.UnivariateSpline(r, f, k=3, s=0, ext=1, check_finite=False)</span>
<span class="sd">    &gt;&gt;&gt; def i_interp1d(r, f):</span>
<span class="sd">        ...    return interp.interp1d(r, f, kind=&quot;cubic&quot;, fill_value=(f[0], 0.), bounds_error=False)</span>
<span class="sd">    &gt;&gt;&gt; def i_spline(r, f):</span>
<span class="sd">        ...    from functools import partial</span>
<span class="sd">    ...    tck = interp.splrep(r, f, k=3, s=0)</span>
<span class="sd">    ...    return partial(interp.splev, tck=tck, der=0, ext=1)</span>
<span class="sd">    &gt;&gt;&gt; R = np.linspace(0, 4, 400)</span>
<span class="sd">    &gt;&gt;&gt; o.set_radial(r, f, interp=i_univariate)</span>
<span class="sd">    &gt;&gt;&gt; f_univariate = o.radial(R)</span>
<span class="sd">    &gt;&gt;&gt; o.set_radial(r, f, interp=i_interp1d)</span>
<span class="sd">    &gt;&gt;&gt; f_interp1d = o.radial(R)</span>
<span class="sd">    &gt;&gt;&gt; o.set_radial(r, f, interp=i_spline)</span>
<span class="sd">    &gt;&gt;&gt; f_spline = o.radial(R)</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(f_univariate, f_interp1d)</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; np.allclose(f_univariate, f_spline)</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">f0</span><span class="p">(</span><span class="n">r</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Wrapper for returning 0s&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_radial</span> <span class="o">=</span> <span class="n">f0</span>
        <span class="c1"># we cannot set R since it will always give the largest distance</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="nb">callable</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radial</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
        <span class="c1"># A radial and function component has been passed</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="c1"># Sort r and f</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">r</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">f</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># k = 3 == cubic spline</span>
        <span class="c1"># ext = 1 == return zero outside of bounds.</span>
        <span class="c1"># s, smoothing factor. If 0, smooth through all points</span>
        <span class="c1"># I can see that this function is *much* faster than</span>
        <span class="c1"># interp1d, AND it yields same results with these arguments.</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">partial</span><span class="p">(</span><span class="n">UnivariateSpline</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ext</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">check_finite</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">interp</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;interp&quot;</span><span class="p">,</span> <span class="n">interp</span><span class="p">)(</span><span class="n">r</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>

        <span class="c1"># this will defer the actual R designation (whether it should be set or not)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radial</span> <span class="o">=</span> <span class="n">interp</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.set_radial could not determine the arguments, please correct.&quot;</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_radial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the radial part of spherical orbital :math:`R(\mathbf r)`</span>

<span class="sd">    The position `r` is a vector from the origin of this orbital.</span>

<span class="sd">    Parameters</span>
<span class="sd">    -----------</span>
<span class="sd">    r : array_like</span>
<span class="sd">       radius from the orbital origin</span>
<span class="sd">    *args :</span>
<span class="sd">       arguments passed to the radial function</span>
<span class="sd">    **args :</span>
<span class="sd">       keyword arguments passed to the radial function</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    numpy.ndarray</span>
<span class="sd">        radial orbital value at point `r`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
    <span class="n">p</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Only calculate where it makes sense, all other points are removed and set to zero</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>

    <span class="c1"># Reduce memory immediately</span>
    <span class="n">r</span> <span class="o">=</span> <span class="n">take</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">idx</span><span class="p">)</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">p</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radial</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">p</span>


<span class="n">RadialFuncType</span> <span class="o">=</span> <span class="n">Union</span><span class="p">[</span>
    <span class="nb">tuple</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">,</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">],</span> <span class="n">npt</span><span class="o">.</span><span class="n">NDArray</span><span class="p">]</span>
<span class="p">]</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SphericalOrbital</span><span class="p">(</span><span class="n">Orbital</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;An *arbitrary* orbital class which only contains the harmonical part of the wavefunction  where :math:`\phi(\mathbf r)=f(|\mathbf r|)Y_l^m(\theta,\varphi)`</span>

<span class="sd">    Note that in this case the used spherical harmonics is:</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y^m_l(\theta,\varphi) = (-1)^m\sqrt{\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">             e^{i m \theta} P^m_l(\cos(\varphi))</span>

<span class="sd">    The resulting orbital is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \phi_{lmn}(\mathbf r) = f(|\mathbf r|) Y^m_l(\theta, \varphi)</span>

<span class="sd">    where typically :math:`f(|\mathbf r|)\equiv\phi_{ln}(|\mathbf r|)`. The above equation</span>
<span class="sd">    clarifies that this class is only intended for each :math:`l`, and that subsequent</span>
<span class="sd">    :math:`m` orders may be extracted by altering the spherical harmonic. Also, the quantum</span>
<span class="sd">    number :math:`n` is not necessary as that value is implicit in the</span>
<span class="sd">    :math:`\phi_{ln}(|\mathbf r|)` function.</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    l :</span>
<span class="sd">       azimuthal quantum number</span>
<span class="sd">    rf_or_func :</span>
<span class="sd">       radial components as a tuple/list, or the function which can interpolate to any R</span>
<span class="sd">       See `set_radial` for details.</span>
<span class="sd">    R :</span>
<span class="sd">       See `Orbital` for details.</span>
<span class="sd">    q0 :</span>
<span class="sd">       initial charge</span>
<span class="sd">    tag :</span>
<span class="sd">       user defined tag</span>
<span class="sd">    **kwargs:</span>
<span class="sd">       arguments passed directly to ``set_radial(rf_or_func, **kwargs)``</span>

<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    f : func</span>
<span class="sd">        interpolation function that returns `f(r)` for a given radius</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; from scipy.interpolate import interp1d</span>
<span class="sd">    &gt;&gt;&gt; orb = SphericalOrbital(1, (np.arange(10.), np.arange(10.)))</span>
<span class="sd">    &gt;&gt;&gt; orb.equal(SphericalOrbital(1, interp1d(np.arange(10.), np.arange(10.),</span>
<span class="sd">    ...       fill_value=(0., 0.), kind=&quot;cubic&quot;, bounds_error=False)))</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># Additional slots (inherited classes retain the same slots)</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_l&quot;</span><span class="p">,</span> <span class="s2">&quot;_radial&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">rf_or_func</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">RadialFuncType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">q0</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">tag</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize spherical orbital object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l</span> <span class="o">=</span> <span class="n">l</span>

        <span class="c1"># Set the internal function</span>
        <span class="k">if</span> <span class="n">rf_or_func</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">elif</span> <span class="nb">callable</span><span class="p">(</span><span class="n">rf_or_func</span><span class="p">):</span>
            <span class="n">args</span> <span class="o">=</span> <span class="p">[</span><span class="n">rf_or_func</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">args</span> <span class="o">=</span> <span class="n">rf_or_func</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">set_radial</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># ensure we pass an R value (default None)</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>

        <span class="c1"># Initialize R and tag through the parent</span>
        <span class="c1"># Note that the maximum range of the orbital will be the</span>
        <span class="c1"># maximum value in r.</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`l` quantum number&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">((</span><span class="nb">super</span><span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radial</span><span class="p">))</span>

    <span class="n">set_radial</span> <span class="o">=</span> <span class="n">_set_radial</span>
    <span class="n">radial</span> <span class="o">=</span> <span class="n">_radial</span>

<div class="viewcode-block" id="SphericalOrbital.spher">
<a class="viewcode-back" href="../../../api/generated/sisl.SphericalOrbital.html#sisl.SphericalOrbital.spher">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the spherical harmonics of this orbital at a given point (in spherical coordinates)</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        theta : array_like</span>
<span class="sd">            azimuthal angle in the :math:`xy` plane (from :math:`x`)</span>
<span class="sd">        phi : array_like</span>
<span class="sd">            polar angle from :math:`z` axis</span>
<span class="sd">        m :</span>
<span class="sd">            magnetic quantum number, must be in range ``-self.l &lt;= m &lt;= self.l``</span>
<span class="sd">        cos_phi :</span>
<span class="sd">            whether `phi` is actually :math:`cos(\phi)` which will be faster because</span>
<span class="sd">            `cos` is not necessary to call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">           spherical harmonics at angles :math:`\theta` and :math:`\phi` and given quantum number `m`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cos_phi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_rspherical_harm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_rspherical_harm</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span></div>


<div class="viewcode-block" id="SphericalOrbital.psi">
<a class="viewcode-back" href="../../../api/generated/sisl.SphericalOrbital.html#sisl.SphericalOrbital.psi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\phi(\mathbf r)` at a given point (or more points)</span>

<span class="sd">        The position `r` is a vector from the origin of this orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r : array_like of (:, 3)</span>
<span class="sd">           vector from the orbital origin</span>
<span class="sd">        m :</span>
<span class="sd">           magnetic quantum number, must be in range ``-self.l &lt;= m &lt;= self.l``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            basis function value at point `r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Convert to spherical coordinates</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2spher</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cos_phi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxR</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_spher</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">cos_phi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Reduce memory immediately</span>
            <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span>
        <span class="n">p</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">p</span></div>


<div class="viewcode-block" id="SphericalOrbital.psi_spher">
<a class="viewcode-back" href="../../../api/generated/sisl.SphericalOrbital.html#sisl.SphericalOrbital.psi_spher">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">psi_spher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\phi(|\mathbf r|, \theta, \phi)` at a given point (in spherical coordinates)</span>

<span class="sd">        This is equivalent to `psi` however, the input is given in spherical coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r : array_like</span>
<span class="sd">           the radius from the orbital origin</span>
<span class="sd">        theta : array_like</span>
<span class="sd">           azimuthal angle in the :math:`xy` plane (from :math:`x`)</span>
<span class="sd">        phi : array_like</span>
<span class="sd">           polar angle from :math:`z` axis</span>
<span class="sd">        m :</span>
<span class="sd">           magnetic quantum number, must be in range ``-self.l &lt;= m &lt;= self.l``</span>
<span class="sd">        cos_phi :</span>
<span class="sd">           whether `phi` is actually :math:`cos(\phi)` which will be faster because</span>
<span class="sd">           `cos` is not necessary to call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            basis function value at point `r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spher</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">)</span></div>


<div class="viewcode-block" id="SphericalOrbital.equal">
<a class="viewcode-back" href="../../../api/generated/sisl.SphericalOrbital.html#sisl.SphericalOrbital.equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">psi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">radial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two orbitals by comparing their radius, and possibly the radial and psi functions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Orbital</span>
<span class="sd">           comparison orbital</span>
<span class="sd">        psi : bool, optional</span>
<span class="sd">           also compare that the full psi are the same</span>
<span class="sd">        radial : bool, optional</span>
<span class="sd">           also compare that the radial parts are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">same</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">radial</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">same</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">SphericalOrbital</span><span class="p">):</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">l</span>
        <span class="k">return</span> <span class="n">same</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A string representation of the object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">l: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, R: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">l: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, R: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> l=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, R=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> l=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, R=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

<div class="viewcode-block" id="SphericalOrbital.toAtomicOrbital">
<a class="viewcode-back" href="../../../api/generated/sisl.SphericalOrbital.html#sisl.SphericalOrbital.toAtomicOrbital">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">toAtomicOrbital</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">m</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">zeta</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">P</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">q0</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a list of `AtomicOrbital` objects</span>

<span class="sd">        This defaults to create a list of `AtomicOrbital` objects for every `m` (for m in -l:l).</span>
<span class="sd">        One may optionally specify the sub-set of `m` to retrieve.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        m : int or list or None</span>
<span class="sd">           if ``None`` it defaults to ``-l:l``, else only for the requested `m`</span>
<span class="sd">        zeta :</span>
<span class="sd">           the specified :math:`\zeta`-shell</span>
<span class="sd">        n :</span>
<span class="sd">           specify the :math:`n` quantum number</span>
<span class="sd">        P :</span>
<span class="sd">           whether the orbitals are polarized.</span>
<span class="sd">        q0 :</span>
<span class="sd">           the initial charge per orbital, initially :math:`q_0 / (2l+1)` with :math:`q_0` from this object</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        AtomicOrbital : for passed `m` an atomic orbital will be returned</span>
<span class="sd">        list of AtomicOrbital : for each :math:`m\in[-l;l]` an atomic orbital will be returned in the list</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Initial charge</span>
        <span class="k">if</span> <span class="n">q0</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">q0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">q0</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">AtomicOrbital</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">spherical</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="p">[</span>
            <span class="n">AtomicOrbital</span><span class="p">(</span>
                <span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">mm</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span> <span class="n">P</span><span class="o">=</span><span class="n">P</span><span class="p">,</span> <span class="n">spherical</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">mm</span> <span class="ow">in</span> <span class="n">m</span>
        <span class="p">]</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the state of this object&quot;&quot;&quot;</span>
        <span class="c1"># A function is not necessarily pickable, so we store interpolated</span>
        <span class="c1"># data which *should* ensure the correct pickable state (to close agreement)</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;l&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;q0&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="p">,</span> <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-create the state of this object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;l&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]),</span> <span class="n">q0</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">])</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">AtomicOrbital</span><span class="p">(</span><span class="n">Orbital</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; A projected atomic orbital consisting of real harmonics</span>

<span class="sd">    The `AtomicOrbital` is a specification of the `SphericalOrbital` by</span>
<span class="sd">    assigning the magnetic quantum number :math:`m` to the object.</span>

<span class="sd">    `AtomicOrbital` should always be preferred over the</span>
<span class="sd">    `SphericalOrbital` because it explicitly contains *all* quantum numbers.</span>

<span class="sd">    The atomic orbital has a radial part defined by an external function; this</span>
<span class="sd">    is then expanded using spherical harmonics</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y^m_l(\theta,\varphi) &amp;= (-1)^m\sqrt{\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">             e^{i m \theta} P^m_l(\cos(\varphi))</span>
<span class="sd">        \\</span>
<span class="sd">                \phi_{lmn}(\mathbf r) &amp;= R(|\mathbf r|) Y^m_l(\theta, \varphi)</span>

<span class="sd">    where the function :math:`R(|\mathbf r|)` is user-defined.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    *args : list of arguments</span>
<span class="sd">        list of arguments can be in different input options</span>
<span class="sd">    R :</span>
<span class="sd">       See `Orbital` for details.</span>
<span class="sd">    q0 :</span>
<span class="sd">        initial charge</span>
<span class="sd">    tag :</span>
<span class="sd">        user defined tag</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; r = np.linspace(0, 5, 50)</span>
<span class="sd">    &gt;&gt;&gt; f = np.exp(-r)</span>
<span class="sd">    &gt;&gt;&gt; #                    n, l, m, [zeta, [P]]</span>
<span class="sd">    &gt;&gt;&gt; orb1 = AtomicOrbital(2, 1, 0, 1, (r, f))</span>
<span class="sd">    &gt;&gt;&gt; orb2 = AtomicOrbital(n=2, l=1, m=0, zeta=1, (r, f))</span>
<span class="sd">    &gt;&gt;&gt; orb3 = AtomicOrbital(&quot;2pzZ&quot;, (r, f))</span>
<span class="sd">    &gt;&gt;&gt; orb4 = AtomicOrbital(&quot;2pzZ1&quot;, (r, f))</span>
<span class="sd">    &gt;&gt;&gt; orb5 = AtomicOrbital(&quot;pz&quot;, (r, f))</span>
<span class="sd">    &gt;&gt;&gt; orb2 == orb3</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; orb2 == orb4</span>
<span class="sd">    True</span>
<span class="sd">    &gt;&gt;&gt; orb2 == orb5</span>
<span class="sd">    True</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># All of these follow standard notation:</span>
    <span class="c1">#   n = principal quantum number</span>
    <span class="c1">#   l = azimuthal quantum number</span>
    <span class="c1">#   m = magnetic quantum number</span>
    <span class="c1">#   Z = zeta shell</span>
    <span class="c1">#   P = polarization shell or not</span>
    <span class="c1"># orb is the SphericalOrbital class that retains the radial</span>
    <span class="c1"># grid and enables to calculate psi(r)</span>
    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_n&quot;</span><span class="p">,</span> <span class="s2">&quot;_l&quot;</span><span class="p">,</span> <span class="s2">&quot;_m&quot;</span><span class="p">,</span> <span class="s2">&quot;_zeta&quot;</span><span class="p">,</span> <span class="s2">&quot;_P&quot;</span><span class="p">,</span> <span class="s2">&quot;_orb&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Initialize atomic orbital object&quot;&quot;&quot;</span>

        <span class="c1"># Ensure args is a list (to be able to pop)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Extract shell information</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;zeta&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">P</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">str</span><span class="p">):</span>
                <span class="c1"># String specification of the atomic orbital</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="n">_n</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="mi">5</span><span class="p">}</span>
                <span class="n">_l</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;p&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span> <span class="s2">&quot;d&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span> <span class="s2">&quot;g&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">}</span>
                <span class="n">_m</span> <span class="o">=</span> <span class="p">{</span>
                    <span class="s2">&quot;s&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;pz&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;px&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;py&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;dxy&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;dyz&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;dz2&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;dxz&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;dx2-y2&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;fy(3x2-y2)&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
                    <span class="s2">&quot;fxyz&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;fz2y&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;fyz2&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;fz3&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;fz2x&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;fxz2&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;fz(x2-y2)&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;fx(x2-3y2)&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                    <span class="s2">&quot;gxy(x2-y2)&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>
                    <span class="s2">&quot;gyx(x2-y2)&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">4</span><span class="p">,</span>
                    <span class="s2">&quot;gzy(3x2-y2)&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
                    <span class="s2">&quot;gyz(3x2-y2)&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span>
                    <span class="s2">&quot;gz2xy&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;gxyz2&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;gyxz2&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;gz3y&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;gyz3&quot;</span><span class="p">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;gz4&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span>
                    <span class="s2">&quot;gz3x&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;gxz3&quot;</span><span class="p">:</span> <span class="mi">1</span><span class="p">,</span>
                    <span class="s2">&quot;gz2(x2-y2)&quot;</span><span class="p">:</span> <span class="mi">2</span><span class="p">,</span>
                    <span class="s2">&quot;gzx(x2-3y2)&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                    <span class="s2">&quot;gxz(x2-3y2)&quot;</span><span class="p">:</span> <span class="mi">3</span><span class="p">,</span>
                    <span class="s2">&quot;gx4+y4&quot;</span><span class="p">:</span> <span class="mi">4</span><span class="p">,</span>
                <span class="p">}</span>

                <span class="c1"># First remove a P for polarization</span>
                <span class="n">P</span> <span class="o">=</span> <span class="s2">&quot;P&quot;</span> <span class="ow">in</span> <span class="n">s</span>
                <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;P&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

                <span class="c1"># Try and figure out the input</span>
                <span class="c1">#   2s =&gt; n=2, l=0, m=0, z=1, P=False</span>
                <span class="c1">#   2sZ2P =&gt; n=2, l=0, m=0, z=2, P=True</span>
                <span class="c1">#   2pxZ2P =&gt; n=2, l=0, m=0, z=2, P=True</span>
                <span class="c1"># By default a non-&quot;n&quot; specification takes the lowest value allowed</span>
                <span class="c1">#    s =&gt; n=1</span>
                <span class="c1">#    p =&gt; n=2</span>
                <span class="c1">#    ...</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="c1"># Remove n specification</span>
                    <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">_n</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">n</span><span class="p">)</span>

                <span class="c1"># Get l</span>
                <span class="n">l</span> <span class="o">=</span> <span class="n">_l</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">l</span><span class="p">)</span>

                <span class="c1"># Get number of zeta shell</span>
                <span class="n">iZ</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="s2">&quot;Z&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">iZ</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># Currently we know that we are limited to 9 zeta shells.</span>
                    <span class="c1"># However, for now we assume this is enough (could easily</span>
                    <span class="c1"># be extended by a reg-exp)</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">zeta</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">iZ</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
                        <span class="c1"># Remove Z + int</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">iZ</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">iZ</span> <span class="o">+</span> <span class="mi">2</span> <span class="p">:]</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="n">zeta</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="p">[:</span><span class="n">iZ</span><span class="p">]</span> <span class="o">+</span> <span class="n">s</span><span class="p">[</span><span class="n">iZ</span> <span class="o">+</span> <span class="mi">1</span> <span class="p">:]</span>

                <span class="c1"># We should be left with m specification</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">_m</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Arguments *have* to be</span>
                <span class="c1"># n, l, [m (only for l&gt;0)] [, zeta [, P]]</span>
                <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">l</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                <span class="c1"># Now we need to figure out if they are shell</span>
                <span class="c1"># information or radial functions</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Integral</span><span class="p">):</span>
                        <span class="n">zeta</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">bool</span><span class="p">):</span>
                        <span class="n">P</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> l is not defined&quot;</span><span class="p">)</span>

        <span class="c1"># Still if n is None, we assign the default (lowest) quantum number</span>
        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Still if m is None, we assign the default value of 0</span>
        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Copy over information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l</span> <span class="o">=</span> <span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_zeta</span> <span class="o">=</span> <span class="n">zeta</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_P</span> <span class="o">=</span> <span class="n">P</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> n must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">zeta</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> zeta must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_rspher_harm_fact</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not implement shells l&gt;=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">_rspher_harm_fact</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires |m| &lt;= l.&quot;</span><span class="p">)</span>

        <span class="c1"># Now we should figure out how the spherical orbital</span>
        <span class="c1"># has been passed.</span>
        <span class="c1"># There are two options:</span>
        <span class="c1">#  1. The radial function is passed as two arrays: r, f</span>
        <span class="c1">#  2. The SphericalOrbital-class is passed which already contains</span>
        <span class="c1">#     the relevant information.</span>
        <span class="c1"># Figure out if it is a sphericalorbital</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">if</span> <span class="s2">&quot;spherical&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> multiple values for the spherical &quot;</span>
                    <span class="s2">&quot;orbital is present, 1) argument, 2) spherical=. Only supply one of them.&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># in case the class has its own radial implementation, we might as well rely on that one</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;spherical&quot;</span><span class="p">,</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_radial&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

        <span class="c1"># Get the radius requested</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">)</span>
        <span class="n">q0</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;q0&quot;</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">s</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">Orbital</span><span class="p">(</span><span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Determine the correct R if requested a sub-set</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span> <span class="o">=</span> <span class="n">SphericalOrbital</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">,</span> <span class="n">SphericalOrbital</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">l</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> got a spherical argument with l=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2"> which is different from this objects l=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="n">q0</span><span class="o">=</span><span class="n">q0</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;tag&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="nb">super</span><span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_l</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_n</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_m</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_zeta</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_P</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`n` shell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`l` quantum number&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`m` quantum number&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">zeta</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`\zeta` shell&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_zeta</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">P</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Whether this is polarized shell or not&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_P</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orb</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Orbital with radial part&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_orb</span>

<div class="viewcode-block" id="AtomicOrbital.equal">
<a class="viewcode-back" href="../../../api/generated/sisl.AtomicOrbital.html#sisl.AtomicOrbital.equal">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">psi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">radial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Compare two orbitals by comparing their radius, and possibly the radial and psi functions</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        other : Orbital</span>
<span class="sd">           comparison orbital</span>
<span class="sd">        psi :</span>
<span class="sd">           also compare that the full psi are the same</span>
<span class="sd">        radial :</span>
<span class="sd">           also compare that the radial parts are the same</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">AtomicOrbital</span><span class="p">):</span>
            <span class="n">same</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="o">.</span><span class="n">orb</span><span class="p">,</span> <span class="n">psi</span><span class="p">,</span> <span class="n">radial</span><span class="p">)</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">n</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">l</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">m</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">zeta</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">zeta</span>
            <span class="n">same</span> <span class="o">&amp;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span> <span class="o">==</span> <span class="n">other</span><span class="o">.</span><span class="n">P</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">other</span><span class="p">,</span> <span class="n">Orbital</span><span class="p">):</span>
            <span class="n">same</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="o">.</span><span class="n">equal</span><span class="p">(</span><span class="n">other</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">same</span></div>


<div class="viewcode-block" id="AtomicOrbital.name">
<a class="viewcode-back" href="../../../api/generated/sisl.AtomicOrbital.html#sisl.AtomicOrbital.name">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tex</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return named specification of the atomic orbital&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tex</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;spdfghij&quot;</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">])</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;_y&quot;</span><span class="p">,</span> <span class="s2">&quot;_z&quot;</span><span class="p">,</span> <span class="s2">&quot;_x&quot;</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;_</span><span class="si">{xy}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{yz}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;_{z^2}&quot;</span><span class="p">,</span> <span class="s2">&quot;_</span><span class="si">{xz}</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;_{x^2-y^2}&quot;</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="s2">&quot;_{y(3x^2-y^2)}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_</span><span class="si">{xyz}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^2y}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^3}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^2x}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z(x^2-y^2)}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{x(x^2-3y^2)}&quot;</span><span class="p">,</span>
                <span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">3</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span>
                    <span class="s2">&quot;_{_{xy(x^2-y^2)}}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{zy(3x^2-y^2)}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^2xy}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^3y}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^4}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^3x}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{z^2(x^2-y^2)}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{zx(x^2-3y^2)}&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;_{x^4+y^4}&quot;</span><span class="p">,</span>
                <span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
                <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">_</span><span class="se">{{</span><span class="s2">m=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}</span><span class="se">}}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;\zeta^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="si">}</span><span class="s2">\mathrm</span><span class="se">{{</span><span class="s2">P</span><span class="se">}}</span><span class="s2">&quot;</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="sa">rf</span><span class="s2">&quot;\zeta^</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">{}{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="s2">&quot;spdfghij&quot;</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;y&quot;</span><span class="p">,</span> <span class="s2">&quot;z&quot;</span><span class="p">,</span> <span class="s2">&quot;x&quot;</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;xy&quot;</span><span class="p">,</span> <span class="s2">&quot;yz&quot;</span><span class="p">,</span> <span class="s2">&quot;z2&quot;</span><span class="p">,</span> <span class="s2">&quot;xz&quot;</span><span class="p">,</span> <span class="s2">&quot;x2-y2&quot;</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">2</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;y(3x2-y2)&quot;</span><span class="p">,</span> <span class="s2">&quot;xyz&quot;</span><span class="p">,</span> <span class="s2">&quot;z2y&quot;</span><span class="p">,</span> <span class="s2">&quot;z3&quot;</span><span class="p">,</span> <span class="s2">&quot;z2x&quot;</span><span class="p">,</span> <span class="s2">&quot;z(x2-y2)&quot;</span><span class="p">,</span> <span class="s2">&quot;x(x2-3y2)&quot;</span><span class="p">)[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">3</span>
            <span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">4</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">+=</span> <span class="p">(</span>
                <span class="s2">&quot;xy(x2-y2)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;zy(3x2-y2)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;z2xy&quot;</span><span class="p">,</span>
                <span class="s2">&quot;z3y&quot;</span><span class="p">,</span>
                <span class="s2">&quot;z4&quot;</span><span class="p">,</span>
                <span class="s2">&quot;z3x&quot;</span><span class="p">,</span>
                <span class="s2">&quot;z2(x2-y2)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;zx(x2-3y2)&quot;</span><span class="p">,</span>
                <span class="s2">&quot;x4+y4&quot;</span><span class="p">,</span>
            <span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">+</span> <span class="mi">4</span><span class="p">]</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="mi">5</span><span class="p">:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">(m=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}</span><span class="s2">)&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">P</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Z</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="si">}</span><span class="s2">P&quot;</span>
        <span class="k">return</span> <span class="n">name</span> <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;Z</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">zeta</span><span class="si">}</span><span class="s2">&quot;</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A string representation of the object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="si">!s}</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="si">!s}</span><span class="se">}}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">()</span><span class="si">}</span><span class="s2"> q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="p">)</span>

<div class="viewcode-block" id="AtomicOrbital.set_radial">
<a class="viewcode-back" href="../../../api/generated/sisl.AtomicOrbital.html#sisl.AtomicOrbital.set_radial">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_radial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Update the internal radial function used as a :math:`f(|\mathbf r|)`</span>

<span class="sd">        See `SphericalOrbital.set_radial` where these arguments are passed to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="o">.</span><span class="n">set_radial</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="AtomicOrbital.radial">
<a class="viewcode-back" href="../../../api/generated/sisl.AtomicOrbital.html#sisl.AtomicOrbital.radial">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">radial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the radial part of the wavefunction :math:`f(\mathbf r)`</span>

<span class="sd">        The position `r` is a vector from the origin of this orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r : array_like</span>
<span class="sd">           radius from the orbital origin</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            radial orbital value at point `r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="o">.</span><span class="n">radial</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="AtomicOrbital.psi">
<a class="viewcode-back" href="../../../api/generated/sisl.AtomicOrbital.html#sisl.AtomicOrbital.psi">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\phi(\mathbf r)` at a given point (or more points)</span>

<span class="sd">        The position `r` is a vector from the origin of this orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r : array_like</span>
<span class="sd">           the vector from the orbital origin</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">             basis function value at point `r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="o">.</span><span class="n">psi</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span></div>


<div class="viewcode-block" id="AtomicOrbital.spher">
<a class="viewcode-back" href="../../../api/generated/sisl.AtomicOrbital.html#sisl.AtomicOrbital.spher">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">spher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the spherical harmonics of this orbital at a given point (in spherical coordinates)</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        theta : array_like</span>
<span class="sd">           azimuthal angle in the :math:`xy` plane (from :math:`x`)</span>
<span class="sd">        phi : array_like</span>
<span class="sd">           polar angle from :math:`z` axis</span>
<span class="sd">        cos_phi :</span>
<span class="sd">           whether `phi` is actually :math:`cos(\phi)` which will be faster because</span>
<span class="sd">           `cos` is not necessary to call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            spherical harmonics at angles :math:`\theta` and :math:`\phi`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="o">.</span><span class="n">spher</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">)</span></div>


<div class="viewcode-block" id="AtomicOrbital.psi_spher">
<a class="viewcode-back" href="../../../api/generated/sisl.AtomicOrbital.html#sisl.AtomicOrbital.psi_spher">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">psi_spher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\phi(|\mathbf r|, \theta, \phi)` at a given point (in spherical coordinates)</span>

<span class="sd">        This is equivalent to `psi` however, the input is given in spherical coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r : array_like</span>
<span class="sd">           the radius from the orbital origin</span>
<span class="sd">        theta : array_like</span>
<span class="sd">           azimuthal angle in the :math:`xy` plane (from :math:`x`)</span>
<span class="sd">        phi : array_like</span>
<span class="sd">           polar angle from :math:`z` axis</span>
<span class="sd">        cos_phi :</span>
<span class="sd">           whether `phi` is actually :math:`cos(\phi)` which will be faster because</span>
<span class="sd">           `cos` is not necessary to call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">             basis function value at point `r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orb</span><span class="o">.</span><span class="n">psi_spher</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the state of this object&quot;&quot;&quot;</span>
        <span class="c1"># A function is not necessarily pickable, so we store interpolated</span>
        <span class="c1"># data which *should* ensure the correct pickable state (to close agreement)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># this will tricker the AttributeError</span>
            <span class="c1"># before we create the data-array</span>
            <span class="n">r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span> <span class="mi">1000</span><span class="p">)</span>
            <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">r</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;name&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">(),</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span> <span class="n">r</span><span class="p">,</span> <span class="s2">&quot;f&quot;</span><span class="p">:</span> <span class="n">f</span><span class="p">,</span> <span class="s2">&quot;q0&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="p">,</span> <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-create the state of this object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="n">q0</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">])</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;name&quot;</span><span class="p">],</span> <span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;r&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;f&quot;</span><span class="p">]),</span> <span class="n">q0</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">])</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">HydrogenicOrbital</span><span class="p">(</span><span class="n">AtomicOrbital</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; A hydrogen-like atomic orbital defined by an effective atomic number Z in addition to the usual quantum numbers (n, l, m).</span>

<span class="sd">    A hydrogenic atom (Hydrogen-like) is an atom with a single valence electron.</span>

<span class="sd">    The returned orbital is properly normalized, see [HydrogenicO]_ for details.</span>

<span class="sd">    The orbital has the familiar spherical shape</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y^m_l(\theta,\varphi) &amp;= (-1)^m\sqrt{\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">             e^{i m \theta} P^m_l(\cos(\varphi))</span>
<span class="sd">        \\</span>
<span class="sd">        \phi_{lmn}(\mathbf r) &amp;= R_{nl}(|\mathbf r|) Y^m_l(\theta, \varphi)</span>
<span class="sd">        \\</span>
<span class="sd">        R_{nl}(|\mathbf r|) &amp;= -\sqrt{\big(\frac{2Z}{na_0}\big)^3 \frac{(n-l-1)!}{2n(n+l)!}}</span>
<span class="sd">           e^{-Zr/(na_0)} \big( \frac{2Zr}{na_0} \big)^l L_{n-l-1}^{(2l+1)}</span>
<span class="sd">           \big( \frac{2Zr}{na_0} \big)</span>

<span class="sd">    With :math:`L_{n-l-1}^{(2l+1)}` is the generalized Laguerre polynomials.</span>


<span class="sd">    References</span>
<span class="sd">    ----------</span>
<span class="sd">    .. [HydrogenicO] https://en.wikipedia.org/wiki/Hydrogen-like_atom</span>


<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n :</span>
<span class="sd">        principal quantum number</span>
<span class="sd">    l :</span>
<span class="sd">        angular momentum quantum number</span>
<span class="sd">    m :</span>
<span class="sd">        magnetic quantum number</span>
<span class="sd">    Z :</span>
<span class="sd">        effective atomic number</span>
<span class="sd">    **kwargs :</span>
<span class="sd">        See `Orbital` for details.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; carbon_pz = HydrogenicOrbital(2, 1, 0, 3.2)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">Z</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_Z</span> <span class="o">=</span> <span class="n">Z</span>

        <span class="n">Helper</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Helper&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">,</span> <span class="s2">&quot;prefactor&quot;</span><span class="p">])</span>
        <span class="n">z</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">Z</span> <span class="o">/</span> <span class="p">(</span><span class="n">n</span> <span class="o">*</span> <span class="n">a0</span><span class="p">(</span><span class="s2">&quot;Ang&quot;</span><span class="p">))</span>
        <span class="n">pref</span> <span class="o">=</span> <span class="p">(</span><span class="n">z</span><span class="o">**</span><span class="mi">3</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">n</span> <span class="o">*</span> <span class="n">factorial</span><span class="p">(</span><span class="n">n</span> <span class="o">+</span> <span class="n">l</span><span class="p">)))</span> <span class="o">**</span> <span class="mf">0.5</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_radial_helper</span> <span class="o">=</span> <span class="n">Helper</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">pref</span><span class="p">)</span>

        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_radial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Radial functional for the Hydrogenic orbital&quot;&quot;&quot;</span>
        <span class="n">H</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_radial_helper</span>
        <span class="n">n</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span>
        <span class="n">zr</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">Z</span> <span class="o">*</span> <span class="n">r</span>
        <span class="n">L</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">prefactor</span> <span class="o">*</span> <span class="n">eval_genlaguerre</span><span class="p">(</span><span class="n">n</span> <span class="o">-</span> <span class="n">l</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">zr</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">zr</span> <span class="o">*</span> <span class="mf">0.5</span><span class="p">)</span> <span class="o">*</span> <span class="n">zr</span><span class="o">**</span><span class="n">l</span> <span class="o">*</span> <span class="n">L</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the state of this object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;n&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span>
            <span class="s2">&quot;l&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span>
            <span class="s2">&quot;m&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span>
            <span class="s2">&quot;Z&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Z</span><span class="p">,</span>
            <span class="s2">&quot;R&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">,</span>
            <span class="s2">&quot;q0&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="p">,</span>
            <span class="s2">&quot;tag&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">,</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Re-create the state of this object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span>
            <span class="n">d</span><span class="p">[</span><span class="s2">&quot;n&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;l&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;m&quot;</span><span class="p">],</span> <span class="n">d</span><span class="p">[</span><span class="s2">&quot;Z&quot;</span><span class="p">],</span> <span class="n">R</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;R&quot;</span><span class="p">],</span> <span class="n">q0</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;q0&quot;</span><span class="p">],</span> <span class="n">tag</span><span class="o">=</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;tag&quot;</span><span class="p">]</span>
        <span class="p">)</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_ExponentialOrbital</span><span class="p">(</span><span class="n">Orbital</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Inheritable class for different exponential spherical orbitals</span>

<span class="sd">    All exponential spherical orbitals are defined using:</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y^m_l(\theta,\varphi) = (-1)^m\sqrt{\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">             e^{i m \theta} P^m_l(\cos(\varphi))</span>

<span class="sd">    The resulting orbital is</span>

<span class="sd">    .. math::</span>
<span class="sd">        \phi_{lmn}(\mathbf r) = R_l(|\mathbf r|) Y^m_l(\theta, \varphi)</span>

<span class="sd">    And :math:`R_l` is some exponential function with suitable parameters</span>
<span class="sd">    that are to be defined in the subclass.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;_n&quot;</span><span class="p">,</span> <span class="s2">&quot;_l&quot;</span><span class="p">,</span> <span class="s2">&quot;_m&quot;</span><span class="p">,</span> <span class="s2">&quot;_alpha&quot;</span><span class="p">,</span> <span class="s2">&quot;_coeff&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Ensure args is a list (to be able to pop)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

        <span class="c1"># Extract shell information</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;alpha&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;coeff&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Arguments *have* to be</span>
        <span class="c1"># n, l, [m (only for l&gt;0)], alpha, coeff</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">l</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> l is not defined&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">l</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">m</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">m</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># default to 0</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="k">if</span> <span class="n">n</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">l</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="k">if</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> n must be &gt;= 1&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">coeff</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> coeff is not defined&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">alpha</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> alpha is not defined&quot;</span><span class="p">)</span>

        <span class="c1"># Copy over information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_n</span> <span class="o">=</span> <span class="n">n</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_l</span> <span class="o">=</span> <span class="n">l</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_m</span> <span class="o">=</span> <span class="n">m</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">alpha</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">alpha</span> <span class="o">=</span> <span class="p">(</span><span class="n">alpha</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">alpha</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">coeff</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">coeff</span> <span class="o">=</span> <span class="p">(</span><span class="n">coeff</span><span class="p">,)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">coeff</span><span class="p">)</span>

        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span>
        <span class="p">),</span> <span class="s2">&quot;Contraction factors and exponents needs to have same length&quot;</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">_rspher_harm_fact</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> does not implement shells l&gt;=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">_rspher_harm_fact</span><span class="p">)</span><span class="si">}</span><span class="s2">!&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">)</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires |m| &lt;= l.&quot;</span><span class="p">)</span>

        <span class="c1"># update R in case the user did not specify it</span>
        <span class="n">R</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;R&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">R</span><span class="o">=</span><span class="n">R</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A string representation of the object&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">n: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">, l: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, m: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}</span><span class="s2">, R: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">s</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">n: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">, l: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, m: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}</span><span class="s2">, R: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">}</span><span class="s2">, q0: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> c, a:&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
            <span class="p">[</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">c</span><span class="si">:</span><span class="s2">.4f</span><span class="si">}</span><span class="s2"> , </span><span class="si">{</span><span class="n">a</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2">&quot;</span> <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">s</span><span class="si">}{</span><span class="n">orbs</span><span class="si">}</span><span class="se">\n}}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="p">:</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">, l=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, m=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}</span><span class="s2">, no=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span><span class="si">}</span><span class="s2">, R=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">, tag=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">tag</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> n=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="si">}</span><span class="s2">, l=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="si">}</span><span class="s2">, m=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="si">}</span><span class="s2">, no=</span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span><span class="si">}</span><span class="s2">, R=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2">, q0=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">q0</span><span class="si">}</span><span class="s2">&gt;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__hash__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">hash</span><span class="p">(</span>
            <span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">Orbital</span><span class="p">,</span> <span class="bp">self</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span><span class="p">)</span>
        <span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">n</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`n` quantum number&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_n</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">l</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`l` quantum number&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_l</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">m</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`m` quantum number&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_m</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">alpha</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`\alpha` factors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_alpha</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">coeff</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;:math:`c` contraction factors&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coeff</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">psi</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\phi(\mathbf r)` at a given point (or more points)</span>

<span class="sd">        The position `r` is a vector from the origin of this orbital.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r : array_like</span>
<span class="sd">           the vector from the orbital origin</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">             basis function value at point `r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">r</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">r</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Convert to spherical coordinates</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2spher</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">cos_phi</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">maxR</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">(</span><span class="n">s</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">p</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">psi_spher</span><span class="p">(</span><span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">cos_phi</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="c1"># Reduce memory immediately</span>
            <span class="k">del</span> <span class="n">idx</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span>
        <span class="n">p</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="n">s</span>
        <span class="k">return</span> <span class="n">p</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">spher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate the spherical harmonics of this orbital at a given point (in spherical coordinates)</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        theta : array_like</span>
<span class="sd">           azimuthal angle in the :math:`xy` plane (from :math:`x`)</span>
<span class="sd">        phi : array_like</span>
<span class="sd">           polar angle from :math:`z` axis</span>
<span class="sd">        cos_phi :</span>
<span class="sd">           whether `phi` is actually :math:`cos(\phi)` which will be faster because</span>
<span class="sd">           `cos` is not necessary to call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            spherical harmonics at angles :math:`\theta` and :math:`\phi`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">cos_phi</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">_rspherical_harm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">_rspherical_harm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">m</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">cos</span><span class="p">(</span><span class="n">phi</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">psi_spher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Calculate :math:`\phi(|\mathbf r|, \theta, \phi)` at a given point (in spherical coordinates)</span>

<span class="sd">        This is equivalent to `psi` however, the input is given in spherical coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        r : array_like</span>
<span class="sd">           the radius from the orbital origin</span>
<span class="sd">        theta : array_like</span>
<span class="sd">           azimuthal angle in the :math:`xy` plane (from :math:`x`)</span>
<span class="sd">        phi : array_like</span>
<span class="sd">           polar angle from :math:`z` axis</span>
<span class="sd">        cos_phi :</span>
<span class="sd">           whether `phi` is actually :math:`cos(\phi)` which will be faster because</span>
<span class="sd">           `cos` is not necessary to call.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">             basis function value at point `r`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">radial</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spher</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="n">phi</span><span class="p">,</span> <span class="n">cos_phi</span><span class="p">)</span>


<div class="viewcode-block" id="GTOrbital">
<a class="viewcode-back" href="../../../api/generated/sisl.GTOrbital.html#sisl.GTOrbital">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">GTOrbital</span><span class="p">(</span><span class="n">_ExponentialOrbital</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Gaussian type orbital</span>

<span class="sd">    The `GTOrbital` uses contraction factors and coefficients.</span>

<span class="sd">    The Gaussian type orbital consists of a gaussian radial part and a spherical</span>
<span class="sd">    harmonic part that only depends on angles.</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y^m_l(\theta,\varphi) &amp;= (-1)^m\sqrt{\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">             e^{i m \theta} P^m_l(\cos(\varphi))</span>
<span class="sd">        \\</span>
<span class="sd">        \phi_{lmn}(\mathbf r) &amp;= R_l(|\mathbf r|) Y^m_l(\theta, \varphi)</span>
<span class="sd">        \\</span>
<span class="sd">        R_l(|\mathbf r|) &amp;= \sum c_i e^{-\alpha_i r^2}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is opted for significant changes based on user feedback. If you use it,</span>
<span class="sd">    please give feedback.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int, optional</span>
<span class="sd">       principal quantum number, default to ``l + 1``</span>
<span class="sd">    l : int</span>
<span class="sd">       azimuthal quantum number</span>
<span class="sd">    m : int, optional for l == 0</span>
<span class="sd">       magnetic quantum number</span>
<span class="sd">    alpha : float or array_like</span>
<span class="sd">       coefficients for the exponential (in 1/Ang^2)</span>
<span class="sd">       Generally the coefficients are given in atomic units, so</span>
<span class="sd">       a conversion from online tables is necessary.</span>
<span class="sd">    coeff : float or array_like</span>
<span class="sd">       contraction factors</span>
<span class="sd">    R :</span>
<span class="sd">        See `Orbital` for details.</span>
<span class="sd">    q0 : float, optional</span>
<span class="sd">        initial charge</span>
<span class="sd">    tag : str, optional</span>
<span class="sd">        user defined tag</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">radial</span> <span class="o">=</span> <span class="n">_radial</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_radial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Radial function&quot;&quot;&quot;</span>
        <span class="n">r2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">square</span><span class="p">(</span><span class="n">r</span><span class="p">)</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r2</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">v</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">r2</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">r</span><span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">l</span> <span class="o">*</span> <span class="n">v</span></div>



<div class="viewcode-block" id="STOrbital">
<a class="viewcode-back" href="../../../api/generated/sisl.STOrbital.html#sisl.STOrbital">[docs]</a>
<span class="k">class</span><span class="w"> </span><span class="nc">STOrbital</span><span class="p">(</span><span class="n">_ExponentialOrbital</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Slater type orbital</span>

<span class="sd">    The `STOrbital` uses contraction factors and coefficients.</span>

<span class="sd">    The Slater type orbital consists of an exponential radial part and a spherical</span>
<span class="sd">    harmonic part that only depends on angles.</span>

<span class="sd">    .. math::</span>
<span class="sd">        Y^m_l(\theta,\varphi) &amp;= (-1)^m\sqrt{\frac{2l+1}{4\pi} \frac{(l-m)!}{(l+m)!}}</span>
<span class="sd">             e^{i m \theta} P^m_l(\cos(\varphi))</span>
<span class="sd">        \\</span>
<span class="sd">        \phi_{lmn}(\mathbf r) &amp;= R_n(|\mathbf r|) Y^m_l(\theta, \varphi)</span>
<span class="sd">        \\</span>
<span class="sd">        R_n(|\mathbf r|) &amp;= r^{n-1} \sum c_i e^{-\alpha_i r}</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    This class is opted for significant changes based on user feedback. If you use it,</span>
<span class="sd">    please give feedback.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    n : int</span>
<span class="sd">       principal quantum number</span>
<span class="sd">    l : int</span>
<span class="sd">       azimuthal quantum number</span>
<span class="sd">    m : int, optional for l == 0</span>
<span class="sd">       magnetic quantum number</span>
<span class="sd">    alpha : float or array_like</span>
<span class="sd">       coefficients for the exponential (in 1/Ang)</span>
<span class="sd">       Generally the coefficients are given in atomic units, so</span>
<span class="sd">       a conversion from online tables is necessary.</span>
<span class="sd">    coeff : float or array_like</span>
<span class="sd">       contraction factors</span>
<span class="sd">    R :</span>
<span class="sd">        See `Orbital` for details.</span>
<span class="sd">    q0 : float, optional</span>
<span class="sd">        initial charge</span>
<span class="sd">    tag : str, optional</span>
<span class="sd">        user defined tag</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">()</span>

    <span class="n">radial</span> <span class="o">=</span> <span class="n">_radial</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_radial</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">r</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Radial function&quot;&quot;&quot;</span>
        <span class="n">coeff</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">coeff</span>
        <span class="n">alpha</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">alpha</span>
        <span class="n">v</span> <span class="o">=</span> <span class="n">coeff</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">alpha</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">c</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">coeff</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span> <span class="n">alpha</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
            <span class="n">v</span> <span class="o">+=</span> <span class="n">c</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span><span class="o">-</span><span class="n">a</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span>
        <span class="k">return</span> <span class="n">r</span> <span class="o">**</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">v</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>