

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.io.tbtrans.tbt &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=7b70f75b"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl.io.tbtrans.tbt</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.io.tbtrans.tbt</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">StringIO</span><span class="w"> </span><span class="kn">import</span> <span class="n">StringIO</span>
<span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">StringIO</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">reduce</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="n">ndarray</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span>

<span class="c1"># The sparse matrix for the orbital/bond currents</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">scipy.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">SparseEfficiencyWarning</span><span class="p">,</span> <span class="n">csr_matrix</span><span class="p">,</span> <span class="n">issparse</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sisl._array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_a</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl</span><span class="w"> </span><span class="kn">import</span> <span class="n">Atoms</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">constant</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._core.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">_ncol_to_indptr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._help</span><span class="w"> </span><span class="kn">import</span> <span class="n">wrap_filterwarnings</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">deprecate_argument</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics.densitymatrix</span><span class="w"> </span><span class="kn">import</span> <span class="n">DensityMatrix</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics.distribution</span><span class="w"> </span><span class="kn">import</span> <span class="n">fermi_dirac</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.unit.siesta</span><span class="w"> </span><span class="kn">import</span> <span class="n">unit_convert</span>

<span class="c1"># Import sile objects</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">collect_action</span><span class="p">,</span>
    <span class="n">default_ArgumentParser</span><span class="p">,</span>
    <span class="n">default_namespace</span><span class="p">,</span>
    <span class="n">list2str</span><span class="p">,</span>
    <span class="n">lstranges</span><span class="p">,</span>
    <span class="n">run_actions</span><span class="p">,</span>
    <span class="n">strmap</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">..sile</span><span class="w"> </span><span class="kn">import</span> <span class="n">add_sile</span><span class="p">,</span> <span class="n">get_sile</span><span class="p">,</span> <span class="n">sile_raise_write</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._cdf</span><span class="w"> </span><span class="kn">import</span> <span class="n">ElecType</span><span class="p">,</span> <span class="n">EType</span><span class="p">,</span> <span class="n">_devncSileTBtrans</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.sile</span><span class="w"> </span><span class="kn">import</span> <span class="n">missing_input_fdf</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tbtncSileTBtrans&quot;</span><span class="p">,</span> <span class="s2">&quot;tbtavncSileTBtrans&quot;</span><span class="p">]</span>


<span class="n">NormType</span> <span class="o">=</span> <span class="n">Literal</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">,</span> <span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">]</span>

<span class="n">Bohr2Ang</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s2">&quot;Bohr&quot;</span><span class="p">,</span> <span class="s2">&quot;Ang&quot;</span><span class="p">)</span>
<span class="n">Ry2eV</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s2">&quot;Ry&quot;</span><span class="p">,</span> <span class="s2">&quot;eV&quot;</span><span class="p">)</span>
<span class="n">Ry2K</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s2">&quot;Ry&quot;</span><span class="p">,</span> <span class="s2">&quot;K&quot;</span><span class="p">)</span>
<span class="n">eV2Ry</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s2">&quot;eV&quot;</span><span class="p">,</span> <span class="s2">&quot;Ry&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">window_warning</span><span class="p">(</span>
    <span class="n">routine</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">mu_from</span><span class="p">,</span> <span class="n">kt_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">mu_to</span><span class="p">,</span> <span class="n">kt_to</span><span class="p">,</span> <span class="n">kT_factor</span><span class="o">=</span><span class="mi">3</span>
<span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Issue a warning if the energy grid does not  the chemical potentials&quot;&quot;&quot;</span>

    <span class="n">Emin</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">min</span><span class="p">()</span>
    <span class="n">Emax</span> <span class="o">=</span> <span class="n">E</span><span class="o">.</span><span class="n">max</span><span class="p">()</span>

    <span class="c1"># We expect the tbtrans calcluation was created with the simple</span>
    <span class="c1">#   mid-rule!</span>
    <span class="c1"># The mid-rule is equivalent to adding a dE = (E[1] - E[0]) / 2</span>
    <span class="c1"># to both ends.</span>
    <span class="n">dE</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

    <span class="c1"># Check that the lower bound is sufficient</span>
    <span class="n">print_warning</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mu_from</span> <span class="o">-</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="n">kT_factor</span> <span class="o">&lt;</span> <span class="n">Emin</span> <span class="o">-</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="ow">or</span> <span class="n">mu_to</span> <span class="o">-</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="n">kT_factor</span> <span class="o">&lt;</span> <span class="n">Emin</span> <span class="o">-</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span>
    <span class="p">)</span>
    <span class="n">print_warning</span> <span class="o">=</span> <span class="p">(</span>
        <span class="n">mu_from</span> <span class="o">+</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="n">kT_factor</span> <span class="o">&gt;</span> <span class="n">Emax</span> <span class="o">+</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="ow">or</span> <span class="n">mu_to</span> <span class="o">+</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="n">kT_factor</span> <span class="o">&gt;</span> <span class="n">Emax</span> <span class="o">+</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="ow">or</span> <span class="n">print_warning</span>
    <span class="p">)</span>
    <span class="k">if</span> <span class="n">print_warning</span><span class="p">:</span>
        <span class="c1"># We should pretty-print a table of data</span>
        <span class="n">m</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">elec_from</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">elec_to</span><span class="p">),</span> <span class="mi">15</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;Energy range&quot;</span><span class="p">,</span> <span class="n">Emin</span> <span class="o">-</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Emax</span> <span class="o">+</span> <span class="n">dE</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">elec_from</span><span class="p">,</span> <span class="n">mu_from</span> <span class="o">-</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="n">kT_factor</span><span class="p">,</span> <span class="n">mu_from</span> <span class="o">+</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="n">kT_factor</span>
        <span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">elec_to</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">-</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="n">kT_factor</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">+</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="n">kT_factor</span>
        <span class="p">)</span>
        <span class="n">min_e</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">mu_from</span> <span class="o">-</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="n">kT_factor</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">-</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="n">kT_factor</span><span class="p">)</span>
        <span class="n">max_e</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">mu_from</span> <span class="o">+</span> <span class="n">kt_from</span> <span class="o">*</span> <span class="n">kT_factor</span><span class="p">,</span> <span class="n">mu_to</span> <span class="o">+</span> <span class="n">kt_to</span> <span class="o">*</span> <span class="n">kT_factor</span><span class="p">)</span>
        <span class="n">s</span> <span class="o">+=</span> <span class="p">(</span><span class="s2">&quot;{:&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">m</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;s} </span><span class="si">{:9.3f}</span><span class="s2"> : </span><span class="si">{:9.3f}</span><span class="s2"> eV</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="s2">&quot;dFermi function&quot;</span><span class="p">,</span> <span class="n">min_e</span><span class="p">,</span> <span class="n">max_e</span>
        <span class="p">)</span>

        <span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">routine</span><span class="si">}</span><span class="s2"> cannot &quot;</span>
            <span class="s2">&quot;accurately calculate the current due to the calculated energy range. &quot;</span>
            <span class="s2">&quot;Increase the calculated energy-range.</span><span class="se">\n</span><span class="si">{s}</span><span class="s2">&quot;</span>
        <span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.tbtrans&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">tbtncSileTBtrans</span><span class="p">(</span><span class="n">_devncSileTBtrans</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;TBtrans output file object</span>

<span class="sd">    Implementation of the TBtrans output ``*.TBT.nc`` files which contains</span>
<span class="sd">    calculated quantities related to the NEGF code TBtrans.</span>

<span class="sd">    Although the TBtrans code is in fortran and the resulting NetCDF file variables</span>
<span class="sd">    are in fortran indexing (1-based), everything is returned as Python indexing (0-based)</span>
<span class="sd">    when using Python scripts.</span>

<span class="sd">    The mathematical notation described :ref:`here &lt;math_convention&gt;`</span>
<span class="sd">    will be used throughout.</span>

<span class="sd">    A word on DOS normalization:</span>

<span class="sd">    All the device region DOS functions may request a normalization depending</span>
<span class="sd">    on a variety of functions. You are highly encouraged to read the documentation for</span>
<span class="sd">    the `norm` function and to consider the benefit of using the ``norm=&#39;atom&#39;``</span>
<span class="sd">    normalization to more easily compare various partitions of DOS.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    The API for this class are largely equivalent to the arguments of the `sdata` command-line</span>
<span class="sd">    tool, with the execption that the command-line tool uses Fortran indexing numbers (1-based).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_trans_type</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;TBT&quot;</span>
    <span class="n">_E2eV</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="n">Ry2eV</span>

    <span class="n">_k_avg</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="tbtncSileTBtrans.write_tbtav">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.write_tbtav">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_tbtav</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert this to a TBT.AV.nc file, i.e. all k dependent quantites are averaged out.</span>

<span class="sd">        This command will overwrite any previous file with the ending TBT.AV.nc and thus</span>
<span class="sd">        will not take notice of any older files.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        file : str</span>
<span class="sd">            output filename</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">with_suffix</span><span class="p">(</span><span class="s2">&quot;.AV.nc&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;file&quot;</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span>
        <span class="n">tbtavncSileTBtrans</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">write_tbtav</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_value_avg</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Local method for obtaining the data from the SileCDF.</span>

<span class="sd">        This method checks how the file is accessed, i.e. whether</span>
<span class="sd">        data is stored in the object or it should be read consequtively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str</span>
<span class="sd">            name of the variable (located in `tree`)</span>
<span class="sd">        tree: str or list of str, optional</span>
<span class="sd">            the group location of the variable</span>
<span class="sd">        kavg: bool, optional</span>
<span class="sd">            whether to k-average the quantity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_access</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">[:]</span>

        <span class="c1"># Perform normalization</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kavg</span><span class="p">:</span>
                <span class="n">wkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wk</span>
                <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wkpt</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nk</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">kavg</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires kavg argument to be either bool or an integer corresponding to the k-point index.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Return data</span>
        <span class="k">return</span> <span class="n">data</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_value_E</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
        <span class="n">tree</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">list</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Etype</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Local method for obtaining energy resolved data from the SileCDF.</span>

<span class="sd">        This method checks how the file is accessed, i.e. whether</span>
<span class="sd">        data is stored in the object or it should be read consequtively.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name: str</span>
<span class="sd">            name of the variable (located in `tree`)</span>
<span class="sd">        tree: str or list of str, optional</span>
<span class="sd">            the group location of the variable</span>
<span class="sd">        kavg: bool, optional</span>
<span class="sd">            whether to k-average the quantity</span>
<span class="sd">        E:</span>
<span class="sd">            if provided, only extract the quantity based on the energy `E`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">E</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span>

        <span class="c1"># Ensure that it is an index</span>
        <span class="n">iE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>

        <span class="n">v</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">v</span><span class="p">[</span><span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="n">wkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wk</span>

        <span class="c1"># Perform normalization</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">kavg</span><span class="p">:</span>
                <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">wkpt</span><span class="p">)</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">])</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nk</span><span class="p">):</span>
                    <span class="n">data</span> <span class="o">+=</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[:,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">v</span><span class="p">[</span><span class="n">kavg</span><span class="p">,</span> <span class="n">iE</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> requires kavg argument to be either bool or an integer corresponding to the k-point index.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Return data</span>
        <span class="k">return</span> <span class="n">data</span>

<div class="viewcode-block" id="tbtncSileTBtrans.transmission">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.transmission">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.T.All&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transmission</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transmission from `elec_from` to `elec_to`.</span>

<span class="sd">        The transmission between two electrodes may be retrieved</span>
<span class="sd">        from the `Sile`.</span>

<span class="sd">        The transmission is calculated as:</span>

<span class="sd">        .. math::</span>

<span class="sd">            T(E) = \mathrm{Tr}[\mathbf{G}\boldsymbol\Gamma_{\mathrm{from}}\mathbf{G}^\dagger\boldsymbol\Gamma_{\mathrm{to}}]</span>

<span class="sd">        where all quantities are energy dependent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to:</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned transmission is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transmission_eig : the transmission decomposed in eigenchannels</span>
<span class="sd">        transmission_bulk : the total transmission in a periodic lead</span>
<span class="sd">        reflection : total reflection back into the electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elec_from</span> <span class="o">==</span> <span class="n">elec_to</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.transmission elec_from[</span><span class="si">{</span><span class="n">elec_from</span><span class="si">}</span><span class="s2">] and elec_to[</span><span class="si">{</span><span class="n">elec_to</span><span class="si">}</span><span class="s2">] must not be the same.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec_to</span><span class="si">}</span><span class="s2">.T&quot;</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.reflection">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.reflection">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.T.Out&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;TBT.T.All&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">reflection</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">from_single</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Reflection into electrode `elec`</span>

<span class="sd">        The reflection into electrode `elec` is calculated as:</span>

<span class="sd">        .. math::</span>

<span class="sd">             R(E) = T_{\mathrm{bulk}}(E) - \sum_{\mathrm{to}} T_{\mathrm{elec}\to\mathrm{to}}(E)</span>

<span class="sd">        Another way of calculating the reflection is via:</span>

<span class="sd">        .. math::</span>

<span class="sd">             R(E) = T_{\mathrm{bulk}}(E) - \big\{i \mathrm{Tr}[(\mathbf G-\mathbf G^\dagger)\boldsymbol\Gamma_{\mathrm{elec}}]</span>
<span class="sd">                   - \mathrm{Tr}[\mathbf G\boldsymbol\Gamma_{\mathrm{elec}}\mathbf G^\dagger\boldsymbol\Gamma_{\mathrm{elec}}]\big\}</span>

<span class="sd">        Both are identical, however, numerically they may be different. Particularly when the bulk transmission</span>
<span class="sd">        is very large compared to the transmission to the other electrodes one should prefer the first equation.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           the backscattered electrode</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned reflection is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        from_single:</span>
<span class="sd">           whether the reflection is calculated using the Green function and a</span>
<span class="sd">           single scattering matrix Eq. (2) above (true), otherwise Eq. (1) will be used (false).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transmission : the total transmission</span>
<span class="sd">        transmission_eig : the transmission decomposed in eigenchannels</span>
<span class="sd">        transmission_bulk : the total transmission in a periodic lead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="n">BT</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_bulk</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>

        <span class="c1"># Find full transmission out of electrode</span>
        <span class="k">if</span> <span class="n">from_single</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">.T&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">.C&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">for</span> <span class="n">to</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                <span class="n">to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">to</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">elec</span> <span class="o">==</span> <span class="n">to</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">T</span> <span class="o">=</span> <span class="n">T</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BT</span> <span class="o">-</span> <span class="n">T</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.transmission_eig">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.transmission_eig">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.T.Eig&quot;</span><span class="p">,</span> <span class="s2">&quot;&lt;int&gt;&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transmission_eig</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transmission eigenvalues from `elec_from` to `elec_to`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to:</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned transmission eigenvalues are k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transmission : the total transmission</span>
<span class="sd">        transmission_bulk : the total transmission in a periodic lead</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">elec_from</span> <span class="o">==</span> <span class="n">elec_to</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.transmission_eig elec_from[</span><span class="si">{</span><span class="n">elec_from</span><span class="si">}</span><span class="s2">] and elec_to[</span><span class="si">{</span><span class="n">elec_to</span><span class="si">}</span><span class="s2">] must not be the same.&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec_to</span><span class="si">}</span><span class="s2">.T.Eig&quot;</span><span class="p">,</span> <span class="n">elec_from</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.transmission_bulk">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.transmission_bulk">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.T.Bulk&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">transmission_bulk</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Bulk transmission for the `elec` electrode</span>

<span class="sd">        The bulk transmission is equivalent to creating a 2 terminal device with</span>
<span class="sd">        electrode `elec` tiled 3 times.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           the bulk electrode</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned transmission are k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        transmission : the total transmission</span>
<span class="sd">        transmission_eig : the transmission decomposed in eigenchannels</span>
<span class="sd">        reflection : total reflection back into the electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_avg</span><span class="p">(</span><span class="s2">&quot;T&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">),</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.norm">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.norm">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">norm</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">norm</span><span class="p">:</span> <span class="n">NormType</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Normalization factor depending on the input</span>

<span class="sd">        The normalization can be performed in one of the below methods.</span>
<span class="sd">        In the following :math:`N` refers to the normalization constant</span>
<span class="sd">        that is to be used (i.e. the divisor):</span>

<span class="sd">        ``&#39;none&#39;``</span>
<span class="sd">           :math:`N=1`</span>
<span class="sd">        ``&#39;all&#39;``</span>
<span class="sd">           :math:`N` equals the number of orbitals in the total device region.</span>
<span class="sd">        ``&#39;atom&#39;``</span>
<span class="sd">           :math:`N` equals the total number of orbitals in the selected</span>
<span class="sd">           atoms. If `orbitals` is an argument a conversion of `orbitals` to the equivalent</span>
<span class="sd">           unique atoms is performed, and subsequently the total number of orbitals on the</span>
<span class="sd">           atoms is used. This makes it possible to compare the fraction of orbital DOS easier.</span>
<span class="sd">        ``&#39;orbital&#39;``</span>
<span class="sd">           :math:`N` is the sum of selected orbitals, if `atoms` is specified, this</span>
<span class="sd">           is equivalent to the &#39;atom&#39; option.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        atoms : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbitals` keyword</span>
<span class="sd">        orbitals : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atoms` keyword</span>
<span class="sd">        norm :</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Cast to lower</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">,</span> <span class="s2">&quot;orbital&quot;</span><span class="p">):</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">no_d</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.norm error on norm keyword in when requesting normalization!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># If the user simply requests a specific norm</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NORM</span>

        <span class="c1"># Now figure out what to do</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Get pivoting indices to average over</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;orbital&quot;</span><span class="p">:</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">orbitals</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;atom&quot;</span><span class="p">:</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals</span><span class="p">))</span>
                <span class="c1"># Now sum the orbitals per atom</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">NORM</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.norm both atom and orbital cannot be specified!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># atom is specified, this will result in the same normalization</span>
        <span class="c1"># regardless of norm == [orbital, atom] since it is all orbitals</span>
        <span class="c1"># on the given atoms.</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">):</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a2p</span><span class="p">(</span><span class="n">atoms</span><span class="p">))</span>

        <span class="k">return</span> <span class="n">NORM</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_DOS</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DOS</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Averages/sums the DOS</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        DOS : numpy.ndarray</span>
<span class="sd">           data to process</span>
<span class="sd">        atoms : array_like of int, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbitals` keyword</span>
<span class="sd">        orbitals : array_like of int, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atoms` keyword</span>
<span class="sd">        sum : bool, optional</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm : {&#39;none&#39;, &#39;atom&#39;, &#39;orbital&#39;, &#39;all&#39;}</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            in order of the geometry orbitals (i.e. pivoted back to the device region).</span>
<span class="sd">            If `atoms` or `orbitals` is specified they are returned in that order.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Force False equivalent as None.</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span><span class="p">:</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">orbitals</span><span class="p">:</span>
                <span class="n">orbitals</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;Both atoms and orbitals keyword in DOS request &quot;</span>
                <span class="s2">&quot;cannot be specified, only one at a time.&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Cast to lower</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;none&quot;</span><span class="p">:</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">,</span> <span class="s2">&quot;orbital&quot;</span><span class="p">):</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">no_d</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Error on norm keyword in DOS request&quot;</span><span class="p">)</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We simply return *everything*</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DOS</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>
            <span class="c1"># We return the sorted DOS</span>
            <span class="n">p</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">pivot</span><span class="p">())</span>
            <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># Now figure out what to do</span>
        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># orbital *must* be specified</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
                <span class="c1"># Request all orbitals of the device</span>
                <span class="n">orbitals</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="s2">&quot;Device&quot;</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">orbitals</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

            <span class="c1"># Get pivoting indices to average over</span>
            <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;orbital&quot;</span><span class="p">:</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>
            <span class="k">elif</span> <span class="n">norm</span> <span class="o">==</span> <span class="s2">&quot;atom&quot;</span><span class="p">:</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">unique</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                <span class="c1"># Now sum the orbitals per atom</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">sumi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">a</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span><span class="p">[</span><span class="n">a</span><span class="p">]))</span>

            <span class="k">if</span> <span class="nb">sum</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>
            <span class="c1"># Else, we have to return the full subset</span>
            <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># Check if user requests all atoms/orbitals</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="c1"># Request all atoms of the device</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="s2">&quot;Device&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">names</span><span class="p">[</span><span class="n">atoms</span><span class="p">]</span>

        <span class="c1"># atom is specified</span>
        <span class="c1"># Return the pivoting orbitals for the atom</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2p</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">):</span>
            <span class="n">NORM</span> <span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">sum</span> <span class="ow">or</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="c1"># Regardless of SUM, when requesting a single atom</span>
            <span class="c1"># we return it</span>
            <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># We default the case where 1-orbital systems are in use</span>
        <span class="c1"># Then it becomes *very* easy</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">p</span><span class="p">]</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="c1"># This is the multi-orbital case...</span>

        <span class="c1"># We will return per-atom</span>
        <span class="n">shp</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">DOS</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">nDOS</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">shp</span> <span class="o">+</span> <span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)],</span> <span class="n">DOS</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

        <span class="c1"># Sum for new return stuff</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">a</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="p">):</span>
            <span class="n">pvt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">a2p</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
            <span class="n">nDOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">DOS</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">pvt</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">NORM</span>

        <span class="k">return</span> <span class="n">nDOS</span>

<div class="viewcode-block" id="tbtncSileTBtrans.DOS">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.DOS">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.DOS.Gf&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">DOS</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">sum</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">norm</span><span class="p">:</span> <span class="n">NormType</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Green function density of states (DOS) (1/eV).</span>

<span class="sd">        Extract the DOS on a selected subset of atoms/orbitals in the device region</span>

<span class="sd">        .. math::</span>

<span class="sd">           \mathrm{DOS}(E) = -\frac{1}{\pi N} \sum_{i\in \{I\}} \Im \mathbf{G}_{ii}(E)</span>

<span class="sd">        The normalization constant (:math:`N`) is defined in the routine `norm` and depends on the</span>
<span class="sd">        arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E :</span>
<span class="sd">           optionally only return the DOS of atoms at a given energy point</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned DOS is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        atoms : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbitals` keyword. If `True` it will use all atoms in the device.</span>
<span class="sd">           False is equivalent to None.</span>
<span class="sd">        orbitals : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atoms` keyword. If `True` it will use all orbitals in the device.</span>
<span class="sd">           False is equivalent to None.</span>
<span class="sd">        sum :</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm :</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        ADOS : the spectral density of states from an electrode</span>
<span class="sd">        BDOS : the bulk density of states in an electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_DOS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s2">&quot;DOS&quot;</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">),</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">norm</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">eV2Ry</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.ADOS">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.ADOS">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.DOS.A&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ADOS</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">atoms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="nb">sum</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">norm</span><span class="p">:</span> <span class="n">NormType</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Spectral density of states (DOS) (1/eV).</span>

<span class="sd">        Extract the spectral DOS from electrode `elec` on a selected subset of atoms/orbitals in the device region</span>

<span class="sd">        .. math::</span>
<span class="sd">           \mathrm{ADOS}_\mathfrak{el}(E) = \frac{1}{2\pi N} \sum_{i\in\{I\}} [\mathbf{G}(E)\Gamma_\mathfrak{el}\mathbf{G}^\dagger]_{ii}(E)</span>

<span class="sd">        The normalization constant (:math:`N`) is defined in the routine `norm` and depends on the</span>
<span class="sd">        arguments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           electrode originating spectral function</span>
<span class="sd">        E :</span>
<span class="sd">           optionally only return the DOS of atoms at a given energy point</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned DOS is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        atoms : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of atoms (default to all).</span>
<span class="sd">           *NOT* allowed with `orbitals` keyword. If `True` it will use all atoms in the device.</span>
<span class="sd">           False is equivalent to None.</span>
<span class="sd">        orbitals : array_like of int or bool, optional</span>
<span class="sd">           only return for a given set of orbitals (default to all)</span>
<span class="sd">           *NOT* allowed with `atoms` keyword. If `True` it will use all orbitals in the device.</span>
<span class="sd">           False is equivalent to None.</span>
<span class="sd">        sum :</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm :</span>
<span class="sd">           how the normalization of the summed DOS is performed (see `norm` routine).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DOS : the total density of states (including bound states)</span>
<span class="sd">        BDOS : the bulk density of states in an electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_DOS</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s2">&quot;ADOS&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">),</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">,</span> <span class="nb">sum</span><span class="p">,</span> <span class="n">norm</span>
            <span class="p">)</span>
            <span class="o">*</span> <span class="n">eV2Ry</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.BDOS">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.BDOS">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.DOS.Elecs&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">BDOS</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">EType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="nb">sum</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">norm</span><span class="p">:</span> <span class="n">NormType</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Bulk density of states (DOS) (1/eV).</span>

<span class="sd">        Extract the bulk DOS from electrode `elec`.</span>

<span class="sd">        .. math::</span>

<span class="sd">           \mathrm{BDOS}_\mathfrak{el}(E) = -\frac{1}{\pi} \Im\mathbf{G}(E)</span>

<span class="sd">        This returns the density of states for the full (Bloch-expanded) electrode.</span>
<span class="sd">        When `norm` is &#39;none&#39;, the DOS is the full DOS for all electrode atoms (fully expanded),</span>
<span class="sd">        if you want to get the DOS for the minimal (un-expanded) electrode unit-cell,</span>
<span class="sd">        then divide by ``np.prod(tbt.bloch(elec))``.</span>
<span class="sd">        When `norm` is anything else, it will be normalised to the number of atoms/orbitals</span>
<span class="sd">        in the electrode.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           electrode where the bulk DOS is returned</span>
<span class="sd">        E :</span>
<span class="sd">           optionally only return the DOS of atoms at a given energy point</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned DOS is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        sum :</span>
<span class="sd">           whether the returned quantities are summed or returned *as is*, i.e. resolved per atom/orbital.</span>
<span class="sd">        norm :</span>
<span class="sd">           whether the returned quantities are summed over all orbitals or normed by number of orbitals in the electrode.</span>
<span class="sd">           Currently one cannot extract DOS per atom/orbital.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        DOS : the total density of states (including bound states)</span>
<span class="sd">        ADOS : the spectral density of states from an electrode</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># The bulk DOS is already normalized per non-expanded cell</span>
        <span class="c1"># Hence the non-normalized quantity needs to be multiplied by</span>
        <span class="c1">#  product(bloch)</span>
        <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">norm</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;atom&quot;</span><span class="p">,</span> <span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">):</span>
            <span class="c1"># This is normalized per non-expanded unit-cell, so no need to do Bloch</span>
            <span class="n">fact</span> <span class="o">=</span> <span class="n">eV2Ry</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_dimension</span><span class="p">(</span><span class="s2">&quot;no_u&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fact</span> <span class="o">=</span> <span class="n">eV2Ry</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">bloch</span><span class="p">(</span><span class="n">elec</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">sum</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s2">&quot;DOS&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="s2">&quot;DOS&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="p">)</span> <span class="o">*</span> <span class="n">fact</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.current">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.current">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">current</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Current from `from` to `to` using the k-weights and energy spacings in the file.</span>

<span class="sd">        Calculates the current as:</span>

<span class="sd">        .. math::</span>
<span class="sd">           I(\mu_t - \mu_f) = \frac{e}{h}\int\!\mathrm{d}E\, T(E) [n_F(\mu_t, k_B T_t) - n_F(\mu_f, k_B T_f)]</span>

<span class="sd">        The chemical potential and the temperature are taken from this object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from: str, int, optional</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to: str, int, optional</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned current is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        current_parameter : to explicitly set the electronic temperature and chemical potentials</span>
<span class="sd">        chemical_potential : routine that defines the chemical potential of the queried electrodes</span>
<span class="sd">        kT : routine that defines the electronic temperature of the queried electrodes</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mu_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">kt_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kT</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">mu_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="n">kt_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kT</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_parameter</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">mu_f</span><span class="p">,</span> <span class="n">kt_f</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">mu_t</span><span class="p">,</span> <span class="n">kt_t</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.current_parameter">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.current_parameter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">current_parameter</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">:</span> <span class="n">ElecType</span><span class="p">,</span>
        <span class="n">mu_from</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kt_from</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="p">:</span> <span class="n">ElecType</span><span class="p">,</span>
        <span class="n">mu_to</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kt_to</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Current from `from` to `to` using the k-weights and energy spacings in the file.</span>

<span class="sd">        Calculates the current as:</span>

<span class="sd">        .. math::</span>
<span class="sd">           I(\mu_t - \mu_f) = \frac{e}{h}\int\!\mathrm{d}E\, T(E) [n_F(\mu_t, k_B T_t) - n_F(\mu_f, k_B T_f)]</span>

<span class="sd">        The chemical potential and the temperature are passed as arguments to</span>
<span class="sd">        this routine.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        mu_from:</span>
<span class="sd">           the chemical potential of the electrode (in eV)</span>
<span class="sd">        kt_from:</span>
<span class="sd">           the electronic temperature of the electrode (in eV)</span>
<span class="sd">        elec_to:</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        mu_to:</span>
<span class="sd">           the chemical potential of the electrode (in eV)</span>
<span class="sd">        kt_to:</span>
<span class="sd">           the electronic temperature of the electrode (in eV)</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned current is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        current : which calculates the current with the chemical potentials and temperatures set in the TBtrans calculation</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">elec_from</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">elec_to</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="c1"># Get energies</span>
        <span class="n">idx_sort</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argsort_E</span><span class="p">()</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>
        <span class="n">T</span> <span class="o">=</span> <span class="n">T</span><span class="p">[</span><span class="n">idx_sort</span><span class="p">]</span>

        <span class="n">dE</span> <span class="o">=</span> <span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">window_warning</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.current_parameter&quot;</span><span class="p">,</span>
            <span class="n">E</span><span class="p">,</span>
            <span class="n">elec_from</span><span class="p">,</span>
            <span class="n">mu_from</span><span class="p">,</span>
            <span class="n">kt_from</span><span class="p">,</span>
            <span class="n">elec_to</span><span class="p">,</span>
            <span class="n">mu_to</span><span class="p">,</span>
            <span class="n">kt_to</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="n">I</span> <span class="o">=</span> <span class="p">(</span>
            <span class="n">T</span> <span class="o">*</span> <span class="n">dE</span> <span class="o">*</span> <span class="p">(</span><span class="n">fermi_dirac</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">kt_from</span><span class="p">,</span> <span class="n">mu_from</span><span class="p">)</span> <span class="o">-</span> <span class="n">fermi_dirac</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">kt_to</span><span class="p">,</span> <span class="n">mu_to</span><span class="p">))</span>
        <span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">I</span> <span class="o">*</span> <span class="n">constant</span><span class="o">.</span><span class="n">q</span> <span class="o">/</span> <span class="n">constant</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="s2">&quot;eV s&quot;</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_check_Teig</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func_name</span><span class="p">,</span> <span class="n">TE</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.001</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal method to check whether all transmission eigenvalues are present&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="o">.</span><span class="n">reduce</span><span class="p">(</span><span class="n">TE</span> <span class="o">&gt;</span> <span class="n">atol</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)):</span>
            <span class="n">info</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">func_name</span><span class="si">}</span><span class="s2"> does possibly not have all relevant transmission eigenvalues in the &quot;</span>
                <span class="s2">&quot;calculation. For some energy values all transmission eigenvalues are above </span><span class="si">{atol}</span><span class="s2">!&quot;</span>
            <span class="p">)</span>

<div class="viewcode-block" id="tbtncSileTBtrans.shot_noise">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.shot_noise">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">shot_noise</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">classical</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Shot-noise term `from` to `to` using the k-weights</span>

<span class="sd">        Calculates the shot-noise term according to `classical` (also known as the Poisson value).</span>
<span class="sd">        If `classical` is True the shot-noise calculated is:</span>

<span class="sd">        .. math::</span>
<span class="sd">           S_P(E, V) = \frac{2e^2}{h}|V|\sum_k\sum_n T_{k,n}(E) w_k = \frac{2e^3}{h}|V|T(E)</span>

<span class="sd">        while for `classical` False (default) the Fermi-Dirac statistics is taken into account:</span>

<span class="sd">        .. math::</span>
<span class="sd">           S(E, V) = \frac{2e^2}{h}|V|\sum_k\sum_n T_{k,n}(E) [1 - T_{k,n}(E)] w_k</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SislInfo</span>
<span class="sd">            If *all* of the calculated :math:`T_{k,n}(E)` values in the file are above 0.001.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to:</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        classical:</span>
<span class="sd">           which shot-noise to calculate, default to non-classical</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned shot-noise is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fano : the ratio between the quantum mechanial and the classical shot noise.</span>
<span class="sd">        noise_power : temperature dependent noise power</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">mu_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">mu_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="c1"># The applied bias between the two electrodes</span>
        <span class="n">eV</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">mu_f</span> <span class="o">-</span> <span class="n">mu_t</span><span class="p">)</span>
        <span class="c1"># Pre-factor</span>
        <span class="c1"># 2 e ^ 3 V / h</span>
        <span class="c1"># Note that h in eV units will cancel the units in the applied bias</span>
        <span class="n">noise_const</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">constant</span><span class="o">.</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="p">(</span><span class="n">eV</span> <span class="o">/</span> <span class="n">constant</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="s2">&quot;eV s&quot;</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">classical</span><span class="p">:</span>
            <span class="c1"># Calculate the Poisson shot-noise (equal to 2eI in the low T and zero kT limit)</span>
            <span class="k">return</span> <span class="n">noise_const</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>

        <span class="c1"># Non-classical</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kavg</span><span class="p">:</span>
                <span class="c1"># The user wants it k-resolved</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;shot_noise&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">noise_const</span> <span class="o">*</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

            <span class="c1"># We need to manually weigh the k-points</span>
            <span class="n">wkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wkpt</span>

            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;shot_noise&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">sn</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nkpt</span><span class="p">):</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ik</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;shot_noise&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
                <span class="n">sn</span> <span class="o">+=</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;shot_noise&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">sn</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">noise_const</span> <span class="o">*</span> <span class="n">sn</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.noise_power">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.noise_power">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">noise_power</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Noise power `from` to `to` using the k-weights and energy spacings in the file (temperature dependent)</span>

<span class="sd">        Calculates the noise power as</span>

<span class="sd">        .. math::</span>
<span class="sd">           S(V) = \frac{2e^2}{h}\sum_k\sum_n \int\mathrm d E</span>
<span class="sd">                  \big\{&amp;T_{k,n}(E)[f_L(1-f_L)+f_R(1-f_R)] +</span>
<span class="sd">           \\</span>
<span class="sd">                        &amp;T_{k,n}(E)[1 - T_{k,n}(E)](f_L - f_R)^2\big\} w_k</span>

<span class="sd">        Where :math:`f_i` are the Fermi-Dirac distributions for the electrodes.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SislInfo</span>
<span class="sd">            If *all* of the calculated :math:`T_{k,n}(E)` values in the file are above 0.001.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to:</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned noise-power is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        fano : the ratio between the quantum mechanial and the classical shot noise.</span>
<span class="sd">        shot_noise : shot-noise term (zero temperature limit)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">kT_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kT</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">kT_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kT</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="n">mu_f</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_from</span><span class="p">)</span>
        <span class="n">mu_t</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec_to</span><span class="p">)</span>
        <span class="n">fd_f</span> <span class="o">=</span> <span class="n">fermi_dirac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">kT_f</span><span class="p">,</span> <span class="n">mu_f</span><span class="p">)</span>
        <span class="n">fd_t</span> <span class="o">=</span> <span class="n">fermi_dirac</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">kT_t</span><span class="p">,</span> <span class="n">mu_t</span><span class="p">)</span>

        <span class="c1"># Get the energy spacing (probably we should add a routine)</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="c1"># Pre-calculate the factors</span>
        <span class="n">eq_fac</span> <span class="o">=</span> <span class="n">dE</span> <span class="o">*</span> <span class="p">(</span><span class="n">fd_f</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fd_f</span><span class="p">)</span> <span class="o">+</span> <span class="n">fd_t</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">fd_t</span><span class="p">))</span>
        <span class="n">neq_fac</span> <span class="o">=</span> <span class="n">dE</span> <span class="o">*</span> <span class="p">(</span><span class="n">fd_f</span> <span class="o">-</span> <span class="n">fd_t</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span>
        <span class="k">del</span> <span class="n">fd_f</span><span class="p">,</span> <span class="n">fd_t</span>

        <span class="c1"># Pre-factor</span>
        <span class="c1"># 2 e ^ 2 / h</span>
        <span class="c1"># Note that h in eV units will cancel the units in the dE integration</span>
        <span class="n">noise_const</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">constant</span><span class="o">.</span><span class="n">q</span><span class="o">**</span><span class="mi">2</span> <span class="o">/</span> <span class="n">constant</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="s2">&quot;eV s&quot;</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">noise</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">eq</span><span class="p">,</span> <span class="n">neq</span><span class="p">):</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">T</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">eq</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="p">((</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">neq</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Determine the k-average</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kavg</span><span class="p">:</span>
                <span class="c1"># The user wants it k-resolved</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;noise_power&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">noise_const</span> <span class="o">*</span> <span class="n">noise</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">eq_fac</span><span class="p">,</span> <span class="n">neq_fac</span><span class="p">)</span>

            <span class="c1"># We need to manually weigh the k-points</span>
            <span class="n">wkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wkpt</span>

            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;noise_power&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
            <span class="c1"># Separate the calculation into two terms (see Ya.M. Blanter, M. Buttiker, Physics Reports 336 2000)</span>
            <span class="n">np</span> <span class="o">=</span> <span class="n">noise</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">eq_fac</span><span class="p">,</span> <span class="n">neq_fac</span><span class="p">)</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nkpt</span><span class="p">):</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ik</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;noise_power&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
                <span class="n">np</span> <span class="o">+=</span> <span class="n">noise</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">eq_fac</span><span class="p">,</span> <span class="n">neq_fac</span><span class="p">)</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;noise_power&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">np</span> <span class="o">=</span> <span class="n">noise</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">eq_fac</span><span class="p">,</span> <span class="n">neq_fac</span><span class="p">)</span>

        <span class="c1"># Do final conversion</span>
        <span class="k">return</span> <span class="n">noise_const</span> <span class="o">*</span> <span class="n">np</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.fano">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.fano">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;zero_T&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument zero_T has been deprecated in favor of atol, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">fano</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec_from</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_to</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-6</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; The Fano-factor for the calculation (requires calculated transmission eigenvalues)</span>

<span class="sd">        Calculate the Fano factor defined as (or through the shot-noise):</span>

<span class="sd">        .. math::</span>
<span class="sd">           F(E) &amp;= \frac{\sum_{k,n} T_{k,n}(E)[1 - T_{k,n}(E)] w_k}{\sum_{k,n} T_{k,n}(E) w_k}</span>
<span class="sd">           \\</span>
<span class="sd">               &amp;= S(E, V) / S_P(E, V)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        The default `zero_T` may change in the future.</span>
<span class="sd">        This calculation will *only* work for non-polarized calculations since the divisor needs</span>
<span class="sd">        to be the spin-sum.</span>
<span class="sd">        The current implementation uses the full transmission as the divisor.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        For a spin-polarized calculation one should calculate the Fano factor as:</span>

<span class="sd">        &gt;&gt;&gt; up = get_sile(&#39;siesta.TBT_UP.nc&#39;)</span>
<span class="sd">        &gt;&gt;&gt; down = get_sile(&#39;siesta.TBT_DN.nc&#39;)</span>
<span class="sd">        &gt;&gt;&gt; fano = up.fano() * up.transmission() + down.fano() * down.transmission()</span>
<span class="sd">        &gt;&gt;&gt; fano /= up.transmission() + down.transmission()</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec_from:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_to:</span>
<span class="sd">           the absorbing electrode (different from `elec_from`)</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned Fano factor is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned. In any case the divisor will always be the k-averaged transmission.</span>
<span class="sd">        atol :</span>
<span class="sd">           any transmission eigen value lower than this value will be treated as exactly 0.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        shot_noise : shot-noise term (zero temperature limit)</span>
<span class="sd">        noise_power : temperature dependent noise power</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">dividend</span><span class="p">(</span><span class="n">T</span><span class="p">):</span>
            <span class="n">T</span><span class="p">[</span><span class="n">T</span> <span class="o">&lt;=</span> <span class="n">atol</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span> <span class="p">(</span><span class="mi">1</span> <span class="o">-</span> <span class="n">T</span><span class="p">))</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">kavg</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">kavg</span><span class="p">:</span>
                <span class="c1"># The user wants it k-resolved</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;fano&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
                <span class="n">fano</span> <span class="o">=</span> <span class="n">dividend</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">)</span>
                <span class="n">fano</span> <span class="o">/=</span> <span class="n">T</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
                <span class="n">fano</span><span class="p">[:,</span> <span class="n">T</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
                <span class="k">return</span> <span class="n">fano</span>

            <span class="c1"># We need to manually weigh the k-points</span>
            <span class="n">wkpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wkpt</span>

            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;fano&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">fano</span> <span class="o">=</span> <span class="n">dividend</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">ik</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nkpt</span><span class="p">):</span>
                <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ik</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;fano&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
                <span class="n">fano</span> <span class="o">+=</span> <span class="n">dividend</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_check_Teig</span><span class="p">(</span><span class="s2">&quot;fano&quot;</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
            <span class="n">fano</span> <span class="o">=</span> <span class="n">dividend</span><span class="p">(</span><span class="n">T</span><span class="p">)</span>

        <span class="c1"># Divide by k-averaged transmission</span>
        <span class="n">T</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">elec_from</span><span class="p">,</span> <span class="n">elec_to</span><span class="p">)</span>
        <span class="n">fano</span> <span class="o">/=</span> <span class="n">T</span>
        <span class="n">fano</span><span class="p">[</span><span class="n">T</span> <span class="o">&lt;=</span> <span class="mf">0.0</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">return</span> <span class="n">fano</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_sparse_data</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">elec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ElecType</span><span class="p">],</span> <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span> <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal routine for retrieving sparse data (orbital current, COOP)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">elec</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>

        <span class="c1"># retrieve and return data</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value_E</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sparse_data_to_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal routine for retrieving sparse data (orbital current, COOP)&quot;&quot;&quot;</span>
        <span class="c1"># Get the geometry for obtaining the sparsity pattern.</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>

        <span class="c1"># These are the row-pointers...</span>
        <span class="n">ncol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s2">&quot;n_col&quot;</span><span class="p">)</span>

        <span class="c1"># Get column indices</span>
        <span class="n">col</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_value</span><span class="p">(</span><span class="s2">&quot;list_col&quot;</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>

        <span class="c1"># get subset orbitals</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">orbitals</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">orbitals</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">_sanitize_orbs</span><span class="p">(</span><span class="n">orbitals</span><span class="p">)</span>

            <span class="c1"># select values for all supercells</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">add</span><span class="o">.</span><span class="n">outer</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">),</span> <span class="n">orbitals</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># get both row and column indices</span>
            <span class="n">row_nonzero</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Now we have [0 0 0 0 1 1 1 1 2 2 ... no-1 no-1]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row_nonzero</span><span class="p">,</span> <span class="n">ncol</span><span class="p">[</span><span class="n">row_nonzero</span><span class="p">])</span>

            <span class="c1"># now figure out all places where we</span>
            <span class="c1"># have the corresponding values</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">all_col</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">all_col</span><span class="p">))</span>

            <span class="c1"># reduce space</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">all_col</span><span class="p">]</span>
            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">all_col</span><span class="p">]</span>

            <span class="c1"># now calculate new subset rows</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">nrow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">row</span><span class="p">[</span><span class="n">all_col</span><span class="p">],</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
            <span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">nrow</span>
            <span class="k">del</span> <span class="n">row</span><span class="p">,</span> <span class="n">nrow</span>

        <span class="n">rptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>

        <span class="c1"># Default matrix size</span>
        <span class="n">mat_size</span> <span class="o">=</span> <span class="p">[</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span><span class="p">]</span>

        <span class="c1"># Figure out the super-cell indices that are requested</span>
        <span class="c1"># First we figure out the indices, then</span>
        <span class="c1"># we build the array of allowed columns</span>
        <span class="k">if</span> <span class="n">isc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">isc</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]</span>

        <span class="c1"># reset for next phase</span>
        <span class="n">all_col</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">isc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">isc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="c1"># The user has requested specific supercells</span>
            <span class="c1"># Here we create a list of supercell interactions.</span>

            <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>
            <span class="c1"># Shorten to the unit-cell if there are no more</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">isc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="c1"># Small function for creating the supercells allowed</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">ret_range</span><span class="p">(</span><span class="n">val</span><span class="p">,</span> <span class="n">req</span><span class="p">):</span>
                <span class="n">i</span> <span class="o">=</span> <span class="n">val</span> <span class="o">//</span> <span class="mi">2</span>
                <span class="k">if</span> <span class="n">req</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">return</span> <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
                <span class="k">return</span> <span class="p">[</span><span class="n">req</span><span class="p">]</span>

            <span class="n">x</span> <span class="o">=</span> <span class="n">ret_range</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">ret_range</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">ret_range</span><span class="p">(</span><span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">isc</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>

            <span class="c1"># Make a shrinking logical array for selecting a subset of the</span>
            <span class="c1"># orbital currents...</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyi</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">z</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="p">(</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)):</span>
                <span class="n">all_col</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc_index</span><span class="p">([</span><span class="n">ix</span><span class="p">,</span> <span class="n">iy</span><span class="p">,</span> <span class="n">iz</span><span class="p">])</span>

            <span class="c1"># Transfer all_col to the range</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">array_arangei</span><span class="p">(</span>
                <span class="n">all_col</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="n">_a</span><span class="o">.</span><span class="n">fulli</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">all_col</span><span class="p">),</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># get both row and column indices</span>
            <span class="n">row_nonzero</span> <span class="o">=</span> <span class="p">(</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Now we have [0 0 0 0 1 1 1 1 2 2 ... no-1 no-1]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row_nonzero</span><span class="p">,</span> <span class="n">ncol</span><span class="p">[</span><span class="n">row_nonzero</span><span class="p">])</span>

            <span class="c1"># Create a logical array for sub-indexing</span>
            <span class="n">all_col</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isin</span><span class="p">(</span><span class="n">col</span><span class="p">,</span> <span class="n">all_col</span><span class="p">)</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">all_col</span><span class="p">]</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">all_col</span><span class="p">]</span>

            <span class="c1"># now calculate new subset rows</span>
            <span class="n">row</span><span class="p">,</span> <span class="n">nrow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">return_counts</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">ncol</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">)</span>
            <span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">]</span> <span class="o">=</span> <span class="n">nrow</span>

            <span class="n">rptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">ncol</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">nrow</span>

            <span class="n">data</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">all_col</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">data</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">rptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="n">mat_size</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sparse_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">name</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ElecType</span><span class="p">],</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Internal routine for retrieving sparse matrices (orbital current, COOP)&quot;&quot;&quot;</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data_to_matrix</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span>

<div class="viewcode-block" id="tbtncSileTBtrans.sparse_orbital_to_atom">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.sparse_orbital_to_atom">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sparse_orbital_to_atom</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">Dij</span><span class="p">,</span> <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">sum_dup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce a sparse matrix in orbital sparse to a sparse matrix in atomic indices</span>

<span class="sd">        This algorithm *may* keep the same non-zero entries, but will return</span>
<span class="sd">        a new csr_matrix with duplicate indices.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine may be moved to a ``sisl.utility`` at some point since it would</span>
<span class="sd">        be a generic routine usable for other parts of `sisl`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dij : scipy.sparse.csr_matrix</span>
<span class="sd">           the input sparse matrix in orbital format</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned data are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>
<span class="sd">        sum_dup :</span>
<span class="sd">           duplicates will be summed if this is true, in this case, no duplicates are</span>
<span class="sd">           present in the returned sparse matrix. If false, duplicates may exist for</span>
<span class="sd">           multi-orbital systems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>
        <span class="n">o2a</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">uc</span><span class="p">:</span>
            <span class="n">uc</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">Dij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># We convert to atomic bond-currents</span>
        <span class="k">if</span> <span class="n">uc</span><span class="p">:</span>
            <span class="n">Dab</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Dij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">map_col</span><span class="p">(</span><span class="n">c</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">o2a</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="o">%</span> <span class="n">na</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">Dab</span> <span class="o">=</span> <span class="n">csr_matrix</span><span class="p">((</span><span class="n">na</span><span class="p">,</span> <span class="n">na</span> <span class="o">*</span> <span class="n">geom</span><span class="o">.</span><span class="n">n_s</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">Dij</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>

            <span class="n">map_col</span> <span class="o">=</span> <span class="n">o2a</span>

        <span class="c1"># Lets do array notation for speeding up the computations</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">issparse</span><span class="p">(</span><span class="n">Dij</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Dij</span><span class="o">.</span><span class="n">format</span> <span class="o">==</span> <span class="s2">&quot;csr&quot;</span><span class="p">):</span>
            <span class="n">Dij</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">tocsr</span><span class="p">()</span>

        <span class="c1"># Check for the simple case of 1-orbital systems</span>
        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span><span class="p">:</span>
            <span class="c1"># In this case it is extremely easy!</span>
            <span class="c1"># Just copy to the new data</span>

            <span class="c1"># Transfer all columns to the new columns</span>
            <span class="n">Dab</span><span class="o">.</span><span class="n">indptr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">indptr</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">uc</span><span class="p">:</span>
                <span class="n">Dab</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dij</span><span class="o">.</span><span class="n">indices</span> <span class="o">%</span> <span class="n">na</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">Dab</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">indices</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># The multi-orbital case</span>

            <span class="c1"># Loop all atoms to make the new pointer array</span>
            <span class="c1"># I.e. a consecutive array of pointers starting from</span>
            <span class="c1">#   firsto[.] .. lasto[.]</span>
            <span class="n">iptr</span> <span class="o">=</span> <span class="n">Dij</span><span class="o">.</span><span class="n">indptr</span>
            <span class="c1"># Get first orbital</span>
            <span class="n">fo</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">firsto</span>
            <span class="c1"># Automatically create the new index pointer</span>
            <span class="c1"># from first and last orbital</span>
            <span class="n">indptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">iptr</span><span class="p">[</span><span class="n">fo</span><span class="p">[</span><span class="mi">1</span><span class="p">:]]</span> <span class="o">-</span> <span class="n">iptr</span><span class="p">[</span><span class="n">fo</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]])</span>

            <span class="c1"># Now we have a new indptr, and the column indices have also</span>
            <span class="c1"># been processed.</span>
            <span class="n">Dab</span><span class="o">.</span><span class="n">indptr</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">indptr</span><span class="p">[:]</span>
            <span class="c1"># Transfer all columns to the new columns</span>
            <span class="n">Dab</span><span class="o">.</span><span class="n">indices</span> <span class="o">=</span> <span class="n">map_col</span><span class="p">(</span><span class="n">Dij</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Copy data</span>
        <span class="n">Dab</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">Dij</span><span class="o">.</span><span class="n">data</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">sum_dup</span><span class="p">:</span>
            <span class="n">Dab</span><span class="o">.</span><span class="n">sum_duplicates</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">Dab</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.sparse_atom_to_vector">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.sparse_atom_to_vector">[docs]</a>
    <span class="nd">@wrap_filterwarnings</span><span class="p">(</span><span class="s2">&quot;ignore&quot;</span><span class="p">,</span> <span class="n">category</span><span class="o">=</span><span class="n">SparseEfficiencyWarning</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">sparse_atom_to_vector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dab</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce an atomic sparse matrix to a vector contribution of each atom</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine may be moved to a ``sisl.utility`` at some point since it would</span>
<span class="sd">        be a generic routine usable for other parts of `sisl`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dab : scipy.sparse.csr_matrix</span>
<span class="sd">           the input sparse matrix in atomic indices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">na</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span>

        <span class="c1"># vector</span>
        <span class="n">V</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="n">na</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>

        <span class="c1"># Loop atoms in the device region</span>
        <span class="c1"># These are the only atoms which may have vector contributions</span>
        <span class="c1"># So no need to loop over any other atoms</span>
        <span class="n">getrow</span> <span class="o">=</span> <span class="n">Dab</span><span class="o">.</span><span class="n">getrow</span>
        <span class="n">Rij</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">Rij</span>

        <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">a_dev</span><span class="p">:</span>
            <span class="c1"># Get csr matrix</span>
            <span class="n">Dia</span> <span class="o">=</span> <span class="n">getrow</span><span class="p">(</span><span class="n">ia</span><span class="p">)</span>

            <span class="c1"># Set diagonal to zero</span>
            <span class="n">Dia</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">ia</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
            <span class="c1"># Remove the diagonal (prohibits the calculation of the</span>
            <span class="c1"># norm of the zero vector, hence required)</span>
            <span class="n">Dia</span><span class="o">.</span><span class="n">eliminate_zeros</span><span class="p">()</span>

            <span class="c1"># Now calculate the vector elements</span>
            <span class="c1"># Remark that the vector goes from ia -&gt; ja</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">Rij</span><span class="p">(</span><span class="n">ia</span><span class="p">,</span> <span class="n">Dia</span><span class="o">.</span><span class="n">indices</span><span class="p">)</span>
            <span class="n">rv</span> <span class="o">=</span> <span class="n">rv</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">rv</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))[:,</span> <span class="kc">None</span><span class="p">]</span>
            <span class="n">V</span><span class="p">[</span><span class="n">ia</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">Dia</span><span class="o">.</span><span class="n">data</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="n">rv</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">V</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.sparse_orbital_to_vector">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.sparse_orbital_to_vector">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sparse_orbital_to_vector</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">Dij</span><span class="p">,</span> <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">sum_dup</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reduce an orbital sparse matrix to a vector contribution of each atom</span>

<span class="sd">        Equivalent to calling `sparse_orbital_to_atom` and `sparse_atom_to_vector`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine may be moved to a ``sisl.utility`` at some point since it would</span>
<span class="sd">        be a generic routine usable for other parts of `sisl`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dij : scipy.sparse.csr_matrix</span>
<span class="sd">           the input sparse matrix</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned data are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>
<span class="sd">        sum_dup :</span>
<span class="sd">           duplicates will be summed if this is true, in this case, no duplicates are</span>
<span class="sd">           present in the returned sparse matrix. If false, duplicates may exist for</span>
<span class="sd">           multi-orbital systems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Dab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_atom</span><span class="p">(</span><span class="n">Dij</span><span class="p">,</span> <span class="n">uc</span><span class="p">,</span> <span class="n">sum_dup</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_atom_to_vector</span><span class="p">(</span><span class="n">Dab</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.sparse_orbital_to_scalar">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.sparse_orbital_to_scalar">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">sparse_orbital_to_scalar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">Dij</span><span class="p">,</span> <span class="n">activity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic scalar contribution of atoms for a sparse orbital matrix</span>

<span class="sd">        The atomic contribution is a single number specifying a figure of the *magnitude*</span>
<span class="sd">        of sparse matrix elements for each atom. It is thus *not* a quantity that can be related to</span>
<span class="sd">        any physical quantity that the sparse matrix may represent but is merely a number that provides an</span>
<span class="sd">        idea of *how much* this atom is governing the data in the matrix.</span>

<span class="sd">        The atomic contribution may have two meanings based on these two equations</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf a_I^{|a|} &amp;=\frac 12 \sum_{\{J\}} \Big| \sum_{i\in I}\sum_{j\in J} \mathbf A_{ij} \Big|</span>
<span class="sd">            \\</span>
<span class="sd">            \mathbf a_I^{|o|} &amp;=\frac 12 \sum_{i\in I}\sum_{j\in\{J\}} \big| A_{ij} \big|</span>

<span class="sd">        If the *activity* is requested (``activity=True``)</span>
<span class="sd">        :math:`\mathbf a_I^{\mathcal A} = \sqrt{\mathbf a_I^{|a|} \mathbf a_I^{|o|} }` is returned.</span>

<span class="sd">        If ``activity=False`` :math:`\mathbf a_I^{|a|}` is returned.</span>

<span class="sd">        For geometries with all atoms only having 1-orbital, they are equivalent.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Dij: scipy.sparse.csr_matrix</span>
<span class="sd">           the orbital sparse matrix.</span>
<span class="sd">        activity:</span>
<span class="sd">           ``True`` to return the atomic activity, see explanation above</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        This routine may be moved to a ``sisl.utility`` at some point since it would</span>
<span class="sd">        be a generic routine usable for other parts of `sisl`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_current(0, -1.03, what=&quot;both&quot;) # orbital current @ E = -1 eV originating from electrode ``0``</span>
<span class="sd">        &gt;&gt;&gt; Ja = tbt.sparse_orbital_to_scalar(Jij)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create the bond-currents with all summations</span>
        <span class="n">Dab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_atom</span><span class="p">(</span><span class="n">Dij</span><span class="p">)</span>
        <span class="c1"># We take the absolute and sum it over all connecting atoms</span>
        <span class="n">Da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Dab</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">activity</span><span class="p">:</span>
            <span class="c1"># Calculate the absolute summation of all orbital</span>
            <span class="c1"># currents and transfer it to a bond-current</span>
            <span class="n">Dab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_atom</span><span class="p">(</span><span class="nb">abs</span><span class="p">(</span><span class="n">Dij</span><span class="p">))</span>

            <span class="c1"># Sum to make it per atom, it is already the absolute</span>
            <span class="n">Do</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">Dab</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

            <span class="c1"># Return the geometric mean of the atomic current X orbital</span>
            <span class="c1"># current.</span>
            <span class="n">Da</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">Da</span> <span class="o">*</span> <span class="n">Do</span><span class="p">)</span>

        <span class="c1"># Scale correctly</span>
        <span class="n">Da</span> <span class="o">*=</span> <span class="mf">0.5</span>

        <span class="k">return</span> <span class="n">Da</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.orbital_transmission">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_transmission">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.T.Orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;TBT.Current.Orb&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbital_transmission</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Transmission at energy `E` between orbitals originating from `elec`</span>

<span class="sd">        Each matrix element of the sparse matrix corresponds to the orbital indices of the</span>
<span class="sd">        underlying geometry (including buffer and electrode atoms).</span>

<span class="sd">        When requesting orbital-transmissions it is vital to consider how the data needs to be analysed</span>
<span class="sd">        before extracting the data. For instance, if only local transmission pathways are interesting one should</span>
<span class="sd">        use ``what=&quot;+&quot;`` to retain the positive orbital transmissions.</span>
<span class="sd">        While if one is interested in the transmission between subset of orbitals,</span>
<span class="sd">        ``what=&quot;all&quot;`` is the correct method to account for loop transmissions.</span>

<span class="sd">        The orbital transmissions are calculated as described in the TBtrans manual:</span>

<span class="sd">        .. math::</span>
<span class="sd">            T_{ij}(E) = i [</span>
<span class="sd">            (\mathbf H_{ji} - E\mathbf S_{ji}) \mathbf A_{ij}(E)</span>
<span class="sd">            -</span>
<span class="sd">            (\mathbf H_{ij} - E\mathbf S_{ij}) \mathbf A_{ji}(E)],</span>

<span class="sd">        It is easy to show that the above matrix obeys :math:`T_{ij}=-T_{ji}`.</span>

<span class="sd">        For inexperienced users it is adviced to try out all three values of ``what`` to ensure</span>
<span class="sd">        the correct physics is obtained.</span>

<span class="sd">        This becomes even more important when the orbital transmissions are calculated with magnetic</span>
<span class="sd">        fields. With :math:`\mathbf B` fields local transmission loops may form and the pathways does</span>
<span class="sd">        not necessarily flow along the transport direction.</span>

<span class="sd">        For correct interpretation of the orbital transmissions it is vital that one integrates the full</span>
<span class="sd">        Brillouin zone without any symmetry operations, see Section 5.4 in :cite:`Papior2016`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the orbital transmission corresponding to the energy.</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned orbital transmission is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned transmissions from the unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all transmissions for the supercell.</span>
<span class="sd">           To only get unit cell transmissions, pass ``[0, 0, 0]``.</span>
<span class="sd">        what : {&quot;all&quot;/&quot;both&quot;/&quot;+-&quot;/&quot;inout&quot;, &quot;+&quot;/&quot;out&quot;, &quot;-&quot;/&quot;in&quot;}</span>
<span class="sd">           which transmissions to return, all, positive (outgoing) or negative (incoming).</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain transmissions for a subset of orbitals (including their supercell equivalents)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A `scipy.sparse.csr_matrix` containing the supercell transmission pathways, or</span>
<span class="sd">        orbital transmissions.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_transmission(-1.0) # orbital current @ E = -1 eV originating from electrode ``0``</span>
<span class="sd">        &gt;&gt;&gt; Jij[10, 11] # orbital transmission from the 11th to the 12th orbital</span>

<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_transmission(-1.0,</span>
<span class="sd">        ...     orbitals={tbt.geometry.atoms[0]: [0, 1]})</span>

<span class="sd">        only retain transmissions from 1st and 2nd orbitals on first atom type (all atoms of</span>
<span class="sd">        that type in the entire structure.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_current : bias window integrated transmissions</span>
<span class="sd">        bond_transmission : energy resolved transmissions between atoms</span>
<span class="sd">        bond_current : bias window integrated transmissions (orbital current summed over orbitals)</span>
<span class="sd">        vector_transmission : an atomic field transmission for each atom (Cartesian representation of bond-transmissions)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        atom_transmission : energy resolved atomic transmission for each atom (scalar representation of bond-transmissions)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">J</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_matrix</span><span class="p">(</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;+&quot;</span><span class="p">,</span> <span class="s2">&quot;out&quot;</span><span class="p">):</span>
            <span class="n">J</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">J</span><span class="o">.</span><span class="n">data</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="p">,</span> <span class="s2">&quot;in&quot;</span><span class="p">):</span>
            <span class="n">J</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">J</span><span class="o">.</span><span class="n">data</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">elif</span> <span class="n">what</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="s2">&quot;-+&quot;</span><span class="p">,</span> <span class="s2">&quot;inout&quot;</span><span class="p">,</span> <span class="s2">&quot;outin&quot;</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.orbital_transmission &#39;what&#39; keyword has &quot;</span>
                <span class="s2">&quot;wrong value [all/both/+-, +/out,-/in] allowed.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># do not delete explicit 0&#39;s as the user can then know the sparse matrices</span>
        <span class="c1"># calculated.</span>
        <span class="c1"># Users can them-selves remove them (eliminate_zeros)</span>

        <span class="k">return</span> <span class="n">J</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.orbital_current">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_current">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.T.Orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">),</span> <span class="p">(</span><span class="s2">&quot;TBT.Current.Orb&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbital_current</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_other</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Orbital current originating from `elec` as a sparse matrix</span>

<span class="sd">        This is the bias window integrated quantity of `orbital_transmission`. As such it</span>
<span class="sd">        represents how the current is flowing at an applied bias from a given electrode.</span>

<span class="sd">        .. math::</span>
<span class="sd">            J_{ij} = \frac eh\int_{\mu_1}^{\mu_2} \!\mathrm dE\, T_{ij} [n_F(\mu_2, k_B T_2) - n_F(\mu_1, k_B T_1)]</span>

<span class="sd">        with :math:`T_{\langle\rangle}` being the electronic temperature of the respective reservoir.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_other:</span>
<span class="sd">           this electrode determines the *other* chemical potential. As such the orbital currents</span>
<span class="sd">           does not reflect the current going from `elec` *to* `elec_other`!</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned orbital current is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned bond currents from the unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all orbital currents for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        what : {&quot;all&quot;/&quot;both&quot;/&quot;+-&quot;/&quot;inout&quot;, &quot;+&quot;/&quot;out&quot;, &quot;-&quot;/&quot;in&quot;}</span>
<span class="sd">           which orbital currents to return, all, positive (outgoing) or negative (incoming).</span>
<span class="sd">           Default to ``&quot;all&quot;`` because it can then be used in the subsequent default</span>
<span class="sd">           arguments for `sparse_orbital_to_atom` and `sparse_orbital_to_scalar`.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain orbital currents for a subset of orbitals.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calculating the current between two electrodes with the same</span>
<span class="sd">        chemical potential will return a matrix filled with 0&#39;s since there is</span>
<span class="sd">        no bias window.</span>

<span class="sd">        The currents does not reflect the current going from `elec_from` *to* `elec_other`!</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_transmission : energy resolved transmission between orbitals</span>
<span class="sd">        bond_transmission : energy resolved transmissions between atoms</span>
<span class="sd">        bond_current : bias window integrated transmissions (orbital current summed over orbitals)</span>
<span class="sd">        vector_transmission : an atomic field transmission for each atom (Cartesian representation of bond-transmissions)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        atom_transmission : energy resolved atomic transmission for each atom (scalar representation of bond-transmissions)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get integrator</span>
        <span class="n">integrator</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bias_window_integrator</span><span class="p">(</span><span class="n">elec</span><span class="p">,</span> <span class="n">elec_other</span><span class="p">)</span>

        <span class="c1"># Do integration of data</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">func_out</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
            <span class="n">E</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">A</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data</span><span class="p">(</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>
            <span class="n">D</span><span class="p">[</span><span class="n">D</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">data</span> <span class="o">+</span> <span class="n">D</span> <span class="o">*</span> <span class="n">weight</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func_in</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
            <span class="n">E</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">A</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data</span><span class="p">(</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>
            <span class="n">D</span><span class="p">[</span><span class="n">D</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">return</span> <span class="n">data</span> <span class="o">+</span> <span class="n">D</span> <span class="o">*</span> <span class="n">weight</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func_all</span><span class="p">(</span><span class="n">data</span><span class="p">,</span> <span class="n">A</span><span class="p">):</span>
            <span class="n">E</span><span class="p">,</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">A</span>
            <span class="n">D</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data</span><span class="p">(</span><span class="s2">&quot;J&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">data</span> <span class="o">+</span> <span class="n">D</span> <span class="o">*</span> <span class="n">weight</span>

        <span class="c1"># nonlocal cannot be used in an if-statement</span>
        <span class="n">getdata</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;+&quot;</span><span class="p">:</span> <span class="n">func_out</span><span class="p">,</span>
            <span class="s2">&quot;out&quot;</span><span class="p">:</span> <span class="n">func_out</span><span class="p">,</span>
            <span class="s2">&quot;-&quot;</span><span class="p">:</span> <span class="n">func_in</span><span class="p">,</span>
            <span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">func_in</span><span class="p">,</span>
            <span class="s2">&quot;all&quot;</span><span class="p">:</span> <span class="n">func_all</span><span class="p">,</span>
            <span class="s2">&quot;inout&quot;</span><span class="p">:</span> <span class="n">func_all</span><span class="p">,</span>
            <span class="s2">&quot;outin&quot;</span><span class="p">:</span> <span class="n">func_all</span><span class="p">,</span>
            <span class="s2">&quot;+-&quot;</span><span class="p">:</span> <span class="n">func_all</span><span class="p">,</span>
            <span class="s2">&quot;-+&quot;</span><span class="p">:</span> <span class="n">func_all</span><span class="p">,</span>
            <span class="s2">&quot;both&quot;</span><span class="p">:</span> <span class="n">func_all</span><span class="p">,</span>
        <span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">what</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">getdata</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.orbital_current &#39;what&#39; keyword has &quot;</span>
                <span class="s2">&quot;wrong value [all/both/+-/inout, +/out,-/in] allowed.&quot;</span>
            <span class="p">)</span>

        <span class="n">J</span> <span class="o">=</span> <span class="n">reduce</span><span class="p">(</span><span class="n">getdata</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">,</span> <span class="n">integrator</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">E</span><span class="p">)),</span> <span class="mf">0.0</span><span class="p">)</span>

        <span class="k">return</span> <span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_data_to_matrix</span><span class="p">(</span><span class="n">J</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span>
            <span class="o">*</span> <span class="n">constant</span><span class="o">.</span><span class="n">q</span>
            <span class="o">/</span> <span class="n">constant</span><span class="o">.</span><span class="n">h</span><span class="p">(</span><span class="s2">&quot;eV s&quot;</span><span class="p">)</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.bond_transmission">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.bond_transmission">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bond_transmission</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Bond transmission between atoms at a specific energy</span>

<span class="sd">        Short hand function for calling `orbital_transmission` and `sparse_orbital_to_atom`.</span>

<span class="sd">        The bond transmissions are a sum over all orbital transmissions</span>

<span class="sd">        .. math::</span>
<span class="sd">           T_{IJ}(E) = \sum_{i\in I}\sum_{j\in J} T_{ij}(E)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the bond transmission corresponding to the energy.</span>
<span class="sd">        elec :</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        kavg :</span>
<span class="sd">           whether the returned bond transmissions is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">           the returned transmissions from the unit-cell (``[None, None, None]``) (default) to</span>
<span class="sd">           the given supercell. If ``[None, None, None]`` is passed all transmissions are returned.</span>
<span class="sd">        what : {&quot;all&quot;/&quot;both&quot;/&quot;+-&quot;/&quot;inout&quot;, &quot;+&quot;/&quot;out&quot;, &quot;-&quot;/&quot;in&quot;}</span>
<span class="sd">           If +/out is supplied only the positive transmissions are used (going out)</span>
<span class="sd">           for -/in, only the negative transmissions are used (going in),</span>
<span class="sd">           else return both. Please see discussion in `orbital_transmission`.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain transmissions for a subset of orbitals before calculating bond transmissions</span>
<span class="sd">           Passed directly to `orbital_transmission`.</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned transmissions are only in the unit-cell (supercell bonds will be folded to their unit-cell equivalents).</span>
<span class="sd">           If `True` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_transmission(-1.0, what=&quot;out&quot;) # orbital transmission @ E = -1 eV originating from electrode ``0``</span>
<span class="sd">        &gt;&gt;&gt; Jab1 = tbt.sparse_orbital_to_atom(Jij)[</span>
<span class="sd">        &gt;&gt;&gt; Jab2 = tbt.bond_transmission(-1.0, what=&quot;out&quot;)</span>
<span class="sd">        &gt;&gt;&gt; Jab1 == Jab2</span>
<span class="sd">        True</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_transmission : energy resolved transmission between orbitals</span>
<span class="sd">        orbital_current : bias window integrated transmissions</span>
<span class="sd">        bond_current : bias window integrated transmissions (orbital current summed over orbitals)</span>
<span class="sd">        vector_transmission : an atomic field transmission for each atom (Cartesian representation of bond-transmissions)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        atom_transmission : energy resolved atomic transmission for each atom (scalar representation of bond-transmissions)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_transmission</span><span class="p">(</span>
            <span class="n">E</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="n">what</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_atom</span><span class="p">(</span><span class="n">Jij</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="n">uc</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.bond_current">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.bond_current">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">bond_current</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_other</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Bond current between atoms (sum of orbital currents)</span>

<span class="sd">        Short hand function for calling `orbital_current` and `sparse_orbital_to_atom`.</span>

<span class="sd">        The bond currents are a sum over all orbital currents:</span>

<span class="sd">        .. math::</span>
<span class="sd">           J_{IJ} = \sum_{i\in I}\sum_{j\in J} J_{ij}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec :</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        elec_other:</span>
<span class="sd">           this electrode determines the *other* chemical potential. As such the orbital currents</span>
<span class="sd">           does not reflect the current going from `elec` *to* `elec_other`!</span>
<span class="sd">        kavg :</span>
<span class="sd">           whether the returned bond current is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc : array_like, optional</span>
<span class="sd">           the returned bond currents from the unit-cell (``[None, None, None]``) (default) to</span>
<span class="sd">           the given supercell. If ``[None, None, None]`` is passed all</span>
<span class="sd">           bond currents are returned.</span>
<span class="sd">        what : {&quot;all&quot;/&quot;both&quot;/&quot;+-&quot;/&quot;inout&quot;, &quot;+&quot;/&quot;out&quot;, &quot;-&quot;/&quot;in&quot;}</span>
<span class="sd">           If +/out is supplied only the positive currents are used (going out)</span>
<span class="sd">           for -/in, only the negative currents are used (going in),</span>
<span class="sd">           else return both. Please see discussion in `orbital_current`.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain currents for a subset of orbitals before calculating bond current</span>
<span class="sd">           Passed directly to `orbital_current`.</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned currents are only in the unit-cell (supercell currents</span>
<span class="sd">           will be folded to their unit-cell equivalents).</span>
<span class="sd">           If `True` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_current(0, 1, what=&quot;out&quot;) # orbital current originating from electrode ``0``</span>
<span class="sd">        &gt;&gt;&gt; Jab1 = tbt.sparse_orbital_to_atom(Jij)</span>
<span class="sd">        &gt;&gt;&gt; Jab2 = tbt.bond_current(0, 1, what=&quot;out&quot;)</span>
<span class="sd">        &gt;&gt;&gt; Jab1 == Jab2</span>
<span class="sd">        True</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calculating the current between two electrodes with the same</span>
<span class="sd">        chemical potential will return a matrix filled with 0&#39;s since there is</span>
<span class="sd">        no bias window.</span>

<span class="sd">        The currents does not reflect the current going from `elec_from` *to* `elec_other`!</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_transmission : energy resolved transmission between orbitals</span>
<span class="sd">        orbital_current : bias window integrated transmissions</span>
<span class="sd">        bond_transmission : energy resolved transmissions between atoms</span>
<span class="sd">        vector_transmission : an atomic field transmission for each atom (Cartesian representation of bond-transmissions)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        atom_transmission : energy resolved atomic transmission for each atom (scalar representation of bond-transmissions)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span>
            <span class="n">elec</span><span class="p">,</span> <span class="n">elec_other</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="n">what</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_atom</span><span class="p">(</span><span class="n">Jij</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="n">uc</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.vector_transmission">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.vector_transmission">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vector_transmission</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">what</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Vector for each atom being the sum of bond transmissions times the normalized bond vector between the atoms</span>

<span class="sd">        The vector transmission is defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">              \mathbf T_I = \sum_J \frac{\mathbf r^{(J)} - \mathbf r^{(I)}}{|\mathbf r^{(J)} - \mathbf r^{(I)}|} \cdot T_{IJ}</span>

<span class="sd">        Where :math:`T_{IJ}` is the bond transmission between atom :math:`I` and :math:`J` and</span>
<span class="sd">        :math:`\mathbf r^{(\langle\rangle)}` are the atomic coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the vector transmission corresponding to the energy.</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned vector transmission is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned vectors from the unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all vectors for the supercell.</span>
<span class="sd">           To only get unit cell vectors, pass ``[0, 0, 0]``.</span>
<span class="sd">        what : {&quot;all&quot;/&quot;both&quot;/&quot;+-&quot;/&quot;inout&quot;, &quot;+&quot;/&quot;out&quot;, &quot;-&quot;/&quot;in&quot;}</span>
<span class="sd">           The *outgoing* vectors may be retrieved by ``&quot;out&quot;``.</span>
<span class="sd">           The *incoming* vectors may be retrieved by ``&quot;in&quot;``, while the</span>
<span class="sd">           average incoming and outgoing direction can be obtained with ``&quot;both&quot;``.</span>
<span class="sd">           In the last case the vector transmissions are divided by 2 to ensure the length</span>
<span class="sd">           of the vector is compatible with the other options; given a pristine system.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain transmissions for a subset of orbitals before calculating bond transmissions</span>
<span class="sd">           Passed directly to `orbital_transmission`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of vectors per atom in the Geometry (only non-zero for device atoms)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_transmission : energy resolved transmission between orbitals</span>
<span class="sd">        orbital_current : bias window integrated transmissions</span>
<span class="sd">        bond_transmission : energy resolved transmissions between atoms</span>
<span class="sd">        bond_current : bias window integrated transmissions (orbital current summed over orbitals)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        atom_transmission : energy resolved atomic transmission for each atom (scalar representation of bond-transmissions)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_transmission</span><span class="p">(</span>
            <span class="n">E</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="n">what</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="s2">&quot;-+&quot;</span><span class="p">,</span> <span class="s2">&quot;inout&quot;</span><span class="p">,</span> <span class="s2">&quot;outin&quot;</span><span class="p">):</span>
            <span class="c1"># When we divide by two one can *always* compare the bulk</span>
            <span class="c1"># vector currents using either of the sum-rules.</span>
            <span class="c1"># I.e. it will be much easier to distinguish differences</span>
            <span class="c1"># between &quot;incoming&quot; and &quot;outgoing&quot;.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_atom_to_vector</span><span class="p">(</span><span class="n">Jab</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_atom_to_vector</span><span class="p">(</span><span class="n">Jab</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.vector_current">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.vector_current">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">vector_current</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_other</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">what</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;all&quot;</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Vector for each atom being the sum of bond currents times the normalized bond vector between the atoms</span>

<span class="sd">        The vector current is defined as:</span>

<span class="sd">        .. math::</span>
<span class="sd">              \mathbf J_I = \sum_J \frac{\mathbf r^{(J)} - \mathbf r^{(I)}}{|\mathbf r^{(J)} - \mathbf r^{(I)}|} \cdot J_{IJ}</span>

<span class="sd">        Where :math:`J_{IJ}` is the bond current between atom :math:`I` and :math:`J` and</span>
<span class="sd">        :math:`\mathbf r^{(\langle\rangle)}` are the atomic coordinates.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        elec_other:</span>
<span class="sd">           this electrode determines the *other* chemical potential. As such the vector currents</span>
<span class="sd">           does not reflect the current going from `elec` *to* `elec_other`!</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned vector current is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned currents from the unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all currents for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        what : {&quot;all&quot;/&quot;both&quot;/&quot;+-&quot;/&quot;inout&quot;, &quot;+&quot;/&quot;out&quot;, &quot;-&quot;/&quot;in&quot;}</span>
<span class="sd">           The *outgoing* currents may be retrieved by ``&quot;out&quot;``.</span>
<span class="sd">           The *incoming* currents may be retrieved by ``&quot;in&quot;``, while the</span>
<span class="sd">           average incoming and outgoing direction can be obtained with ``&quot;both&quot;``.</span>
<span class="sd">           In the last case the vector currents are divided by 2 to ensure the length</span>
<span class="sd">           of the vector is compatible with the other options given a pristine system.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain currents for a subset of orbitals before calculating currents</span>
<span class="sd">           Passed directly to `orbital_current`.</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calculating the current between two electrodes with the same</span>
<span class="sd">        chemical potential will return a matrix filled with 0&#39;s since there is</span>
<span class="sd">        no bias window.</span>

<span class="sd">        The currents does not reflect the current going from `elec_from` *to* `elec_other`!</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            array of vectors per atom in the Geometry (only non-zero for device atoms)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_transmission : energy resolved transmission between orbitals</span>
<span class="sd">        orbital_current : bias window integrated transmissions</span>
<span class="sd">        bond_transmission : energy resolved transmissions between atoms</span>
<span class="sd">        bond_current : bias window integrated transmissions (orbital current summed over orbitals)</span>
<span class="sd">        vector_transmission : an atomic field transmission for each atom (Cartesian representation of bond-transmissions)</span>
<span class="sd">        atom_transmission : energy resolved atomic transmission for each atom (scalar representation of bond-transmissions)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jab</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bond_current</span><span class="p">(</span>
            <span class="n">elec</span><span class="p">,</span> <span class="n">elec_other</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="n">what</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">what</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="s2">&quot;both&quot;</span><span class="p">,</span> <span class="s2">&quot;+-&quot;</span><span class="p">,</span> <span class="s2">&quot;-+&quot;</span><span class="p">,</span> <span class="s2">&quot;inout&quot;</span><span class="p">,</span> <span class="s2">&quot;outin&quot;</span><span class="p">):</span>
            <span class="c1"># When we divide by two one can *always* compare the bulk</span>
            <span class="c1"># vector currents using either of the sum-rules.</span>
            <span class="c1"># I.e. it will be much easier to distinguish differences</span>
            <span class="c1"># between &quot;incoming&quot; and &quot;outgoing&quot;.</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_atom_to_vector</span><span class="p">(</span><span class="n">Jab</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_atom_to_vector</span><span class="p">(</span><span class="n">Jab</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.atom_transmission">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_transmission">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">atom_transmission</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">activity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic transmission at energy `E` of atoms, a scalar quantity quantifying how much transmission flows through an atom</span>

<span class="sd">        The atomic transmission is a single number specifying a figure of the *magnitude*</span>
<span class="sd">        transmission flowing through each atom. It is thus *not* a quantity that can be related to</span>
<span class="sd">        the physical transmission flowing in/out of atoms but is merely a number that provides an</span>
<span class="sd">        idea of *how much* this atom is redistributing.</span>

<span class="sd">        The atomic transmission may have two meanings based on these two equations</span>

<span class="sd">        .. math::</span>
<span class="sd">            T_I^{|a|} &amp;=\frac 12 \sum_{\{J\}} \Big| \sum_{i\in I}\sum_{j\in J} \mathbf T_{ij} \Big|</span>
<span class="sd">            \\</span>
<span class="sd">            T_I^{|o|} &amp;=\frac 12 \sum_{i\in I}\sum_{j\in\{J\}} \big| T_{ij} \big|</span>
<span class="sd">        .. math::</span>

<span class="sd">        If the *activity* is requested (``activity=True``)</span>
<span class="sd">        :math:`T_I^{\mathcal A} = \sqrt{T_I^{|a|} T_I^{|o|} }` is returned.</span>
<span class="sd">        If the *activity* current is requested (``activity=True``)</span>

<span class="sd">        If ``activity=False`` :math:`T_I^{|a|}` is returned.</span>

<span class="sd">        For geometries with all atoms only having 1-orbital, they are equivalent.</span>

<span class="sd">        Generally the *activity* is a more rigorous figure of merit for the transmission</span>
<span class="sd">        flowing through an atom. More so than than the summed absolute atomic transmission due to</span>
<span class="sd">        the following reasoning. The activity transmission is a geometric mean of the absolute bond transmission</span>
<span class="sd">        and the absolute orbital transmission. This means that if there is an atom with a large orbital transmission</span>
<span class="sd">        it will have a larger activity.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the atomic transmission corresponding to the energy.</span>
<span class="sd">        elec:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        activity:</span>
<span class="sd">           ``True`` to return the activity, see explanation above</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned atomic transmissions are k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned transmissions from the unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all orbital transmissions are used for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain orbital currents for a subset of orbitals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_transmission(-1., what&quot;all&quot;) # transmission @ E=-1 eV from electrode ``0``</span>
<span class="sd">        &gt;&gt;&gt; Ja = tbt.sparse_orbital_to_scalar(Jij)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_transmission : energy resolved transmission between orbitals</span>
<span class="sd">        orbital_current : bias window integrated transmissions</span>
<span class="sd">        bond_transmission : energy resolved transmissions between atoms</span>
<span class="sd">        bond_current : bias window integrated transmissions (orbital current summed over orbitals)</span>
<span class="sd">        vector_transmission : an atomic field transmission for each atom (Cartesian representation of bond-transmissions)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        atom_current : the atomic current for each atom (scalar representation of bond-currents)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_transmission</span><span class="p">(</span>
            <span class="n">E</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_scalar</span><span class="p">(</span><span class="n">Jij</span><span class="p">,</span> <span class="n">activity</span><span class="o">=</span><span class="n">activity</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.atom_current">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_current">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">atom_current</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">elec_other</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
        <span class="n">activity</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Atomic current of atoms, a scalar quantity quantifying how much currents flows through an atom</span>

<span class="sd">        The atomic current is a single number specifying a figure of the *magnitude*</span>
<span class="sd">        current flowing through each atom. It is thus *not* a quantity that can be related to</span>
<span class="sd">        the physical current flowing in/out of atoms but is merely a number that provides an</span>
<span class="sd">        idea of *how much* current this atom is redistributing.</span>

<span class="sd">        The atomic current may have two meanings based on these two equations</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathbf j_I^{|a|} &amp;=\frac 12 \sum_{\{J\}} \Big| \sum_{i\in I}\sum_{j\in J} \mathbf J_{ij} \Big|</span>
<span class="sd">            \\</span>
<span class="sd">            \mathbf j_I^{|o|} &amp;=\frac 12 \sum_{i\in I}\sum_{j\in\{J\}} \big| J_{ij} \big|</span>
<span class="sd">        .. math::</span>

<span class="sd">        If the *activity* is requested (``activity=True``)</span>
<span class="sd">        :math:`\mathbf j_I^{\mathcal A} = \sqrt{\mathbf j_I^{|a|} \mathbf j_I^{|o|} }` is returned.</span>

<span class="sd">        If ``activity=False`` :math:`\mathbf j_I^{|a|}` is returned.</span>

<span class="sd">        For geometries with all atoms only having 1-orbital, they are equivalent.</span>

<span class="sd">        Generally the activity current is a more rigorous figure of merit for the current</span>
<span class="sd">        flowing through an atom. More so than than the summed absolute atomic current due to</span>
<span class="sd">        the following reasoning. The activity current is a geometric mean of the absolute bond current</span>
<span class="sd">        and the absolute orbital current. This means that if there is an atom with a large orbital current</span>
<span class="sd">        it will have a larger activity current.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           the originating electrode</span>
<span class="sd">        elec_other:</span>
<span class="sd">           this electrode determines the *other* chemical potential. As such the orbital currents</span>
<span class="sd">           does not reflect the current going from `elec` *to* `elec_other`!</span>
<span class="sd">        activity:</span>
<span class="sd">           ``True`` to return the activity current, see explanation above</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned orbital current is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned bond currents from the unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all orbital currents for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain orbital currents for a subset of orbitals.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; Jij = tbt.orbital_current(0, 1, what=&quot;all&quot;) # orbital current originating from electrode ``0``</span>
<span class="sd">        &gt;&gt;&gt; Ja = tbt.sparse_orbital_to_scalar(Jij)</span>

<span class="sd">        Notes</span>
<span class="sd">        -----</span>
<span class="sd">        Calculating the current between two electrodes with the same</span>
<span class="sd">        chemical potential will return a matrix filled with 0&#39;s since there is</span>
<span class="sd">        no bias window.</span>

<span class="sd">        The currents does not reflect the current going from `elec_from` *to* `elec_other`!</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_transmission : energy resolved transmission between orbitals</span>
<span class="sd">        orbital_current : bias window integrated transmissions</span>
<span class="sd">        bond_transmission : energy resolved transmissions between atoms</span>
<span class="sd">        bond_current : bias window integrated transmissions (orbital current summed over orbitals)</span>
<span class="sd">        vector_transmission : an atomic field transmission for each atom (Cartesian representation of bond-transmissions)</span>
<span class="sd">        vector_current : an atomic field current for each atom (Cartesian representation of bond-currents)</span>
<span class="sd">        atom_transmission : energy resolved atomic transmission for each atom (scalar representation of bond-transmissions)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Jij</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_current</span><span class="p">(</span>
            <span class="n">elec</span><span class="p">,</span> <span class="n">elec_other</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">what</span><span class="o">=</span><span class="s2">&quot;all&quot;</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_scalar</span><span class="p">(</span><span class="n">Jij</span><span class="p">,</span> <span class="n">activity</span><span class="o">=</span><span class="n">activity</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.density_matrix">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.density_matrix">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.DM.Gf&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">density_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">geometry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Geometry</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Density matrix from the Green function at energy `E` (1/eV)</span>

<span class="sd">        The density matrix can be used to calculate the LDOS in real-space.</span>

<span class="sd">        The :math:`\mathrm{LDOS}(E, \mathbf r)` may be calculated using the `~sisl.physics.DensityMatrix.density`</span>
<span class="sd">        routine. Basically the LDOS in real-space may be calculated as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol\rho_{\mathbf G}(E, \mathbf r) = -\frac{1}{\pi}\sum_{ij}\phi_i(\mathbf r)\phi_j(\mathbf r) \Im[\mathbf G_{ij}(E)]</span>

<span class="sd">        where :math:`\phi` are the orbitals. Note that the broadening used in the TBtrans calculations</span>
<span class="sd">        ensures the broadening of the density, i.e. it should not be necessary to perform energy</span>
<span class="sd">        averages over the density matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E :</span>
<span class="sd">           the density matrix corresponding to the energy.</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned density matrix is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned density matrix from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all density matrix elements for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain density matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>
<span class="sd">        geometry:</span>
<span class="sd">           geometry that will be associated with the density matrix. By default the</span>
<span class="sd">           geometry contained in this file will be used. However, then the</span>
<span class="sd">           atomic species are probably incorrect, nor will the orbitals contain</span>
<span class="sd">           the basis-set information required to generate the required density</span>
<span class="sd">           in real-space.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        Adensity_matrix : spectral function density matrix</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DensityMatrix</span>
<span class="sd">            object containing the Geometry and the density matrix elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Adensity_matrix</span><span class="p">(</span>
            <span class="kc">None</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.Adensity_matrix">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.Adensity_matrix">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.DM.A&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">Adensity_matrix</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">geometry</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Geometry</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Spectral function density matrix at energy `E` (1/eV)</span>

<span class="sd">        The density matrix can be used to calculate the LDOS in real-space.</span>

<span class="sd">        The :math:`\mathrm{LDOS}(E, \mathbf r)` may be calculated using the `~sisl.physics.DensityMatrix.density`</span>
<span class="sd">        routine. Basically the LDOS in real-space may be calculated as</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol\rho_{\mathbf A_{\mathfrak{el}}}(E, \mathbf r) = \frac{1}{2\pi}\sum_{ij}\phi_i(\mathbf r)\phi_j(\mathbf r) \Re[\mathbf A_{\mathfrak{el}, ij}(E)]</span>

<span class="sd">        where :math:`\phi` are the orbitals. Note that the broadening used in the TBtrans calculations</span>
<span class="sd">        ensures the broadening of the density, i.e. it should not be necessary to perform energy</span>
<span class="sd">        averages over the density matrices.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of originating electrons</span>
<span class="sd">        E :</span>
<span class="sd">           the density matrix corresponding to the energy.</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned density matrix is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned density matrix from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all density matrix elements for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain density matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>
<span class="sd">        geometry:</span>
<span class="sd">           geometry that will be associated with the density matrix. By default the</span>
<span class="sd">           geometry contained in this file will be used. However, then the</span>
<span class="sd">           atomic species are probably incorrect, nor will the orbitals contain</span>
<span class="sd">           the basis-set information required to generate the required density</span>
<span class="sd">           in real-space.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        density_matrix : Green function density matrix</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        DensityMatrix</span>
<span class="sd">            object containing the Geometry and the density matrix elements</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">dm</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_matrix</span><span class="p">(</span><span class="s2">&quot;DM&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span> <span class="o">*</span> <span class="n">eV2Ry</span>
        <span class="c1"># Now create the density matrix object</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">geometry</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">DM</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="o">.</span><span class="n">fromsp</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">no</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.Adensity_matrix requires input geometry to contain the correct number of orbitals. Please correct input!&quot;</span>
                <span class="p">)</span>
            <span class="n">DM</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="o">.</span><span class="n">fromsp</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">dm</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">DM</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.orbital_COOP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_COOP">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.COOP.Gf&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbital_COOP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span> <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Orbital COOP analysis of the Green function</span>

<span class="sd">        This will return a sparse matrix, see `scipy.sparse.csr_matrix` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COOP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COOP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COOP}^{\mathbf G}_{ij} = \frac{-1}{2\pi}</span>
<span class="sd">              \Im\big[(\mathbf G - \mathbf G^\dagger)_{ij} \mathbf S_{ji} \big]</span>

<span class="sd">        The sum of the COOP DOS is equal to the DOS:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{DOS}_{i} = \sum_j \mathrm{COOP}^{\mathbf G}_{ij}</span>

<span class="sd">        One can calculate the (diagonal) balanced COOP analysis, see JPCM 15 (2003),</span>
<span class="sd">        7751-7761 for details. The DBCOOP is given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">            D &amp;= \sum_i \mathrm{COOP}^{\mathbf G}_{ii}</span>
<span class="sd">            \\</span>
<span class="sd">            \mathrm{DBCOOP}^{\mathbf G}_{ij} &amp;= \mathrm{COOP}^{\mathbf G}_{ij} / D</span>

<span class="sd">        The BCOOP can be looked up in the reference above.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the COOP corresponding to the energy.</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COOP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COOP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; COOP = tbt.orbital_COOP(-1.0) # COOP @ E = -1 eV</span>
<span class="sd">        &gt;&gt;&gt; COOP[10, 11] # COOP value between the 11th and 12th orbital</span>
<span class="sd">        &gt;&gt;&gt; COOP.sum(1).A[tbt.o_dev, 0] == tbt.DOS(sum=False)[tbt.Eindex(-1.0)]</span>
<span class="sd">        &gt;&gt;&gt; D = COOP.diagonal().sum()</span>
<span class="sd">        &gt;&gt;&gt; DBCOOP = COOP / D</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOOP</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.orbital_ACOOP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_ACOOP">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.COOP.A&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbital_ACOOP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot; Orbital COOP analysis of the spectral function</span>

<span class="sd">        This will return a sparse matrix, see `~scipy.sparse.csr_matrix` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COOP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COOP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COOP}^{\mathbf A}_{ij} = \frac{1}{2\pi} \Re\big[\mathbf A_{ij} \mathbf S_{ji} \big]</span>

<span class="sd">        The sum of the COOP DOS is equal to the DOS:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{ADOS}_{i} = \sum_j \mathrm{COOP}^{\mathbf A}_{ij}</span>

<span class="sd">        One can calculate the (diagonal) balanced COOP analysis, see JPCM 15 (2003),</span>
<span class="sd">        7751-7761 for details. The DBCOOP is given by:</span>

<span class="sd">        .. math::</span>
<span class="sd">            D &amp;= \sum_i \mathrm{COOP}^{\mathbf A}_{ii}</span>
<span class="sd">            \\</span>
<span class="sd">            \mathrm{DBCOOP}^{\mathbf A}_{ij} &amp;= \mathrm{COOP}^{\mathbf A}_{ij} / D</span>

<span class="sd">        The BCOOP can be looked up in the reference above.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the COOP values corresponding to the energy.</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COOP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COOP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; ACOOP = tbt.orbital_ACOOP(-1.0) # COOP @ E = -1 eV from ``0`` spectral function</span>
<span class="sd">        &gt;&gt;&gt; ACOOP[10, 11] # COOP value between the 11th and 12th orbital</span>
<span class="sd">        &gt;&gt;&gt; ACOOP.sum(1).A[tbt.o_dev, 0] == tbt.ADOS(0, sum=False)[tbt.Eindex(-1.0)]</span>
<span class="sd">        &gt;&gt;&gt; D = ACOOP.diagonal().sum()</span>
<span class="sd">        &gt;&gt;&gt; ADBCOOP = ACOOP / D</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_matrix</span><span class="p">(</span><span class="s2">&quot;COOP&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span> <span class="o">*</span> <span class="n">eV2Ry</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.atom_COOP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_COOP">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">atom_COOP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Atomic COOP curve of the Green function</span>

<span class="sd">        The atomic COOP are a sum over all orbital COOP:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COOP}_{IJ} = \sum_{i\in I}\sum_{j\in J} \mathrm{COOP}_{ij}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the atomic COOP corresponding to the energy.</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COOP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COOP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned COOP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_ACOOP</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="n">uc</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.atom_ACOOP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_ACOOP">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">atom_ACOOP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Atomic COOP curve of the spectral function</span>

<span class="sd">        The atomic COOP are a sum over all orbital COOP:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COOP}_{IJ} = \sum_{i\in I}\sum_{j\in J} \mathrm{COOP}_{ij}</span>

<span class="sd">        This is a shorthand for calling `orbital_ACOOP` and `sparse_orbital_to_atom` in order.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the atomic COOP corresponding to the energy.</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COOP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COOP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COOP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COOP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned COOP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">COOP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOOP</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_atom</span><span class="p">(</span><span class="n">COOP</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.orbital_COHP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_COHP">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.COHP.Gf&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbital_COHP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span> <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Orbital resolved COHP analysis of the Green function</span>

<span class="sd">        This will return a sparse matrix, see `scipy.sparse.csr_matrix` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COHP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COHP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COHP}^{\mathbf G}_{ij} = \frac{-1}{2\pi}</span>
<span class="sd">              \Im\big[(\mathbf G - \mathbf G^\dagger)_{ij} \mathbf H_{ji} \big]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the COHP corresponding to the energy.</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COHP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COHP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; COHP = tbt.orbital_COHP(-1.0) # COHP @ E = -1 eV</span>
<span class="sd">        &gt;&gt;&gt; COHP[10, 11] # COHP value between the 11th and 12th orbital</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOHP</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.orbital_ACOHP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.orbital_ACOHP">[docs]</a>
    <span class="nd">@missing_input_fdf</span><span class="p">([(</span><span class="s2">&quot;TBT.COHP.A&quot;</span><span class="p">,</span> <span class="s2">&quot;True&quot;</span><span class="p">)])</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">orbital_ACOHP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Orbital resolved COHP analysis of the spectral function</span>

<span class="sd">        This will return a sparse matrix, see `scipy.sparse.csr_matrix` for details.</span>
<span class="sd">        Each matrix element of the sparse matrix corresponds to the COHP of the</span>
<span class="sd">        underlying geometry.</span>

<span class="sd">        The COHP analysis can be written as:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COHP}^{\mathbf A}_{ij} = \frac{1}{2\pi} \Re\big[\mathbf A_{ij}</span>
<span class="sd">                \mathbf H_{ij} \big]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the COHP corresponding to the energy.</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COHP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COHP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sparse_matrix</span><span class="p">(</span><span class="s2">&quot;COHP&quot;</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.atom_COHP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_COHP">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">atom_COHP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Atomic COHP curve of the Green function</span>

<span class="sd">        The atomic COHP are a sum over all orbital COHP:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \mathrm{COHP}_{IJ} = \sum_{i\in I}\sum_{j\in J} \mathrm{COHP}_{ij}</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the atomic COHP corresponding to the energy.</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COHP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COHP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned COHP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        atom_ACOHP : atomic COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">atom_ACOHP</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="kc">None</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">uc</span><span class="o">=</span><span class="n">uc</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.atom_ACOHP">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.atom_ACOHP">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">atom_ACOHP</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">E</span><span class="p">:</span> <span class="n">EType</span><span class="p">,</span>
        <span class="n">elec</span><span class="p">:</span> <span class="n">ElecType</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>
        <span class="n">kavg</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">isc</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">orbitals</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">uc</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">csr_matrix</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Atomic COHP curve of the spectral function</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E:</span>
<span class="sd">           the atomic COHP corresponding to the energy.</span>
<span class="sd">        elec:</span>
<span class="sd">           the electrode of the spectral function</span>
<span class="sd">        kavg:</span>
<span class="sd">           whether the returned COHP is k-averaged, or an explicit (unweighed) k-point</span>
<span class="sd">           is returned</span>
<span class="sd">        isc: array_like, optional</span>
<span class="sd">           the returned COHP from unit-cell (``[None, None, None]``) to</span>
<span class="sd">           the given supercell, the default is all COHP for the supercell.</span>
<span class="sd">           To only get unit cell orbital currents, pass ``[0, 0, 0]``.</span>
<span class="sd">        orbitals : array-like or dict, optional</span>
<span class="sd">           only retain COHP matrix elements for a subset of orbitals, all</span>
<span class="sd">           other are set to 0.</span>
<span class="sd">        uc :</span>
<span class="sd">           whether the returned COHP are only in the unit-cell.</span>
<span class="sd">           If ``True`` this will return a sparse matrix of ``shape = (self.na, self.na)``,</span>
<span class="sd">           else, it will return a sparse matrix of ``shape = (self.na, self.na * self.n_s)``.</span>
<span class="sd">           One may figure out the connections via `~sisl._core.geometry.Geometry.sc_index`.</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        orbital_COOP : orbital resolved COOP analysis of the Green function</span>
<span class="sd">        atom_COOP : atomic COOP analysis of the Green function</span>
<span class="sd">        orbital_ACOOP : orbital resolved COOP analysis of the spectral function</span>
<span class="sd">        atom_ACOOP : atomic COOP analysis of the spectral function</span>
<span class="sd">        orbital_COHP : orbital resolved COHP analysis of the Green function</span>
<span class="sd">        atom_COHP : atomic COHP analysis of the Green function</span>
<span class="sd">        orbital_ACOHP : orbital resolved COHP analysis of the spectral function</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">COHP</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">orbital_ACOHP</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">elec</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">kavg</span><span class="p">,</span> <span class="n">isc</span><span class="o">=</span><span class="n">isc</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sparse_orbital_to_atom</span><span class="p">(</span><span class="n">COHP</span><span class="p">,</span> <span class="n">uc</span><span class="p">)</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.read_data">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.read_data">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read specific type of data.</span>

<span class="sd">        This is a generic routine for reading different parts of the data-file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry: bool, optional</span>
<span class="sd">           return the geometry</span>
<span class="sd">        vector_transmission: bool, optional</span>
<span class="sd">           return the bond transmissions as vectors</span>
<span class="sd">        vector_current: bool, optional</span>
<span class="sd">           return the bond currents as vectors</span>
<span class="sd">        atom_transmission: bool, optional</span>
<span class="sd">           return the atomic transmission flowing through an atom (the *activity* current)</span>
<span class="sd">        atom_current: bool, optional</span>
<span class="sd">           return the atomic current flowing through an atom (the *activity* current)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">val</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">kw</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="s2">&quot;geometry&quot;</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]:</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">kw</span> <span class="ow">in</span> <span class="p">(</span>
                <span class="s2">&quot;atom_current&quot;</span><span class="p">,</span>
                <span class="s2">&quot;atom_transmission&quot;</span><span class="p">,</span>
                <span class="s2">&quot;vector_current&quot;</span><span class="p">,</span>
                <span class="s2">&quot;vector_transmission&quot;</span><span class="p">,</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">kwargs</span><span class="p">[</span><span class="n">kw</span><span class="p">]:</span>
                    <span class="c1"># TODO we need some way of handling arguments.</span>
                    <span class="n">val</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">kw</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">val</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">val</span></div>


<div class="viewcode-block" id="tbtncSileTBtrans.info">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtncSileTBtrans.html#sisl.io.tbtrans.tbtncSileTBtrans.info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">elec</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ElecType</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Information about the calculated quantities available for extracting in this file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        elec : str or int</span>
<span class="sd">           the electrode to request information from</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">elec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>

        <span class="c1"># Create a StringIO object to retain the information</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">StringIO</span><span class="p">()</span>

        <span class="c1"># Create wrapper function</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">prnt</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">option</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;option&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">option</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">file</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{:60s}</span><span class="s2">[</span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="s2">&quot; &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">args</span><span class="p">),</span> <span class="s2">&quot;, &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">option</span><span class="p">)),</span> <span class="n">file</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">truefalse</span><span class="p">(</span><span class="n">bol</span><span class="p">,</span> <span class="n">string</span><span class="p">,</span> <span class="n">fdf</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">bol</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  + </span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s2">: true&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - </span><span class="si">{</span><span class="n">string</span><span class="si">}</span><span class="s2">: false&quot;</span><span class="p">,</span> <span class="n">option</span><span class="o">=</span><span class="n">fdf</span><span class="p">)</span>

        <span class="c1"># Retrieve the device atoms</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;Device information:&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - all data is k-averaged&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Print out some more information related to the</span>
            <span class="c1"># k-point sampling.</span>
            <span class="c1"># However, we still do not know whether TRS is</span>
            <span class="c1"># applied.</span>
            <span class="n">kpt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
            <span class="n">nA</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kpt</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]))</span>
            <span class="n">nB</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kpt</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]))</span>
            <span class="n">nC</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">kpt</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]))</span>
            <span class="n">prnt</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;  - number of kpoints: </span><span class="si">{}</span><span class="s2"> &lt;- &quot;</span>
                    <span class="s2">&quot;[ A = </span><span class="si">{}</span><span class="s2"> , B = </span><span class="si">{}</span><span class="s2"> , C = </span><span class="si">{}</span><span class="s2"> ] (time-reversal unknown)&quot;</span>
                <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nk</span><span class="p">,</span> <span class="n">nA</span><span class="p">,</span> <span class="n">nB</span><span class="p">,</span> <span class="n">nC</span><span class="p">)</span>
            <span class="p">)</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - energy range:&quot;</span><span class="p">)</span>
        <span class="n">E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">E</span>
        <span class="n">Em</span><span class="p">,</span> <span class="n">EM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">E</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">dEm</span><span class="p">,</span> <span class="n">dEM</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">dE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">dE</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1000</span>  <span class="c1"># convert to meV</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">dEM</span> <span class="o">-</span> <span class="n">dEm</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mf">1e-3</span><span class="p">:</span>  <span class="c1"># 0.001 meV</span>
            <span class="n">prnt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     </span><span class="si">{</span><span class="n">Em</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="n">EM</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV  [</span><span class="si">{</span><span class="n">dEm</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> meV]&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">prnt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;     </span><span class="si">{</span><span class="n">Em</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="n">EM</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV  [</span><span class="si">{</span><span class="n">dEm</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> -- </span><span class="si">{</span><span class="n">dEM</span><span class="si">:</span><span class="s2">.3f</span><span class="si">}</span><span class="s2"> meV]&quot;</span><span class="p">)</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - imaginary part (eta): </span><span class="si">{:.4f}</span><span class="s2"> meV&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">()</span> <span class="o">*</span> <span class="mf">1e3</span><span class="p">))</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - atoms with DOS (1-based):&quot;</span><span class="p">)</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;     &quot;</span> <span class="o">+</span> <span class="n">list2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">a_dev</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
        <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - number of BTD blocks: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">n_btd</span><span class="p">()))</span>
        <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;DOS&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;DOS Green function&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.DOS.Gf&quot;</span><span class="p">])</span>
        <span class="n">truefalse</span><span class="p">(</span>
            <span class="s2">&quot;DM&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;Density matrix Green function&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.DM.Gf&quot;</span><span class="p">]</span>
        <span class="p">)</span>
        <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;COOP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;COOP Green function&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.COOP.Gf&quot;</span><span class="p">])</span>
        <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;COHP&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;COHP Green function&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.COHP.Gf&quot;</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">elec</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">elecs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">elecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">elec</span><span class="p">]</span>

        <span class="c1"># Print out information for each electrode</span>
        <span class="k">for</span> <span class="n">elec</span> <span class="ow">in</span> <span class="n">elecs</span><span class="p">:</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">elec</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  * no information available&quot;</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="n">bloch</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bloch</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">n_btd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_btd</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="n">n_btd</span> <span class="o">=</span> <span class="s2">&quot;unknown&quot;</span>
            <span class="n">prnt</span><span class="p">()</span>
            <span class="n">prnt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Electrode: </span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">prnt</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;  - number of BTD blocks: </span><span class="si">{</span><span class="n">n_btd</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - Bloch: [</span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">, </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">bloch</span><span class="p">))</span>
            <span class="n">gelec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">elec</span><span class="p">]</span>
            <span class="k">if</span> <span class="s2">&quot;TBT&quot;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trans_type</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span>
                    <span class="s2">&quot;  - chemical potential: </span><span class="si">{:.4f}</span><span class="s2"> eV&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">chemical_potential</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
                <span class="n">prnt</span><span class="p">(</span>
                    <span class="s2">&quot;  - electron temperature: </span><span class="si">{:.2f}</span><span class="s2"> K&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">electron_temperature</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prnt</span><span class="p">(</span>
                    <span class="s2">&quot;  - phonon temperature: </span><span class="si">{:.4f}</span><span class="s2"> K&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">phonon_temperature</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span>
                    <span class="p">)</span>
                <span class="p">)</span>
            <span class="n">prnt</span><span class="p">(</span><span class="s2">&quot;  - imaginary part (eta): </span><span class="si">{:.4f}</span><span class="s2"> meV&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="n">elec</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e3</span><span class="p">))</span>
            <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;DOS&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;DOS bulk&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.DOS.Elecs&quot;</span><span class="p">])</span>
            <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;ADOS&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;DOS spectral&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.DOS.A&quot;</span><span class="p">])</span>
            <span class="n">truefalse</span><span class="p">(</span>
                <span class="s2">&quot;J&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
                <span class="s2">&quot;orbital-transmission&quot;</span><span class="p">,</span>
                <span class="p">[</span><span class="s2">&quot;TBT.T.Orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;TBT.Current.Orb&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;DM&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;Density matrix spectral&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.DM.A&quot;</span><span class="p">])</span>
            <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;COOP&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;COOP spectral&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.COOP.A&quot;</span><span class="p">])</span>
            <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;COHP&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;COHP spectral&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.COHP.A&quot;</span><span class="p">])</span>
            <span class="n">truefalse</span><span class="p">(</span><span class="s2">&quot;T&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission bulk&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.T.Bulk&quot;</span><span class="p">])</span>
            <span class="n">truefalse</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">.T&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="s2">&quot;transmission out&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;TBT.T.Out&quot;</span><span class="p">])</span>
            <span class="n">truefalse</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">.C&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
                <span class="s2">&quot;transmission out correction&quot;</span><span class="p">,</span>
                <span class="p">[</span><span class="s2">&quot;TBT.T.Out&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="n">truefalse</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec</span><span class="si">}</span><span class="s2">.C.Eig&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
                <span class="s2">&quot;transmission out correction (eigen)&quot;</span><span class="p">,</span>
                <span class="p">[</span><span class="s2">&quot;TBT.T.Out&quot;</span><span class="p">,</span> <span class="s2">&quot;TBT.T.Eig&quot;</span><span class="p">],</span>
            <span class="p">)</span>
            <span class="k">for</span> <span class="n">elec2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                <span class="c1"># Skip it self, checked above in .T and .C</span>
                <span class="k">if</span> <span class="n">elec2</span> <span class="o">==</span> <span class="n">elec</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">truefalse</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec2</span><span class="si">}</span><span class="s2">.T&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;transmission -&gt; </span><span class="si">{</span><span class="n">elec2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">truefalse</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">elec2</span><span class="si">}</span><span class="s2">.T.Eig&quot;</span> <span class="ow">in</span> <span class="n">gelec</span><span class="o">.</span><span class="n">variables</span><span class="p">,</span>
                    <span class="sa">f</span><span class="s2">&quot;transmission (eigen) -&gt; </span><span class="si">{</span><span class="n">elec2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
                    <span class="p">[</span><span class="s2">&quot;TBT.T.Eig&quot;</span><span class="p">],</span>
                <span class="p">)</span>

        <span class="n">s</span> <span class="o">=</span> <span class="n">out</span><span class="o">.</span><span class="n">getvalue</span><span class="p">()</span>
        <span class="n">out</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">s</span></div>


    <span class="nd">@default_ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;Extract data from a TBT.nc file&quot;</span><span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ArgumentParser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the arguments that is available for this Sile&quot;&quot;&quot;</span>

        <span class="c1"># We limit the import to occur here</span>
        <span class="kn">import</span><span class="w"> </span><span class="nn">argparse</span>

        <span class="n">namespace</span> <span class="o">=</span> <span class="n">default_namespace</span><span class="p">(</span>
            <span class="n">_tbt</span><span class="o">=</span><span class="bp">self</span><span class="p">,</span>
            <span class="n">_geometry</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span>
            <span class="n">_data</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">_data_description</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">_data_header</span><span class="o">=</span><span class="p">[],</span>
            <span class="n">_norm</span><span class="o">=</span><span class="s2">&quot;none&quot;</span><span class="p">,</span>
            <span class="n">_Ovalue</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">_Orng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">_Erng</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">_krng</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">ensure_E</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;This decorater ensures that E is the first element in the _data container&quot;&quot;&quot;</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">assign_E</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="n">ns</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># We immediately extract the energies</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">E</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Energy[eV]&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">assign_E</span>

        <span class="c1"># Correct the geometry species information</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">GeometryAction</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">old_g</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>

                <span class="c1"># Now read the file to read the geometry from</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">Geometry</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># Make sure g has the same # of orbitals</span>
                <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">old_g</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">g</span><span class="o">.</span><span class="n">atoms</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idx</span><span class="p">:</span>
                        <span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">a</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">old_g</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">R</span><span class="p">)</span>
                <span class="n">g</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span>

                <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">g</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--geometry&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-G&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">GeometryAction</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="p">(</span>
                <span class="s2">&quot;Update the geometry of the output file, this enables one to set the species correctly,&quot;</span>
                <span class="s2">&quot; note this only affects output-files where species are important&quot;</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">ERange</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">E</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">E</span>
                <span class="n">Emap</span> <span class="o">=</span> <span class="n">strmap</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">E</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">E</span><span class="o">.</span><span class="n">max</span><span class="p">())</span>
                <span class="c1"># Convert to actual indices</span>
                <span class="n">E</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">begin</span><span class="p">,</span> <span class="n">end</span> <span class="ow">in</span> <span class="n">Emap</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">begin</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="kc">None</span>
                        <span class="k">return</span>
                    <span class="k">elif</span> <span class="n">begin</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                    <span class="k">elif</span> <span class="n">end</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                        <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">E</span><span class="p">)))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">E</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">begin</span><span class="p">),</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">end</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span><span class="p">))</span>
                <span class="c1"># Issuing unique also sorts the entries</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--energy&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-E&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">ERange</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Denote the sub-section of energies that are extracted: &quot;-1:0,1:2&quot; [eV]</span>

<span class="s2">                       This flag takes effect on all energy-resolved quantities and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># k-range</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">kRange</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_krng</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="c1"># Parse it as an array</span>
                    <span class="k">if</span> <span class="s2">&quot;,&quot;</span> <span class="ow">in</span> <span class="n">value</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">k</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">value</span><span class="o">.</span><span class="n">split</span><span class="p">())</span>
                    <span class="n">k</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">3</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="s2">&quot;Argument --kpoint *must* be an integer or 3 values to find the corresponding k-index&quot;</span>
                        <span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_krng</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">kindex</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
                <span class="c1"># Add a description on which k-point this is</span>
                <span class="n">k</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;Data is extracted at k-point: [</span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2"> </span><span class="si">{}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">k</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">k</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k_avg</span><span class="p">:</span>
            <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
                <span class="s2">&quot;--kpoint&quot;</span><span class="p">,</span>
                <span class="s2">&quot;-k&quot;</span><span class="p">,</span>
                <span class="n">action</span><span class="o">=</span><span class="n">kRange</span><span class="p">,</span>
                <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Denote a specific k-index or comma/white-space separated k-point that is extracted, default to k-averaged quantity.</span>
<span class="s2">                           For specific k-points the k weight will not be used.</span>

<span class="s2">                           This flag takes effect on all k-resolved quantities and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="c1"># The normalization method</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">NormAction</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="n">value</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--norm&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-N&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">NormAction</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="s2">&quot;atom&quot;</span><span class="p">,</span>
            <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s2">&quot;none&quot;</span><span class="p">,</span> <span class="s2">&quot;atom&quot;</span><span class="p">,</span> <span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="s2">&quot;all&quot;</span><span class="p">],</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Specify the normalization method; &quot;none&quot;) no normalization, &quot;atom&quot;) total orbitals in selected atoms,</span>
<span class="s2">                       &quot;orbital&quot;) selected orbitals or &quot;all&quot;) total orbitals in the device region.</span>

<span class="s2">                       This flag only takes effect on --dos and --ados and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Try and add the atomic specification</span>
        <span class="k">class</span><span class="w"> </span><span class="nc">AtomRange</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">value</span> <span class="o">=</span> <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>  <span class="c1"># ensure only single commas (no space between them)</span>
                    <span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>  <span class="c1"># ensure no empty whitespaces</span>
                        <span class="s2">&quot;,&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>  <span class="c1"># join different lines with a comma</span>
                            <span class="n">value</span><span class="o">.</span><span class="n">splitlines</span><span class="p">()</span>
                        <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">()</span>
                    <span class="p">)</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;,&quot;</span><span class="p">)</span>
                <span class="p">)</span>

                <span class="c1"># Immediately convert to proper indices</span>
                <span class="n">geom</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span>
                <span class="n">a_dev</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">a_dev</span><span class="p">[:]</span> <span class="o">+</span> <span class="mi">1</span>

                <span class="c1"># Sadly many shell interpreters does not</span>
                <span class="c1"># allow simple [] because they are expansion tokens</span>
                <span class="c1"># in the shell.</span>
                <span class="c1"># We bypass this by allowing *, [, {</span>
                <span class="c1"># * will &quot;only&quot; fail if files are named accordingly, else</span>
                <span class="c1"># it will be passed as-is.</span>
                <span class="c1">#       {    [    *</span>
                <span class="k">for</span> <span class="n">sep</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">):</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">ranges</span> <span class="o">=</span> <span class="n">lstranges</span><span class="p">(</span>
                            <span class="n">strmap</span><span class="p">(</span><span class="nb">int</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">a_dev</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">a_dev</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">sep</span><span class="p">)</span>
                        <span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">pass</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># only if break was not encountered</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Could not parse the atomic/orbital ranges: </span><span class="si">{</span><span class="n">value</span><span class="si">}</span><span class="s2">&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># we have only a subset of the orbitals</span>
                <span class="n">orbs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">no</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">asarrayi</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayi</span>
                <span class="k">for</span> <span class="n">atoms</span> <span class="ow">in</span> <span class="n">ranges</span><span class="p">:</span>
                    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
                        <span class="c1"># this will be</span>
                        <span class="c1">#  atoms[0] == atom</span>
                        <span class="c1">#  atoms[1] == list of orbitals on the atom</span>
                        <span class="k">if</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_dev</span><span class="p">:</span>
                            <span class="k">continue</span>

                        <span class="c1"># Get atoms and orbitals</span>
                        <span class="n">ob</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="c1"># We normalize for the total number of orbitals</span>
                        <span class="c1"># on the requested atoms.</span>
                        <span class="c1"># In this way the user can compare directly the DOS</span>
                        <span class="c1"># for same atoms with different sets of orbitals and the</span>
                        <span class="c1"># total will add up.</span>
                        <span class="n">no</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
                        <span class="n">ob</span> <span class="o">=</span> <span class="n">ob</span><span class="p">[</span><span class="n">asarrayi</span><span class="p">(</span><span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">a_dev</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">ob</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">a2o</span><span class="p">(</span><span class="n">atoms</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="nb">all</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
                        <span class="n">no</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>
                    <span class="n">orbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ob</span><span class="p">)</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Device atoms:&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">list2str</span><span class="p">(</span><span class="n">a_dev</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Input atoms:&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Atomic/Orbital requests are not fully included in the device region.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Add one to make the c-index equivalent to the f-index</span>
                <span class="n">orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>

                <span class="c1"># Check that the requested orbitals are all in the device region</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">o2p</span><span class="p">(</span><span class="n">orbs</span><span class="p">)):</span>
                    <span class="c1"># This should in principle never be called because of the</span>
                    <span class="c1"># checks above.</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Device atoms:&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">list2str</span><span class="p">(</span><span class="n">a_dev</span><span class="p">))</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Input atoms:&quot;</span><span class="p">)</span>
                    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;  &quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="s2">&quot;Atomic/Orbital requests are not fully included in the device region.&quot;</span>
                    <span class="p">)</span>

                <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span> <span class="o">=</span> <span class="n">value</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="o">=</span> <span class="n">orbs</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--atom&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-a&quot;</span><span class="p">,</span>
            <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">AtomRange</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Limit orbital resolved quantities to a sub-set of atoms/orbitals: &quot;1-2[3,4]&quot; will yield the 1st and 2nd atom and their 3rd and fourth orbital. Multiple comma-separated specifications are allowed. Note that some shells does not allow [] as text-input (due to expansion), {, [ or * are allowed orbital delimiters.</span>

<span class="s2">                       This flag takes effect on all atom/orbital resolved quantities (except BDOS, transmission_bulk) and is reset whenever --plot or --out is called&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">DataT</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e2</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">e2</span> <span class="o">!=</span> <span class="n">e1</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>  <span class="c1"># catches if T isn&#39;t calculated</span>
                                    <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                    <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">transmission</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;T:</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;Column </span><span class="si">{}</span><span class="s2"> is transmission from </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;-T&quot;</span><span class="p">,</span>
            <span class="s2">&quot;--transmission&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;ELEC1&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEC2&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataT</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store transmission between two electrodes.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">DataBT</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">try</span><span class="p">:</span>  <span class="c1"># catches if B isn&#39;t calculated</span>
                                <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">e</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">transmission_bulk</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BT:</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;Column </span><span class="si">{}</span><span class="s2"> is bulk-transmission&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">))</span>
                <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;-BT&quot;</span><span class="p">,</span>
            <span class="s2">&quot;--transmission-bulk&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ELEC&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataBT</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store bulk transmission of an electrode.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">DataDOS</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="c1"># we are storing the spectral DOS</span>
                    <span class="n">e</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                        <span class="p">)</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">ADOS</span><span class="p">(</span>
                        <span class="n">e</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_norm</span>
                    <span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;ADOS[1/eV]:</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">DOS</span><span class="p">(</span><span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_norm</span><span class="p">)</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;DOS[1/eV]&quot;</span><span class="p">)</span>
                <span class="n">NORM</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_norm</span><span class="p">))</span>

                <span class="c1"># The flatten is because when ns._Erng is None, then a new</span>
                <span class="c1"># dimension (of size 1) is created</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                <span class="k">if</span> <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;Column </span><span class="si">{}</span><span class="s2"> is sum of all device atoms+orbitals with normalization 1/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">NORM</span>
                        <span class="p">)</span>
                    <span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;Column </span><span class="si">{}</span><span class="s2"> is atoms[orbs] </span><span class="si">{}</span><span class="s2"> with normalization 1/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span><span class="p">,</span> <span class="n">NORM</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--dos&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-D&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;?&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ELEC&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataDOS</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store DOS. If no electrode is specified, it is Green function, else it is the spectral function.&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--ados&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-AD&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ELEC&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataDOS</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store spectral DOS, same as --dos but requires an electrode-argument.&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">DataDOSBulk</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># we are storing the Bulk DOS</span>
                <span class="n">e</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">BDOS</span><span class="p">(</span><span class="n">e</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">,</span> <span class="nb">sum</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;BDOS[1/eV]:</span><span class="si">{</span><span class="n">e</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Select the energies, even if _Erng is None, this will work!</span>
                <span class="n">no</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="s2">&quot;Column </span><span class="si">{}</span><span class="s2"> is sum of all electrode[</span><span class="si">{}</span><span class="s2">] atoms+orbitals with normalization 1/</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                        <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">e</span><span class="p">,</span> <span class="n">no</span>
                    <span class="p">)</span>
                <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--bulk-dos&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-BD&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ELEC&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataDOSBulk</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Store bulk DOS of an electrode.&quot;&quot;&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">DataTEig</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e2</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">e1</span> <span class="o">!=</span> <span class="n">e2</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>  <span class="c1"># catches if T-eig isn&#39;t calculated</span>
                                    <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                    <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">transmission_eig</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)</span>
                <span class="c1"># The shape is: E, neig</span>
                <span class="n">neig</span> <span class="o">=</span> <span class="n">data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">for</span> <span class="n">eig</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">neig</span><span class="p">):</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">,</span> <span class="o">...</span><span class="p">,</span> <span class="n">eig</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">())</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;Teig(</span><span class="si">{}</span><span class="s2">):</span><span class="si">{}</span><span class="s2">-</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">eig</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">))</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="s2">&quot;Column </span><span class="si">{}</span><span class="s2"> is transmission eigenvalues from electrode </span><span class="si">{}</span><span class="s2"> to </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                            <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">),</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--transmission-eig&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-Teig&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;ELEC1&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEC2&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataTEig</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store transmission eigenvalues between two electrodes.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">DataFano</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">e1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e2</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">e2</span> <span class="o">!=</span> <span class="n">e1</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>  <span class="c1"># catches if T isn&#39;t calculated</span>
                                    <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                    <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">fano</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)[</span><span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span><span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Fano:</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> is fano-factor from </span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--fano&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;ELEC1&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEC2&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataFano</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store fano-factor between two electrodes.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">DataShot</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@collect_action</span>
            <span class="nd">@ensure_E</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">classical</span> <span class="o">=</span> <span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;classical&quot;</span><span class="p">,</span> <span class="s2">&quot;c&quot;</span><span class="p">)</span>

                <span class="n">e1</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>
                <span class="n">e2</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">_elec</span><span class="p">(</span><span class="n">values</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                <span class="k">if</span> <span class="n">e2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">e2</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">e2</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">elecs</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">e2</span> <span class="o">!=</span> <span class="n">e1</span><span class="p">:</span>
                                <span class="k">try</span><span class="p">:</span>  <span class="c1"># catches if T isn&#39;t calculated</span>
                                    <span class="bp">self</span><span class="p">(</span><span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="p">[</span><span class="n">values</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">],</span> <span class="n">option_string</span><span class="p">)</span>
                                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                                    <span class="k">pass</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;Electrode: &#39;</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&#39; cannot be found in the specified file.&quot;</span>
                    <span class="p">)</span>

                <span class="c1"># Grab the information</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">shot_noise</span><span class="p">(</span><span class="n">e1</span><span class="p">,</span> <span class="n">e2</span><span class="p">,</span> <span class="n">classical</span><span class="o">=</span><span class="n">classical</span><span class="p">,</span> <span class="n">kavg</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_krng</span><span class="p">)[</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span>
                <span class="p">]</span>
                <span class="n">data</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Shot:</span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2">-</span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">classical</span><span class="p">:</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;classical&quot;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">method</span> <span class="o">=</span> <span class="s2">&quot;non-classical&quot;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Column </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span><span class="si">}</span><span class="s2"> is </span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> shot-noise from </span><span class="si">{</span><span class="n">e1</span><span class="si">}</span><span class="s2"> to </span><span class="si">{</span><span class="n">e2</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--shot-noise&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;METHOD&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEC1&quot;</span><span class="p">,</span> <span class="s2">&quot;ELEC2&quot;</span><span class="p">),</span>
            <span class="n">action</span><span class="o">=</span><span class="n">DataShot</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store shot-noise between two electrodes.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">Info</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Action to print information contained in the TBT.nc file, helpful before performing actions&quot;&quot;&quot;</span>

            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="c1"># First short-hand the file</span>
                <span class="nb">print</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">value</span><span class="p">))</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--info&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-i&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Info</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;?&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;ELEC&quot;</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Print out what information is contained in the TBT.nc file, optionally only for one of the electrodes.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">Out</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@run_actions</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">value</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="c1"># We figure out if the user wants to write</span>
                    <span class="c1"># to a geometry</span>
                    <span class="n">obj</span> <span class="o">=</span> <span class="n">get_sile</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="s2">&quot;write_geometry&quot;</span><span class="p">):</span>
                        <span class="k">with</span> <span class="n">obj</span> <span class="k">as</span> <span class="n">fh</span><span class="p">:</span>
                            <span class="n">fh</span><span class="o">.</span><span class="n">write_geometry</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_geometry</span><span class="p">)</span>
                        <span class="k">return</span>
                    <span class="k">raise</span> <span class="ne">NotImplementedError</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>

                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># do nothing if data has not been collected</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;No data has been collected in the arguments, nothing will be written, have you forgotten arguments?&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">sisl.io</span><span class="w"> </span><span class="kn">import</span> <span class="n">tableSile</span>

                <span class="n">tableSile</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;w&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">write</span><span class="p">(</span>
                    <span class="o">*</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">,</span> <span class="n">comment</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span>
                <span class="p">)</span>
                <span class="c1"># Clean all data</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># These are expert options</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_krng</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--out&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-o&quot;</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Out</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Store currently collected information (at its current invocation) to the out file.&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">AVOut</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">write_tbtav</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">ns</span><span class="o">.</span><span class="n">_tbt</span><span class="o">.</span><span class="n">write_tbtav</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--tbt-av&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">AVOut</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;?&quot;</span><span class="p">,</span>
            <span class="n">default</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s1">&#39;Create &quot;</span><span class="si">{}</span><span class="s1">&quot; with the k-averaged quantities of this file.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;TBT.nc&quot;</span><span class="p">,</span> <span class="s2">&quot;TBT.AV.nc&quot;</span><span class="p">)</span>
            <span class="p">),</span>
        <span class="p">)</span>

        <span class="k">class</span><span class="w"> </span><span class="nc">Plot</span><span class="p">(</span><span class="n">argparse</span><span class="o">.</span><span class="n">Action</span><span class="p">):</span>
            <span class="nd">@run_actions</span>
            <span class="k">def</span><span class="w"> </span><span class="fm">__call__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parser</span><span class="p">,</span> <span class="n">ns</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">option_string</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># do nothing if data has not been collected</span>
                    <span class="nb">print</span><span class="p">(</span>
                        <span class="s2">&quot;No data has been collected in the arguments, nothing will be plotted, have you forgotten arguments?&quot;</span>
                    <span class="p">)</span>
                    <span class="k">return</span>

                <span class="kn">from</span><span class="w"> </span><span class="nn">matplotlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">_get_header</span><span class="p">(</span><span class="n">header</span><span class="p">):</span>
                    <span class="n">val_info</span> <span class="o">=</span> <span class="n">header</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;:&quot;</span><span class="p">)</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">val_info</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># We smiply have the data</span>
                        <span class="k">return</span> <span class="n">val_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                    <span class="c1"># We have a value *and* the electrode</span>
                    <span class="k">return</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2">:</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">val_info</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;[&quot;</span><span class="p">)[</span><span class="mi">0</span><span class="p">],</span> <span class="n">val_info</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

                <span class="n">is_DOS</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">is_T</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">is_Teig</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">is_SHOT</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="n">is_FANO</span> <span class="o">=</span> <span class="kc">True</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">)):</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span>
                        <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">ns</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">label</span><span class="o">=</span><span class="n">_get_header</span><span class="p">(</span><span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>
                    <span class="p">)</span>
                    <span class="n">is_DOS</span> <span class="o">&amp;=</span> <span class="s2">&quot;DOS&quot;</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">is_T</span> <span class="o">&amp;=</span> <span class="s2">&quot;T:&quot;</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">is_Teig</span> <span class="o">&amp;=</span> <span class="s2">&quot;Teig&quot;</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">is_SHOT</span> <span class="o">&amp;=</span> <span class="s2">&quot;Shot&quot;</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">is_FANO</span> <span class="o">&amp;=</span> <span class="s2">&quot;Fano&quot;</span> <span class="ow">in</span> <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="k">if</span> <span class="n">is_DOS</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;DOS [1/eV]&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">is_T</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Transmission&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">is_Teig</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Transmission eigen&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">is_FANO</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Fano factor&quot;</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">is_SHOT</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;Shot-noise&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s2">&quot;mixed units&quot;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s2">&quot;E - E_F [eV]&quot;</span><span class="p">)</span>

                <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> <span class="n">ncol</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">bbox_to_anchor</span><span class="o">=</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

                <span class="c1"># Clean all data</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_description</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data_header</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="c1"># These are expert options</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_norm</span> <span class="o">=</span> <span class="s2">&quot;none&quot;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Ovalue</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Orng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_Erng</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">ns</span><span class="o">.</span><span class="n">_krng</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="n">p</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span>
            <span class="s2">&quot;--plot&quot;</span><span class="p">,</span>
            <span class="s2">&quot;-p&quot;</span><span class="p">,</span>
            <span class="n">action</span><span class="o">=</span><span class="n">Plot</span><span class="p">,</span>
            <span class="n">nargs</span><span class="o">=</span><span class="s2">&quot;?&quot;</span><span class="p">,</span>
            <span class="n">metavar</span><span class="o">=</span><span class="s2">&quot;FILE&quot;</span><span class="p">,</span>
            <span class="n">help</span><span class="o">=</span><span class="s2">&quot;Plot the currently collected information (at its current invocation).&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">p</span><span class="p">,</span> <span class="n">namespace</span>


<span class="c1"># The average files</span>
<span class="c1"># These are essentially equivalent to the TBT.nc files</span>
<span class="c1"># with the exception that the k-points have been averaged out.</span>
<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.tbtrans&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">tbtavncSileTBtrans</span><span class="p">(</span><span class="n">tbtncSileTBtrans</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;TBtrans average file object</span>

<span class="sd">    This `Sile` implements the writing of the TBtrans output ``*.TBT.AV.nc`` sile which contains</span>
<span class="sd">    the k-averaged quantities related to the NEGF code TBtrans.</span>

<span class="sd">    See `tbtncSileTBtrans` for details as this object is essentially a copy of it.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_trans_type</span> <span class="o">=</span> <span class="s2">&quot;TBT&quot;</span>
    <span class="n">_k_avg</span> <span class="o">=</span> <span class="kc">True</span>
    <span class="n">_E2eV</span> <span class="o">=</span> <span class="n">Ry2eV</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">nkpt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Always return 1, this is to signal other routines&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="mi">1</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">wkpt</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Always return [1.], this is to signal other routines&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

<div class="viewcode-block" id="tbtavncSileTBtrans.write_tbtav">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.tbtrans.tbtavncSileTBtrans.html#sisl.io.tbtrans.tbtavncSileTBtrans.write_tbtav">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_tbtav</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper for writing the k-averaged TBT.AV.nc file.</span>

<span class="sd">        This write *requires* the TBT.nc `Sile` object passed as the first argument,</span>
<span class="sd">        or as the keyword ``from=tbt`` argument.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        from : tbtncSileTBtrans</span>
<span class="sd">          the TBT.nc file object that has the k-sampled quantities.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="s2">&quot;from&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">tbt</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s2">&quot;from&quot;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">tbt</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                <span class="s2">&quot;tbtncSileTBtrans has not been passed to write the averaged file&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tbt</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;first argument of tbtavncSileTBtrans.write *must* be a tbtncSileTBtrans object&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Notify if the object is not in write mode.</span>
        <span class="n">sile_raise_write</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">copy_attr</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="p">):</span>
            <span class="n">t</span><span class="o">.</span><span class="n">setncatts</span><span class="p">({</span><span class="n">att</span><span class="p">:</span> <span class="n">f</span><span class="o">.</span><span class="n">getncattr</span><span class="p">(</span><span class="n">att</span><span class="p">)</span> <span class="k">for</span> <span class="n">att</span> <span class="ow">in</span> <span class="n">f</span><span class="o">.</span><span class="n">ncattrs</span><span class="p">()})</span>

        <span class="c1"># Retrieve k-weights</span>
        <span class="n">nkpt</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">tbt</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="s2">&quot;nkpt&quot;</span><span class="p">])</span>
        <span class="n">wkpt</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">tbt</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="s2">&quot;wkpt&quot;</span><span class="p">][:])</span>

        <span class="c1"># First copy and re-create all entries in the output file</span>
        <span class="k">for</span> <span class="n">dvg</span> <span class="ow">in</span> <span class="n">tbt</span><span class="p">:</span>
            <span class="c1"># Iterate all:</span>
            <span class="c1">#  root,</span>
            <span class="c1">#  dimensions,</span>
            <span class="c1">#  variables</span>
            <span class="c1">#  sub-groups, (start over again)</span>

            <span class="c1"># Root group</span>
            <span class="k">if</span> <span class="n">tbt</span><span class="o">.</span><span class="n">isDataset</span><span class="p">(</span><span class="n">dvg</span><span class="p">):</span>
                <span class="c1"># Copy attributes and continue</span>
                <span class="n">copy_attr</span><span class="p">(</span><span class="n">dvg</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Ensure the group exists</span>
            <span class="k">if</span> <span class="n">tbt</span><span class="o">.</span><span class="n">isGroup</span><span class="p">(</span><span class="n">dvg</span><span class="p">):</span>
                <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
                <span class="n">copy_attr</span><span class="p">(</span><span class="n">dvg</span><span class="p">,</span> <span class="n">grp</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Ensure the group exists... (the above case handles groups)</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">group</span><span class="p">()</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">tbt</span><span class="o">.</span><span class="n">isDimension</span><span class="p">(</span><span class="n">dvg</span><span class="p">):</span>
                <span class="c1"># In case the dimension is the k-point one</span>
                <span class="c1"># we remove that dimension</span>
                <span class="k">if</span> <span class="s2">&quot;nkpt&quot;</span> <span class="o">==</span> <span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="c1"># Simply re-create the dimension</span>
                <span class="k">if</span> <span class="n">dvg</span><span class="o">.</span><span class="n">isunlimited</span><span class="p">():</span>
                    <span class="n">grp</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">grp</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">dvg</span><span class="p">))</span>

                <span class="k">continue</span>

            <span class="c1"># It *must* be a variable now</span>

            <span class="c1"># Quickly skip the k-point variable and the weights</span>
            <span class="k">if</span> <span class="n">dvg</span><span class="o">.</span><span class="n">name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;kpt&quot;</span><span class="p">,</span> <span class="s2">&quot;wkpt&quot;</span><span class="p">):</span>
                <span class="k">continue</span>

            <span class="c1"># Down-scale the k-point dimension</span>
            <span class="k">if</span> <span class="s2">&quot;nkpt&quot;</span> <span class="ow">in</span> <span class="n">dvg</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
                <span class="c1"># Remove that dimension</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">dimensions</span><span class="p">)</span>
                <span class="c1"># Create slice</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">dims</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="s2">&quot;nkpt&quot;</span><span class="p">)</span>
                <span class="n">dims</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">dims</span><span class="p">)</span>
                <span class="n">has_kpt</span> <span class="o">=</span> <span class="kc">True</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="n">dims</span> <span class="o">=</span> <span class="n">dvg</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[:]</span>
                <span class="n">has_kpt</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># We can&#39;t use dvg.filters() since it doesn&#39;t always</span>
            <span class="c1"># work...</span>
            <span class="n">v</span> <span class="o">=</span> <span class="n">grp</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">dvg</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">dimensions</span><span class="o">=</span><span class="n">dims</span><span class="p">)</span>

            <span class="c1"># Copy attributes</span>
            <span class="n">copy_attr</span><span class="p">(</span><span class="n">dvg</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

            <span class="c1"># Copy values</span>
            <span class="k">if</span> <span class="n">has_kpt</span><span class="p">:</span>
                <span class="c1"># Instead of constantly reading-writing to disk</span>
                <span class="c1"># (if buffer is too small)</span>
                <span class="c1"># we create a temporary array to hold the averaged</span>
                <span class="c1"># quantities.</span>
                <span class="c1"># This should only be faster for very large variables</span>
                <span class="k">if</span> <span class="n">idx</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dvg</span><span class="p">[</span><span class="mi">0</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">):</span>
                        <span class="n">dat</span> <span class="o">+=</span> <span class="n">dvg</span><span class="p">[</span><span class="n">k</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                    <span class="n">v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[:]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">slc</span> <span class="ow">in</span> <span class="n">iter_shape</span><span class="p">(</span><span class="n">dvg</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="n">idx</span><span class="p">]):</span>
                        <span class="n">dat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">dvg</span><span class="p">[</span><span class="n">slc</span><span class="p">][</span><span class="mi">0</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">):</span>
                            <span class="n">dat</span> <span class="o">+=</span> <span class="n">dvg</span><span class="p">[</span><span class="n">slc</span><span class="p">][</span><span class="n">k</span><span class="p">][:]</span> <span class="o">*</span> <span class="n">wkpt</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
                        <span class="n">v</span><span class="p">[</span><span class="n">slc</span><span class="p">][:]</span> <span class="o">=</span> <span class="n">dat</span><span class="p">[:]</span>
                <span class="k">del</span> <span class="n">dat</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">v</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">dvg</span><span class="p">[:]</span>

        <span class="c1"># Update the source attribute to signal the originating file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">setncattr</span><span class="p">(</span><span class="s2">&quot;source&quot;</span><span class="p">,</span> <span class="s2">&quot;k-average of: &quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">tbt</span><span class="o">.</span><span class="n">_file</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sync</span><span class="p">()</span></div>


    <span class="c1"># Denote default writing routine</span>
    <span class="n">_write_default</span> <span class="o">=</span> <span class="n">write_tbtav</span>


<span class="k">for</span> <span class="n">_name</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;shot_noise&quot;</span><span class="p">,</span> <span class="s2">&quot;noise_power&quot;</span><span class="p">,</span> <span class="s2">&quot;fano&quot;</span><span class="p">):</span>
    <span class="nb">setattr</span><span class="p">(</span><span class="n">tbtavncSileTBtrans</span><span class="p">,</span> <span class="n">_name</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>


<span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TBT.nc&quot;</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">)</span>
<span class="c1"># Add spin-dependent files</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TBT_DN.nc&quot;</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">)</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TBT_UP.nc&quot;</span><span class="p">,</span> <span class="n">tbtncSileTBtrans</span><span class="p">)</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TBT.AV.nc&quot;</span><span class="p">,</span> <span class="n">tbtavncSileTBtrans</span><span class="p">)</span>
<span class="c1"># Add spin-dependent files</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TBT_DN.AV.nc&quot;</span><span class="p">,</span> <span class="n">tbtavncSileTBtrans</span><span class="p">)</span>
<span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TBT_UP.AV.nc&quot;</span><span class="p">,</span> <span class="n">tbtavncSileTBtrans</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>