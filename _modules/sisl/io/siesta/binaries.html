

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.io.siesta.binaries &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../../_static/documentation_options.js?v=7b70f75b"></script>
      <script src="../../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl.io.siesta.binaries</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.io.siesta.binaries</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">collections</span><span class="w"> </span><span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics.brillouinzone</span><span class="w"> </span><span class="kn">import</span> <span class="n">MonkhorstPack</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_siesta</span>

    <span class="n">has_fortran_module</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">ImportError</span> <span class="k">as</span> <span class="n">_e</span><span class="p">:</span>
    <span class="n">has_fortran_module</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sisl._array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_a</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl</span><span class="w"> </span><span class="kn">import</span> <span class="p">(</span>
    <span class="n">Atom</span><span class="p">,</span>
    <span class="n">AtomicOrbital</span><span class="p">,</span>
    <span class="n">Atoms</span><span class="p">,</span>
    <span class="n">AtomUnknown</span><span class="p">,</span>
    <span class="n">Geometry</span><span class="p">,</span>
    <span class="n">Grid</span><span class="p">,</span>
    <span class="n">Lattice</span><span class="p">,</span>
    <span class="n">SparseCSR</span><span class="p">,</span>
<span class="p">)</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._core.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">_ncol_to_indptr</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">deprecate_argument</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics</span><span class="w"> </span><span class="kn">import</span> <span class="n">BrillouinZone</span><span class="p">,</span> <span class="n">DensityMatrix</span><span class="p">,</span> <span class="n">EnergyDensityMatrix</span><span class="p">,</span> <span class="n">Hamiltonian</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics.electron</span><span class="w"> </span><span class="kn">import</span> <span class="n">EigenstateElectron</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics.overlap</span><span class="w"> </span><span class="kn">import</span> <span class="n">Overlap</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.physics.sparse</span><span class="w"> </span><span class="kn">import</span> <span class="n">SparseOrbitalBZ</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.unit.siesta</span><span class="w"> </span><span class="kn">import</span> <span class="n">unit_convert</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.._help</span><span class="w"> </span><span class="kn">import</span> <span class="n">grid_reduce_indices</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">..sile</span><span class="w"> </span><span class="kn">import</span> <span class="n">MissingFermiLevelWarning</span><span class="p">,</span> <span class="n">SileError</span><span class="p">,</span> <span class="n">SileWarning</span><span class="p">,</span> <span class="n">add_sile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._help</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">.sile</span><span class="w"> </span><span class="kn">import</span> <span class="n">SileBinSiesta</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;tshsSileSiesta&quot;</span><span class="p">,</span> <span class="s2">&quot;onlysSileSiesta&quot;</span><span class="p">,</span> <span class="s2">&quot;tsdeSileSiesta&quot;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;hsxSileSiesta&quot;</span><span class="p">,</span> <span class="s2">&quot;dmSileSiesta&quot;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;wfsxSileSiesta&quot;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;gridSileSiesta&quot;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;tsgfSileSiesta&quot;</span><span class="p">]</span>


<span class="n">_Bohr2Ang</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s2">&quot;Bohr&quot;</span><span class="p">,</span> <span class="s2">&quot;Ang&quot;</span><span class="p">)</span>
<span class="n">_Ry2eV</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s2">&quot;Ry&quot;</span><span class="p">,</span> <span class="s2">&quot;eV&quot;</span><span class="p">)</span>
<span class="n">_eV2Ry</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s2">&quot;eV&quot;</span><span class="p">,</span> <span class="s2">&quot;Ry&quot;</span><span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_toF</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># we won&#39;t force the fortran order, f2py,</span>
        <span class="c1"># will handle this anyways. So we might as</span>
        <span class="c1"># well let that machinery deal with the</span>
        <span class="c1"># details.</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

    <span class="c1"># As we are writing to Fortran, we might as well</span>
    <span class="c1"># do the proper copy to F-contiguous.</span>
    <span class="c1"># This will save a 2nd copy!</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_geometry_align</span><span class="p">(</span><span class="n">geom_b</span><span class="p">,</span> <span class="n">geom_u</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Routine used to align two geometries</span>

<span class="sd">    There are a few twists in this since the fdf-reads will automatically</span>
<span class="sd">    try and pass a geometry from the output files.</span>
<span class="sd">    In cases where the *.ion* files are non-existing this will</span>
<span class="sd">    result in a twist.</span>

<span class="sd">    This routine will select and return a merged Geometry which</span>
<span class="sd">    fulfills the correct number of atoms and orbitals.</span>

<span class="sd">    However, if the input geometries have mis-matching number</span>
<span class="sd">    of atoms a SislError will be raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    geom_b : Geometry from binary file</span>
<span class="sd">    geom_u : Geometry supplied by user</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    SislError</span>
<span class="sd">        if the geometries have non-equal atom count</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">geom_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom_u</span>
    <span class="k">elif</span> <span class="n">geom_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom_b</span>

    <span class="c1"># Default to use the users geometry</span>
    <span class="n">geom</span> <span class="o">=</span> <span class="n">geom_u</span>

    <span class="n">is_copy</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geom</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">na</span> <span class="o">!=</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">:</span>
        <span class="c1"># we have no way of solving this issue...</span>
        <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> could not use the passed geometry as the &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;of atoms is not consistent, user-atoms=</span><span class="si">{</span><span class="n">geom_u</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s2">, file-atoms=</span><span class="si">{</span><span class="n">geom_b</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s2">.&quot;</span>
        <span class="p">)</span>

    <span class="c1"># Try and figure out what to do</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has mismatched atomic coordinates, will copy geometry and use file XYZ.&quot;</span>
        <span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has non-equal lattice vectors, will copy geometry and use file lattice.&quot;</span>
        <span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">nsc</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has non-equal number of supercells, will copy geometry and use file supercell count.&quot;</span>
        <span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
    <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

    <span class="c1"># Now for the difficult part.</span>
    <span class="c1"># If there is a mismatch in the number of orbitals we will</span>
    <span class="c1"># prefer to use the user-supplied atomic species, but fill with</span>
    <span class="c1"># *random* orbitals</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has non-equal number of orbitals per atom, will correct with *empty* orbitals.&quot;</span>
        <span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>

        <span class="c1"># Now create a new atom specie with the correct number of orbitals</span>
        <span class="n">norbs</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[:]</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span>
            <span class="p">[</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.0</span><span class="p">]</span> <span class="o">*</span> <span class="n">norbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)]</span>
        <span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">atoms</span>

    <span class="k">return</span> <span class="n">geom</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_add_overlap</span><span class="p">(</span><span class="n">M</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">str_method</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Adds the overlap matrix to the matrix `M`</span>

<span class="sd">    Handles different cases of `S`</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span>

    <span class="n">fail</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">M</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">):</span>
            <span class="n">fail</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">M</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">M</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="p">[:]</span>

    <span class="k">elif</span> <span class="n">M</span><span class="o">.</span><span class="n">spsame</span><span class="p">(</span><span class="n">S</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">Overlap</span><span class="p">):</span>
            <span class="n">fail</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="n">M</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">M</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">SparseOrbitalBZ</span><span class="p">):</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">S</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
                <span class="n">fail</span> <span class="o">=</span> <span class="kc">False</span>
                <span class="n">M</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">M</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span> <span class="o">=</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">S</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

    <span class="k">if</span> <span class="n">fail</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">str_method</span><span class="si">}</span><span class="s2"> could not paste overlap matrix into the &quot;</span>
            <span class="s2">&quot;matrix due to non-conforming sparse elements.&quot;</span>
        <span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">onlysSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Geometry and overlap matrix&quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The version of the file&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_version</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>

<div class="viewcode-block" id="onlysSileSiesta.read_lattice">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_lattice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Lattice</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns a Lattice object from a TranSiesta file&quot;&quot;&quot;</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_lattice&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read sizes.&quot;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_lattice&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read cell.&quot;</span><span class="p">)</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># We have to transpose since the data is read *as-is*</span>
        <span class="c1"># The cell in fortran files are (:, A1)</span>
        <span class="c1"># after reading this is still obeyed (regardless of order)</span>
        <span class="c1"># So we transpose to get it C-like</span>
        <span class="c1"># Note that care must be taken for the different data-structures</span>
        <span class="c1"># In particular not all data needs to be transposed (sparse H and S)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="k">return</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span></div>


<div class="viewcode-block" id="onlysSileSiesta.read_geometry">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_geometry">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;geometry&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atoms&quot;</span><span class="p">,</span>
        <span class="s2">&quot;use atoms=geometry.atoms instead of geometry=&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">atoms</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Atoms</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns Geometry object from a TranSiesta file&quot;&quot;&quot;</span>

        <span class="c1"># Read supercell</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_lattice</span><span class="p">()</span>

        <span class="n">na</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read sizes.&quot;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_geom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read geometry.&quot;</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_lattice for .T</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Since the TSHS file does not contain species information</span>
        <span class="c1"># and/or other stuff we *can* reuse an existing</span>
        <span class="c1"># geometry which contains the correct atomic numbers etc.</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lasto</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="n">atoms</span><span class="o">.</span><span class="n">atoms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.read_geometry &quot;</span>
                    <span class="s2">&quot;got a basis set (Atoms object) with incorrect &quot;</span>
                    <span class="s2">&quot;number of atoms.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create all different atoms...</span>
            <span class="c1"># The TSHS file does not contain the</span>
            <span class="c1"># atomic numbers, so we will just</span>
            <span class="c1"># create them individually</span>

            <span class="c1"># Get unique orbitals</span>
            <span class="n">uorb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>

            <span class="c1"># Create atoms</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">Z</span><span class="p">,</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uorb</span><span class="p">):</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">Z</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">orb</span><span class="p">))</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">no</span> <span class="o">==</span> <span class="n">orbs</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">atom</span>

            <span class="n">atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orb</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create a new geometry with the correct atomic numbers</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">a</span><span class="p">,</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">no</span> <span class="o">==</span> <span class="n">no</span><span class="p">:</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># correct atom</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span>
                        <span class="n">a</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                            <span class="n">a</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)],</span> <span class="n">mass</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">tag</span>
                        <span class="p">)</span>
                    <span class="p">)</span>

        <span class="c1"># Create and return geometry object</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">)</span></div>


<div class="viewcode-block" id="onlysSileSiesta.read_overlap">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_overlap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Overlap</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the overlap matrix from the TranSiesta file&quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">_geometry_align</span><span class="p">(</span>
            <span class="n">tshs_g</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">tshs_g</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;read_overlap&quot;</span>
        <span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_overlap&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read sizes.&quot;</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_lattice for .T</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_overlap&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read cell.&quot;</span><span class="p">)</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_overlap&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read overlap matrix.&quot;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="c1"># equivalent as _csr_from_siesta with explicit isc from file</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># In siesta the matrix layout is written in CSC format</span>
        <span class="c1"># due to fortran indexing, this means that we need to transpose</span>
        <span class="c1"># to get it to correct layout.</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="onlysSileSiesta.read_fermi_level">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_fermi_level">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_fermi_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Query the Fermi-level contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float</span>
<span class="sd">            fermi-level of the system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_ef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_fermi_level&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read fermi-level.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ef</span></div>


<div class="viewcode-block" id="onlysSileSiesta.read_brillouinzone">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_brillouinzone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_brillouinzone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MonkhorstPack</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the Brillouin zone object&quot;&quot;&quot;</span>
        <span class="n">kcell</span><span class="p">,</span> <span class="n">kdispl</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_k</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_brillouinzone&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read the file.&quot;</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">MonkhorstPack</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">kcell</span><span class="p">,</span> <span class="n">displacement</span><span class="o">=</span><span class="n">kdispl</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="n">trs</span><span class="p">)</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">tshsSileSiesta</span><span class="p">(</span><span class="n">onlysSileSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Geometry, Hamiltonian and overlap matrix file&quot;&quot;&quot;</span>

<div class="viewcode-block" id="tshsSileSiesta.read_hamiltonian">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.read_hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hamiltonian</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Electronic structure from the siesta.TSHS file</span>

<span class="sd">        The TSHS file format does *not* contain exact orbital information.</span>
<span class="sd">        When reading the Hamiltonian directly using this class one will find</span>
<span class="sd">        wrong orbital information. In such cases it may be beneficial to pass</span>
<span class="sd">        the `geometry` argument to override the contained geometry.</span>

<span class="sd">        The orbital order is unaltered but the atomic and orbital information</span>
<span class="sd">        will be somewhat arbitrary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : Geometry, optional</span>
<span class="sd">           override the contained geometry in the returned Hamiltonian. Useful</span>
<span class="sd">           when reading files directly using this class.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Reading the Hamiltonian using the `tshsSileSiesta` backend through</span>
<span class="sd">        the fdf sile. Since the fdf file will try and read the basis sets</span>
<span class="sd">        using other files than the TSHS.</span>

<span class="sd">        &gt;&gt;&gt; H = sisl.get_sile(&quot;RUN.fdf&quot;).read_hamiltonian(order=&quot;TSHS&quot;)</span>

<span class="sd">        An equivalent, but different way would be:</span>

<span class="sd">        &gt;&gt;&gt; geom = sisl.get_sile(&quot;RUN.fdf&quot;).read_geometry()</span>
<span class="sd">        &gt;&gt;&gt; H = sisl.get_sile(&quot;siesta.TSHS&quot;).read_hamiltonian(geometry=geom)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">tshs_g</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">_geometry_align</span><span class="p">(</span><span class="n">tshs_g</span><span class="p">,</span> <span class="n">geometry</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read sizes.&quot;</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_lattice for .T</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read cell.&quot;</span><span class="p">)</span>
        <span class="n">spin</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian and overlap matrix.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Check whether it is an orthogonal basis set</span>
        <span class="c1"># TODO, this is not an exhaustive test, but is *fine* for most</span>
        <span class="c1"># cases</span>
        <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="n">orthogonal</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orthogonal</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;read orthogonal hamiltonian&quot;</span><span class="p">)</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="p">])</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;read non-orthogonal hamiltonian&quot;</span><span class="p">)</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_mat_siesta2sisl</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="c1"># equivalent as _csr_from_siesta with explicit isc from file</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># Find all indices where dS == 1 (remember col is in fortran indices)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dS</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">no</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Number of orbitals: </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_hamiltonian could not assert &quot;</span>
                <span class="s2">&quot;the supercell connections in the primary unit-cell.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># see onlysSileSiesta.read_overlap for .transpose()</span>
        <span class="c1"># For H, DM and EDM we also need to Hermitian conjugate it.</span>
        <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>


<div class="viewcode-block" id="tshsSileSiesta.write_hamiltonian">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.write_hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the Hamiltonian to a siesta.TSHS file&quot;&quot;&quot;</span>
        <span class="c1"># we sort below, so no need to do it here</span>
        <span class="c1"># see onlysSileSiesta.read_overlap for .transpose()</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.write_hamiltonian cannot write &quot;</span>
                <span class="s2">&quot;a zero element sparse matrix!&quot;</span>
            <span class="p">)</span>

        <span class="n">sort</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Convert to siesta CSR</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>

        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_mat_sisl2siesta</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span>

        <span class="c1"># Extract the data to pass to the fortran routine</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span>

        <span class="c1"># Get H and S</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;writing orthogonal hamiltonian&quot;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">keep_nnz</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">missing_diags</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">nnz</span> <span class="o">-</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span>
            <span class="k">if</span> <span class="n">missing_diags</span><span class="p">:</span>
                <span class="c1"># This should never happen as _csr_to_siesta should ensure</span>
                <span class="c1"># that the diagonal entries always exists.</span>
                <span class="c1"># Hence it gets changed before writing.</span>
                <span class="c1"># Not compeletely optimal, but for now this is OK</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.write_hamiltonian &quot;</span>
                    <span class="s2">&quot;The diagonal elements of your orthogonal Hamiltonian &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;have not been defined. Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">missing_diags</span><span class="si">}</span><span class="s2"> elements, expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;writing non-orthogonal hamiltonian&quot;</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="c1"># Get shorter variants</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">siesta_sc_off</span><span class="p">(</span><span class="o">*</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># see onlysSileSiesta.read_lattice for .T</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_tshs_hs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
            <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span>
            <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span>
            <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
            <span class="n">isc</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;write_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not write Hamiltonian and overlap matrix.&quot;</span>
        <span class="p">)</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">dmSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Density matrix file&quot;&quot;&quot;</span>

<div class="viewcode-block" id="dmSileSiesta.read_density_matrix">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.read_density_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">DensityMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the density matrix from the siesta.DM file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : Geometry, optional</span>
<span class="sd">           attach a geometry object to the sparse matrix</span>
<span class="sd">        overlap : SparseMatrix, optional</span>
<span class="sd">           attach the overlap matrix to the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;read_density_matrix&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read density matrix sizes.&quot;</span>
        <span class="p">)</span>

        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_density_matrix&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read density matrix.&quot;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_density_matrix could not use the &quot;</span>
                <span class="s2">&quot;passed geometry as the number of atoms or orbitals is &quot;</span>
                <span class="s2">&quot;inconsistent with DM file.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create the density matrix container</span>
        <span class="n">DM</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDM</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="c1"># DM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">_mat_siesta2sisl</span><span class="p">(</span><span class="n">DM</span><span class="p">)</span>
        <span class="n">DM</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_density_matrix may result in a wrong sparse pattern!&quot;</span><span class="p">)</span>

        <span class="n">DM</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">_add_overlap</span><span class="p">(</span>
            <span class="n">DM</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;overlap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.read_density_matrix&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">DM</span></div>


<div class="viewcode-block" id="dmSileSiesta.write_density_matrix">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.write_density_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the density matrix to a siesta.DM file&quot;&quot;&quot;</span>
        <span class="n">DM</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># This ensures that we don&quot;t have any *empty* elements</span>
        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.write_density_matrix cannot write &quot;</span>
                <span class="s2">&quot;a zero element sparse matrix!&quot;</span>
            <span class="p">)</span>

        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="c1"># We do not really need to sort this one, but we do for consistency</span>
        <span class="c1"># of the interface.</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

        <span class="n">DM</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_mat_sisl2siesta</span><span class="p">(</span><span class="n">DM</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span>

        <span class="c1"># Get DM</span>
        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">DM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="c1"># Ensure shapes (say if only 1 spin)</span>
        <span class="n">dm</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_toF</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;write_density_matrix&quot;</span><span class="p">,</span> <span class="s2">&quot;could not write density matrix.&quot;</span><span class="p">)</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">tsdeSileSiesta</span><span class="p">(</span><span class="n">dmSileSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Non-equilibrium density matrix and energy density matrix file&quot;&quot;&quot;</span>

<div class="viewcode-block" id="tsdeSileSiesta.read_energy_density_matrix">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.read_energy_density_matrix">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_energy_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EnergyDensityMatrix</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the energy density matrix from the siesta.TSDE file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        geometry : Geometry, optional</span>
<span class="sd">           attach a geometry object to the sparse matrix</span>
<span class="sd">        overlap : SparseMatrix, optional</span>
<span class="sd">           attach the overlap matrix to the sparse matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;read_energy_density_matrix&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read energy density matrix sizes.&quot;</span>
        <span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dEDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_edm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;read_energy_density_matrix&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read energy density matrix.&quot;</span>
        <span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_energy_density_matrix could &quot;</span>
                <span class="s2">&quot;not use the passed geometry as the number of atoms or orbitals &quot;</span>
                <span class="s2">&quot;is inconsistent with DM file.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create the energy density matrix container</span>
        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EnergyDensityMatrix</span><span class="p">(</span>
            <span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span>
        <span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dEDM</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="c1"># EDM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="n">_mat_siesta2sisl</span><span class="p">(</span><span class="n">EDM</span><span class="p">)</span>
        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_energy_density_matrix may result in a wrong sparse pattern!&quot;</span>
            <span class="p">)</span>

        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">_add_overlap</span><span class="p">(</span>
            <span class="n">EDM</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;overlap&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.read_energy_density_matrix&quot;</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">EDM</span></div>


<div class="viewcode-block" id="tsdeSileSiesta.read_fermi_level">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.read_fermi_level">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_fermi_level</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Query the Fermi-level contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        float :</span>
<span class="sd">            fermi-level of the system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_ef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_fermi_level&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read fermi-level.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ef</span></div>


<div class="viewcode-block" id="tsdeSileSiesta.write_density_matrices">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.write_density_matrices">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_density_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="n">EDM</span><span class="p">,</span> <span class="n">Ef</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Writes the density matrix to a siesta.DM file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        DM : DensityMatrix</span>
<span class="sd">           density matrix to write to the file</span>
<span class="sd">        EDM : EnergyDensityMatrix</span>
<span class="sd">           energy density matrix to write to the file</span>
<span class="sd">        Ef :</span>
<span class="sd">           fermi-level to be contained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">sort</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">DM</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.write_density_matrices cannot write &quot;</span>
                <span class="s2">&quot;a zero element sparse matrix!&quot;</span>
            <span class="p">)</span>

        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>

        <span class="n">DM</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_mat_sisl2siesta</span><span class="p">(</span><span class="n">DM</span><span class="p">)</span>
        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_mat_sisl2siesta</span><span class="p">(</span><span class="n">EDM</span><span class="p">)</span>

        <span class="c1"># Ensure everything is correct</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span>
            <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span>
            <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span><span class="p">)</span>
        <span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.write_density_matrices got non compatible &quot;</span>
                <span class="s2">&quot;DM and EDM matrices.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">DM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">EDM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">edm</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edm</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">EDM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_tsde_dm_edm</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span>
            <span class="n">nsc</span><span class="p">,</span>
            <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span>
            <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">edm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span>
            <span class="n">Ef</span> <span class="o">*</span> <span class="n">_eV2Ry</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;write_density_matrices&quot;</span><span class="p">,</span> <span class="s2">&quot;could not write DM + EDM matrices.&quot;</span>
        <span class="p">)</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">hsxSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Hamiltonian and overlap matrix file</span>

<span class="sd">    Historically there are several HSX file versions output from Siesta.</span>

<span class="sd">    Since Siesta 5.3, the HSX file format is containing all the information present in</span>
<span class="sd">    the TranSiesta specific TSHS file-format, plus more information.</span>
<span class="sd">    As such, the TSHS file format is deprecated and will not be used anymore.</span>
<span class="sd">    Therefore users should adapt their workflows to be done with HSX</span>
<span class="sd">    files.</span>

<span class="sd">    Basically, one should never work with HSX files from Siesta &lt;= 4, since they are</span>
<span class="sd">    not information complete.</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>
<span class="sd">    At some point we will deprecate the older HSX file versions (&lt;= 4).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">version</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The version of the file&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">int</span><span class="p">(</span><span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_version</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_stored_dtype</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">is_dp</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_is_dp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="k">return</span> <span class="p">{</span><span class="kc">True</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="kc">False</span><span class="p">:</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">}[</span><span class="n">is_dp</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_xij2system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xij</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Create a new geometry with *correct* nsc and somewhat correct xyz</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xij : SparseCSR</span>
<span class="sd">            orbital distances</span>
<span class="sd">        geometry : Geometry, optional</span>
<span class="sd">            passed geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_geom_handle</span><span class="p">(</span><span class="n">xij</span><span class="p">):</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_basis</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">geometry</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">atoms</span><span class="p">)</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">)</span>
            <span class="c1"># convert csr to dok format</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Now we have [0 0 0 0 1 1 1 1 2 2 ... no-1 no-1]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">xij</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">col</span>

            <span class="c1"># Parse xij to correct geometry</span>
            <span class="c1"># first figure out all zeros (i.e. self-atom-orbitals)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">_D</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mf">0.0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">row0</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span>

            <span class="c1"># convert row0 and col0 to a first attempt of &quot;atomization&quot;</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">idx0r</span> <span class="o">=</span> <span class="p">(</span><span class="n">row0</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="c1"># row0r = row0[idx0r]</span>
                <span class="c1"># although xij == 0, we just do % to ensure unit-cell orbs</span>
                <span class="n">col0r</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">idx0</span><span class="p">[</span><span class="n">idx0r</span><span class="p">]]</span> <span class="o">%</span> <span class="n">N</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">col0r</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">):</span>
                    <span class="c1"># we have a new atom</span>
                    <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">col0r</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">col0r</span><span class="p">))</span>

            <span class="c1"># convert list of orbitals to lists</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> could not determine correct &quot;</span>
                    <span class="s2">&quot;number of orbitals.&quot;</span>
                <span class="p">)</span>

            <span class="n">atms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
            <span class="k">for</span> <span class="n">orbs</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">atms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s2">&quot;H&quot;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">atms</span><span class="p">)</span>

        <span class="n">geom_handle</span> <span class="o">=</span> <span class="n">get_geom_handle</span><span class="p">(</span><span class="n">xij</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">convert_to_atom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">xij</span><span class="p">):</span>
            <span class="c1"># o2a does not check for correct super-cell index</span>
            <span class="n">n_s</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">atm_s</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># convert csr to dok format</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">xij</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">col</span>
            <span class="n">arow</span> <span class="o">=</span> <span class="n">atm_s</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">atm_s</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">atm_s</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">acol</span><span class="p">,</span> <span class="n">arow</span><span class="p">))</span>
            <span class="n">arow</span> <span class="o">=</span> <span class="n">arow</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">acol</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">xij</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">idx</span>

            <span class="c1"># Now figure out if xij is consistent</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">acol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">arow</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">duplicates</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xij</span><span class="p">[</span><span class="n">duplicates</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xij</span><span class="p">[</span><span class="n">duplicates</span><span class="p">],</span> <span class="mf">0.0</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> converting xij(orb) -&gt; xij(atom) went wrong. &quot;</span>
                        <span class="s2">&quot;This may happen if your coordinates are not inside the unitcell, please pass &quot;</span>
                        <span class="s2">&quot;a usable geometry.&quot;</span>
                    <span class="p">)</span>

            <span class="c1"># remove duplicates to create new matrix</span>
            <span class="n">arow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arow</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">)</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">acol</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">)</span>
            <span class="n">xij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Create a new sparse matrix</span>
            <span class="c1"># Create the new index pointer</span>
            <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span>
                <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span>
                <span class="mi">1</span><span class="p">,</span>
                <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">arow</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indptr</span><span class="p">)</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">xij</span><span class="p">,</span> <span class="n">acol</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">n_s</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">coord_from_xij</span><span class="p">(</span><span class="n">xij</span><span class="p">):</span>
            <span class="c1"># first atom is at 0, 0, 0</span>
            <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="n">na</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>
            <span class="n">mark</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">run_atoms</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">run_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">atm</span> <span class="o">=</span> <span class="n">run_atoms</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">xyz_atm</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">atm</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atm</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">atm</span><span class="p">)</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">neighbors</span> <span class="o">&lt;</span> <span class="n">na</span><span class="p">]</span>

                <span class="c1"># update those that haven&#39;t been calculated</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">mark</span><span class="p">[</span><span class="n">neighbors</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">neigh_idx</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neigh_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">xyz</span><span class="p">[</span><span class="n">neigh_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xij</span><span class="p">[</span><span class="n">atm</span><span class="p">,</span> <span class="n">neigh_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz_atm</span>
                <span class="n">mark</span><span class="p">[</span><span class="n">neigh_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># add more atoms to be processed, since we have *mark*</span>
                <span class="c1"># we will only run every atom once</span>
                <span class="n">run_atoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neigh_idx</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                <span class="c1"># check that everything is correct</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">neg_neighbors</span> <span class="o">=</span> <span class="n">neighbors</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span>
                        <span class="n">xyz</span><span class="p">[</span><span class="n">neg_neighbors</span><span class="p">,</span> <span class="p">:],</span> <span class="n">xij</span><span class="p">[</span><span class="n">atm</span><span class="p">,</span> <span class="n">neg_neighbors</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz_atm</span>
                    <span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; xyz did not  &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;find same coordinates for different connections&quot;</span>
                        <span class="p">)</span>

            <span class="k">if</span> <span class="n">mark</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="n">na</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; Geometry does not  &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;have a fully connected geometry. It is impossible to create relative coordinates&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">xyz</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">sc_from_xij</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_s</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n_s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># easy!!</span>
                <span class="k">return</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">10.0</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">sc_off</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="n">n_s</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">n_s</span><span class="p">)</span>
            <span class="n">mark</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">):</span>
                <span class="n">neighbors</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atm</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">atm</span><span class="p">)</span>
                <span class="n">uneighbors</span> <span class="o">=</span> <span class="n">neighbors</span> <span class="o">%</span> <span class="n">na</span>
                <span class="n">neighbor_isc</span> <span class="o">=</span> <span class="n">neighbors</span> <span class="o">//</span> <span class="n">na</span>

                <span class="c1"># get offset in terms of unit-cell</span>
                <span class="n">off</span> <span class="o">=</span> <span class="n">xij</span><span class="p">[</span><span class="n">atm</span><span class="p">,</span> <span class="n">neighbors</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="n">uneighbors</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">[</span><span class="n">atm</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">mark</span><span class="p">[</span><span class="n">neighbor_isc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">off</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">],</span> <span class="n">sc_off</span><span class="p">[</span><span class="n">neighbor_isc</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; xyz did not  &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;find same supercell offsets for different connections&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">nidx</span> <span class="o">=</span> <span class="n">neighbor_isc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mark</span><span class="p">[</span><span class="n">nidx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mark</span><span class="p">[</span><span class="n">nidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">sc_off</span><span class="p">[</span><span class="n">nidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sc_off</span><span class="p">[</span><span class="n">nidx</span><span class="p">],</span> <span class="n">off</span><span class="p">[</span><span class="n">idx</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; xyz did not  &quot;</span>
                            <span class="sa">f</span><span class="s2">&quot;find same supercell offsets for different connections&quot;</span>
                        <span class="p">)</span>
            <span class="c1"># We know that siesta returns isc</span>
            <span class="c1"># for iz in [0, 1, 2, 3, -3, -2, -1]:</span>
            <span class="c1">#  for iy in [0, 1, 2, -2, -1]:</span>
            <span class="c1">#   for ix in [0, 1, -1]:</span>
            <span class="c1"># every block we find a half monotonically increasing vector additions</span>
            <span class="c1"># Note the first is always [0, 0, 0]</span>
            <span class="c1"># So our best chance is to *guess* the first nsc</span>
            <span class="c1"># then reshape, then guess, then reshape, then guess :)</span>
            <span class="c1"># sc_diff = np.diff(sc_off, axis=0)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">get_nsc</span><span class="p">(</span><span class="n">sc_off</span><span class="p">):</span>
<span class="w">                </span><span class="sd">&quot;&quot;&quot;Determine nsc depending on the axis&quot;&quot;&quot;</span>
                <span class="c1"># correct the offsets</span>
                <span class="n">ndim</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">ndim</span>

                <span class="k">if</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>

                <span class="c1"># always select the 2nd one since that contains the offset</span>
                <span class="c1"># for the first isc [1, 0, 0] or [0, 1, 0] or [0, 0, 1]</span>
                <span class="n">sc_dir</span> <span class="o">=</span> <span class="n">sc_off</span><span class="p">[(</span><span class="mi">1</span><span class="p">,)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span>
                <span class="n">norm2_sc_dir</span> <span class="o">=</span> <span class="n">sc_dir</span> <span class="o">@</span> <span class="n">sc_dir</span>
                <span class="c1"># figure out the maximum integer part</span>
                <span class="c1"># we select 0 indices for all already determined lattice</span>
                <span class="c1"># vectors since we know the first one is [0, 0, 0]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">projection</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">sc_dir</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm2_sc_dir</span>
                <span class="n">iprojection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span>
                <span class="c1"># reduce, find 0</span>
                <span class="n">idx_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">iprojection</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idx_zero</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>

                <span class="c1"># only take those values that are continuous</span>
                <span class="c1"># we *must* have some supercell connections</span>
                <span class="n">idx_max</span> <span class="o">=</span> <span class="n">idx_zero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># find where they are close</span>
                <span class="c1"># since there may be *many* zeros (non-coupling elements)</span>
                <span class="c1"># we first have to cut off anything that is not integer</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">projection</span><span class="p">[:</span><span class="n">idx_max</span><span class="p">],</span> <span class="n">iprojection</span><span class="p">[:</span><span class="n">idx_max</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">idx_max</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not determine nsc from coordinates&quot;</span><span class="p">)</span>

            <span class="n">nsc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nsc</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span>
            <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nsc</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span>
            <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># now determine cell parameters</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">sc_off</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sc_off</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">sc_off</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we will never have all(nsc == 1) since that is</span>
                <span class="c1"># taken care of at the start</span>

                <span class="c1"># this gets a bit tricky, since we don&#39;t know one of the</span>
                <span class="c1"># lattice vectors</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">isc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nsc</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">isc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">sl</span><span class="p">[</span><span class="mi">2</span> <span class="o">-</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_off</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># figure out the last vectors</span>
                <span class="c1"># We will just use Cartesian coordinates</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># this means we don&#39;t have any supercell connections</span>
                    <span class="c1"># along at least 1 other lattice vector.</span>
                    <span class="n">lcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># figure out which Cartesian direction we are *missing*</span>
                    <span class="n">cart_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">lcell</span><span class="p">)</span>
                    <span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cart_dir</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span>
                        <span class="n">xyz</span><span class="p">[:,</span> <span class="n">cart_dir</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="n">cart_dir</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mf">10.0</span>
                    <span class="p">)</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># now we have all orbitals, ensure compatibility with passed geometry</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atm_xij</span> <span class="o">=</span> <span class="n">convert_to_atom</span><span class="p">(</span><span class="n">geom_handle</span><span class="p">,</span> <span class="n">xij</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">coord_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">)</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">sc_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">geom_handle</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">lattice</span><span class="p">)</span>

            <span class="c1"># Move coordinates into unit-cell</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">fxyz</span> <span class="o">%</span> <span class="mf">1.0</span><span class="p">)</span> <span class="o">@</span> <span class="n">geometry</span><span class="o">.</span><span class="n">cell</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span> <span class="o">!=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">atm_xij</span> <span class="o">=</span> <span class="n">convert_to_atom</span><span class="p">(</span><span class="n">geom_handle</span><span class="p">,</span> <span class="n">xij</span><span class="p">)</span>
                <span class="n">lattice</span> <span class="o">=</span> <span class="n">sc_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">,</span> <span class="n">coord_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">))</span>
                <span class="n">geometry</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">conv</span><span class="p">(</span><span class="n">orbs</span><span class="p">,</span> <span class="n">atm</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">atm</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">atm</span>
                <span class="k">return</span> <span class="n">atm</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.0</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">])</span>

            <span class="n">atms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">geom_handle</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometry</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> passed geometry for reading &quot;</span>
                    <span class="s2">&quot;sparse matrix does not contain same number of atoms!&quot;</span>
                <span class="p">)</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># TODO check that geometry and xyz are the same!</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">atms</span>

        <span class="n">geometry</span> <span class="o">=</span> <span class="n">_geometry_align</span><span class="p">(</span>
            <span class="n">geometry</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s2">&quot;read_geometry&quot;</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">geometry</span>

<div class="viewcode-block" id="hsxSileSiesta.read_basis">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_basis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atoms</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads basis set and geometry information from the HSX file&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
            <span class="s2">&quot;basis </span><span class="si">%r</span><span class="s2"> </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="p">)</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">no</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">nspecies</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_species_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read specie sizes.&quot;</span><span class="p">)</span>
        <span class="c1"># Read specie information</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">val_q</span><span class="p">,</span> <span class="n">norbs</span><span class="p">,</span> <span class="n">isa</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_species_info</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nspecies</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">na</span>
        <span class="p">)</span>
        <span class="c1"># convert to proper string</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nspecies</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
            <span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="sa">b</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s2">&quot;utf-8&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span> <span class="n">labels</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read species.&quot;</span><span class="p">)</span>
        <span class="c1"># to python index</span>
        <span class="n">isa</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="kn">from</span><span class="w"> </span><span class="nn">sisl._core.atom</span><span class="w"> </span><span class="kn">import</span> <span class="n">_ptbl</span>

        <span class="c1"># try and convert labels into symbols</span>
        <span class="c1"># We do this by:</span>
        <span class="c1"># 1. label -&gt; symbol</span>
        <span class="c1"># 2. label[:2] -&gt; symbol</span>
        <span class="c1"># 3. label[:1] -&gt; symbol</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lbls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">label</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">labels</span><span class="p">):</span>
            <span class="n">lbls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>

            <span class="c1"># 1.</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">_ptbl</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;fa&quot;</span><span class="p">:</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># 2.</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">_ptbl</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">label</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;fa&quot;</span><span class="p">:</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># 3.</span>
            <span class="n">symbol</span> <span class="o">=</span> <span class="n">_ptbl</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">label</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">symbol</span> <span class="o">!=</span> <span class="s2">&quot;fa&quot;</span><span class="p">:</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># 4. we have no clue, assign -1</span>
            <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">200</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span>

        <span class="c1"># Read in orbital information</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ispecie</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspecies</span><span class="p">):</span>
            <span class="n">n_l_zeta</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_species</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">ispecie</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">norbs</span><span class="p">[</span><span class="n">ispecie</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_basis&quot;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;could not read specie </span><span class="si">{</span><span class="n">ispecie</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="c1"># create orbital</span>
            <span class="c1"># since the n, l, zeta is unique per atomic orbital (before expanding to</span>
            <span class="c1"># m shells), we will figure this out manually.</span>
            <span class="n">old_values</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">zeta</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">n_l_zeta</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">old_values</span> <span class="o">!=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span> <span class="ow">or</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">old_values</span> <span class="o">=</span> <span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">zeta</span><span class="p">)</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="n">l</span>
                <span class="n">orbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AtomicOrbital</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span> <span class="n">R</span><span class="o">=-</span><span class="mf">1.0</span><span class="p">))</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># now create atom</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="n">ispecie</span><span class="p">],</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">lbls</span><span class="p">[</span><span class="n">ispecie</span><span class="p">]))</span>

        <span class="c1"># now create atoms object</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">([</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">isa</span><span class="p">])</span>

        <span class="n">base</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">atoms</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="n">atoms</span>

        <span class="c1"># Now compare the atoms such that we select the best one</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">get_best</span><span class="p">(</span><span class="n">aF</span><span class="p">,</span> <span class="n">aI</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">aF</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">aI</span><span class="p">):</span>
                <span class="c1"># the file has the correct number of orbitals</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;basis file atom=</span><span class="si">%r</span><span class="s2"> better than input </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">aF</span><span class="p">,</span> <span class="n">aI</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">aF</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">aF</span><span class="p">,</span> <span class="n">AtomUnknown</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">aF</span><span class="o">.</span><span class="n">Z</span> <span class="o">!=</span> <span class="n">aI</span><span class="o">.</span><span class="n">Z</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                        <span class="s2">&quot;basis file atom=</span><span class="si">%r</span><span class="s2"> has different Z than input </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">aF</span><span class="p">,</span> <span class="n">aI</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">aF</span>

            <span class="c1"># check for orbitals being atomicorbital</span>
            <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">aI</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">orb</span><span class="p">,</span> <span class="n">AtomicOrbital</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                        <span class="s2">&quot;basis file, input atom=</span><span class="si">%r</span><span class="s2"> does not use AtomicOrbital&quot;</span><span class="p">,</span> <span class="n">aI</span>
                    <span class="p">)</span>
                    <span class="k">return</span> <span class="n">aF</span>

            <span class="k">for</span> <span class="n">oF</span><span class="p">,</span> <span class="n">oI</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">aF</span><span class="p">,</span> <span class="n">aI</span><span class="p">):</span>
                <span class="c1"># we can&#39;t check polarization, not stored in the HSX file format</span>
                <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;n&quot;</span><span class="p">,</span> <span class="s2">&quot;l&quot;</span><span class="p">,</span> <span class="s2">&quot;m&quot;</span><span class="p">,</span> <span class="s2">&quot;zeta&quot;</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">oF</span><span class="p">,</span> <span class="n">prop</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">oI</span><span class="p">,</span> <span class="n">prop</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
                            <span class="s2">&quot;basis file atom, orbital </span><span class="si">%r</span><span class="s2">,</span><span class="si">%r</span><span class="s2"> property </span><span class="si">%s</span><span class="s2"> cannot be matched with input atom, orbital </span><span class="si">%r</span><span class="s2">,</span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
                            <span class="n">aF</span><span class="p">,</span>
                            <span class="n">oF</span><span class="p">,</span>
                            <span class="n">prop</span><span class="p">,</span>
                            <span class="n">aI</span><span class="p">,</span>
                            <span class="n">oI</span><span class="p">,</span>
                        <span class="p">)</span>
                        <span class="k">return</span> <span class="n">aF</span>

            <span class="c1"># the atoms are the same, so we select the input atom</span>
            <span class="c1"># since it likely contains the spherical functions</span>
            <span class="c1"># and the charge</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;basis file, choose input atom=</span><span class="si">%r</span><span class="s2"> over file atom </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span> <span class="n">aI</span><span class="p">,</span> <span class="n">aF</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">aI</span>

        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">get_best</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">base</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">atoms</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_r_lattice_v0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the Lattice from the old file version&quot;&quot;&quot;</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read geometry sizes.&quot;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dxij</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_hsx0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">dxij</span> <span class="o">=</span> <span class="n">dxij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian.&quot;</span><span class="p">)</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">xij</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">dxij</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">))</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xij2system</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geom&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">lattice</span>
        <span class="k">del</span> <span class="n">geom</span>
        <span class="k">return</span> <span class="n">lattice</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_lattice_v1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>

        <span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_geom1_2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;lattice v1_2&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>

    <span class="c1"># Same</span>
    <span class="n">_r_lattice_v2</span> <span class="o">=</span> <span class="n">_r_lattice_v1</span>

<div class="viewcode-block" id="hsxSileSiesta.read_lattice">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_lattice">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Lattice</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the lattice from the file</span>

<span class="sd">        This will always work on new files Siesta &gt;=5, but only sometimes on older</span>
<span class="sd">        versions of the HSX file format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_r_lattice_v</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_r_geometry_v0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the geometry from the old file version&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
            <span class="s2">&quot;geometry v0 </span><span class="si">%r</span><span class="s2">, </span><span class="si">%r</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read geometry sizes.&quot;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dxij</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_hsx0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">dxij</span> <span class="o">=</span> <span class="n">dxij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_geometry&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian.&quot;</span><span class="p">)</span>
        <span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">xij</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">dxij</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">))</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xij2system</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">geom</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_geometry_v1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;geometry v</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2"> %r, %r&quot;</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;atoms&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
            <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="c1"># first read the atoms object</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_basis</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># now read coordinates and cell sizes</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>

        <span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">xa</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_geom1_2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>

        <span class="n">lattice</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span><span class="p">,</span> <span class="n">atoms</span><span class="p">,</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">)</span>

    <span class="n">_r_geometry_v2</span> <span class="o">=</span> <span class="n">_r_geometry_v1</span>

<div class="viewcode-block" id="hsxSileSiesta.read_geometry">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_geometry">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Geometry</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the geometry from the file</span>

<span class="sd">        This will always work on new files Siesta &gt;=5, but only sometimes on older</span>
<span class="sd">        versions of the HSX file format.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_r_geometry_v</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="hsxSileSiesta.read_fermi_level">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_fermi_level">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_fermi_level</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">float</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the fermi level in the file</span>

<span class="sd">        Only valid for files created by Siesta &gt;=5.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">version</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="n">MissingFermiLevelWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_file</span><span class="si">!s}</span><span class="s2"> (base=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_directory</span><span class="p">()</span><span class="si">!s}</span><span class="s2">) &quot;</span>
                    <span class="s2">&quot;does not contain Ef, too old version file.&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_ef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_fermi_level&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Fermi-level&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">Ef</span> <span class="o">&gt;=</span> <span class="n">np</span><span class="o">.</span><span class="n">finfo</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">:</span>
            <span class="c1"># we can&#39;t compare with math.isinf, as it doesn&#39;t work.</span>
            <span class="c1"># fortran huge returns the maximum represented value that is not</span>
            <span class="c1"># inf.</span>
            <span class="c1"># So we will just compare against the max of the float.</span>
            <span class="c1"># This should then also work for HSX files in single-precision.</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="n">MissingFermiLevelWarning</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_file</span><span class="si">!s}</span><span class="s2"> (base=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_directory</span><span class="p">()</span><span class="si">!s}</span><span class="s2">) &quot;</span>
                    <span class="s2">&quot;does not contain a usable Ef, likely the Fermi-level &quot;</span>
                    <span class="s2">&quot;has not been calculated by Siesta? (option = H.Setup.Only)&quot;</span>
                <span class="p">)</span>
            <span class="p">)</span>
            <span class="n">Ef</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="k">return</span> <span class="n">Ef</span> <span class="o">*</span> <span class="n">_Ry2eV</span></div>


<div class="viewcode-block" id="hsxSileSiesta.read_brillouinzone">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_brillouinzone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_brillouinzone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">trs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">MonkhorstPack</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the Brillouin zone object&quot;&quot;&quot;</span>
        <span class="n">kcell</span><span class="p">,</span> <span class="n">kdispl</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_k</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_brillouinzone&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read the file.&quot;</span><span class="p">)</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">MonkhorstPack</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">kcell</span><span class="p">,</span> <span class="n">displacement</span><span class="o">=</span><span class="n">kdispl</span><span class="p">,</span> <span class="n">trs</span><span class="o">=</span><span class="n">trs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_r_hamiltonian_v0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian sizes.&quot;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_hsx0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">!=</span> <span class="n">no_s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_hamiltonian could not use the &quot;</span>
                <span class="s2">&quot;passed geometry as the number of atoms or orbitals is &quot;</span>
                <span class="s2">&quot;inconsistent with HSX file.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dH</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_mat_siesta2sisl</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_dtype</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="n">warn</span><span class="p">(</span>
            <span class="n">MissingFermiLevelWarning</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="si">}</span><span class="s2"> does not contain Ef, electronic structure not shifted to Fermi level.&quot;</span>
            <span class="p">)</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_hamiltonian_v1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="n">spin</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian sizes.&quot;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_hsx1_2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">!=</span> <span class="n">no_s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_hamiltonian could not use the &quot;</span>
                <span class="s2">&quot;passed geometry as the number of atoms or orbitals is &quot;</span>
                <span class="s2">&quot;inconsistent with HSX file.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span> <span class="o">+</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dH</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_mat_siesta2sisl</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_dtype</span><span class="p">),</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># Correct the fermi-level here</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_fermi_level</span><span class="p">()</span>
        <span class="n">H</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="o">-</span><span class="n">Ef</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

    <span class="n">_r_hamiltonian_v2</span> <span class="o">=</span> <span class="n">_r_hamiltonian_v1</span>

<div class="viewcode-block" id="hsxSileSiesta.read_hamiltonian">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Hamiltonian</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the electronic structure from the siesta.HSX file&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_r_hamiltonian_v</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_r_overlap_v0</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the overlap matrix from the siesta.HSX file&quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_overlap&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read overlap matrix sizes.&quot;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sx0</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_overlap&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read overlap matrix.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">!=</span> <span class="n">no_s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_overlap could not use the &quot;</span>
                <span class="s2">&quot;passed geometry as the number of atoms or orbitals is &quot;</span>
                <span class="s2">&quot;inconsistent with HSX file.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get dtype</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_dtype</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># not really necessary with Hermitian transposing, but for consistency</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_overlap_v1</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the overlap matrix from the siesta.HSX file&quot;&quot;&quot;</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_overlap&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read overlap matrix sizes.&quot;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sx1_2</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_overlap&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read overlap matrix.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">!=</span> <span class="n">no_s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.read_overlap could not use the &quot;</span>
                <span class="s2">&quot;passed geometry as the number of atoms or orbitals is &quot;</span>
                <span class="s2">&quot;inconsistent with HSX file.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Get dtype</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_stored_dtype</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># not really necessary with Hermitian transposing, but for consistency</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>

    <span class="n">_r_overlap_v2</span> <span class="o">=</span> <span class="n">_r_overlap_v1</span>

<div class="viewcode-block" id="hsxSileSiesta.read_overlap">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_overlap">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Overlap</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the electronic structure from the siesta.HSX file&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;_r_overlap_v</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)(</span><span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


<div class="viewcode-block" id="hsxSileSiesta.write_hamiltonian">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.write_hamiltonian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Writes the Hamiltonian to a siesta.HSX file&quot;&quot;&quot;</span>
        <span class="c1"># we sort below, so no need to do it here</span>
        <span class="c1"># see hsxSileSiesta.read_overlap for .transpose()</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.write_hamiltonian cannot write &quot;</span>
                <span class="s2">&quot;a zero element sparse matrix!&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Default to writing version 2</span>
        <span class="n">version</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;version&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">version</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.write_hamiltonian only &quot;</span> <span class="s2">&quot;supports one of versions [1, 2].&quot;</span>
            <span class="p">)</span>
        <span class="n">sort</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;bz&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>  <span class="c1"># In case the BZ is an argument</span>
        <span class="n">dtype</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;dtype&quot;</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="si">!r}</span><span class="s2">.write_hamiltonian only &quot;</span>
                <span class="s2">&quot;supports float32 or float64 in the HSX file format.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Convert to siesta CSR</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">,</span> <span class="n">diag</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>

        <span class="c1"># we have the required dtype above.</span>
        <span class="c1"># However, the fortran interface requires a double, so we have to</span>
        <span class="c1"># use a bool to signal the stored data.</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">_mat_sisl2siesta</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span>

        <span class="c1"># Extract the data to pass to the fortran routine</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span>

        <span class="c1"># Get H and S</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;writing orthogonal hamiltonian&quot;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">dims</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">keep_nnz</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">+=</span> <span class="n">s</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">missing_diags</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">nnz</span> <span class="o">-</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span>
            <span class="k">if</span> <span class="n">missing_diags</span><span class="p">:</span>
                <span class="c1"># This should never happen as _csr_to_siesta should ensure</span>
                <span class="c1"># that the diagonal entries always exists.</span>
                <span class="c1"># Hence it gets changed before writing.</span>
                <span class="c1"># Not compeletely optimal, but for now this is OK</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.write_hamiltonian &quot;</span>
                    <span class="s2">&quot;The diagonal elements of your orthogonal Hamiltonian &quot;</span>
                    <span class="sa">f</span><span class="s2">&quot;have not been defined. Got </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">missing_diags</span><span class="si">}</span><span class="s2"> elements, expected </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span><span class="si">}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_log</span><span class="p">(</span><span class="s2">&quot;writing non-orthogonal hamiltonian&quot;</span><span class="p">)</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span> <span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="c1"># Get shorter variants</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">siesta_sc_off</span><span class="p">(</span><span class="o">*</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># Correct arguments depending on BZ</span>
        <span class="n">kcell</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">kdispl</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">3</span><span class="p">])</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bz</span><span class="p">,</span> <span class="n">MonkhorstPack</span><span class="p">):</span>
            <span class="n">kcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">bz</span><span class="o">.</span><span class="n">_diag</span><span class="p">)</span>
            <span class="n">kdispl</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">_displ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># TODO, perhaps do something based on the type of BZ</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">3</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">kcell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">kcell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

        <span class="n">geom</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span>

        <span class="c1"># Populate arguments</span>
        <span class="n">args</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">func</span><span class="p">(</span><span class="n">atom_</span><span class="p">):</span>
            <span class="n">atom</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">atom_</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">atom</span><span class="o">.</span><span class="n">tag</span><span class="si">:</span><span class="s2">20s</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">[:</span><span class="mi">20</span><span class="p">],</span> <span class="n">atom</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">atom</span><span class="p">)</span>

        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">atoms</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="kc">True</span><span class="p">))))))</span>

        <span class="c1"># Next values</span>
        <span class="n">no_max</span> <span class="o">=</span> <span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">lasto</span> <span class="o">-</span> <span class="n">atoms</span><span class="o">.</span><span class="n">firsto</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="c1"># Atoms require &#39;n&#39; and &#39;zeta&#39; to be &gt;=1</span>
        <span class="n">n</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">([</span><span class="n">no_max</span><span class="p">,</span> <span class="n">atoms</span><span class="o">.</span><span class="n">nspecies</span><span class="p">],</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="n">zeta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i_s</span><span class="p">,</span> <span class="p">(</span><span class="n">atom</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atoms</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span><span class="n">species</span><span class="o">=</span><span class="kc">True</span><span class="p">)):</span>
                <span class="k">for</span> <span class="n">io</span><span class="p">,</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">atom</span><span class="p">):</span>
                    <span class="n">n</span><span class="p">[</span><span class="n">io</span><span class="p">,</span> <span class="n">i_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">n</span>
                    <span class="n">l</span><span class="p">[</span><span class="n">io</span><span class="p">,</span> <span class="n">i_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">l</span>
                    <span class="n">zeta</span><span class="p">[</span><span class="n">io</span><span class="p">,</span> <span class="n">i_s</span><span class="p">]</span> <span class="o">=</span> <span class="n">orb</span><span class="o">.</span><span class="n">zeta</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>  <span class="c1"># should we warn?</span>

        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">zeta</span><span class="p">])</span>

        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="n">_toF</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">species</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">firsto</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
            <span class="p">]</span>
        <span class="p">)</span>

        <span class="c1"># Now cell etc.</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_toF</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mi">1</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">))</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">isc</span><span class="p">)</span>  <span class="c1"># already in correct shape!</span>

        <span class="c1"># Now the matrices</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_toF</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">))</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_toF</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="n">args</span><span class="o">.</span><span class="n">extend</span><span class="p">([</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">])</span>

        <span class="k">if</span> <span class="n">version</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kcell</span><span class="p">)</span>
            <span class="n">args</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">kdispl</span><span class="p">)</span>

        <span class="c1"># see hsxSileSiesta.read_lattice for .T</span>
        <span class="n">write_hsx</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">_siesta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;write_hsx</span><span class="si">{</span><span class="n">version</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">write_hsx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;write_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not write Hamiltonian and overlap matrix.&quot;</span>
        <span class="p">)</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">wfsxSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Binary WFSX file reader for Siesta</span>

<span class="sd">    The WFSX file assumes that users initialize the object with</span>
<span class="sd">    a `parent` argument (or one of the other geometry related objects as</span>
<span class="sd">    shown below).</span>

<span class="sd">    The `parent` argument is necessary to convert WFSX k-points from 1/Ang to</span>
<span class="sd">    reduced coordinates.</span>
<span class="sd">    When returning `EigenstateElectron` objects the parent of these objects</span>
<span class="sd">    are the equivalent of the `parent` argument upon initialization.</span>
<span class="sd">    Therefore please remember to pass a correct `parent`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : obj, optional</span>
<span class="sd">        a parent may contain a geometry, and/or a supercell</span>
<span class="sd">    geometry : Geometry, optional</span>
<span class="sd">        a geometry contains a cell with corresponding lattice vectors</span>
<span class="sd">        used to convert k [1/Ang] -&gt; [b]</span>
<span class="sd">    lattice : Lattice, optional</span>
<span class="sd">        a supercell contains the lattice vectors to convert k</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Simple setup that needs to be overwritten</span>

<span class="sd">        All _r_next_* methods expect the fortran file unit to be handled</span>
<span class="sd">        and that the position in the file is correct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># default lattice</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># In case the instantiation was called with wfsxSileSiesta(&quot;path&quot;, geometry=geometry)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">):</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">geometry</span>

        <span class="n">geometry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">lattice</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span>

        <span class="n">lattice</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;lattice&quot;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sc&quot;</span><span class="p">,</span> <span class="n">lattice</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">lattice</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(geometry=Geometry, lattice=None) is not an allowed argument combination.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">lattice</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lattice</span> <span class="o">=</span> <span class="n">lattice</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lattice</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">conv</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cannot convert stored k-points from 1/Ang to reduced coordinates. &quot;</span>
                        <span class="s2">&quot;Please ensure parent=Hamiltonian, geometry=Geometry, or lattice=Lattice to ensure reduced k.&quot;</span>
                    <span class="p">)</span>
                <span class="k">return</span> <span class="n">k</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span>

        <span class="k">else</span><span class="p">:</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">conv</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">k</span> <span class="o">@</span> <span class="n">lattice</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_k</span> <span class="o">=</span> <span class="n">conv</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open_wfsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Open the file unit for the WFSX file.</span>

<span class="sd">        Here we also initialize some variables to keep track of the state of the read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_open</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="n">rewind</span><span class="p">)</span>
        <span class="c1"># Here we initialize the variables that will keep track of the state of the read.</span>
        <span class="c1"># The process for identification is done on this basis:</span>
        <span class="c1">#  _ik is the current (Python) index for the k-point to be read</span>
        <span class="c1">#  _ispin is the current (Python) index for the spin-index to be read (only has meaning for a spin-polarized</span>
        <span class="c1">#         WFSX files)</span>
        <span class="c1">#  _state is:</span>
        <span class="c1">#        -1 : the file-descriptor has just been opened (i.e. in front of header)</span>
        <span class="c1">#         0 : it means that the file-descriptor is in front of basis information</span>
        <span class="c1">#         1 : it means that the file-descriptor is in front of k point information</span>
        <span class="c1">#         2 : it means that the file-descriptor is in front of k point WFSX values</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_close_wfsx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Close the file unit for the WFSX file.</span>

<span class="sd">        We clean the variables used to keep track of read state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_close</span><span class="p">()</span>

        <span class="c1"># Clean variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_setup_parsing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_basis</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Gets all the things needed to parse the wfsx file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        close: bool, optional</span>
<span class="sd">            Whether the file unit should be closed afterwards.</span>
<span class="sd">        skip_basis : bool, optional</span>
<span class="sd">            whether to also read the basis or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_wfsx</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="c1"># Read the sizes relevant to the file.</span>
        <span class="c1"># We also read whether there&#39;s only gamma point information or there are multiple points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_sizes</span><span class="p">(</span><span class="n">skip_basis</span><span class="o">=</span><span class="n">skip_basis</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_basis</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_basis</span><span class="p">()</span>

        <span class="c1"># Get the functions that should be used to parse state values.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
            <span class="c1"># We will have twice as many coefficients.</span>
            <span class="n">func_index</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">Gamma</span><span class="p">:</span>
            <span class="c1"># State values will be in double precision floats</span>
            <span class="n">func_index</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># State values will be in double precision complex</span>
            <span class="n">func_index</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="n">Funcs</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;WFSXReads&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;read_index&quot;</span><span class="p">,</span> <span class="s2">&quot;read_next&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span> <span class="o">=</span> <span class="n">Funcs</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">_siesta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;read_wfsx_index_</span><span class="si">{</span><span class="n">func_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">_siesta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;read_wfsx_next_</span><span class="si">{</span><span class="n">func_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">close</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_next_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the sizes if they are the next thing to be read.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        skip_basis: boolean, optional</span>
<span class="sd">            Whether this method should also skip over the basis information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        namedtuple :</span>
<span class="sd">                - &#39;nspin&#39;: int. Number of spin components.</span>
<span class="sd">                - &#39;no_u&#39;: int. Number of orbitals in the unit cell.</span>
<span class="sd">                - &#39;nk&#39;: int. Number of k points in the file.</span>
<span class="sd">                - &#39;Gamma&#39;: bool. Whether the file contains only the gamma point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that we are in the right position in the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;We are not in a position to read the sizes. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Read the sizes that we can find in the WFSX file</span>
        <span class="n">Sizes</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Sizes&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;nspin&quot;</span><span class="p">,</span> <span class="s2">&quot;no_u&quot;</span><span class="p">,</span> <span class="s2">&quot;nk&quot;</span><span class="p">,</span> <span class="s2">&quot;Gamma&quot;</span><span class="p">])</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">skip_basis</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of k point information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">skip_basis</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="c1"># Check that everything went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;_r_next_sizes&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read sizes&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Sizes</span><span class="p">(</span><span class="o">*</span><span class="n">sizes</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_next_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the basis if it is the next thing to be read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Atoms:</span>
<span class="sd">            the basis read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that we are in the right position in the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;We are not in a position to read the basis. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="c1"># Read the basis information that we can find in the WFSX file</span>
        <span class="n">basis_info</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">no_u</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of k point information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Check that everything went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;_r_next_basis&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read basis information&quot;</span><span class="p">)</span>

        <span class="c1"># Convert the information to a dict so that code is easier to follow.</span>
        <span class="n">basis_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span>
            <span class="nb">zip</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="s2">&quot;atom_indices&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;atom_labels&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;orb_index_atom&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;orb_n&quot;</span><span class="p">,</span>
                    <span class="s2">&quot;orb_symmetry&quot;</span><span class="p">,</span>
                <span class="p">),</span>
                <span class="n">basis_info</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="p">)</span>

        <span class="c1"># Sanitize the string information</span>
        <span class="k">for</span> <span class="n">char_key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;atom_labels&quot;</span><span class="p">,</span> <span class="s2">&quot;orb_symmetry&quot;</span><span class="p">):</span>
            <span class="n">basis_info</span><span class="p">[</span><span class="n">char_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span>
                <span class="p">[</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">basis_info</span><span class="p">[</span><span class="n">char_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)]</span>
            <span class="p">)</span>

        <span class="c1"># Find out the unique atom indices</span>
        <span class="n">unique_ats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;atom_indices&quot;</span><span class="p">])</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_get_atom_object</span><span class="p">(</span><span class="n">at</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Given an atom index, generates an Atom object with all the information we have about it&quot;&quot;&quot;</span>
            <span class="n">atom_orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;atom_indices&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">at</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">at_label</span> <span class="o">=</span> <span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;atom_labels&quot;</span><span class="p">][</span><span class="n">atom_orbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">AtomicOrbital</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}{</span><span class="n">symmetry</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">symmetry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span>
                    <span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;orb_n&quot;</span><span class="p">][</span><span class="n">atom_orbs</span><span class="p">],</span>
                    <span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;orb_symmetry&quot;</span><span class="p">][</span><span class="n">atom_orbs</span><span class="p">],</span>
                <span class="p">)</span>
            <span class="p">]</span>

            <span class="k">return</span> <span class="n">Atom</span><span class="p">(</span><span class="n">at_label</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># Generate the Atoms oject.</span>
        <span class="k">return</span> <span class="n">Atoms</span><span class="p">([</span><span class="n">_get_atom_object</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">unique_ats</span><span class="p">])</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_next_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the next eigenstate information.</span>

<span class="sd">        This function should only be called after reading the sizes</span>
<span class="sd">        or reading the previous states values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ispin: integer</span>
<span class="sd">            the (python) spin index of the next eigenstate.</span>
<span class="sd">        ik: integer</span>
<span class="sd">            the (python) k index of the next eigenstate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of shape (3,):</span>
<span class="sd">            The k point of the state.</span>
<span class="sd">        float:</span>
<span class="sd">            The weight of the k point.</span>
<span class="sd">        int:</span>
<span class="sd">            Number of wavefunctions that the state contains. It is needed by the</span>
<span class="sd">            function that reads the eigenstates values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the indices of the current state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">ispin</span>
        <span class="c1"># Check that we are in a position where we will read state information</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;We are not in a position to read k point information. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Read the state information</span>
        <span class="n">file_ispin</span><span class="p">,</span> <span class="n">file_ik</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nwf</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of state values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="c1"># Check that the read went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;_r_next_info&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;could not read next eigenstate info [</span><span class="si">{</span><span class="n">ispin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ik</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="c1"># Check that the read indices match the indices that we were expecting.</span>
        <span class="k">if</span> <span class="n">file_ispin</span> <span class="o">!=</span> <span class="n">ispin</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">file_ik</span> <span class="o">!=</span> <span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">file_ik</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">file_ispin</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;WFSX indices do not match the expected ones. Expected: [</span><span class="si">{</span><span class="n">ispin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ik</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">], found [</span><span class="si">{</span><span class="n">file_ispin</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">file_ik</span><span class="si">}</span><span class="s2">]&quot;</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nwf</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_next_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">nwf</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the next eigenstate values.</span>

<span class="sd">        This function should only be called after reading the states information</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ispin: integer</span>
<span class="sd">            the (python) spin index of the next eigenstate.</span>
<span class="sd">        ik: integer</span>
<span class="sd">            the (python) k index of the next eigenstate.</span>
<span class="sd">        nwf: integer</span>
<span class="sd">            The number of wavefunctions that the next eigenstate contains.</span>
<span class="sd">            Should have been obtained by reading the states info with `_r_next_info`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of shape (nwf,):</span>
<span class="sd">            The indices of each wavefunction that the state contains.</span>
<span class="sd">        array of shape (nwf,):</span>
<span class="sd">            The eigenvalues (in eV) of each wavefunction that the state contains.</span>
<span class="sd">        array of shape (norbitals, nwf):</span>
<span class="sd">            The coefficients for each wavefunction that the state contains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that we are in the right position in the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;We are not in a position to read k point WFSX values. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Read the state values</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span><span class="o">.</span><span class="n">read_next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">no_u</span><span class="p">,</span> <span class="n">nwf</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of the next state info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Check that everything went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;_r_next_values&quot;</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">&quot;could not read next eigenstate values [</span><span class="si">{</span><span class="n">ispin</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ik</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_r_next_eigenstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the next eigenstate in the WFSX file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ispin: integer</span>
<span class="sd">            the (python) spin index of the next eigenstate.</span>
<span class="sd">        ik: integer</span>
<span class="sd">            the (python) k index of the next eigenstate.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        EigenstateElectron:</span>
<span class="sd">            The next eigenstate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the information of this eigenstate</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nwf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_info</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">)</span>
        <span class="c1"># Now that we have the information, we can read the values because</span>
        <span class="c1"># we know the number of wavefunctions stored in the k point (`nwf`)</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_values</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">nwf</span><span class="p">)</span>

        <span class="c1"># Build the info dictionary for the eigenstate to know how it was calculated</span>
        <span class="c1"># We include the spin index if needed.</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_k</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">gauge</span><span class="o">=</span><span class="s2">&quot;orbital&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ispin</span>

        <span class="c1"># `eig` is already in eV</span>
        <span class="c1"># See onlysSileSiesta.read_lattice to understand why we transpose `state`</span>
        <span class="k">return</span> <span class="n">EigenstateElectron</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

<div class="viewcode-block" id="wfsxSileSiesta.read_sizes">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_sizes">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the sizes related to this WFSX file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int : number of spin components</span>
<span class="sd">        int : number of orbitals in the unit-cell</span>
<span class="sd">        int : number of k-points</span>
<span class="sd">        bool : True if the file only contains the Gamma-point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_wfsx</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_sizes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sizes</span></div>


<div class="viewcode-block" id="wfsxSileSiesta.read_basis">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_basis">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Atoms</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the basis contained in the WFSX file.</span>

<span class="sd">        The WFSX file only contains information about the atom labels, which atom</span>
<span class="sd">        each orbital belongs to and the orbital quantum numbers. It is thus not</span>
<span class="sd">        complete in every sense.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Atoms:</span>
<span class="sd">            the basis read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_wfsx</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_sizes</span><span class="p">(</span><span class="n">skip_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_basis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">basis</span></div>


<div class="viewcode-block" id="wfsxSileSiesta.yield_eigenstate">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.yield_eigenstate">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">yield_eigenstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Iterates over the states in the WFSX file</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        EigenstateElectron</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open file and get parsing information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_parsing</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">itt_spin</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">itt_spin</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Iterate over all eigenstates in the WFSX file, yielding control to the caller at</span>
            <span class="c1"># each iteration.</span>
            <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ispin</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nk</span><span class="p">),</span> <span class="n">itt_spin</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_r_next_eigenstate</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">)</span>
            <span class="c1"># We ran out of eigenstates</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
            <span class="c1"># The loop in which the generator was used has been broken.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span></div>


<div class="viewcode-block" id="wfsxSileSiesta.read_eigenstate">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_eigenstate">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;ktol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;atol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;use atol instead of ktol&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_eigenstate</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">spin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">EigenstateElectron</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads a specific eigenstate from the file.</span>

<span class="sd">        This method iterates over the states until it finds a match. Do not call</span>
<span class="sd">        this method repeatedly. If you want to loop eigenstates, use `yield_eigenstate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: array-like of shape (3,), optional</span>
<span class="sd">            The k point of the state you want to find.</span>
<span class="sd">        spin:</span>
<span class="sd">            The spin index of the state you want to find. Only meaningful for polarized</span>
<span class="sd">            calculations.</span>
<span class="sd">        atol:</span>
<span class="sd">            The threshold value for considering two k-points the same (i.e. to match</span>
<span class="sd">            the query k point with the states k point).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        yield_eigenstate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        EigenstateElectron or None:</span>
<span class="sd">            If found, the state that was queried.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        LookupError :</span>
<span class="sd">            in case the requested k-point can not be found in the file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over all eigenstates in the file</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_eigenstate</span><span class="p">():</span>
            <span class="n">info</span> <span class="o">=</span> <span class="n">state</span><span class="o">.</span><span class="n">info</span>
            <span class="k">if</span> <span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;spin&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">spin</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">info</span><span class="p">[</span><span class="s2">&quot;k&quot;</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">atol</span><span class="p">):</span>
                <span class="c1"># This is the state that the user requested</span>
                <span class="k">return</span> <span class="n">state</span>
        <span class="k">raise</span> <span class="ne">LookupError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.read_eigenstate could not find k-point: </span><span class="si">{</span><span class="n">k</span><span class="si">!s}</span><span class="s2"> eigenstate&quot;</span>
        <span class="p">)</span></div>


<div class="viewcode-block" id="wfsxSileSiesta.read_info">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_info">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reads the information for all the k points contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k: array of shape (nk, 3)</span>
<span class="sd">            k values of the k points contained in the file.</span>
<span class="sd">        weight: array of shape (nk,)</span>
<span class="sd">            weight of each k point</span>
<span class="sd">        nwf: array of shape (nspin, nk)</span>
<span class="sd">            number of wavefunctions that each kpoint(-spin) contains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open file and get parsing information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_parsing</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_basis</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Check if we are in the correct position in the file (we should be just after the header)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;We are not in a position to read eigenstate info in the file. State: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nspin</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nspin</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Read all the information. Parse here the k values obtained.</span>
        <span class="c1"># Store the information that should be returned under `returns`.</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">kw</span><span class="p">,</span> <span class="n">nwf</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_all_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nk</span><span class="p">)</span>

        <span class="c1"># Close the file unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="c1"># Check for errors in the read.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_info&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read file information.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_k</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">kw</span><span class="p">,</span> <span class="n">nwf</span></div>


<div class="viewcode-block" id="wfsxSileSiesta.read_brillouinzone">
<a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_brillouinzone">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read_brillouinzone</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BrillouinZone</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the brillouin zone object&quot;&quot;&quot;</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_gridSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Binary real-space grid file</span>

<span class="sd">    The Siesta binary grid sile will automatically convert the units from Siesta</span>
<span class="sd">    units (Bohr, Ry) to sisl units (Ang, eV) provided the correct extension is present.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">read_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Lattice</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Return the cell contained in the file&quot;&quot;&quot;</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_lattice&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read cell.&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">read_grid_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Query grid size information such as the grid size and number of spin components</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int : number of spin-components</span>
<span class="sd">        mesh : 3 values for the number of mesh-elements</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read the sizes</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_grid_size&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read grid sizes.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Grid</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read grid contained in the Grid file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or str or array_like, optional</span>
<span class="sd">           the spin-index for retrieving one of the components. If a vector</span>
<span class="sd">           is passed it refers to the fraction per indexed component. I.e.</span>
<span class="sd">           ``[0.5, 0.5]`` will return sum of half the first two components.</span>
<span class="sd">           Default to the first component.</span>
<span class="sd">        dtype : numpy.float64, optional</span>
<span class="sd">           default data-type precision</span>
<span class="sd">        spin : optional</span>
<span class="sd">           same as `index` argument. `spin` argument has precedence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;spin&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="c1"># Read the sizes and cell</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_grid_size</span><span class="p">()</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_lattice</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_grid&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read grid.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">index</span> <span class="o">=</span> <span class="n">index</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="c1"># convert to factors</span>
            <span class="k">if</span> <span class="n">index</span> <span class="o">==</span> <span class="s2">&quot;z&quot;</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="s2">&quot;x&quot;</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="s2">&quot;y&quot;</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">index</span> <span class="o">==</span> <span class="s2">&quot;total&quot;</span><span class="p">:</span>
                <span class="n">index</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">nspin</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">index</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">nspin</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.read_grid got a wrong spin request for the grid values.&quot;</span>
                <span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid_reduce_indices</span><span class="p">(</span><span class="n">grid</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">axis</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Simply create the grid (with no information)</span>
        <span class="c1"># We will overwrite the actual grid</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">lattice</span><span class="o">=</span><span class="n">lattice</span><span class="p">)</span>
        <span class="c1"># NOTE: there is no need to swap-axes since the returned array is in F ordering</span>
        <span class="c1">#       and thus the first axis is the fast (x, y, z) is retained</span>
        <span class="n">g</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_unit</span>
        <span class="k">return</span> <span class="n">g</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">grids</span><span class="p">:</span> <span class="n">Grid</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the grid to the file&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_open</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_grid_header</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span>
            <span class="nb">len</span><span class="p">(</span><span class="n">grids</span><span class="p">),</span>
            <span class="o">*</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
        <span class="p">)</span>

        <span class="k">for</span> <span class="n">grid</span> <span class="ow">in</span> <span class="n">grids</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span> <span class="o">!=</span> <span class="n">grids</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">shape</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.write_grid got grids with different shapes.&quot;</span>
                <span class="p">)</span>

            <span class="k">if</span> <span class="n">grid</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">in</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">):</span>
                <span class="n">_siesta</span><span class="o">.</span><span class="n">write_grid_sp</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span>
                    <span class="n">_toF</span><span class="p">(</span><span class="n">grid</span><span class="o">.</span><span class="n">grid</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_unit</span><span class="p">),</span>
                    <span class="o">*</span><span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">,</span>
                <span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.write_grid can only write real-valued grids.&quot;</span>
                <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_close</span><span class="p">()</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">_gfSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Surface Green function file containing, Hamiltonian, overlap matrix and self-energies</span>

<span class="sd">    Do not mix read and write statements when using this code. Complete one or the other</span>
<span class="sd">    before doing the other thing. Fortran does not allow the same file opened twice, if this</span>
<span class="sd">    is needed you are recommended to make a symlink to the file and thus open two different</span>
<span class="sd">    files.</span>

<span class="sd">    This small snippet reads/writes the GF file</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&quot;hello.GF&quot;) as f:</span>
<span class="sd">    ...    nspin, no, k, E = f.read_header()</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            H, S = f.read_hamiltonian()</span>
<span class="sd">    ...        SeHSE = f.read_self_energy()</span>

<span class="sd">    To write a file do:</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&quot;hello.GF&quot;) as f:</span>
<span class="sd">    ...    f.write_header(sisl.MonkhorstPack(...), E)</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            f.write_hamiltonian(H, S)</span>
<span class="sd">    ...        f.write_self_energy(SeHSE)</span>

<span class="sd">    Notes</span>
<span class="sd">    -----</span>

<span class="sd">    The Greens function files does not implement the cases where un-expanded</span>
<span class="sd">    parts of the self-energies/Hamiltonians are stored.</span>
<span class="sd">    This is a missing implementation.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_open</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="n">rewind</span><span class="p">)</span>

        <span class="c1"># They will at any given time</span>
        <span class="c1"># correspond to the current Python indices that is to be read</span>
        <span class="c1"># The process for identification is done on this basis:</span>
        <span class="c1">#  iE is the current (Python) index for the energy-point to be read</span>
        <span class="c1">#  ik is the current (Python) index for the k-point to be read</span>
        <span class="c1">#  ispin is the current (Python) index for the spin-index to be read (only has meaning for a spin-polarized</span>
        <span class="c1">#         GF files)</span>
        <span class="c1">#  state is:</span>
        <span class="c1">#        -1 : the file-descriptor has just been opened (i.e. in front of header)</span>
        <span class="c1">#         0 : it means that the file-descriptor IS in front of H and S</span>
        <span class="c1">#         1 : it means that the file-descriptor is NOT in front of H and S but somewhere in front of a self-energy</span>
        <span class="c1">#  is_read is:</span>
        <span class="c1">#         0 : means that the current indices HAVE NOT been read</span>
        <span class="c1">#         1 : means that the current indices HAVE been read</span>
        <span class="c1">#</span>
        <span class="c1"># All routines in the gf_read/write sources requires input in Python indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_close_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_close</span><span class="p">()</span>

        <span class="c1"># Clean variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_step_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Method for stepping values *must* be called before doing the actual read to check correct values&quot;&quot;&quot;</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="p">{</span><span class="s2">&quot;method&quot;</span><span class="p">:</span> <span class="n">method</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;header&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># The header only exists once, so check whether it is the correct place to read/write</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because the header has already &quot;</span>
                    <span class="s2">&quot;been read.&quot;</span>
                <span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1"># print(&quot;HEADER: &quot;, self._state, self._ispin, self._ik, self._iE)</span>

        <span class="k">elif</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;HS&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Correct for the previous state and jump values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We have just read the header</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because the file descriptor &quot;</span>
                        <span class="s2">&quot;has not read the header.&quot;</span>
                    <span class="p">)</span>
                <span class="c1"># Reset values as though the header has just been read</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because the file descriptor &quot;</span>
                        <span class="s2">&quot;has already read the current HS for the given k-point.&quot;</span>
                    <span class="p">)</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We have just read from the last energy-point</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because the file descriptor &quot;</span>
                        <span class="s2">&quot;has not read all energy-points for a given k-point.&quot;</span>
                    <span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">:</span>
                    <span class="c1"># We need to step spin</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># print(&quot;HS: &quot;, self._state, self._ispin, self._ik, self._iE)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">:</span>
                <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;nspin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because of missing information, &quot;</span>
                    <span class="s2">&quot;a non-existing entry has been requested! spin=</span><span class="si">{spin}</span><span class="s2"> max_spin=</span><span class="si">{nspin}</span><span class="s2">.&quot;</span>
                <span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are reading an energy-point</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because the file descriptor &quot;</span>
                    <span class="s2">&quot;has an unknown state.&quot;</span>
                <span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Fine, we have just read the HS, ispin and ik are correct</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because the file descriptor &quot;</span>
                        <span class="s2">&quot;has an unknown state.&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="c1"># we have not read the current energy-point.and self._iE + 1 &lt; self._nE:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because the file descriptor &quot;</span>
                        <span class="s2">&quot;has an unknown state.&quot;</span>
                    <span class="p">)</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="c1"># You are trying to read beyond the entry</span>
                    <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;iE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">opt</span><span class="p">[</span><span class="s2">&quot;NE&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> failed because of missing information, &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;a non-existing energy-point has been requested! E_index=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="o">+</span><span class="mi">1</span><span class="si">}</span><span class="s2"> max_E_index=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>
            <span class="c1"># print(&quot;SE: &quot;, self._state, self._ispin, self._ik, self._iE)</span>

        <span class="c1"># Always signal (when stepping) that we have not yet read the thing</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;read&quot;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">Eindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the closest energy index corresponding to the energy ``E``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float or int</span>
<span class="sd">           if ``int``, return it-self, else return the energy index which is</span>
<span class="sd">           closests to the energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">E</span>
        <span class="n">idxE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">ret_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="n">idxE</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ret_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">5e-3</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="o">+</span> <span class="s2">&quot; requesting energy &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV, found </span><span class="si">{</span><span class="n">ret_E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV as the closest energy!&quot;</span>
            <span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ret_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                <span class="o">+</span> <span class="s2">&quot; requesting energy &quot;</span>
                <span class="o">+</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV, found </span><span class="si">{</span><span class="n">ret_E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV as the closest energy!&quot;</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">idxE</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">kindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return the index of the k-point that is closests to the queried k-point (in reduced coordinates)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like of float or int</span>
<span class="sd">           the queried k-point in reduced coordinates :math:`]-0.5;0.5]`. If ``int``</span>
<span class="sd">           return it-self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">-</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">ret_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ret_k</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="n">SileWarning</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span>
                    <span class="o">+</span> <span class="s2">&quot; requesting k-point &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;[</span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">)</span>
                    <span class="o">+</span> <span class="s2">&quot; found &quot;</span>
                    <span class="o">+</span> <span class="s2">&quot;[</span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">ret_k</span><span class="p">)</span>
                <span class="p">)</span>
            <span class="p">)</span>
        <span class="k">return</span> <span class="n">ik</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">read_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Read the header of the file and open it for reading subsequently</span>

<span class="sd">        NOTES: this method may change in the future</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nspin : number of spin-components stored (1 or 2)</span>
<span class="sd">        no_u : size of the matrices returned</span>
<span class="sd">        k : k points in the GF file</span>
<span class="sd">        E : energy points in the GF file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure it is open (in read-mode)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">rewind_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_header&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read sizes.&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">=</span> <span class="n">nkpt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">=</span> <span class="n">NE</span>

        <span class="c1"># We need to rewind (because of k and energy -points)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">rewind_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s2">&quot;read_header&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_header&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read header information.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">8</span><span class="p">:</span>  <span class="c1"># Nambu</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>  <span class="c1"># non-colinear + soc</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">disk_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the estimated size of the resulting file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimated disk-space used in GB</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_open</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="c1"># HS are only stored per k-point</span>
        <span class="n">HS</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">HS</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span>

        <span class="c1"># Now calculate the full size</span>
        <span class="c1"># no_u ** 2 = matrix size</span>
        <span class="c1"># 16 = bytes in double complex</span>
        <span class="c1"># 1024 ** 3 = B -&gt; GB</span>
        <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">HS</span> <span class="o">+</span> <span class="n">SE</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">1024</span><span class="o">**</span><span class="mi">3</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">mem</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return current Hamiltonian and overlap matrix from the GF file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Hamiltonian matrix</span>
<span class="sd">        complex128 : Overlap matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="n">HS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;read_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read Hamiltonian and overlap matrices.&quot;</span>
        <span class="p">)</span>
        <span class="c1"># we don&#39;t convert to C order!</span>
        <span class="k">return</span> <span class="n">H</span> <span class="o">*</span> <span class="n">_Ry2eV</span><span class="p">,</span> <span class="n">S</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">read_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Read the currently reached bulk self-energy</span>

<span class="sd">        The returned self-energy is:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Self-energy matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s2">&quot;read_self_energy&quot;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_se</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_self_energy&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read self-energy.&quot;</span><span class="p">)</span>
        <span class="c1"># we don&#39;t convert to C order!</span>
        <span class="k">return</span> <span class="n">SE</span> <span class="o">*</span> <span class="n">_Ry2eV</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">HkSk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">spin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">tuple</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve H and S for the given k-point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or array_like of float, optional</span>
<span class="sd">           k-point to read the corresponding Hamiltonian and overlap matrices</span>
<span class="sd">           for. If a specific k-point is passed `kindex` will be used to find</span>
<span class="sd">           the corresponding index.</span>
<span class="sd">        spin :</span>
<span class="sd">           spin-index for the Hamiltonian and overlap matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="c1"># find k-index that is requested</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kindex</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_find</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">spin</span><span class="p">,</span>
            <span class="n">ik</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;HkSk&quot;</span><span class="p">,</span> <span class="s2">&quot;could not find Hamiltonian and overlap matrix.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">spin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># signal this is to be read</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_hamiltonian</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">spin</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve self-energy for a given energy-point and k-point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : int or float</span>
<span class="sd">           energy to retrieve self-energy at</span>
<span class="sd">        k : int or array_like of float, optional</span>
<span class="sd">           k-point to retrieve k-point at</span>
<span class="sd">        spin :</span>
<span class="sd">           spin-index to retrieve self-energy at</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kindex</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">iE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_find</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span><span class="p">,</span>
            <span class="mi">1</span><span class="p">,</span>
            <span class="n">spin</span><span class="p">,</span>
            <span class="n">ik</span><span class="p">,</span>
            <span class="n">iE</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;self_energy&quot;</span><span class="p">,</span> <span class="s2">&quot;could not find requested self-energy.&quot;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">spin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="n">iE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>  <span class="c1"># signal this is to be read</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_self_energy</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bz</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">mu</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write to the binary file the header of the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bz : BrillouinZone</span>
<span class="sd">           contains the k-points, the weights and possibly the parent Hamiltonian (if `obj` is None)s</span>
<span class="sd">        E : array_like of cmplx or float</span>
<span class="sd">           the energy points. If `obj` is an instance of `SelfEnergy` where an</span>
<span class="sd">           associated ``eta`` is defined then `E` may be float, otherwise</span>
<span class="sd">           it *has* to be a complex array.</span>
<span class="sd">        mu :</span>
<span class="sd">           chemical potential in the file</span>
<span class="sd">        obj : ..., optional</span>
<span class="sd">           an object that contains the Hamiltonian definitions, defaults to ``bz.parent``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">nspin</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">spin</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">lattice</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">na_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>
        <span class="n">no_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span>
        <span class="c1"># The lasto in siesta requires lasto(0) == 0</span>
        <span class="c1"># and secondly, the Python index to fortran</span>
        <span class="c1"># index makes firsto behave like fortran lasto</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span>
        <span class="n">bloch</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">E</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">eta</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bz</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">k</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">weight</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s2">&quot;na_used&quot;</span><span class="p">:</span> <span class="n">na_u</span><span class="p">,</span>
            <span class="s2">&quot;nkpt&quot;</span><span class="p">:</span> <span class="n">Nk</span><span class="p">,</span>
            <span class="s2">&quot;ne&quot;</span><span class="p">:</span> <span class="n">NE</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>

        <span class="c1"># Ensure it is open (in write mode)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">)</span>

        <span class="c1"># Now write to it...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s2">&quot;write_header&quot;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_lattice for .T</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_header</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span>
            <span class="n">nspin</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
            <span class="n">na_u</span><span class="p">,</span>
            <span class="n">no_u</span><span class="p">,</span>
            <span class="n">no_u</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
            <span class="n">lasto</span><span class="p">,</span>
            <span class="n">bloch</span><span class="p">,</span>
            <span class="mi">0</span><span class="p">,</span>
            <span class="n">mu</span> <span class="o">*</span> <span class="n">_eV2Ry</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
            <span class="n">w</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">/</span> <span class="n">_Ry2eV</span><span class="p">,</span>
            <span class="o">**</span><span class="n">sizes</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;write_header&quot;</span><span class="p">,</span> <span class="s2">&quot;could not write header information.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Write the current energy, k-point and H and S to the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        H : matrix</span>
<span class="sd">           a square matrix corresponding to the Hamiltonian</span>
<span class="sd">        S : matrix, optional</span>
<span class="sd">           a square matrix corresponding to the overlap, for efficiency reasons</span>
<span class="sd">           it may be advantageous to specify this argument for orthogonal cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s2">&quot;F&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s2">&quot;write_hamiltonian&quot;</span><span class="p">,</span> <span class="n">HS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_hs</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">]</span> <span class="o">/</span> <span class="n">_Ry2eV</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span>
            <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span>
            <span class="s2">&quot;write_hamiltonian&quot;</span><span class="p">,</span> <span class="s2">&quot;could not write Hamiltonian and overlap matrices.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">write_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SE</span><span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Write the current self energy, k-point and H and S to the file</span>

<span class="sd">        The self-energy must correspond to the *bulk* self-energy</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SE : matrix</span>
<span class="sd">           a square matrix corresponding to the self-energy (Green function)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s2">&quot;write_self_energy&quot;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_se</span><span class="p">(</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">]</span> <span class="o">/</span> <span class="n">_Ry2eV</span><span class="p">,</span>
            <span class="n">_toF</span><span class="p">(</span><span class="n">SE</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span>
            <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">,</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;write_self_energy&quot;</span><span class="p">,</span> <span class="s2">&quot;could not write self-energy.&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return number of entries thi object has&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterate through the energies and k-points that this GF file is associated with</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        bool, list of float, float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get everything</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">GFStep</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;GFStep&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">,</span> <span class="s2">&quot;do_HS&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ispin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">GFStep</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;GFStep&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;do_HS&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>

        <span class="c1"># We will automatically close once we hit the end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>


<span class="k">def</span><span class="w"> </span><span class="nf">_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dic</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Always pass the docstring</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="s2">&quot;__doc__&quot;</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="s2">&quot;__doc__&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="p">,),</span> <span class="n">dic</span><span class="p">)</span>


<span class="c1"># Faster than class ... \ pass</span>
<span class="n">tsgfSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;tsgfSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gfSileSiesta</span><span class="p">)</span>
<span class="n">gridSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;gridSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span><span class="p">})</span>

<span class="k">if</span> <span class="n">has_fortran_module</span><span class="p">:</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TSHS&quot;</span><span class="p">,</span> <span class="n">tshsSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;onlyS&quot;</span><span class="p">,</span> <span class="n">onlysSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TSDE&quot;</span><span class="p">,</span> <span class="n">tsdeSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;DM&quot;</span><span class="p">,</span> <span class="n">dmSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;HSX&quot;</span><span class="p">,</span> <span class="n">hsxSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;TSGF&quot;</span><span class="p">,</span> <span class="n">tsgfSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;WFSX&quot;</span><span class="p">,</span> <span class="n">wfsxSileSiesta</span><span class="p">)</span>
    <span class="c1"># These have unit-conversions</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;RHO&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;LDOS&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;ldosSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;RHOINIT&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoinitSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;RHOXC&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoxcSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;DRHO&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;drhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;BADER&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;baderSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;IOCH&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;iorhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;TOCH&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalrhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="c1"># The following two files *require* that</span>
    <span class="c1">#  STM.DensityUnits   Ele/bohr**3</span>
    <span class="c1">#  which I can&#39;t check!</span>
    <span class="c1"># They are however the default</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;STS&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;stsSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;STM.LDOS&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;stmldosSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="o">**</span><span class="mi">3</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s2">&quot;VH&quot;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;hartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="n">_Ry2eV</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;VNA&quot;</span><span class="p">,</span>
        <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;neutralatomhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="n">_Ry2eV</span><span class="p">}),</span>
    <span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span>
        <span class="s2">&quot;VT&quot;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s2">&quot;grid_unit&quot;</span><span class="p">:</span> <span class="n">_Ry2eV</span><span class="p">})</span>
    <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>