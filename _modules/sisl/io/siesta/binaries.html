<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.io.siesta.binaries &mdash; sisl 0.1.dev1+ga8efd77 documentation</title>
      <link rel="stylesheet" href="../../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/plot_directive.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/graphviz.css" type="text/css" />
      <link rel="stylesheet" href="../../../../_static/sg_gallery.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../../" id="documentation_options" src="../../../../_static/documentation_options.js"></script>
        <script src="../../../../_static/jquery.js"></script>
        <script src="../../../../_static/underscore.js"></script>
        <script src="../../../../_static/doctools.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.0/dist/embed-amd.js"></script>
    <script src="../../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../../genindex.html" />
    <link rel="search" title="Search" href="../../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../../index.html" class="icon icon-home"> sisl
          </a>
              <div class="version">
                0.1.dev1+ga8efd77
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../contribute.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../other.html">Other resources</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorials.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../scripts/scripts.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Toolboxes</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Visualization</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../visualization/ase/index.html">ASE</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../visualization/viz_module/index.html">The <code class="docutils literal notranslate"><span class="pre">sisl.viz</span></code> module</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Reference documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../api/index.html">API documentation</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      <li>sisl.io.siesta.binaries</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.io.siesta.binaries</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span> <span class="nn">numbers</span> <span class="kn">import</span> <span class="n">Integral</span>
<span class="kn">from</span> <span class="nn">itertools</span> <span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span><span class="p">,</span> <span class="n">namedtuple</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">pi</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_siesta</span>
    <span class="n">found_module</span> <span class="o">=</span> <span class="kc">True</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
    <span class="n">found_module</span> <span class="o">=</span> <span class="kc">False</span>

<span class="kn">from</span> <span class="nn">..sile</span> <span class="kn">import</span> <span class="n">add_sile</span><span class="p">,</span> <span class="n">SileError</span><span class="p">,</span> <span class="n">SileWarning</span>
<span class="kn">from</span> <span class="nn">.sile</span> <span class="kn">import</span> <span class="n">SileBinSiesta</span>
<span class="kn">from</span> <span class="nn">sisl._internal</span> <span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span> <span class="nn">sisl.messages</span> <span class="kn">import</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span><span class="p">,</span> <span class="n">SislError</span>

<span class="kn">from</span> <span class="nn">._help</span> <span class="kn">import</span> <span class="o">*</span>
<span class="kn">import</span> <span class="nn">sisl._array</span> <span class="k">as</span> <span class="nn">_a</span>
<span class="kn">from</span> <span class="nn">sisl</span> <span class="kn">import</span> <span class="n">Geometry</span><span class="p">,</span> <span class="n">Atom</span><span class="p">,</span> <span class="n">Atoms</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">,</span> <span class="n">Grid</span><span class="p">,</span> <span class="n">SparseCSR</span>
<span class="kn">from</span> <span class="nn">sisl</span> <span class="kn">import</span> <span class="n">AtomicOrbital</span>
<span class="kn">from</span> <span class="nn">sisl.sparse</span> <span class="kn">import</span> <span class="n">_ncol_to_indptr</span>
<span class="kn">from</span> <span class="nn">sisl.unit.siesta</span> <span class="kn">import</span> <span class="n">unit_convert</span>
<span class="kn">from</span> <span class="nn">sisl.physics.sparse</span> <span class="kn">import</span> <span class="n">SparseOrbitalBZ</span>
<span class="kn">from</span> <span class="nn">sisl.physics</span> <span class="kn">import</span> <span class="n">Hamiltonian</span><span class="p">,</span> <span class="n">DensityMatrix</span><span class="p">,</span> <span class="n">EnergyDensityMatrix</span>
<span class="kn">from</span> <span class="nn">sisl.physics</span> <span class="kn">import</span> <span class="n">BrillouinZone</span>
<span class="kn">from</span> <span class="nn">sisl.physics.overlap</span> <span class="kn">import</span> <span class="n">Overlap</span>
<span class="kn">from</span> <span class="nn">sisl.physics.electron</span> <span class="kn">import</span> <span class="n">EigenstateElectron</span>


<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;tshsSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;onlysSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;tsdeSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;hsxSileSiesta&#39;</span><span class="p">,</span> <span class="s1">&#39;dmSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;wfsxSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;gridSileSiesta&#39;</span><span class="p">]</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s1">&#39;tsgfSileSiesta&#39;</span><span class="p">]</span>


<span class="n">_Bohr2Ang</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Bohr&#39;</span><span class="p">,</span> <span class="s1">&#39;Ang&#39;</span><span class="p">)</span>
<span class="n">_Ry2eV</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;Ry&#39;</span><span class="p">,</span> <span class="s1">&#39;eV&#39;</span><span class="p">)</span>
<span class="n">_eV2Ry</span> <span class="o">=</span> <span class="n">unit_convert</span><span class="p">(</span><span class="s1">&#39;eV&#39;</span><span class="p">,</span> <span class="s1">&#39;Ry&#39;</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">_toF</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">scale</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">array</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
    <span class="k">elif</span> <span class="n">array</span><span class="o">.</span><span class="n">dtype</span> <span class="o">==</span> <span class="n">dtype</span> <span class="ow">and</span> <span class="n">array</span><span class="o">.</span><span class="n">flags</span><span class="o">.</span><span class="n">f_contiguous</span><span class="p">:</span>
        <span class="c1"># no need to copy since the order is correct</span>
        <span class="k">return</span> <span class="n">array</span> <span class="o">*</span> <span class="n">scale</span>

    <span class="c1"># We have to handle cases</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty_like</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
    <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">scale</span><span class="p">,</span> <span class="n">out</span><span class="o">=</span><span class="n">out</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">out</span>


<span class="k">def</span> <span class="nf">_geometry_align</span><span class="p">(</span><span class="n">geom_b</span><span class="p">,</span> <span class="n">geom_u</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">method</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Routine used to align two geometries</span>

<span class="sd">    There are a few twists in this since the fdf-reads will automatically</span>
<span class="sd">    try and pass a geometry from the output files.</span>
<span class="sd">    In cases where the *.ion* files are non-existing this will</span>
<span class="sd">    result in a twist.</span>

<span class="sd">    This routine will select and return a merged Geometry which</span>
<span class="sd">    fulfills the correct number of atoms and orbitals.</span>

<span class="sd">    However, if the input geometries have mis-matching number</span>
<span class="sd">    of atoms a SislError will be raised.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    geom_b : Geometry from binary file</span>
<span class="sd">    geom_u : Geometry supplied by user</span>

<span class="sd">    Raises</span>
<span class="sd">    ------</span>
<span class="sd">    SislError</span>
<span class="sd">        if the geometries have non-equal atom count</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">geom_b</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom_u</span>
    <span class="k">elif</span> <span class="n">geom_u</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">geom_b</span>

    <span class="c1"># Default to use the users geometry</span>
    <span class="n">geom</span> <span class="o">=</span> <span class="n">geom_u</span>

    <span class="n">is_copy</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">def</span> <span class="nf">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">is_copy</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">geom</span><span class="p">,</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="n">geom</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span> <span class="kc">True</span>

    <span class="k">if</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">na</span> <span class="o">!=</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">:</span>
        <span class="c1"># we have no way of solving this issue...</span>
        <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> could not use the passed geometry as the &quot;</span>
                        <span class="sa">f</span><span class="s2">&quot;of atoms is not consistent, user-atoms=</span><span class="si">{</span><span class="n">geom_u</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s2">, file-atoms=</span><span class="si">{</span><span class="n">geom_b</span><span class="o">.</span><span class="n">na</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

    <span class="c1"># Try and figure out what to do</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">xyz</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has mismatched atomic coordinates, will copy geometry and use file XYZ.&quot;</span><span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has non-equal lattice vectors, will copy geometry and use file lattice.&quot;</span><span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="p">[:,</span> <span class="p">:]</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">nsc</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has non-equal number of supercells, will copy geometry and use file supercell count.&quot;</span><span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

    <span class="c1"># Now for the difficult part.</span>
    <span class="c1"># If there is a mismatch in the number of orbitals we will</span>
    <span class="c1"># prefer to use the user-supplied atomic species, but fill with</span>
    <span class="c1"># *random* orbitals</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="n">geom_b</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">):</span>
        <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="n">method</span><span class="si">}</span><span class="s2"> has non-equal number of orbitals per atom, will correct with *empty* orbitals.&quot;</span><span class="p">)</span>
        <span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span> <span class="o">=</span> <span class="n">get_copy</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">is_copy</span><span class="p">)</span>

        <span class="c1"># Now create a new atom specie with the correct number of orbitals</span>
        <span class="n">norbs</span> <span class="o">=</span> <span class="n">geom_b</span><span class="o">.</span><span class="n">atoms</span><span class="o">.</span><span class="n">orbitals</span><span class="p">[:]</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">([</span><span class="n">geom</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.</span><span class="p">]</span> <span class="o">*</span> <span class="n">norbs</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">)])</span>
        <span class="n">geom</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">atoms</span>

    <span class="k">return</span> <span class="n">geom</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">onlysSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Geometry and overlap matrix &quot;&quot;&quot;</span>

<div class="viewcode-block" id="onlysSileSiesta.read_supercell"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_supercell">[docs]</a>    <span class="k">def</span> <span class="nf">read_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns a SuperCell object from a TranSiesta file &quot;&quot;&quot;</span>
        <span class="n">n_s</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">3</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">n_s</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="c1"># We have to transpose since the data is read *as-is*</span>
        <span class="c1"># The cell in fortran files are (:, A1)</span>
        <span class="c1"># after reading this is still obeyed (regardless of order)</span>
        <span class="c1"># So we transpose to get it C-like</span>
        <span class="c1"># Note that care must be taken for the different data-structures</span>
        <span class="c1"># In particular not all data needs to be transposed (sparse H and S)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_geometry"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_geometry">[docs]</a>    <span class="k">def</span> <span class="nf">read_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns Geometry object from a TranSiesta file &quot;&quot;&quot;</span>

        <span class="c1"># Read supercell</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_supercell</span><span class="p">()</span>

        <span class="n">na</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="n">arr</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_geom</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read geometry.&#39;</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_supercell for .T</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

        <span class="c1"># Since the TSHS file does not contain species information</span>
        <span class="c1"># and/or other stuff we *can* reuse an existing</span>
        <span class="c1"># geometry which contains the correct atomic numbers etc.</span>
        <span class="n">orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">lasto</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create all different atoms...</span>
            <span class="c1"># The TSHS file does not contain the</span>
            <span class="c1"># atomic numbers, so we will just</span>
            <span class="c1"># create them individually</span>

            <span class="c1"># Get unique orbitals</span>
            <span class="n">uorb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span>
            <span class="c1"># Create atoms</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">Z</span><span class="p">,</span> <span class="n">orb</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">uorb</span><span class="p">):</span>
                <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">Z</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">orb</span><span class="p">))</span>

            <span class="k">def</span> <span class="nf">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">atom</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">atom</span><span class="o">.</span><span class="n">no</span> <span class="o">==</span> <span class="n">orbs</span><span class="p">:</span>
                        <span class="k">return</span> <span class="n">atom</span>

            <span class="n">atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">orb</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">:</span>
                <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">get_atom</span><span class="p">(</span><span class="n">atoms</span><span class="p">,</span> <span class="n">orb</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Create a new geometry with the correct atomic numbers</span>
            <span class="n">atom</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">ia</span><span class="p">,</span> <span class="n">no</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">geometry</span><span class="p">,</span> <span class="n">orbs</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">a</span><span class="o">.</span><span class="n">no</span> <span class="o">==</span> <span class="n">no</span><span class="p">:</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># correct atom</span>
                    <span class="n">atom</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span><span class="n">a</span><span class="o">.</span><span class="n">Z</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">io</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)],</span> <span class="n">mass</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">mass</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">a</span><span class="o">.</span><span class="n">tag</span><span class="p">))</span>

        <span class="c1"># Create and return geometry object</span>
        <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">atom</span><span class="p">,</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_overlap"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the overlap matrix from the TranSiesta file &quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">_geometry_align</span><span class="p">(</span><span class="n">tshs_g</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">tshs_g</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;read_overlap&#39;</span><span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_supercell for .T</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_s</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="c1"># equivalent as _csr_from_siesta with explicit isc from file</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">S</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># In siesta the matrix layout is written in CSC format</span>
        <span class="c1"># due to fortran indexing, this means that we need to transpose</span>
        <span class="c1"># to get it to correct layout.</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="onlysSileSiesta.read_fermi_level"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.onlysSileSiesta.html#sisl.io.siesta.onlysSileSiesta.read_fermi_level">[docs]</a>    <span class="k">def</span> <span class="nf">read_fermi_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Query the Fermi-level contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Ef : fermi-level of the system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_ef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_fermi_level&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read fermi-level.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ef</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">tshsSileSiesta</span><span class="p">(</span><span class="n">onlysSileSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Geometry, Hamiltonian and overlap matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="tshsSileSiesta.read_hamiltonian"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.read_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the electronic structure from the siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="n">tshs_g</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_geometry</span><span class="p">()</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">_geometry_align</span><span class="p">(</span><span class="n">tshs_g</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">tshs_g</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span> <span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">)</span>

        <span class="c1"># read the sizes used...</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_supercell for .T</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">3</span><span class="p">])[</span><span class="mi">2</span><span class="p">]</span><span class="o">.</span><span class="n">T</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>
        <span class="n">spin</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">no</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
        <span class="n">nnz</span> <span class="o">=</span> <span class="n">sizes</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tshs_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Check whether it is an orthogonal basis set</span>
        <span class="n">orthogonal</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">dS</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="n">orthogonal</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="p">])</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
            <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>

        <span class="c1"># Convert to sisl supercell</span>
        <span class="c1"># equivalent as _csr_from_siesta with explicit isc from file</span>
        <span class="n">_csr_from_sc_off</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">isc</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># Find all indices where dS == 1 (remember col is in fortran indices)</span>
        <span class="n">idx</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">dS</span><span class="p">,</span> <span class="mf">1.</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]]</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">idx</span> <span class="o">&gt;</span> <span class="n">no</span><span class="p">):</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;Number of orbitals: </span><span class="si">{</span><span class="n">no</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="nb">print</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.read_hamiltonian could not assert &#39;</span>
                            <span class="s1">&#39;the supercell connections in the primary unit-cell.&#39;</span><span class="p">)</span>

        <span class="c1"># see onlysSileSiesta.read_overlap for .transpose()</span>
        <span class="c1"># For H, DM and EDM we also need to Hermitian conjugate it.</span>
        <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="tshsSileSiesta.write_hamiltonian"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tshsSileSiesta.html#sisl.io.siesta.tshsSileSiesta.write_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes the Hamiltonian to a siesta.TSHS file &quot;&quot;&quot;</span>
        <span class="c1"># we sort below, so no need to do it here</span>
        <span class="c1"># see onlysSileSiesta.read_overlap for .transpose()</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_csr</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.write_hamiltonian cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="c1"># Convert to siesta CSR</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">csr</span><span class="p">)</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>

        <span class="c1"># Extract the data to pass to the fortran routine</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">xyz</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span>

        <span class="c1"># Get H and S</span>
        <span class="k">if</span> <span class="n">H</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">diags</span><span class="p">(</span><span class="mf">1.</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="c1"># Ensure all data is correctly formatted (i.e. have the same sparsity pattern)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">csr</span><span class="p">)</span>
            <span class="n">s</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">nnz</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">h</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span><span class="s1">&#39;The diagonal elements of your orthogonal Hamiltonian &#39;</span>
                                <span class="s1">&#39;have not been defined, this is a requirement.&#39;</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">h</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">H</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="c1"># Get shorter variants</span>
        <span class="n">nsc</span> <span class="o">=</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">nsc</span><span class="p">[:]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="n">isc</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">siesta_sc_off</span><span class="p">(</span><span class="o">*</span><span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># see onlysSileSiesta.read_supercell for .T</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_tshs_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span>
                              <span class="n">cell</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">,</span> <span class="n">xyz</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span><span class="p">,</span>
                              <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                              <span class="n">_toF</span><span class="p">(</span><span class="n">h</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span> <span class="n">_toF</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                              <span class="n">isc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">dmSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Density matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="dmSileSiesta.read_density_matrix"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.read_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">read_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the density matrix from the siesta.DM file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read density matrix sizes.&#39;</span><span class="p">)</span>

        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read density matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.read_density_matrix could not use the &#39;</span>
                            <span class="s1">&#39;passed geometry as the number of atoms or orbitals is &#39;</span>
                            <span class="s1">&#39;inconsistent with DM file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the density matrix container</span>
        <span class="n">DM</span> <span class="o">=</span> <span class="n">DensityMatrix</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dDM</span><span class="p">[:,</span> <span class="p">:]</span>
        <span class="c1"># DM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">DM</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.read_density_matrix may result in a wrong sparse pattern!&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">DM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="dmSileSiesta.write_density_matrix"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.dmSileSiesta.html#sisl.io.siesta.dmSileSiesta.write_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">write_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Writes the density matrix to a siesta.DM file &quot;&quot;&quot;</span>
        <span class="n">csr</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_csr</span>
        <span class="c1"># This ensures that we don&#39;t have any *empty* elements</span>
        <span class="k">if</span> <span class="n">csr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.write_density_matrix cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">csr</span><span class="p">)</span>
        <span class="c1"># We do not really need to sort this one, but we do for consistency</span>
        <span class="c1"># of the interface.</span>
        <span class="n">csr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">csr</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>

        <span class="c1"># Get DM</span>
        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">DM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="c1"># Ensure shapes (say if only 1 spin)</span>
        <span class="n">dm</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="p">))</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_dm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">csr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">_toF</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;write_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write density matrix.&#39;</span><span class="p">)</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">tsdeSileSiesta</span><span class="p">(</span><span class="n">dmSileSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Non-equilibrium density matrix and energy density matrix file &quot;&quot;&quot;</span>

<div class="viewcode-block" id="tsdeSileSiesta.read_energy_density_matrix"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.read_energy_density_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">read_energy_density_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the energy density matrix from the siesta.DM file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_energy_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read energy density matrix sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dEDM</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_edm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_energy_density_matrix&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read energy density matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># Try and immediately attach a geometry</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">geom</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># We truly, have no clue,</span>
            <span class="c1"># Just generate a boxed system</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="p">[[</span><span class="n">x</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">no</span><span class="p">)]</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">SuperCell</span><span class="p">([</span><span class="n">no</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="o">=</span><span class="n">nsc</span><span class="p">)</span>
            <span class="n">geom</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">Atom</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span> <span class="o">!=</span> <span class="n">nsc</span><span class="p">):</span>
            <span class="c1"># We have to update the number of supercells!</span>
            <span class="n">geom</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">nsc</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.read_energy_density_matrix could &#39;</span>
                            <span class="s1">&#39;not use the passed geometry as the number of atoms or orbitals &#39;</span>
                            <span class="s1">&#39;is inconsistent with DM file.&#39;</span><span class="p">)</span>

        <span class="c1"># Create the energy density matrix container</span>
        <span class="n">EDM</span> <span class="o">=</span> <span class="n">EnergyDensityMatrix</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dEDM</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="c1"># EDM file does not contain overlap matrix... so neglect it for now.</span>
        <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">EDM</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">&gt;=</span> <span class="n">col</span><span class="o">.</span><span class="n">max</span><span class="p">():</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.read_energy_density_matrix may result in a wrong sparse pattern!&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">EDM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="tsdeSileSiesta.read_fermi_level"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.read_fermi_level">[docs]</a>    <span class="k">def</span> <span class="nf">read_fermi_level</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Query the Fermi-level contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Ef : fermi-level of the system</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">Ef</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_tsde_ef</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_fermi_level&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read fermi-level.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Ef</span></div>

<div class="viewcode-block" id="tsdeSileSiesta.write_density_matrices"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.tsdeSileSiesta.html#sisl.io.siesta.tsdeSileSiesta.write_density_matrices">[docs]</a>    <span class="k">def</span> <span class="nf">write_density_matrices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">DM</span><span class="p">,</span> <span class="n">EDM</span><span class="p">,</span> <span class="n">Ef</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Writes the density matrix to a siesta.DM file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        DM : DensityMatrix</span>
<span class="sd">           density matrix to write to the file</span>
<span class="sd">        EDM : EnergyDensityMatrix</span>
<span class="sd">           energy density matrix to write to the file</span>
<span class="sd">        Ef : float, optional</span>
<span class="sd">           fermi-level to be contained</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">DMcsr</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">EDMcsr</span> <span class="o">=</span> <span class="n">EDM</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span><span class="o">.</span><span class="n">_csr</span>
        <span class="n">DMcsr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">EDMcsr</span><span class="p">)</span>
        <span class="n">EDMcsr</span><span class="o">.</span><span class="n">align</span><span class="p">(</span><span class="n">DMcsr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">nnz</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.write_density_matrices cannot write &#39;</span>
                            <span class="s1">&#39;a zero element sparse matrix!&#39;</span><span class="p">)</span>

        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">DMcsr</span><span class="p">)</span>
        <span class="n">_csr_to_siesta</span><span class="p">(</span><span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="p">)</span>
        <span class="n">sort</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)</span>
        <span class="n">DMcsr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="n">EDMcsr</span><span class="o">.</span><span class="n">finalize</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">sort</span><span class="p">)</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">DMcsr</span><span class="p">,</span> <span class="n">DM</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">EDMcsr</span><span class="p">,</span> <span class="n">EDM</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>

        <span class="c1"># Ensure everything is correct</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">)</span> <span class="ow">and</span>
                <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">DMcsr</span><span class="o">.</span><span class="n">col</span><span class="p">,</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">col</span><span class="p">)):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="bp">self</span><span class="si">!s}</span><span class="s1">.write_density_matrices got non compatible &#39;</span>
                             <span class="s1">&#39;DM and EDM matrices.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">DM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">dm</span> <span class="o">=</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">DM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">EDM</span><span class="o">.</span><span class="n">orthogonal</span><span class="p">:</span>
            <span class="n">edm</span> <span class="o">=</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">_D</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">edm</span> <span class="o">=</span> <span class="n">EDMcsr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">EDM</span><span class="o">.</span><span class="n">S_idx</span><span class="p">]</span>

        <span class="n">nsc</span> <span class="o">=</span> <span class="n">DM</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>

        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_tsde_dm_edm</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nsc</span><span class="p">,</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">ncol</span><span class="p">,</span> <span class="n">DMcsr</span><span class="o">.</span><span class="n">col</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span>
                                  <span class="n">_toF</span><span class="p">(</span><span class="n">dm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                  <span class="n">_toF</span><span class="p">(</span><span class="n">edm</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span> <span class="n">Ef</span> <span class="o">*</span> <span class="n">_eV2Ry</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;write_density_matrices&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write DM + EDM matrices.&#39;</span><span class="p">)</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">hsxSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Hamiltonian and overlap matrix file</span>

<span class="sd">    This file does not contain all information regarding the system.</span>

<span class="sd">    To ensure no errors are being raised one should pass a `Geometry` with</span>
<span class="sd">    correct number of atoms and correct number of supercells.</span>
<span class="sd">    The number of orbitals will be updated in the returned matrices geometry.</span>

<span class="sd">    &gt;&gt;&gt; hsx = hsxSileSiesta(&quot;siesta.HSX&quot;)</span>
<span class="sd">    &gt;&gt;&gt; HS = hsx.read_hamiltonian() # may fail</span>
<span class="sd">    &gt;&gt;&gt; HS = hsx.read_hamiltonian(geometry=&lt;&gt;) # should run correctly if above satisfied</span>

<span class="sd">    Users are adviced to use the `tshsSileSiesta` instead since that correctly contains</span>
<span class="sd">    all information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_xij2system</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">xij</span><span class="p">,</span> <span class="n">geometry</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Create a new geometry with *correct* nsc and somewhat correct xyz</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        xij : SparseCSR</span>
<span class="sd">            orbital distances</span>
<span class="sd">        geometry : Geometry, optional</span>
<span class="sd">            passed geometry</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">def</span> <span class="nf">get_geom_handle</span><span class="p">(</span><span class="n">xij</span><span class="p">):</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_atoms</span><span class="p">()</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">atoms</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">atoms</span><span class="p">)</span>

            <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">)</span>
            <span class="c1"># convert csr to dok format</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Now we have [0 0 0 0 1 1 1 1 2 2 ... no-1 no-1]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">xij</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">col</span>

            <span class="c1"># Parse xij to correct geometry</span>
            <span class="c1"># first figure out all zeros (i.e. self-atom-orbitals)</span>
            <span class="n">idx0</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">_D</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">),</span> <span class="mf">0.</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">row0</span> <span class="o">=</span> <span class="n">row</span><span class="p">[</span><span class="n">idx0</span><span class="p">]</span>

            <span class="c1"># convert row0 and col0 to a first attempt of &quot;atomization&quot;</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">idx0r</span> <span class="o">=</span> <span class="p">(</span><span class="n">row0</span> <span class="o">==</span> <span class="n">r</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">row0r</span> <span class="o">=</span> <span class="n">row0</span><span class="p">[</span><span class="n">idx0r</span><span class="p">]</span>
                <span class="c1"># although xij == 0, we just do % to ensure unit-cell orbs</span>
                <span class="n">col0r</span> <span class="o">=</span> <span class="n">col</span><span class="p">[</span><span class="n">idx0</span><span class="p">[</span><span class="n">idx0r</span><span class="p">]]</span> <span class="o">%</span> <span class="n">N</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">all</span><span class="p">(</span><span class="n">col0r</span> <span class="o">&gt;=</span> <span class="n">r</span><span class="p">):</span>
                    <span class="c1"># we have a new atom</span>
                    <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">col0r</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">atoms</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">col0r</span><span class="p">))</span>

            <span class="c1"># convert list of orbitals to lists</span>
            <span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">a</span><span class="p">):</span>
                <span class="n">a</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span>
                <span class="n">a</span><span class="o">.</span><span class="n">sort</span><span class="p">()</span>
                <span class="k">return</span> <span class="n">a</span>
            <span class="n">atoms</span> <span class="o">=</span> <span class="p">[</span><span class="nb">list</span><span class="p">(</span><span class="n">a</span><span class="p">)</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">]</span>
            <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="n">atoms</span><span class="p">))</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> could not determine correct &quot;</span>
                                 <span class="s2">&quot;number of orbitals.&quot;</span><span class="p">)</span>

            <span class="n">atms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">0</span><span class="p">]]))</span>
            <span class="k">for</span> <span class="n">orbs</span> <span class="ow">in</span> <span class="n">atoms</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">atms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="s1">&#39;H&#39;</span><span class="p">,</span> <span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">([</span><span class="nb">len</span><span class="p">(</span><span class="n">atoms</span><span class="p">),</span> <span class="mi">3</span><span class="p">]),</span> <span class="n">atms</span><span class="p">)</span>

        <span class="n">geom_handle</span> <span class="o">=</span> <span class="n">get_geom_handle</span><span class="p">(</span><span class="n">xij</span><span class="p">)</span>

        <span class="k">def</span> <span class="nf">convert_to_atom</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">xij</span><span class="p">):</span>
            <span class="c1"># o2a does not check for correct super-cell index</span>
            <span class="n">n_s</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">atm_s</span> <span class="o">=</span> <span class="n">geom</span><span class="o">.</span><span class="n">o2a</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]))</span>

            <span class="c1"># convert csr to dok format</span>
            <span class="n">row</span> <span class="o">=</span> <span class="p">(</span><span class="n">xij</span><span class="o">.</span><span class="n">ncol</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">row</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">xij</span><span class="o">.</span><span class="n">ncol</span><span class="p">[</span><span class="n">row</span><span class="p">])</span>
            <span class="n">col</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">col</span>
            <span class="n">arow</span> <span class="o">=</span> <span class="n">atm_s</span><span class="p">[</span><span class="n">row</span><span class="p">]</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">atm_s</span><span class="p">[</span><span class="n">col</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">atm_s</span><span class="p">,</span> <span class="n">row</span><span class="p">,</span> <span class="n">col</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">lexsort</span><span class="p">((</span><span class="n">acol</span><span class="p">,</span> <span class="n">arow</span><span class="p">))</span>
            <span class="n">arow</span> <span class="o">=</span> <span class="n">arow</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">acol</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">xij</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">_D</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="k">del</span> <span class="n">idx</span>

            <span class="c1"># Now figure out if xij is consistent</span>
            <span class="n">duplicates</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">acol</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span>
                                        <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">arow</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">duplicates</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xij</span><span class="p">[</span><span class="n">duplicates</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">xij</span><span class="p">[</span><span class="n">duplicates</span><span class="p">],</span> <span class="mf">0.</span><span class="p">):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> converting xij(orb) -&gt; xij(atom) went wrong. &quot;</span>
                                     <span class="s2">&quot;This may happen if your coordinates are not inside the unitcell, please pass &quot;</span>
                                     <span class="s2">&quot;a usable geometry.&quot;</span><span class="p">)</span>

            <span class="c1"># remove duplicates to create new matrix</span>
            <span class="n">arow</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">arow</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">)</span>
            <span class="n">acol</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">acol</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">)</span>
            <span class="n">xij</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">duplicates</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="c1"># Create a new sparse matrix</span>
            <span class="c1"># Create the new index pointer</span>
            <span class="n">indptr</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">)],</span> <span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">),</span> <span class="mi">1</span><span class="p">,</span>
                               <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">arow</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">indptr</span><span class="p">)</span> <span class="o">==</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">return</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">xij</span><span class="p">,</span> <span class="n">acol</span><span class="p">,</span> <span class="n">indptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">na</span><span class="p">,</span> <span class="n">geom</span><span class="o">.</span><span class="n">na</span> <span class="o">*</span> <span class="n">n_s</span><span class="p">))</span>

        <span class="k">def</span> <span class="nf">coord_from_xij</span><span class="p">(</span><span class="n">xij</span><span class="p">):</span>
            <span class="c1"># first atom is at 0, 0, 0</span>
            <span class="n">na</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">xij</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="n">na</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">xyz</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">na</span><span class="p">)</span>
            <span class="n">mark</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">run_atoms</span> <span class="o">=</span> <span class="n">deque</span><span class="p">([</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">run_atoms</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">atm</span> <span class="o">=</span> <span class="n">run_atoms</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">xyz_atm</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[</span><span class="n">atm</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atm</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">atm</span><span class="p">)</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="n">neighbours</span> <span class="o">&lt;</span> <span class="n">na</span><span class="p">]</span>

                <span class="c1"># update those that haven&#39;t been calculated</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">mark</span><span class="p">[</span><span class="n">neighbours</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="n">neigh_idx</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">neigh_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>
                <span class="n">xyz</span><span class="p">[</span><span class="n">neigh_idx</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">xij</span><span class="p">[</span><span class="n">atm</span><span class="p">,</span> <span class="n">neigh_idx</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz_atm</span>
                <span class="n">mark</span><span class="p">[</span><span class="n">neigh_idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                <span class="c1"># add more atoms to be processed, since we have *mark*</span>
                <span class="c1"># we will only run every atom once</span>
                <span class="n">run_atoms</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">neigh_idx</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>

                <span class="c1"># check that everything is correct</span>
                <span class="k">if</span> <span class="p">(</span><span class="o">~</span><span class="n">idx</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">neg_neighbours</span> <span class="o">=</span> <span class="n">neighbours</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="n">neg_neighbours</span><span class="p">,</span> <span class="p">:],</span>
                                       <span class="n">xij</span><span class="p">[</span><span class="n">atm</span><span class="p">,</span> <span class="n">neg_neighbours</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz_atm</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; xyz did not  &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;find same coordinates for different connections&quot;</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">mark</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">!=</span> <span class="n">na</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; Geometry does not  &quot;</span>
                                 <span class="sa">f</span><span class="s2">&quot;have a fully connected geometry. It is impossible to create relative coordinates&quot;</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">xyz</span>

        <span class="k">def</span> <span class="nf">sc_from_xij</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">xyz</span><span class="p">):</span>
            <span class="n">na</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">n_s</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">n_s</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># easy!!</span>
                <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">xyz</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-</span> <span class="n">xyz</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">10.</span><span class="p">,</span> <span class="n">nsc</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>

            <span class="n">sc_off</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="n">n_s</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="n">mark</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosi</span><span class="p">(</span><span class="n">n_s</span><span class="p">)</span>
            <span class="n">mark</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">atm</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">na</span><span class="p">):</span>
                <span class="n">neighbours</span> <span class="o">=</span> <span class="n">xij</span><span class="o">.</span><span class="n">edges</span><span class="p">(</span><span class="n">atm</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="n">atm</span><span class="p">)</span>
                <span class="n">uneighbours</span> <span class="o">=</span> <span class="n">neighbours</span> <span class="o">%</span> <span class="n">na</span>
                <span class="n">neighbour_isc</span> <span class="o">=</span> <span class="n">neighbours</span> <span class="o">//</span> <span class="n">na</span>

                <span class="c1"># get offset in terms of unit-cell</span>
                <span class="n">off</span> <span class="o">=</span> <span class="n">xij</span><span class="p">[</span><span class="n">atm</span><span class="p">,</span> <span class="n">neighbours</span><span class="p">]</span> <span class="o">-</span> <span class="p">(</span><span class="n">xyz</span><span class="p">[</span><span class="n">uneighbours</span><span class="p">]</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">[</span><span class="n">atm</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>

                <span class="n">idx</span> <span class="o">=</span> <span class="n">mark</span><span class="p">[</span><span class="n">neighbour_isc</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">off</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">],</span> <span class="n">sc_off</span><span class="p">[</span><span class="n">neighbour_isc</span><span class="p">[</span><span class="o">~</span><span class="n">idx</span><span class="p">]]):</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; xyz did not  &quot;</span>
                                     <span class="sa">f</span><span class="s2">&quot;find same supercell offsets for different connections&quot;</span><span class="p">)</span>

                <span class="k">if</span> <span class="n">idx</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="k">continue</span>

                <span class="k">for</span> <span class="n">idx</span> <span class="ow">in</span> <span class="n">idx</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]:</span>
                    <span class="n">nidx</span> <span class="o">=</span> <span class="n">neighbour_isc</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">mark</span><span class="p">[</span><span class="n">nidx</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">mark</span><span class="p">[</span><span class="n">nidx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">sc_off</span><span class="p">[</span><span class="n">nidx</span><span class="p">]</span> <span class="o">=</span> <span class="n">off</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">sc_off</span><span class="p">[</span><span class="n">nidx</span><span class="p">],</span> <span class="n">off</span><span class="p">[</span><span class="n">idx</span><span class="p">]):</span>
                        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> xij(orb) -&gt; xyz did not  &quot;</span>
                                         <span class="sa">f</span><span class="s2">&quot;find same supercell offsets for different connections&quot;</span><span class="p">)</span>
            <span class="c1"># We know that siesta returns isc</span>
            <span class="c1"># for iz in [0, 1, 2, 3, -3, -2, -1]:</span>
            <span class="c1">#  for iy in [0, 1, 2, -2, -1]:</span>
            <span class="c1">#   for ix in [0, 1, -1]:</span>
            <span class="c1"># every block we find a half monotonically increasing vector additions</span>
            <span class="c1"># Note the first is always [0, 0, 0]</span>
            <span class="c1"># So our best chance is to *guess* the first nsc</span>
            <span class="c1"># then reshape, then guess, then reshape, then guess :)</span>
            <span class="n">sc_diff</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">sc_off</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">get_nsc</span><span class="p">(</span><span class="n">sc_off</span><span class="p">):</span>
                <span class="sd">&quot;&quot;&quot; Determine nsc depending on the axis &quot;&quot;&quot;</span>
                <span class="c1"># correct the offsets</span>
                <span class="n">ndim</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">ndim</span>

                <span class="k">if</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>

                <span class="c1"># always select the 2nd one since that contains the offset</span>
                <span class="c1"># for the first isc [1, 0, 0] or [0, 1, 0] or [0, 0, 1]</span>
                <span class="n">sc_dir</span> <span class="o">=</span> <span class="n">sc_off</span><span class="p">[(</span><span class="mi">1</span><span class="p">,</span> <span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
                <span class="n">norm2_sc_dir</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc_dir</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
                <span class="c1"># figure out the maximum integer part</span>
                <span class="c1"># we select 0 indices for all already determined lattice</span>
                <span class="c1"># vectors since we know the first one is [0, 0, 0]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[:]</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">index_exp</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="p">(</span><span class="n">ndim</span> <span class="o">-</span> <span class="mi">2</span><span class="p">)</span>
                <span class="n">projection</span> <span class="o">=</span> <span class="p">(</span><span class="n">sc_off</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">*</span> <span class="n">sc_dir</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm2_sc_dir</span>
                <span class="n">iprojection</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">projection</span><span class="p">)</span>
                <span class="c1"># reduce, find 0</span>
                <span class="n">idx_zero</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">iprojection</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">idx_zero</span><span class="o">.</span><span class="n">size</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="mi">1</span>

                <span class="c1"># only take those values that are continuous</span>
                <span class="c1"># we *must* have some supercell connections</span>
                <span class="n">idx_max</span> <span class="o">=</span> <span class="n">idx_zero</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

                <span class="c1"># find where they are close</span>
                <span class="c1"># since there may be *many* zeros (non-coupling elements)</span>
                <span class="c1"># we first have to cut off anything that is not integer</span>
                <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">projection</span><span class="p">[:</span><span class="n">idx_max</span><span class="p">],</span> <span class="n">iprojection</span><span class="p">[:</span><span class="n">idx_max</span><span class="p">],</span> <span class="n">atol</span><span class="o">=</span><span class="mf">1e-5</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">idx_max</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Could not determine nsc from coordinates&quot;</span><span class="p">)</span>

            <span class="n">nsc</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nsc</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span>
            <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">get_nsc</span><span class="p">(</span><span class="n">sc_off</span><span class="p">)</span>
            <span class="n">sc_off</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nsc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">nsc</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_off</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># now determine cell parameters</span>
            <span class="k">if</span> <span class="nb">all</span><span class="p">(</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">sc_off</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span>
                                  <span class="n">sc_off</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">],</span>
                                  <span class="n">sc_off</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># we will never have all(nsc == 1) since that is</span>
                <span class="c1"># taken care of at the start</span>

                <span class="c1"># this gets a bit tricky, since we don&#39;t know one of the</span>
                <span class="c1"># lattice vectors</span>
                <span class="n">cell</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
                <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">for</span> <span class="n">idx</span><span class="p">,</span> <span class="n">isc</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">nsc</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">isc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">sl</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span>
                        <span class="n">sl</span><span class="p">[</span><span class="mi">2</span> <span class="o">-</span> <span class="n">idx</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
                        <span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sc_off</span><span class="p">[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">sl</span><span class="p">)]</span>
                        <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

                <span class="c1"># figure out the last vectors</span>
                <span class="c1"># We&#39;ll just use Cartesian coordinates</span>
                <span class="k">while</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
                    <span class="c1"># this means we don&#39;t have any supercell connections</span>
                    <span class="c1"># along at least 1 other lattice vector.</span>
                    <span class="n">lcell</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># figure out which Cartesian direction we are *missing*</span>
                    <span class="n">cart_dir</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">lcell</span><span class="p">)</span>
                    <span class="n">cell</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">cart_dir</span><span class="p">]</span> <span class="o">=</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="n">cart_dir</span><span class="p">]</span><span class="o">.</span><span class="n">max</span><span class="p">()</span> <span class="o">-</span> <span class="n">xyz</span><span class="p">[:,</span> <span class="n">cart_dir</span><span class="p">]</span><span class="o">.</span><span class="n">min</span><span class="p">()</span> <span class="o">+</span> <span class="mf">10.</span>
                    <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">,</span> <span class="n">nsc</span><span class="p">)</span>

        <span class="c1"># now we have all orbitals, ensure compatibility with passed geometry</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">atm_xij</span> <span class="o">=</span> <span class="n">convert_to_atom</span><span class="p">(</span><span class="n">geom_handle</span><span class="p">,</span> <span class="n">xij</span><span class="p">)</span>
            <span class="n">xyz</span> <span class="o">=</span> <span class="n">coord_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">)</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">sc_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">,</span> <span class="n">xyz</span><span class="p">)</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">Geometry</span><span class="p">(</span><span class="n">xyz</span><span class="p">,</span> <span class="n">geom_handle</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">sc</span><span class="p">)</span>

            <span class="c1"># Move coordinates into unit-cell</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span><span class="n">geometry</span><span class="o">.</span><span class="n">fxyz</span> <span class="o">%</span> <span class="mf">1.</span><span class="p">)</span> <span class="o">@</span> <span class="n">geometry</span><span class="o">.</span><span class="n">cell</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">geometry</span><span class="o">.</span><span class="n">n_s</span> <span class="o">!=</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">xij</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="n">atm_xij</span> <span class="o">=</span> <span class="n">convert_to_atom</span><span class="p">(</span><span class="n">geom_handle</span><span class="p">,</span> <span class="n">xij</span><span class="p">)</span>
                <span class="n">sc</span> <span class="o">=</span> <span class="n">sc_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">,</span> <span class="n">coord_from_xij</span><span class="p">(</span><span class="n">atm_xij</span><span class="p">))</span>
                <span class="n">geometry</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">sc</span><span class="o">.</span><span class="n">nsc</span><span class="p">)</span>

            <span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">orbs</span><span class="p">,</span> <span class="n">atm</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">orbs</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">atm</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">atm</span>
                <span class="k">return</span> <span class="n">atm</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">orbitals</span><span class="o">=</span><span class="p">[</span><span class="o">-</span><span class="mf">1.</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">orbs</span><span class="p">])</span>
            <span class="n">atms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="n">conv</span><span class="p">,</span> <span class="n">geom_handle</span><span class="o">.</span><span class="n">atoms</span><span class="p">,</span> <span class="n">geometry</span><span class="o">.</span><span class="n">atoms</span><span class="p">)))</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">atms</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">geometry</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> passed geometry for reading &quot;</span>
                                 <span class="s2">&quot;sparse matrix does not contain same number of atoms!&quot;</span><span class="p">)</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
            <span class="c1"># TODO check that geometry and xyz are the same!</span>
            <span class="n">geometry</span><span class="o">.</span><span class="n">_atoms</span> <span class="o">=</span> <span class="n">atms</span>

        <span class="k">return</span> <span class="n">geometry</span>

    <span class="k">def</span> <span class="nf">_read_atoms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Reads basis set and geometry information from the HSX file &quot;&quot;&quot;</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">no</span><span class="p">,</span> <span class="n">na</span><span class="p">,</span> <span class="n">nspecies</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_specie_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read specie sizes.&#39;</span><span class="p">)</span>
        <span class="c1"># Read specie information</span>
        <span class="n">labels</span><span class="p">,</span> <span class="n">val_q</span><span class="p">,</span> <span class="n">norbs</span><span class="p">,</span> <span class="n">isa</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_species</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nspecies</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">na</span><span class="p">)</span>
        <span class="c1"># convert to proper string</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">T</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">nspecies</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="n">labels</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;S</span><span class="si">{</span><span class="n">labels</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">s</span><span class="p">:</span> <span class="sa">b</span><span class="s1">&#39;&#39;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">s</span><span class="p">)</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(),</span>
                          <span class="n">labels</span><span class="o">.</span><span class="n">tolist</span><span class="p">())</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read species.&#39;</span><span class="p">)</span>
        <span class="c1"># to python index</span>
        <span class="n">isa</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="kn">from</span> <span class="nn">sisl.atom</span> <span class="kn">import</span> <span class="n">_ptbl</span>

        <span class="c1"># try and convert labels into symbols</span>
        <span class="c1"># We do this by:</span>
        <span class="c1"># 1. label -&gt; symbol</span>
        <span class="c1"># 2. label[:2] -&gt; symbol</span>
        <span class="c1"># 3. label[:1] -&gt; symbol</span>
        <span class="n">symbols</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lbls</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">labels</span><span class="p">:</span>
            <span class="n">lbls</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">_ptbl</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">_ptbl</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">label</span><span class="p">[:</span><span class="mi">2</span><span class="p">])</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">symbol</span> <span class="o">=</span> <span class="n">_ptbl</span><span class="o">.</span><span class="n">Z_label</span><span class="p">(</span><span class="n">label</span><span class="p">[:</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">symbol</span><span class="p">)</span>
                <span class="k">continue</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="c1"># we have no clue, assign -1</span>
                <span class="n">symbols</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Read in orbital information</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ispecie</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nspecies</span><span class="p">):</span>
            <span class="n">n_l_zeta</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_specie</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">ispecie</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">norbs</span><span class="p">[</span><span class="n">ispecie</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s1">&#39;could not read specie </span><span class="si">{</span><span class="n">ispecie</span><span class="si">}</span><span class="s1">.&#39;</span><span class="p">)</span>
            <span class="c1"># create orbital</span>
            <span class="c1"># no shell will have l&gt;5, so m=10 should be more than enough</span>
            <span class="n">m</span> <span class="o">=</span> <span class="mi">10</span>
            <span class="n">orbs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">zeta</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">n_l_zeta</span><span class="p">):</span>
                <span class="c1"># manual loop on m quantum numbers</span>
                <span class="k">if</span> <span class="n">m</span> <span class="o">&gt;</span> <span class="n">l</span><span class="p">:</span>
                    <span class="n">m</span> <span class="o">=</span> <span class="o">-</span><span class="n">l</span>
                <span class="n">orbs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">AtomicOrbital</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="n">n</span><span class="p">,</span> <span class="n">l</span><span class="o">=</span><span class="n">l</span><span class="p">,</span> <span class="n">m</span><span class="o">=</span><span class="n">m</span><span class="p">,</span> <span class="n">zeta</span><span class="o">=</span><span class="n">zeta</span><span class="p">,</span> <span class="n">R</span><span class="o">=-</span><span class="mf">1.</span><span class="p">))</span>
                <span class="n">m</span> <span class="o">+=</span> <span class="mi">1</span>

            <span class="c1"># now create atom</span>
            <span class="n">atoms</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Atom</span><span class="p">(</span><span class="n">symbols</span><span class="p">[</span><span class="n">ispecie</span><span class="p">],</span> <span class="n">orbs</span><span class="p">,</span> <span class="n">tag</span><span class="o">=</span><span class="n">lbls</span><span class="p">[</span><span class="n">ispecie</span><span class="p">]))</span>

        <span class="c1"># now read in xij to retrieve atomic positions</span>
        <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read matrix sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">dxij</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">dxij</span> <span class="o">=</span> <span class="n">dxij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_geometry&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read xij matrix.&#39;</span><span class="p">)</span>

        <span class="c1"># now create atoms object</span>
        <span class="n">atoms</span> <span class="o">=</span> <span class="n">Atoms</span><span class="p">([</span><span class="n">atoms</span><span class="p">[</span><span class="n">ia</span><span class="p">]</span> <span class="k">for</span> <span class="n">ia</span> <span class="ow">in</span> <span class="n">isa</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">atoms</span>

<div class="viewcode-block" id="hsxSileSiesta.read_hamiltonian"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_hamiltonian">[docs]</a>    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the electronic structure from the siesta.TSHS file &quot;&quot;&quot;</span>

        <span class="c1"># Now read the sizes used...</span>
        <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dH</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">dxij</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_hsx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">dxij</span> <span class="o">=</span> <span class="n">dxij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian.&#39;</span><span class="p">)</span>

        <span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">xij</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">dxij</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">))</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xij2system</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">!=</span> <span class="n">no_s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">.read_hamiltonian could not use the &quot;</span>
                            <span class="s2">&quot;passed geometry as the number of atoms or orbitals is &quot;</span>
                            <span class="s2">&quot;inconsistent with HSX file.&quot;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">H</span> <span class="o">=</span> <span class="n">Hamiltonian</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float32</span><span class="p">,</span> <span class="n">orthogonal</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">ptr</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyf</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="n">spin</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="p">:</span><span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dH</span><span class="p">[:,</span> <span class="p">:]</span> <span class="o">*</span> <span class="n">_Ry2eV</span>
        <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="n">spin</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="n">_mat_spin_convert</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">H</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">H</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">spin</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>

<div class="viewcode-block" id="hsxSileSiesta.read_overlap"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.hsxSileSiesta.html#sisl.io.siesta.hsxSileSiesta.read_overlap">[docs]</a>    <span class="k">def</span> <span class="nf">read_overlap</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Returns the overlap matrix from the siesta.HSX file &quot;&quot;&quot;</span>
        <span class="c1"># Now read the sizes used...</span>
        <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix sizes.&#39;</span><span class="p">)</span>
        <span class="n">ncol</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">dS</span><span class="p">,</span> <span class="n">dxij</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_hsx_sx</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">Gamma</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">,</span> <span class="n">nnz</span><span class="p">)</span>
        <span class="n">dxij</span> <span class="o">=</span> <span class="n">dxij</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="n">col</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_overlap&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read overlap matrix.&#39;</span><span class="p">)</span>

        <span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="n">xij</span> <span class="o">=</span> <span class="n">SparseCSR</span><span class="p">((</span><span class="n">dxij</span><span class="p">,</span> <span class="n">col</span><span class="p">,</span> <span class="n">ptr</span><span class="p">),</span> <span class="n">shape</span><span class="o">=</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">no_s</span><span class="p">))</span>
        <span class="n">geom</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_xij2system</span><span class="p">(</span><span class="n">xij</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geometry&#39;</span><span class="p">,</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;geom&#39;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)))</span>

        <span class="k">if</span> <span class="n">geom</span><span class="o">.</span><span class="n">no</span> <span class="o">!=</span> <span class="n">no</span> <span class="ow">or</span> <span class="n">geom</span><span class="o">.</span><span class="n">no_s</span> <span class="o">!=</span> <span class="n">no_s</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">.read_overlap could not use the &quot;</span>
                            <span class="s2">&quot;passed geometry as the number of atoms or orbitals is &quot;</span>
                            <span class="s2">&quot;inconsistent with HSX file.&quot;</span><span class="p">)</span>

        <span class="c1"># Create the Hamiltonian container</span>
        <span class="n">S</span> <span class="o">=</span> <span class="n">Overlap</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">nnzpr</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Create the new sparse matrix</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ncol</span> <span class="o">=</span> <span class="n">ncol</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">_ncol_to_indptr</span><span class="p">(</span><span class="n">ncol</span><span class="p">)</span>
        <span class="c1"># Correct fortran indices</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">col</span> <span class="o">=</span> <span class="n">col</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_nnz</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">col</span><span class="p">)</span>

        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyf</span><span class="p">([</span><span class="n">nnz</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
        <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="o">.</span><span class="n">_D</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">dS</span><span class="p">[:]</span>

        <span class="c1"># Convert the supercells to sisl supercells</span>
        <span class="k">if</span> <span class="n">no_s</span> <span class="o">//</span> <span class="n">no</span> <span class="o">==</span> <span class="n">np</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">geom</span><span class="o">.</span><span class="n">nsc</span><span class="p">):</span>
            <span class="n">_csr_from_siesta</span><span class="p">(</span><span class="n">geom</span><span class="p">,</span> <span class="n">S</span><span class="o">.</span><span class="n">_csr</span><span class="p">)</span>

        <span class="c1"># not really necessary with Hermitian transposing, but for consistency</span>
        <span class="k">return</span> <span class="n">S</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">sort</span><span class="o">=</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sort&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">))</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">wfsxSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Binary WFSX file reader for Siesta</span>

<span class="sd">    The WFSX file assumes that users initialize the object with</span>
<span class="sd">    a `parent` argument (or one of the other geometry related objects as</span>
<span class="sd">    shown below).</span>

<span class="sd">    The `parent` argument is necessary to convert WFSX k-points from 1/Ang to</span>
<span class="sd">    reduced coordinates.</span>
<span class="sd">    When returning `EigenstateElectron` objects the parent of these objects</span>
<span class="sd">    are the equivalent of the `parent` argument upon initialization.</span>
<span class="sd">    Therefore please remember to pass a correct `parent`.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : obj, optional</span>
<span class="sd">        a parent may contain a geometry, and/or a supercell</span>
<span class="sd">    geometry : Geometry, optional</span>
<span class="sd">        a geometry contains a cell with corresponding lattice vectors</span>
<span class="sd">        used to convert k [1/Ang] -&gt; [b]</span>
<span class="sd">    sc : SuperCell, optional</span>
<span class="sd">        a supercell contains the lattice vectors to convert k</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simple setup that needs to be overwritten</span>

<span class="sd">        All _read_next_* methods expect the fortran file unit to be handled</span>
<span class="sd">        and that the position in the file is correct.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># default sc</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># In case the instantiation was called with wfsxSileSiesta(&quot;path&quot;, geometry=geometry)</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;parent&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Geometry</span><span class="p">):</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">SuperCell</span><span class="p">):</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">geometry</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">geometry</span>

        <span class="n">geometry</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;geometry&quot;</span><span class="p">,</span> <span class="n">geometry</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">sc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">sc</span> <span class="o">=</span> <span class="n">geometry</span><span class="o">.</span><span class="n">sc</span>

        <span class="n">sc</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;sc&quot;</span><span class="p">,</span> <span class="n">sc</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sc</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">geometry</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(geometry=Geometry, sc=None) is not an allowed argument combination.&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">sc</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="o">=</span> <span class="n">geometry</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sc</span> <span class="o">=</span> <span class="n">sc</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_geometry</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sc</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mf">0.</span><span class="p">):</span>
                    <span class="n">warn</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> cannot convert stored k-points from 1/Ang to reduced coordinates. Please ensure &#39;parent=Hamiltonian&#39;, &#39;geometry=Geometry&#39;, or &#39;sc=SuperCell&#39; to ensure reduced k&quot;</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">k</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">def</span> <span class="nf">conv</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="n">k</span> <span class="o">@</span> <span class="n">sc</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_convert_k</span> <span class="o">=</span> <span class="n">conv</span>

    <span class="k">def</span> <span class="nf">_open_wfsx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Open the file unit for the WFSX file.</span>

<span class="sd">        Here we also initialize some variables to keep track of the state of the read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_open</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="n">rewind</span><span class="p">)</span>
        <span class="c1"># Here we initialize the variables that will keep track of the state of the read.</span>
        <span class="c1"># The process for identification is done on this basis:</span>
        <span class="c1">#  _ik is the current (Python) index for the k-point to be read</span>
        <span class="c1">#  _ispin is the current (Python) index for the spin-index to be read (only has meaning for a spin-polarized</span>
        <span class="c1">#         WFSX files)</span>
        <span class="c1">#  _state is:</span>
        <span class="c1">#        -1 : the file-descriptor has just been opened (i.e. in front of header)</span>
        <span class="c1">#         0 : it means that the file-descriptor is in front of basis information</span>
        <span class="c1">#         1 : it means that the file-descriptor is in front of k point information</span>
        <span class="c1">#         2 : it means that the file-descriptor is in front of k point WFSX values</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_close_wfsx</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Close the file unit for the WFSX file.</span>

<span class="sd">        We clean the variables used to keep track of read state.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_close</span><span class="p">()</span>

        <span class="c1"># Clean variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_basis</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_setup_parsing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">skip_basis</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Gets all the things needed to parse the wfsx file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        close: bool, optional</span>
<span class="sd">            Whether the file unit should be closed afterwards.</span>
<span class="sd">        skip_basis : bool, optional</span>
<span class="sd">            whether to also read the basis or not</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_wfsx</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="c1"># Read the sizes relevant to the file.</span>
        <span class="c1"># We also read whether there&#39;s only gamma point information or there are multiple points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_sizes</span><span class="p">(</span><span class="n">skip_basis</span><span class="o">=</span><span class="n">skip_basis</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">skip_basis</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_basis</span><span class="p">()</span>

        <span class="c1"># Get the functions that should be used to parse state values.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">8</span><span class="p">):</span>
            <span class="c1"># We will have twice as many coefficients.</span>
            <span class="n">func_index</span> <span class="o">=</span> <span class="mi">4</span>
        <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">Gamma</span><span class="p">:</span>
            <span class="c1"># State values will be in double precision floats</span>
            <span class="n">func_index</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># State values will be in double precision complex</span>
            <span class="n">func_index</span> <span class="o">=</span> <span class="mi">2</span>

        <span class="n">Funcs</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;WFSXReads&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;read_index&quot;</span><span class="p">,</span> <span class="s2">&quot;read_next&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span> <span class="o">=</span> <span class="n">Funcs</span><span class="p">(</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">_siesta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;read_wfsx_index_</span><span class="si">{</span><span class="n">func_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">),</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="n">_siesta</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;read_wfsx_next_</span><span class="si">{</span><span class="n">func_index</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="p">)</span>

        <span class="k">if</span> <span class="n">close</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_read_next_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">skip_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the sizes if they are the next thing to be read.</span>

<span class="sd">        Parameters</span>
<span class="sd">        -----------</span>
<span class="sd">        skip_basis: boolean, optional</span>
<span class="sd">            Whether this method should also skip over the basis information.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        namedtuple :</span>
<span class="sd">                - &#39;nspin&#39;: int. Number of spin components.</span>
<span class="sd">                - &#39;no_u&#39;: int. Number of orbitals in the unit cell.</span>
<span class="sd">                - &#39;nk&#39;: int. Number of k points in the file.</span>
<span class="sd">                - &#39;Gamma&#39;: bool. Whether the file contains only the gamma point.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that we are in the right position in the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;We are not in a position to read the sizes. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Read the sizes that we can find in the WFSX file</span>
        <span class="n">Sizes</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;Sizes&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;nspin&quot;</span><span class="p">,</span> <span class="s2">&quot;no_u&quot;</span><span class="p">,</span> <span class="s2">&quot;nk&quot;</span><span class="p">,</span> <span class="s2">&quot;Gamma&quot;</span><span class="p">])</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">skip_basis</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of k point information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">skip_basis</span> <span class="k">else</span> <span class="mi">0</span>
        <span class="c1"># Check that everything went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;_read_sizes&#39;</span><span class="p">,</span> <span class="s2">&quot;could not read sizes&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">Sizes</span><span class="p">(</span><span class="o">*</span><span class="n">sizes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_read_next_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the basis if it is the next thing to be read.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Atoms:</span>
<span class="sd">            the basis read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that we are in the right position in the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;We are not in a position to read the basis. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="c1"># Read the basis information that we can find in the WFSX file</span>
        <span class="n">basis_info</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_basis</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">no_u</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of k point information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Check that everything went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;_read_basis&#39;</span><span class="p">,</span> <span class="s2">&quot;could not read basis information&quot;</span><span class="p">)</span>

        <span class="c1"># Convert the information to a dict so that code is easier to follow.</span>
        <span class="n">basis_info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">zip</span><span class="p">((</span><span class="s1">&#39;atom_indices&#39;</span><span class="p">,</span> <span class="s1">&#39;atom_labels&#39;</span><span class="p">,</span> <span class="s1">&#39;orb_index_atom&#39;</span><span class="p">,</span> <span class="s1">&#39;orb_n&#39;</span><span class="p">,</span> <span class="s1">&#39;orb_symmetry&#39;</span><span class="p">),</span> <span class="n">basis_info</span><span class="p">))</span>

        <span class="c1"># Sanitize the string information</span>
        <span class="k">for</span> <span class="n">char_key</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;atom_labels&quot;</span><span class="p">,</span> <span class="s2">&quot;orb_symmetry&quot;</span><span class="p">):</span>
            <span class="n">basis_info</span><span class="p">[</span><span class="n">char_key</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="s2">&quot;&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">label</span><span class="p">)</span><span class="o">.</span><span class="n">rstrip</span><span class="p">()</span> <span class="k">for</span> <span class="n">label</span> <span class="ow">in</span> <span class="n">basis_info</span><span class="p">[</span><span class="n">char_key</span><span class="p">]</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="nb">str</span><span class="p">)])</span>

        <span class="c1"># Find out the unique atom indices</span>
        <span class="n">unique_ats</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;atom_indices&quot;</span><span class="p">])</span>

        <span class="k">def</span> <span class="nf">_get_atom_object</span><span class="p">(</span><span class="n">at</span><span class="p">):</span>
            <span class="sd">&quot;&quot;&quot;Given an atom index, generates an Atom object with all the information we have about it&quot;&quot;&quot;</span>
            <span class="n">atom_orbs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;atom_indices&quot;</span><span class="p">]</span> <span class="o">==</span> <span class="n">at</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">at_label</span> <span class="o">=</span> <span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;atom_labels&quot;</span><span class="p">][</span><span class="n">atom_orbs</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>

            <span class="n">orbitals</span> <span class="o">=</span> <span class="p">[</span>
                <span class="n">AtomicOrbital</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n</span><span class="si">}{</span><span class="n">symmetry</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">n</span><span class="p">,</span> <span class="n">symmetry</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;orb_n&quot;</span><span class="p">][</span><span class="n">atom_orbs</span><span class="p">],</span> <span class="n">basis_info</span><span class="p">[</span><span class="s2">&quot;orb_symmetry&quot;</span><span class="p">][</span><span class="n">atom_orbs</span><span class="p">])</span>
            <span class="p">]</span>

            <span class="k">return</span> <span class="n">Atom</span><span class="p">(</span><span class="n">at_label</span><span class="p">,</span> <span class="n">orbitals</span><span class="o">=</span><span class="n">orbitals</span><span class="p">)</span>

        <span class="c1"># Generate the Atoms oject.</span>
        <span class="k">return</span> <span class="n">Atoms</span><span class="p">([</span><span class="n">_get_atom_object</span><span class="p">(</span><span class="n">at</span><span class="p">)</span> <span class="k">for</span> <span class="n">at</span> <span class="ow">in</span> <span class="n">unique_ats</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_read_next_info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the next eigenstate information.</span>

<span class="sd">        This function should only be called after reading the sizes</span>
<span class="sd">        or reading the previous state&#39;s values.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ispin: integer</span>
<span class="sd">            the (python) spin index of the next eigenstate.</span>
<span class="sd">        ik: integer</span>
<span class="sd">            the (python) k index of the next eigenstate.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of shape (3,):</span>
<span class="sd">            The k point of the state.</span>
<span class="sd">        float:</span>
<span class="sd">            The weight of the k point.</span>
<span class="sd">        int:</span>
<span class="sd">            Number of wavefunctions that the state contains. It is needed by the</span>
<span class="sd">            function that reads the eigenstates values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store the indices of the current state</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">ispin</span>
        <span class="c1"># Check that we are in a position where we will read state information</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;We are not in a position to read k point information. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Read the state information</span>
        <span class="n">file_ispin</span><span class="p">,</span> <span class="n">file_ik</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nwf</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of state values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="c1"># Check that the read went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;_read_next_info&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;could not read next eigenstate info [</span><span class="si">{</span><span class="n">ispin</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="c1"># Check that the read indices match the indices that we were expecting.</span>
        <span class="k">if</span> <span class="n">file_ispin</span> <span class="o">!=</span> <span class="n">ispin</span> <span class="o">+</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">file_ik</span> <span class="o">!=</span> <span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">file_ik</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">file_ispin</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;WFSX indices do not match the expected ones. Expected: [</span><span class="si">{</span><span class="n">ispin</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">], found [</span><span class="si">{</span><span class="n">file_ispin</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">file_ik</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nwf</span>

    <span class="k">def</span> <span class="nf">_read_next_values</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">nwf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the next eigenstate values.</span>

<span class="sd">        This function should only be called after reading the state&#39;s information</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ispin: integer</span>
<span class="sd">            the (python) spin index of the next eigenstate.</span>
<span class="sd">        ik: integer</span>
<span class="sd">            the (python) k index of the next eigenstate.</span>
<span class="sd">        nwf: integer</span>
<span class="sd">            The number of wavefunctions that the next eigenstate contains.</span>
<span class="sd">            Should have been obtained by reading the state&#39;s info with `_read_next_info`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        array of shape (nwf,):</span>
<span class="sd">            The indices of each wavefunction that the state contains.</span>
<span class="sd">        array of shape (nwf,):</span>
<span class="sd">            The eigenvalues (in eV) of each wavefunction that the state contains.</span>
<span class="sd">        array of shape (norbitals, nwf):</span>
<span class="sd">            The coefficients for each wavefunction that the state contains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Check that we are in the right position in the file</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;We are not in a position to read k point WFSX values. State is: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Read the state values</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_funcs</span><span class="o">.</span><span class="n">read_next</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">no_u</span><span class="p">,</span> <span class="n">nwf</span><span class="p">)</span>
        <span class="c1"># Inform that we are now in front of the next state info</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="c1"># Check that everything went fine</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;_read_next_values&#39;</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;could not read next eigenstate values [</span><span class="si">{</span><span class="n">ispin</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">ik</span> <span class="o">+</span> <span class="mi">1</span><span class="si">}</span><span class="s2">]&quot;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">idx</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">state</span>

    <span class="k">def</span> <span class="nf">_read_next_eigenstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the next eigenstate in the WFSX file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ispin: integer</span>
<span class="sd">            the (python) spin index of the next eigenstate.</span>
<span class="sd">        ik: integer</span>
<span class="sd">            the (python) k index of the next eigenstate.</span>

<span class="sd">        Returns</span>
<span class="sd">        --------</span>
<span class="sd">        EigenstateElectron:</span>
<span class="sd">            The next eigenstate.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get the information of this eigenstate</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">nwf</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_info</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">)</span>
        <span class="c1"># Now that we have the information, we can read the values because</span>
        <span class="c1"># we know the number of wavefunctions stored in the k point (`nwf`)</span>
        <span class="n">idx</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_values</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">nwf</span><span class="p">)</span>

        <span class="c1"># Build the info dictionary for the eigenstate to know how it was calculated</span>
        <span class="c1"># We include the spin index if needed.</span>
        <span class="n">info</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">k</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_convert_k</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">gauge</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="n">idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">info</span><span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ispin</span>

        <span class="c1"># `eig` is already in eV</span>
        <span class="c1"># See onlysSileSiesta.read_supercell to understand why we transpose `state`</span>
        <span class="k">return</span> <span class="n">EigenstateElectron</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">eig</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="o">**</span><span class="n">info</span><span class="p">)</span>

<div class="viewcode-block" id="wfsxSileSiesta.read_sizes"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_sizes">[docs]</a>    <span class="k">def</span> <span class="nf">read_sizes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the sizes related to this WFSX file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int : number of spin components</span>
<span class="sd">        int : number of orbitals in the unit-cell</span>
<span class="sd">        int : number of k-points</span>
<span class="sd">        bool : True if the file only contains the Gamma-point</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_wfsx</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="n">sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_sizes</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">sizes</span></div>

<div class="viewcode-block" id="wfsxSileSiesta.read_basis"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_basis">[docs]</a>    <span class="k">def</span> <span class="nf">read_basis</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the basis contained in the WFSX file.</span>

<span class="sd">        The WFSX file only contains information about the atom labels, which atom</span>
<span class="sd">        each orbital belongs to and the orbital quantum numbers. It is thus not</span>
<span class="sd">        complete in every sense.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        Atoms:</span>
<span class="sd">            the basis read.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_wfsx</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_sizes</span><span class="p">(</span><span class="n">skip_basis</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">basis</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_basis</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">basis</span></div>

<div class="viewcode-block" id="wfsxSileSiesta.yield_eigenstate"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.yield_eigenstate">[docs]</a>    <span class="k">def</span> <span class="nf">yield_eigenstate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Iterates over the states in the WFSX file</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        EigenstateElectron</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open file and get parsing information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_parsing</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">itt_spin</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">itt_spin</span> <span class="o">=</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># Iterate over all eigenstates in the WFSX file, yielding control to the caller at</span>
            <span class="c1"># each iteration.</span>
            <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="n">ispin</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nk</span><span class="p">),</span> <span class="n">itt_spin</span><span class="p">):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">_read_next_eigenstate</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="n">ik</span><span class="p">)</span>
            <span class="c1"># We ran out of eigenstates</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="k">except</span> <span class="ne">GeneratorExit</span><span class="p">:</span>
            <span class="c1"># The loop in which the generator was used has been broken.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span></div>

<div class="viewcode-block" id="wfsxSileSiesta.read_eigenstate"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_eigenstate">[docs]</a>    <span class="k">def</span> <span class="nf">read_eigenstate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">ktol</span><span class="o">=</span><span class="mf">1e-4</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads a specific eigenstate from the file.</span>

<span class="sd">        This method iterates over the states until it finds a match. Don&#39;t call</span>
<span class="sd">        this method repeatedly. If you want to loop eigenstates, use `yield_eigenstate`.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k: array-like of shape (3,), optional</span>
<span class="sd">            The k point of the state you want to find.</span>
<span class="sd">        spin: integer, optional</span>
<span class="sd">            The spin index of the state you want to find. Only meaningful for polarized</span>
<span class="sd">            calculations.</span>
<span class="sd">        ktol: float, optional</span>
<span class="sd">            The threshold value for considering two k-points the same (i.e. to match</span>
<span class="sd">            the query k point with the state&#39;s k point).</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        yield_eigenstate</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        EigenstateElectron or None:</span>
<span class="sd">            If found, the state that was queried.</span>
<span class="sd">            If not found, returns `None`. NOTE this may change to an exception in the future</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Iterate over all eigenstates in the file</span>
        <span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">yield_eigenstate</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;spin&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">==</span> <span class="n">spin</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">info</span><span class="p">[</span><span class="s1">&#39;k&#39;</span><span class="p">],</span> <span class="n">k</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">ktol</span><span class="p">):</span>
                <span class="c1"># This is the state that the user requested</span>
                <span class="k">return</span> <span class="n">state</span>
        <span class="k">return</span> <span class="kc">None</span></div>

<div class="viewcode-block" id="wfsxSileSiesta.read_info"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_info">[docs]</a>    <span class="k">def</span> <span class="nf">read_info</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Reads the information for all the k points contained in the file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k: array of shape (nk, 3)</span>
<span class="sd">            k values of the k points contained in the file.</span>
<span class="sd">        weight: array of shape (nk,)</span>
<span class="sd">            weight of each k point</span>
<span class="sd">        nwf: array of shape (nspin, nk)</span>
<span class="sd">            number of wavefunctions that each kpoint(-spin) contains.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Open file and get parsing information</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_setup_parsing</span><span class="p">(</span><span class="n">close</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">skip_basis</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Check if we are in the correct position in the file (we should be just after the header)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;We are not in a position to read eigenstate info in the file. State: </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># Read all the information. Parse here the k values obtained.</span>
        <span class="c1"># Store the information that should be returned under `returns`.</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nspin</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">nspin</span> <span class="o">=</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">nspin</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">kw</span><span class="p">,</span> <span class="n">nwf</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_wfsx_next_all_info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sizes</span><span class="o">.</span><span class="n">nk</span><span class="p">)</span>

        <span class="c1"># Close the file unit</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_wfsx</span><span class="p">()</span>
        <span class="c1"># Check for errors in the read.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s2">&quot;read_info&quot;</span><span class="p">,</span> <span class="s2">&quot;could not read file information.&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_convert_k</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">kw</span><span class="p">,</span> <span class="n">nwf</span></div>

<div class="viewcode-block" id="wfsxSileSiesta.read_brillouinzone"><a class="viewcode-back" href="../../../../api/io/generated/sisl.io.siesta.wfsxSileSiesta.html#sisl.io.siesta.wfsxSileSiesta.read_brillouinzone">[docs]</a>    <span class="k">def</span> <span class="nf">read_brillouinzone</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read the brillouin zone object &quot;&quot;&quot;</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_info</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_gridSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Binary real-space grid file</span>

<span class="sd">    The Siesta binary grid sile will automatically convert the units from Siesta</span>
<span class="sd">    units (Bohr, Ry) to sisl units (Ang, eV) provided the correct extension is present.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">read_supercell</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Return the cell contained in the file &quot;&quot;&quot;</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_cell</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span><span class="o">.</span><span class="n">T</span> <span class="o">*</span> <span class="n">_Bohr2Ang</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_supercell&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read cell.&#39;</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">SuperCell</span><span class="p">(</span><span class="n">cell</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">read_grid_size</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Query grid size information such as the grid size and number of spin components</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        int : number of spin-components</span>
<span class="sd">        mesh : 3 values for the number of mesh-elements</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Read the sizes</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_grid_size&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid sizes.&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span>

    <span class="k">def</span> <span class="nf">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read grid contained in the Grid file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        index : int or array_like, optional</span>
<span class="sd">           the spin-index for retrieving one of the components. If a vector</span>
<span class="sd">           is passed it refers to the fraction per indexed component. I.e.</span>
<span class="sd">           ``[0.5, 0.5]`` will return sum of half the first two components.</span>
<span class="sd">           Default to the first component.</span>
<span class="sd">        dtype : numpy.float64, optional</span>
<span class="sd">           default data-type precision</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">index</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;spin&#39;</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
        <span class="c1"># Read the sizes and cell</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_grid_size</span><span class="p">()</span>
        <span class="n">sc</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_supercell</span><span class="p">()</span>
        <span class="n">grid</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_grid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">mesh</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_grid&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read grid.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="n">index</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">index</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">grid</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.read_grid requires spin to be an integer or &#39;</span>
                                 <span class="s1">&#39;an array of length equal to the number of spin components.&#39;</span><span class="p">)</span>
            <span class="c1"># It is F-contiguous, hence the last index</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">index</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">index</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
                <span class="n">g</span> <span class="o">+=</span> <span class="n">grid</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="o">+</span><span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">scale</span>
            <span class="n">grid</span> <span class="o">=</span> <span class="n">g</span>

        <span class="c1"># Simply create the grid (with no information)</span>
        <span class="c1"># We will overwrite the actual grid</span>
        <span class="n">g</span> <span class="o">=</span> <span class="n">Grid</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">sc</span><span class="o">=</span><span class="n">sc</span><span class="p">)</span>
        <span class="c1"># NOTE: there is no need to swap-axes since the returned array is in F ordering</span>
        <span class="c1">#       and thus the first axis is the fast (x, y, z) is retained</span>
        <span class="n">g</span><span class="o">.</span><span class="n">grid</span> <span class="o">=</span> <span class="n">grid</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_unit</span>
        <span class="k">return</span> <span class="n">g</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io.siesta&quot;</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">_gfSileSiesta</span><span class="p">(</span><span class="n">SileBinSiesta</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot; Surface Green function file containing, Hamiltonian, overlap matrix and self-energies</span>

<span class="sd">    Do not mix read and write statements when using this code. Complete one or the other</span>
<span class="sd">    before doing the other thing. Fortran does not allow the same file opened twice, if this</span>
<span class="sd">    is needed you are recommended to make a symlink to the file and thus open two different</span>
<span class="sd">    files.</span>

<span class="sd">    This small snippet reads/writes the GF file</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&#39;hello.GF&#39;) as f:</span>
<span class="sd">    ...    nspin, no, k, E = f.read_header()</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            H, S = f.read_hamiltonian()</span>
<span class="sd">    ...        SeHSE = f.read_self_energy()</span>

<span class="sd">    To write a file do:</span>

<span class="sd">    &gt;&gt;&gt; with sisl.io._gfSileSiesta(&#39;hello.GF&#39;) as f:</span>
<span class="sd">    ...    f.write_header(sisl.MonkhorstPack(...), E)</span>
<span class="sd">    ...    for ispin, new_k, k, E in f:</span>
<span class="sd">    ...        if new_k:</span>
<span class="sd">    ...            f.write_hamiltonian(H, S)</span>
<span class="sd">    ...        f.write_self_energy(SeHSE)</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Simple setup that needs to be overwritten &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

        <span class="c1"># The unit convention used for energy-points</span>
        <span class="c1"># This is necessary until Siesta uses CODATA values</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;version&quot;</span><span class="p">,</span> <span class="s2">&quot;old&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="ow">in</span> <span class="p">(</span><span class="s2">&quot;old&quot;</span><span class="p">,</span> <span class="s2">&quot;4.1&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_E_Ry2eV</span> <span class="o">=</span> <span class="mf">13.60580</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_E_Ry2eV</span> <span class="o">=</span> <span class="n">_Ry2eV</span>

    <span class="k">def</span> <span class="nf">_open_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_open</span><span class="p">(</span><span class="n">mode</span><span class="p">,</span> <span class="n">rewind</span><span class="o">=</span><span class="n">rewind</span><span class="p">)</span>

        <span class="c1"># They will at any given time</span>
        <span class="c1"># correspond to the current Python indices that is to be read</span>
        <span class="c1"># The process for identification is done on this basis:</span>
        <span class="c1">#  iE is the current (Python) index for the energy-point to be read</span>
        <span class="c1">#  ik is the current (Python) index for the k-point to be read</span>
        <span class="c1">#  ispin is the current (Python) index for the spin-index to be read (only has meaning for a spin-polarized</span>
        <span class="c1">#         GF files)</span>
        <span class="c1">#  state is:</span>
        <span class="c1">#        -1 : the file-descriptor has just been opened (i.e. in front of header)</span>
        <span class="c1">#         0 : it means that the file-descriptor IS in front of H and S</span>
        <span class="c1">#         1 : it means that the file-descriptor is NOT in front of H and S but somewhere in front of a self-energy</span>
        <span class="c1">#  is_read is:</span>
        <span class="c1">#         0 : means that the current indices HAVE NOT been read</span>
        <span class="c1">#         1 : means that the current indices HAVE been read</span>
        <span class="c1">#</span>
        <span class="c1"># All routines in the gf_read/write sources requires input in Python indices</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">_close_gf</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="k">return</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_close</span><span class="p">()</span>

        <span class="c1"># Clean variables</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>

    <span class="k">def</span> <span class="nf">_step_counter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Method for stepping values *must* be called before doing the actual read to check correct values &quot;&quot;&quot;</span>
        <span class="n">opt</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;method&#39;</span><span class="p">:</span> <span class="n">method</span><span class="p">}</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;header&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># The header only exists once, so check whether it is the correct place to read/write</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the header has already &#39;</span>
                                <span class="s1">&#39;been read.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="c1">#print(&#39;HEADER: &#39;, self._state, self._ispin, self._ik, self._iE)</span>

        <span class="k">elif</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;HS&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="c1"># Correct for the previous state and jump values</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We have just read the header</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has not read the header.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
                <span class="c1"># Reset values as though the header has just been read</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has already read the current HS for the given k-point.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># We have just read from the last energy-point</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has not read all energy-points for a given k-point.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">:</span>
                    <span class="c1"># We need to step spin</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">+=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1">#print(&#39;HS: &#39;, self._state, self._ispin, self._ik, self._iE)</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">:</span>
                <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;spin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;nspin&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because of missing information, &#39;</span>
                                <span class="s1">&#39;a non-existing entry has been requested! spin=</span><span class="si">{spin}</span><span class="s1"> max_spin=</span><span class="si">{nspin}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># We are reading an energy-point</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                <span class="s1">&#39;has an unknown state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># Fine, we have just read the HS, ispin and ik are correct</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has an unknown state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

            <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="c1"># we haven&#39;t read the current energy-point.and self._iE + 1 &lt; self._nE:</span>
                    <span class="k">pass</span>
                <span class="k">elif</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because the file descriptor &#39;</span>
                                    <span class="s1">&#39;has an unknown state.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>

                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">&gt;=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">:</span>
                    <span class="c1"># You are trying to read beyond the entry</span>
                    <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;iE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">opt</span><span class="p">[</span><span class="s1">&#39;NE&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span>
                    <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s1">&#39;.</span><span class="si">{method}</span><span class="s1"> failed because of missing information, &#39;</span>
                                    <span class="s1">&#39;a non-existing energy-point has been requested! E_index=</span><span class="si">{iE}</span><span class="s1"> max_E_index=</span><span class="si">{NE}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">**</span><span class="n">opt</span><span class="p">))</span>
            <span class="c1">#print(&#39;SE: &#39;, self._state, self._ispin, self._ik, self._iE)</span>

        <span class="c1"># Always signal (when stepping) that we have not yet read the thing</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;read&#39;</span><span class="p">,</span> <span class="kc">False</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">Eindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the closest energy index corresponding to the energy ``E``</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : float or int</span>
<span class="sd">           if ``int``, return it-self, else return the energy index which is</span>
<span class="sd">           closests to the energy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">E</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">E</span>
        <span class="n">idxE</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">ret_E</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="n">idxE</span><span class="p">]</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ret_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">5e-3</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; requesting energy &quot;</span> <span class="o">+</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV, found </span><span class="si">{</span><span class="n">ret_E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV as the closest energy!&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">ret_E</span> <span class="o">-</span> <span class="n">E</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mf">1e-3</span><span class="p">:</span>
            <span class="n">info</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; requesting energy &quot;</span> <span class="o">+</span>
                 <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV, found </span><span class="si">{</span><span class="n">ret_E</span><span class="si">:</span><span class="s2">.5f</span><span class="si">}</span><span class="s2"> eV as the closest energy!&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">idxE</span>

    <span class="k">def</span> <span class="nf">kindex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return the index of the k-point that is closests to the queried k-point (in reduced coordinates)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like of float or int</span>
<span class="sd">           the queried k-point in reduced coordinates :math:`]-0.5;0.5]`. If ``int``</span>
<span class="sd">           return it-self.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">k</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">-</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)[</span><span class="kc">None</span><span class="p">,</span> <span class="p">:]),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">argmin</span><span class="p">()</span>
        <span class="n">ret_k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">[</span><span class="n">ik</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">ret_k</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="mf">0.0001</span><span class="p">):</span>
            <span class="n">warn</span><span class="p">(</span><span class="n">SileWarning</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span> <span class="o">+</span> <span class="s2">&quot; requesting k-point &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;[</span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">k</span><span class="p">)</span> <span class="o">+</span>
                             <span class="s2">&quot; found &quot;</span> <span class="o">+</span>
                             <span class="s2">&quot;[</span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">, </span><span class="si">{:.3f}</span><span class="s2">]&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="o">*</span><span class="n">ret_k</span><span class="p">)))</span>
        <span class="k">return</span> <span class="n">ik</span>

    <span class="k">def</span> <span class="nf">read_header</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Read the header of the file and open it for reading subsequently</span>

<span class="sd">        NOTES: this method may change in the future</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        nspin : number of spin-components stored (1 or 2)</span>
<span class="sd">        no_u : size of the matrices returned</span>
<span class="sd">        k : k points in the GF file</span>
<span class="sd">        E : energy points in the GF file</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Ensure it is open (in read-mode)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">rewind_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s1">&#39;r&#39;</span><span class="p">)</span>
        <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_sizes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read sizes.&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">=</span> <span class="n">nkpt</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">=</span> <span class="n">NE</span>

        <span class="c1"># We need to rewind (because of k and energy -points)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">io_m</span><span class="o">.</span><span class="n">rewind_file</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">k</span><span class="p">,</span> <span class="n">E</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nkpt</span><span class="p">,</span> <span class="n">NE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read header information.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span> <span class="c1"># non-colinear</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E_Ry2eV</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">T</span>

        <span class="k">return</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span>

    <span class="k">def</span> <span class="nf">disk_usage</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calculate the estimated size of the resulting file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        estimated disk-space used in GB</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">is_open</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">()</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="c1"># HS are only stored per k-point</span>
        <span class="n">HS</span> <span class="o">=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">HS</span> <span class="o">/</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span>

        <span class="c1"># Now calculate the full size</span>
        <span class="c1"># no_u ** 2 = matrix size</span>
        <span class="c1"># 16 = bytes in double complex</span>
        <span class="c1"># 1024 ** 3 = B -&gt; GB</span>
        <span class="n">mem</span> <span class="o">=</span> <span class="p">(</span><span class="n">HS</span> <span class="o">+</span> <span class="n">SE</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">*</span> <span class="mi">16</span> <span class="o">/</span> <span class="mi">1024</span> <span class="o">**</span> <span class="mi">3</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">is_open</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>

        <span class="k">return</span> <span class="n">mem</span>

    <span class="k">def</span> <span class="nf">read_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Return current Hamiltonian and overlap matrix from the GF file</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Hamiltonian matrix</span>
<span class="sd">        complex128 : Overlap matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="n">HS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">H</span><span class="p">,</span> <span class="n">S</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read Hamiltonian and overlap matrices.&#39;</span><span class="p">)</span>
        <span class="c1"># we don&#39;t convert to C order!</span>
        <span class="k">return</span> <span class="n">H</span> <span class="o">*</span> <span class="n">_Ry2eV</span><span class="p">,</span> <span class="n">S</span>

    <span class="k">def</span> <span class="nf">read_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Read the currently reached bulk self-energy</span>

<span class="sd">        The returned self-energy is:</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        complex128 : Self-energy matrix</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;read_self_energy&#39;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">SE</span> <span class="o">=</span> <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_se</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;read_self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not read self-energy.&#39;</span><span class="p">)</span>
        <span class="c1"># we don&#39;t convert to C order!</span>
        <span class="k">return</span> <span class="n">SE</span> <span class="o">*</span> <span class="n">_Ry2eV</span>

    <span class="k">def</span> <span class="nf">HkSk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve H and S for the given k-point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : int or array_like of float, optional</span>
<span class="sd">           k-point to read the corresponding Hamiltonian and overlap matrices</span>
<span class="sd">           for. If a specific k-point is passed `kindex` will be used to find</span>
<span class="sd">           the corresponding index.</span>
<span class="sd">        spin : int, optional</span>
<span class="sd">           spin-index for the Hamiltonian and overlap matrices</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="c1"># find k-index that is requested</span>
        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kindex</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span><span class="p">,</span>
                             <span class="mi">0</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;HkSk&#39;</span><span class="p">,</span> <span class="s1">&#39;could not find Hamiltonian and overlap matrix.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">spin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># signal this is to be read</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_hamiltonian</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">spin</span><span class="o">=</span><span class="mi">0</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Retrieve self-energy for a given energy-point and k-point</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        E : int or float</span>
<span class="sd">           energy to retrieve self-energy at</span>
<span class="sd">        k : int or array_like of float, optional</span>
<span class="sd">           k-point to retrieve k-point at</span>
<span class="sd">        spin : int, optional</span>
<span class="sd">           spin-index to retrieve self-energy at</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_is_open</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">read_header</span><span class="p">()</span>

        <span class="n">ik</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">kindex</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">iE</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Eindex</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">read_gf_find</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span><span class="p">,</span>
                             <span class="bp">self</span><span class="o">.</span><span class="n">_state</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span><span class="p">,</span>
                             <span class="mi">1</span><span class="p">,</span> <span class="n">spin</span><span class="p">,</span> <span class="n">ik</span><span class="p">,</span> <span class="n">iE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not find requested self-energy.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_state</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ispin</span> <span class="o">=</span> <span class="n">spin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span> <span class="o">=</span> <span class="n">ik</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span> <span class="o">=</span> <span class="n">iE</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_read</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># signal this is to be read</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">read_self_energy</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">write_header</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">bz</span><span class="p">,</span> <span class="n">E</span><span class="p">,</span> <span class="n">mu</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write to the binary file the header of the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bz : BrillouinZone</span>
<span class="sd">           contains the k-points, the weights and possibly the parent Hamiltonian (if `obj` is None)s</span>
<span class="sd">        E : array_like of cmplx or float</span>
<span class="sd">           the energy points. If `obj` is an instance of `SelfEnergy` where an</span>
<span class="sd">           associated ``eta`` is defined then `E` may be float, otherwise</span>
<span class="sd">           it *has* to be a complex array.</span>
<span class="sd">        mu : float, optional</span>
<span class="sd">           chemical potential in the file</span>
<span class="sd">        obj : ..., optional</span>
<span class="sd">           an object that contains the Hamiltonian definitions, defaults to ``bz.parent``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">parent</span>
        <span class="n">nspin</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">spin</span><span class="p">)</span>
        <span class="n">cell</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">sc</span><span class="o">.</span><span class="n">cell</span>
        <span class="n">na_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">na</span>
        <span class="n">no_u</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">no</span>
        <span class="n">xa</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">xyz</span>
        <span class="c1"># The lasto in siesta requires lasto(0) == 0</span>
        <span class="c1"># and secondly, the Python index to fortran</span>
        <span class="c1"># index makes firsto behave like fortran lasto</span>
        <span class="n">lasto</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">firsto</span>
        <span class="n">bloch</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesi</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="n">mu</span> <span class="o">=</span> <span class="n">mu</span>
        <span class="n">NE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">E</span><span class="o">.</span><span class="n">dtype</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">complex64</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">]:</span>
            <span class="n">E</span> <span class="o">=</span> <span class="n">E</span> <span class="o">+</span> <span class="mi">1</span><span class="n">j</span> <span class="o">*</span> <span class="n">obj</span><span class="o">.</span><span class="n">eta</span>
        <span class="n">Nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">bz</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">k</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">weight</span>

        <span class="n">sizes</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;na_used&#39;</span><span class="p">:</span> <span class="n">na_u</span><span class="p">,</span>
            <span class="s1">&#39;nkpt&#39;</span><span class="p">:</span> <span class="n">Nk</span><span class="p">,</span>
            <span class="s1">&#39;ne&#39;</span><span class="p">:</span> <span class="n">NE</span><span class="p">,</span>
        <span class="p">}</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">=</span> <span class="n">nspin</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">=</span> <span class="n">E</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">E</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span> <span class="o">*</span> <span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_no_u</span> <span class="o">=</span> <span class="n">no_u</span>

        <span class="c1"># Ensure it is open (in write mode)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open_gf</span><span class="p">(</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="c1"># Now write to it...</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;write_header&#39;</span><span class="p">,</span> <span class="n">header</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># see onlysSileSiesta.read_supercell for .T</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_header</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="n">nspin</span><span class="p">,</span> <span class="n">_toF</span><span class="p">(</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
                                <span class="n">na_u</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">no_u</span><span class="p">,</span> <span class="n">_toF</span><span class="p">(</span><span class="n">xa</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">,</span> <span class="mf">1.</span> <span class="o">/</span> <span class="n">_Bohr2Ang</span><span class="p">),</span>
                                <span class="n">lasto</span><span class="p">,</span> <span class="n">bloch</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">mu</span> <span class="o">*</span> <span class="n">_eV2Ry</span><span class="p">,</span> <span class="n">_toF</span><span class="p">(</span><span class="n">k</span><span class="o">.</span><span class="n">T</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">),</span>
                                <span class="n">w</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E_Ry2eV</span><span class="p">,</span>
                                <span class="o">**</span><span class="n">sizes</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;write_header&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write header information.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_hamiltonian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">S</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Write the current energy, k-point and H and S to the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        H : matrix</span>
<span class="sd">           a square matrix corresponding to the Hamiltonian</span>
<span class="sd">        S : matrix, optional</span>
<span class="sd">           a square matrix corresponding to the overlap, for efficiency reasons</span>
<span class="sd">           it may be advantageous to specify this argument for orthogonal cells.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">H</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">S</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">S</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">eye</span><span class="p">(</span><span class="n">no</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">order</span><span class="o">=</span><span class="s1">&#39;F&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="n">HS</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_hs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E_Ry2eV</span><span class="p">,</span>
                            <span class="n">_toF</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span>
                            <span class="n">_toF</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">),</span> <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;write_hamiltonian&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write Hamiltonian and overlap matrices.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">write_self_energy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">SE</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Write the current self energy, k-point and H and S to the file</span>

<span class="sd">        The self-energy must correspond to the *bulk* self-energy</span>

<span class="sd">        .. math::</span>
<span class="sd">            \boldsymbol \Sigma_{\mathrm{bulk}}(E) = \mathbf S E - \mathbf H - \boldsymbol \Sigma(E)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        SE : matrix</span>
<span class="sd">           a square matrix corresponding to the self-energy (Green function)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">no</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">SE</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_step_counter</span><span class="p">(</span><span class="s1">&#39;write_self_energy&#39;</span><span class="p">,</span> <span class="n">read</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">_siesta</span><span class="o">.</span><span class="n">write_gf_se</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iu</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ik</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_iE</span><span class="p">]</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E_Ry2eV</span><span class="p">,</span>
                            <span class="n">_toF</span><span class="p">(</span><span class="n">SE</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">complex128</span><span class="p">,</span> <span class="n">_eV2Ry</span><span class="p">),</span> <span class="n">no_u</span><span class="o">=</span><span class="n">no</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fortran_check</span><span class="p">(</span><span class="s1">&#39;write_self_energy&#39;</span><span class="p">,</span> <span class="s1">&#39;could not write self-energy.&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nE</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nk</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Iterate through the energies and k-points that this GF file is associated with</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        bool, list of float, float</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># get everything</span>
        <span class="n">e</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_E</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">]:</span>
            <span class="n">GFStep</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;GFStep&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;spin&quot;</span><span class="p">,</span> <span class="s2">&quot;do_HS&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">ispin</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_nspin</span><span class="p">):</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                    <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                    <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                        <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="n">ispin</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">GFStep</span> <span class="o">=</span> <span class="n">namedtuple</span><span class="p">(</span><span class="s2">&quot;GFStep&quot;</span><span class="p">,</span> <span class="p">[</span><span class="s2">&quot;do_HS&quot;</span><span class="p">,</span> <span class="s2">&quot;k&quot;</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">:</span>
                <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="kc">True</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">e</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="k">for</span> <span class="n">E</span> <span class="ow">in</span> <span class="n">e</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                    <span class="k">yield</span> <span class="n">GFStep</span><span class="p">(</span><span class="kc">False</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">E</span><span class="p">)</span>

        <span class="c1"># We will automatically close once we hit the end</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close_gf</span><span class="p">()</span>


<span class="k">def</span> <span class="nf">_type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">obj</span><span class="p">,</span> <span class="n">dic</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="k">if</span> <span class="n">dic</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">dic</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="c1"># Always pass the docstring</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="s1">&#39;__doc__&#39;</span> <span class="ow">in</span> <span class="n">dic</span><span class="p">:</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">dic</span><span class="p">[</span><span class="s1">&#39;__doc__&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">obj</span><span class="o">.</span><span class="vm">__doc__</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="k">pass</span>
    <span class="k">return</span> <span class="nb">type</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="p">),</span> <span class="n">dic</span><span class="p">)</span>

<span class="c1"># Faster than class ... \ pass</span>
<span class="n">tsgfSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;tsgfSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gfSileSiesta</span><span class="p">)</span>
<span class="n">gridSileSiesta</span> <span class="o">=</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;gridSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="p">})</span>

<span class="k">if</span> <span class="n">found_module</span><span class="p">:</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSHS&#39;</span><span class="p">,</span> <span class="n">tshsSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;onlyS&#39;</span><span class="p">,</span> <span class="n">onlysSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSDE&#39;</span><span class="p">,</span> <span class="n">tsdeSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;DM&#39;</span><span class="p">,</span> <span class="n">dmSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;HSX&#39;</span><span class="p">,</span> <span class="n">hsxSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TSGF&#39;</span><span class="p">,</span> <span class="n">tsgfSileSiesta</span><span class="p">)</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;WFSX&#39;</span><span class="p">,</span> <span class="n">wfsxSileSiesta</span><span class="p">)</span>
    <span class="c1"># These have unit-conversions</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHO&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;LDOS&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;ldosSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHOINIT&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoinitSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;RHOXC&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;rhoxcSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;DRHO&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;drhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;BADER&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;baderSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;IOCH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;iorhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;TOCH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalrhoSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="c1"># The following two files *require* that</span>
    <span class="c1">#  STM.DensityUnits   Ele/bohr**3</span>
    <span class="c1">#  which I can&#39;t check!</span>
    <span class="c1"># They are however the default</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;STS&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;stsSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;STM.LDOS&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;stmldosSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="mf">1.</span><span class="o">/</span><span class="n">_Bohr2Ang</span> <span class="o">**</span> <span class="mi">3</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VH&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;hartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">_Ry2eV</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VNA&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;neutralatomhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">_Ry2eV</span><span class="p">}))</span>
    <span class="n">add_sile</span><span class="p">(</span><span class="s1">&#39;VT&#39;</span><span class="p">,</span> <span class="n">_type</span><span class="p">(</span><span class="s2">&quot;totalhartreeSileSiesta&quot;</span><span class="p">,</span> <span class="n">_gridSileSiesta</span><span class="p">,</span> <span class="p">{</span><span class="s1">&#39;grid_unit&#39;</span><span class="p">:</span> <span class="n">_Ry2eV</span><span class="p">}))</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2022, Nick Papior.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>