

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.io.sile &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=9d09c2c4"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl.io.sile</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.io.sile</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">gzip</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">inspect</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">logging</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">re</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">tempfile</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">zipfile</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Callable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">functools</span><span class="w"> </span><span class="kn">import</span> <span class="n">wraps</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">io</span><span class="w"> </span><span class="kn">import</span> <span class="n">IOBase</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">itertools</span><span class="w"> </span><span class="kn">import</span> <span class="n">product</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">operator</span><span class="w"> </span><span class="kn">import</span> <span class="n">contains</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">os.path</span><span class="w"> </span><span class="kn">import</span> <span class="n">basename</span><span class="p">,</span> <span class="n">splitext</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">pathlib</span><span class="w"> </span><span class="kn">import</span> <span class="n">Path</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">textwrap</span><span class="w"> </span><span class="kn">import</span> <span class="n">dedent</span><span class="p">,</span> <span class="n">indent</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">types</span><span class="w"> </span><span class="kn">import</span> <span class="n">MethodType</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Any</span><span class="p">,</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._environ</span><span class="w"> </span><span class="kn">import</span> <span class="n">get_environ_variable</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._help</span><span class="w"> </span><span class="kn">import</span> <span class="n">has_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">deprecate</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">str_spec</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.</span><span class="w"> </span><span class="kn">import</span> <span class="n">_except_base</span><span class="p">,</span> <span class="n">_except_objects</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._except_base</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._except_objects</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._help</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">._zipfile</span><span class="w"> </span><span class="kn">import</span> <span class="n">ZipPath</span>

<span class="c1"># Public used objects</span>
<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;add_sile&quot;</span><span class="p">,</span> <span class="s2">&quot;get_sile_class&quot;</span><span class="p">,</span> <span class="s2">&quot;get_sile&quot;</span><span class="p">,</span> <span class="s2">&quot;get_siles&quot;</span><span class="p">,</span> <span class="s2">&quot;get_sile_rules&quot;</span><span class="p">]</span>

<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span>
    <span class="s2">&quot;BaseSile&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BaseBufferSile&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BufferSile&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BufferSileCDF&quot;</span><span class="p">,</span>
    <span class="s2">&quot;BufferSileBin&quot;</span><span class="p">,</span>
    <span class="s2">&quot;Sile&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SileCDF&quot;</span><span class="p">,</span>
    <span class="s2">&quot;SileBin&quot;</span><span class="p">,</span>
<span class="p">]</span>
<span class="n">__all__</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_except_base</span><span class="o">.</span><span class="n">__all__</span><span class="p">)</span>
<span class="n">__all__</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">_except_objects</span><span class="o">.</span><span class="n">__all__</span><span class="p">)</span>

<span class="c1"># Decorators or sile-specific functions</span>
<span class="n">__all__</span> <span class="o">+=</span> <span class="p">[</span><span class="s2">&quot;sile_fh_open&quot;</span><span class="p">,</span> <span class="s2">&quot;sile_raise_write&quot;</span><span class="p">,</span> <span class="s2">&quot;sile_raise_read&quot;</span><span class="p">]</span>

<span class="c1"># Global container of all Sile rules</span>
<span class="c1"># This list of tuples is formed as</span>
<span class="c1">#  [(&#39;fdf&#39;, fdfSileSiesta, fdfSileSiesta),</span>
<span class="c1">#   (&#39;fdf&#39;, ncSileSiesta, fdfSileSiesta)]</span>
<span class="c1"># [0] is the file suffix</span>
<span class="c1"># [1] is the base class that may be queried</span>
<span class="c1"># [2] is the actual class the file represents</span>
<span class="c1"># This enables one to add several files with the</span>
<span class="c1"># same extension and query it based on a sub-class</span>
<span class="n">__sile_rules</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">__siles</span> <span class="o">=</span> <span class="p">[]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">_sile_rule</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Internal data-structure to check whether a file is the same as this sile&quot;&quot;&quot;</span>

    <span class="n">COMPARISONS</span> <span class="o">=</span> <span class="p">{</span>
        <span class="s2">&quot;contains&quot;</span><span class="p">:</span> <span class="n">contains</span><span class="p">,</span>
        <span class="s2">&quot;in&quot;</span><span class="p">:</span> <span class="n">contains</span><span class="p">,</span>
        <span class="s2">&quot;endswith&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">endswith</span><span class="p">,</span>
        <span class="s2">&quot;startswith&quot;</span><span class="p">:</span> <span class="nb">str</span><span class="o">.</span><span class="n">startswith</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;cls&quot;</span><span class="p">,</span> <span class="s2">&quot;case&quot;</span><span class="p">,</span> <span class="s2">&quot;suffix&quot;</span><span class="p">,</span> <span class="s2">&quot;gzip&quot;</span><span class="p">,</span> <span class="s2">&quot;bases&quot;</span><span class="p">,</span> <span class="s2">&quot;base_names&quot;</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gzip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cls</span> <span class="o">=</span> <span class="bp">cls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">case</span> <span class="o">=</span> <span class="n">case</span>
        <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gzip</span> <span class="o">=</span> <span class="n">gzip</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bases</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">build_bases</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">base_names</span> <span class="o">=</span> <span class="p">[</span><span class="n">c</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">s</span> <span class="o">=</span> <span class="s2">&quot;,</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">__name</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">))</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">case=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">case</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;suffix=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">suffix</span><span class="si">}</span><span class="s2">, gzip=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gzip</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">s</span><span class="si">}</span><span class="se">\n}}</span><span class="s2">&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;&lt;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">, case=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">case</span><span class="si">}</span><span class="s2">, &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;suffix=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">suffix</span><span class="si">}</span><span class="s2">, gzip=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">gzip</span><span class="si">}</span><span class="s2">&gt;&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">build_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a list of all classes that this file is inheriting from (except Sile, SileBin or SileCDF)&quot;&quot;&quot;</span>
        <span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">)</span> <span class="o">+</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="p">]</span>
        <span class="n">nl</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span> <span class="o">!=</span> <span class="n">nl</span><span class="p">:</span>
            <span class="n">nl</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">children</span><span class="p">)</span>
            <span class="c1"># Remove baseclasses everybody have</span>
            <span class="k">for</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">(</span><span class="nb">object</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">,</span> <span class="n">Sile</span><span class="p">,</span> <span class="n">SileBin</span><span class="p">,</span> <span class="n">SileCDF</span><span class="p">):</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">i</span> <span class="o">=</span> <span class="n">children</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
                    <span class="n">children</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">children</span><span class="p">):</span>  <span class="c1"># ensure we have a copy for infinite loops</span>
                <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">child</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">c</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">children</span><span class="p">:</span>
                        <span class="n">children</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">c</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">children</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">in_bases</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;contains&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether any of the inherited bases compares with `base` in their class-name (lower-case sensitive)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="nb">object</span><span class="p">):</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">base</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="n">comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COMPARISONS</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">b</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">comparison</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
                <span class="k">return</span> <span class="kc">True</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">get_base</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;contains&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether any of the inherited bases compares with `base` in their class-name (lower-case sensitive)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">None</span>
        <span class="n">comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COMPARISONS</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">bn</span><span class="p">,</span> <span class="n">b</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">base_names</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">bases</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">comparison</span><span class="p">(</span><span class="n">bn</span><span class="p">,</span> <span class="n">base</span><span class="p">):</span>
                <span class="k">return</span> <span class="n">b</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">in_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">base</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s2">&quot;contains&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Whether any of the inherited bases compares with `base` in their class-name (lower-case sensitive)&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="n">comparison</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">COMPARISONS</span><span class="p">[</span><span class="n">method</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">comparison</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="o">.</span><span class="n">lower</span><span class="p">(),</span> <span class="n">base</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_suffix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">suffix</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">case</span><span class="p">:</span>
            <span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="c1"># Now check names and (possibly gzip)</span>
        <span class="n">my_suffix</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">suffix</span>
        <span class="k">if</span> <span class="n">suffix</span> <span class="o">==</span> <span class="n">my_suffix</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gzip</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">suffix</span> <span class="o">==</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">my_suffix</span><span class="si">}</span><span class="s2">.gz&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_class</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cls</span> <span class="o">==</span> <span class="bp">cls</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">is_subclass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="bp">cls</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cls</span><span class="p">,</span> <span class="bp">cls</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">add_sile</span><span class="p">(</span><span class="n">suffix</span><span class="p">,</span> <span class="bp">cls</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">gzip</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Add files to the global lookup table</span>

<span class="sd">    Public for attaching lookup tables for allowing</span>
<span class="sd">    users to attach files externally.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    suffix : str</span>
<span class="sd">         The file-name suffix, it can be several file endings (.TBT.nc)</span>
<span class="sd">    cls : child of BaseSile</span>
<span class="sd">         An object that is associated with the respective file.</span>
<span class="sd">         It must be inherited from `BaseSile`.</span>
<span class="sd">    case : bool, optional</span>
<span class="sd">         Whether case sensitivity is applicable for determining file.</span>
<span class="sd">    gzip : bool, optional</span>
<span class="sd">         Whether files with ``.gz`` endings can be read.</span>
<span class="sd">         This option should only be given to files with ASCII text</span>
<span class="sd">         output.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">__sile_rules</span><span class="p">,</span> <span class="n">__siles</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Class </span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> must be a subclass of BaseSile!&quot;</span><span class="p">)</span>

    <span class="c1"># Only add pure suffixes...</span>
    <span class="k">if</span> <span class="n">suffix</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
        <span class="n">suffix</span> <span class="o">=</span> <span class="n">suffix</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># If it isn&#39;t already in the list of</span>
    <span class="c1"># Siles, add it.</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">__siles</span><span class="p">:</span>
        <span class="n">__siles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

    <span class="c1"># Add the rule of the sile to the list of rules.</span>
    <span class="n">__sile_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">_sile_rule</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">suffix</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="n">case</span><span class="p">,</span> <span class="n">gzip</span><span class="o">=</span><span class="n">gzip</span><span class="p">))</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_sile_class</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieve a class from the global lookup table via filename and the extension</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    filename : str</span>
<span class="sd">       the file to be quried for a correct file object.</span>
<span class="sd">       This file name may contain {&lt;class-name&gt;} which sets</span>
<span class="sd">       `cls` in case `cls` is not set.</span>
<span class="sd">       For instance:</span>

<span class="sd">          water.xyz</span>

<span class="sd">       will return an `xyzSile`.</span>
<span class="sd">    cls : class, optional</span>
<span class="sd">       In case there are several files with similar file-suffixes</span>
<span class="sd">       you may query the exact base-class that should be chosen.</span>
<span class="sd">       If there are several files with similar file-endings this</span>
<span class="sd">       function returns a random one.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">__sile_rules</span><span class="p">,</span> <span class="n">__siles</span>

    <span class="c1"># This ensures that the first argument need not be cls</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cls&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

    <span class="c1"># Split filename into proper file name and</span>
    <span class="c1"># the Specification of the type</span>
    <span class="n">tmp_file</span><span class="p">,</span> <span class="n">specification</span> <span class="o">=</span> <span class="n">str_spec</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">filename</span><span class="p">))</span>

    <span class="c1"># Now check whether we have a specific checker</span>
    <span class="k">if</span> <span class="n">specification</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># ensure to grab nothing</span>
        <span class="n">specification</span> <span class="o">=</span> <span class="n">get_environ_variable</span><span class="p">(</span><span class="s2">&quot;SISL_IO_DEFAULT&quot;</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span>
    <span class="k">elif</span> <span class="n">specification</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
        <span class="n">specification</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

    <span class="c1"># extract which comparsion method</span>
    <span class="k">if</span> <span class="s2">&quot;=&quot;</span> <span class="ow">in</span> <span class="n">specification</span><span class="p">:</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">cls_search</span> <span class="o">=</span> <span class="n">specification</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;=&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">if</span> <span class="s2">&quot;=&quot;</span> <span class="ow">in</span> <span class="n">cls_search</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Comparison specification currently only supports one level of comparison(single =); got </span><span class="si">{</span><span class="n">specification</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">method</span><span class="p">,</span> <span class="n">cls_search</span> <span class="o">=</span> <span class="s2">&quot;contains&quot;</span><span class="p">,</span> <span class="n">specification</span>

    <span class="c1"># searchable rules</span>
    <span class="n">eligible_rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">if</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="ow">not</span> <span class="n">cls_search</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># cls has not been set, and fcls is found</span>
        <span class="c1"># Figure out if fcls is a valid sile, if not</span>
        <span class="c1"># do nothing (it may be part of the file name)</span>
        <span class="c1"># Which is REALLY obscure... but....)</span>
        <span class="n">cls_searchl</span> <span class="o">=</span> <span class="n">cls_search</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">sr</span> <span class="ow">in</span> <span class="n">__sile_rules</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sr</span><span class="o">.</span><span class="n">in_class</span><span class="p">(</span><span class="n">cls_searchl</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="n">method</span><span class="p">):</span>
                <span class="n">eligible_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">eligible_rules</span><span class="p">:</span>
            <span class="c1"># we have at least one eligible rule</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">tmp_file</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">warn</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;Specification requirement of the file did not result in any found files: </span><span class="si">{</span><span class="n">specification</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># search everything</span>
        <span class="n">eligible_rules</span> <span class="o">=</span> <span class="n">__sile_rules</span>

    <span class="k">if</span> <span class="n">eligible_rules</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eligible_rules</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">eligible_rules</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cls</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="c1"># nothing has been found, this may meen that we need to search *everything*</span>
        <span class="n">eligible_rules</span> <span class="o">=</span> <span class="n">__sile_rules</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="c1"># Create list of endings on this file</span>
        <span class="n">f</span> <span class="o">=</span> <span class="n">basename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">end_list</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">end</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">try_methods</span><span class="p">(</span><span class="n">eligibles</span><span class="p">,</span> <span class="n">prefixes</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;read_&quot;</span><span class="p">,)):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;return only those who can actually perform the read actions&quot;&quot;&quot;</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">has</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                <span class="k">nonlocal</span> <span class="n">prefixes</span>
                <span class="n">has_keys</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">prefix</span> <span class="ow">in</span> <span class="n">prefixes</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">key</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="n">prefix</span><span class="p">):</span>
                            <span class="n">has_keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">has_keys</span>

            <span class="n">outs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">eligibles</span><span class="p">:</span>
                <span class="n">attrs</span> <span class="o">=</span> <span class="n">has</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">sile</span> <span class="o">=</span> <span class="n">e</span><span class="o">.</span><span class="n">cls</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                    <span class="k">continue</span>
                <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="nb">getattr</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">attr</span><span class="p">)()</span>
                        <span class="c1"># if one succeeds, we will assume it is working</span>
                        <span class="n">outs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
                        <span class="k">break</span>
                    <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">return</span> <span class="n">outs</span>

        <span class="c1"># Check for files without ending, or that they are directly zipped</span>
        <span class="n">lext</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">lext</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">end</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">lext</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="si">}{</span><span class="n">end</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">if</span> <span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s2">&quot;.&quot;</span><span class="p">:</span>
                <span class="n">end_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">1</span><span class="p">:])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">end_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">end</span><span class="p">)</span>
            <span class="n">lext</span> <span class="o">=</span> <span class="n">splitext</span><span class="p">(</span><span class="n">lext</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

        <span class="c1"># We also check the entire file name</span>
        <span class="n">end_list</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">f</span><span class="p">)</span>
        <span class="c1"># Reverse to start by the longest extension</span>
        <span class="c1"># (allows grid.nc extensions, etc.)</span>
        <span class="n">end_list</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">end_list</span><span class="p">))</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_eligibles</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">rules</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="bp">cls</span>
            <span class="n">eligibles</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">sr</span> <span class="ow">in</span> <span class="n">rules</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sr</span><span class="o">.</span><span class="n">is_class</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                    <span class="c1"># class-specification has precedence</span>
                    <span class="c1"># This should only occur when the</span>
                    <span class="c1"># class-specification is exact (i.e. xyzSile)</span>
                    <span class="k">return</span> <span class="p">[</span><span class="n">sr</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">sr</span><span class="o">.</span><span class="n">is_suffix</span><span class="p">(</span><span class="n">end</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">sr</span><span class="o">.</span><span class="n">is_subclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
                        <span class="k">return</span> <span class="p">[</span><span class="n">sr</span><span class="p">]</span>
                    <span class="n">eligibles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sr</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">eligibles</span>

        <span class="c1"># First we check for class AND file ending</span>
        <span class="k">for</span> <span class="n">end</span><span class="p">,</span> <span class="n">rules</span> <span class="ow">in</span> <span class="n">product</span><span class="p">(</span><span class="n">end_list</span><span class="p">,</span> <span class="p">(</span><span class="n">eligible_rules</span><span class="p">,</span> <span class="n">__sile_rules</span><span class="p">)):</span>
            <span class="n">eligibles</span> <span class="o">=</span> <span class="n">get_eligibles</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">rules</span><span class="p">)</span>
            <span class="c1"># Determine whether we have found a compatible sile</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">eligibles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">eligibles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cls</span>
            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">eligibles</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">workable_eligibles</span> <span class="o">=</span> <span class="n">try_methods</span><span class="p">(</span><span class="n">eligibles</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">workable_eligibles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="k">return</span> <span class="n">workable_eligibles</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">cls</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Cannot determine the exact Sile requested, multiple hits: </span><span class="si">{</span><span class="nb">tuple</span><span class="p">(</span><span class="n">e</span><span class="o">.</span><span class="n">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">e</span><span class="w"> </span><span class="ow">in</span><span class="w"> </span><span class="n">eligibles</span><span class="p">)</span><span class="si">}</span><span class="s2">&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Print-out error on which extensions it tried (and full filename)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_list</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">ext_list</span> <span class="o">=</span> <span class="n">end_list</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">ext_list</span> <span class="o">=</span> <span class="n">end_list</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Sile for file &#39;</span><span class="si">{</span><span class="n">filename</span><span class="si">}</span><span class="s2">&#39; (</span><span class="si">{</span><span class="n">ext_list</span><span class="si">}</span><span class="s2">) could not be found, &quot;</span>
            <span class="s2">&quot;possibly the file has not been implemented.&quot;</span>
        <span class="p">)</span>

    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">e</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_sile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieve an object from the global lookup table via filename and the extension</span>

<span class="sd">    Internally this is roughly equivalent to ``get_sile_class(...)()``.</span>

<span class="sd">    When the file suffix is not recognized and you know which file-type it is</span>
<span class="sd">    it is recommended to get the file class from the known suffixes and use that</span>
<span class="sd">    class to construct the file object, see examples.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    file : str or pathlib.Path</span>
<span class="sd">       the file to be quried for a correct `Sile` object.</span>
<span class="sd">       This file name may contain {&lt;class-name&gt;} which sets</span>
<span class="sd">       `cls` in case `cls` is not set.</span>
<span class="sd">       For instance ``get_sile(&quot;water.dat{xyzSile}&quot;)``</span>
<span class="sd">       will read the file ``water.dat`` using the `xyzSile` class.</span>
<span class="sd">    cls : class</span>
<span class="sd">       In case there are several files with similar file-suffixes</span>
<span class="sd">       you may query the exact base-less that should be chosen.</span>
<span class="sd">       If there are several files with similar file-endings this</span>
<span class="sd">       function returns a random one.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    A file named ``water.dat`` contains the xyz-coordinates as the `xyzSile`.</span>
<span class="sd">    One can forcefully get the sile by:</span>

<span class="sd">    &gt;&gt;&gt; obj = get_sile(&quot;water.dat{xyzSile}&quot;)</span>

<span class="sd">    Alternatively one can query the xyz file and use that class reference</span>
<span class="sd">    in future instantiations. This ensures a future proof method without</span>
<span class="sd">    explicitly typing the Sile object.</span>

<span class="sd">    &gt;&gt;&gt; cls = get_sile_class(&quot;anyfile.xyz&quot;)</span>
<span class="sd">    &gt;&gt;&gt; obj = cls(&quot;water.dat&quot;)</span>
<span class="sd">    &gt;&gt;&gt; another_xyz = cls(&quot;water2.dat&quot;)</span>

<span class="sd">    To narrow the search one can clarify whether it should start or</span>
<span class="sd">    end with a string:</span>

<span class="sd">    &gt;&gt;&gt; cls = get_sile_class(&quot;water.dat{startswith=xyz}&quot;)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="bp">cls</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;cls&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
    <span class="n">sile</span> <span class="o">=</span> <span class="n">get_sile_class</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="bp">cls</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="c1"># Get the file path with the potential {specification}</span>
    <span class="c1"># removed from the end. However, if this is a zipfile</span>
    <span class="c1"># path we need to preserve the original zipfile.</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
        <span class="n">internal_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">file</span><span class="p">))</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">root</span><span class="o">.</span><span class="n">filename</span><span class="p">)</span>
        <span class="n">clean_filename</span> <span class="o">=</span> <span class="n">str_spec</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">internal_path</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">ZipPath</span><span class="p">(</span><span class="n">file</span><span class="o">.</span><span class="n">root</span><span class="p">,</span> <span class="n">clean_filename</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">clean_filename</span> <span class="o">=</span> <span class="n">str_spec</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">file</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">file</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">clean_filename</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">sile</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_siles</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Retrieve all files with specific attributes or methods</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    attrs : list of attribute names</span>
<span class="sd">       limits the returned objects to those that have</span>
<span class="sd">       the given attributes ``hasattr(sile, attrs)``, default ``[None]``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">__siles</span>

    <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">attrs</span> <span class="o">=</span> <span class="p">[</span><span class="kc">None</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">attrs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">attrs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">__siles</span><span class="p">)</span>

    <span class="n">siles</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">sile</span> <span class="ow">in</span> <span class="n">__siles</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">siles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span>
                    <span class="k">break</span>
            <span class="k">except</span> <span class="ne">TypeError</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">)</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;[SileBinder]&quot;</span><span class="p">):</span>
                    <span class="c1"># a non-bounded deferred class created using the SileBinder</span>
                    <span class="c1"># TODO work around this check</span>
                    <span class="n">siles</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sile</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">siles</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">get_sile_rules</span><span class="p">(</span><span class="n">attrs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="bp">cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Retrieve all sile rules of siles with specific attributes or methods</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    attrs : list of attribute names</span>
<span class="sd">       limits the returned objects to those that have</span>
<span class="sd">       the given attributes ``hasattr(sile, attrs)``, default ``[None]``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">global</span> <span class="n">__sile_rules</span>

    <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="n">__sile_rules</span><span class="p">)</span>

    <span class="n">sile_rules</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">rule</span> <span class="ow">in</span> <span class="n">__sile_rules</span><span class="p">:</span>
        <span class="n">sile</span> <span class="o">=</span> <span class="n">rule</span><span class="o">.</span><span class="n">cls</span>
        <span class="k">if</span> <span class="n">sile</span> <span class="ow">is</span> <span class="bp">cls</span><span class="p">:</span>
            <span class="n">sile_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">attrs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">attr</span> <span class="ow">in</span> <span class="n">attrs</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">sile</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                    <span class="n">sile_rules</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">rule</span><span class="p">)</span>
                    <span class="k">break</span>

    <span class="k">return</span> <span class="n">sile_rules</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BaseSile</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for all sisl files&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># check whether filename is an actual str, or StringIO or some buffer</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">IOBase</span><span class="p">):</span>
            <span class="c1"># this is just a regular sile opening</span>
            <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="n">_buffer_cls</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__init_subclass__</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">buffer_cls</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">BaseBufferSile</span><span class="p">):</span>
            <span class="c1"># return since it already inherits BufferSile</span>
            <span class="k">return</span>

        <span class="n">buffer_extension_cls</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="s2">&quot;_buffer_extension_cls&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">buffer_extension_cls</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">buffer_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">cls</span><span class="o">.</span><span class="n">_buffer_cls</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">buffer_cls</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">buffer_cls</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">Buffer&quot;</span><span class="p">,</span>
                    <span class="p">(</span><span class="n">buffer_extension_cls</span><span class="p">,</span> <span class="bp">cls</span><span class="p">),</span>
                    <span class="c1"># Ensure the module is the same</span>
                    <span class="p">{</span><span class="s2">&quot;__module__&quot;</span><span class="p">:</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__module__</span><span class="p">},</span>
                <span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">buffer_cls</span><span class="p">,</span> <span class="n">BaseBufferSile</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;The passed buffer_cls should inherit from sisl.io.BufferSile to &quot;</span>
                    <span class="s2">&quot;ensure correct behaviour.&quot;</span>
                <span class="p">)</span>

            <span class="bp">cls</span><span class="o">.</span><span class="n">_buffer_cls</span> <span class="o">=</span> <span class="n">buffer_cls</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Just to pass away the args and kwargs&quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_sanitize_filename</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">Path</span><span class="p">,</span> <span class="n">ZipPath</span><span class="p">]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Sanitize the filename to be a ``Path`` or ``ZipPath`` object.</span>

<span class="sd">        If the filename is a ``zipfile.Path``, a ``ZipPath`` or a path with</span>
<span class="sd">        a .zip file in the middle of it, it will be converted to a ``ZipPath``.</span>

<span class="sd">        Otherwise, it will be converted to a ``Path`` object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        filename :</span>
<span class="sd">            The filename to be sanitized.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">Path</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">ZipPath</span><span class="o">.</span><span class="n">from_zipfile_path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">ZipPath</span><span class="p">):</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

            <span class="c1"># Try to convert to a ZipPath, which will only succeed if there</span>
            <span class="c1"># is a .zip file in the middle of the path</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">filename</span> <span class="o">=</span> <span class="n">ZipPath</span><span class="o">.</span><span class="n">from_path</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="k">return</span> <span class="n">filename</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;File of the current `Sile`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">base_file</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;File of the current `Sile`&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">)</span>

<div class="viewcode-block" id="BaseSile.base_directory">
<a class="viewcode-back" href="../../../api/io/generated/sisl.io.BaseSile.html#sisl.io.BaseSile.base_directory">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">base_directory</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">relative_to</span><span class="o">=</span><span class="s2">&quot;.&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve the base directory of the file, relative to the path `relative_to`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">relative_to</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="n">relative_to</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">relative_to</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span><span class="o">.</span><span class="n">relative_to</span><span class="p">(</span><span class="n">relative_to</span><span class="o">.</span><span class="n">resolve</span><span class="p">())</span>
        <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>  <span class="c1"># in case they are not relative</span>
            <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span>
        <span class="k">return</span> <span class="n">d</span></div>


<div class="viewcode-block" id="BaseSile.dir_file">
<a class="viewcode-back" href="../../../api/io/generated/sisl.io.BaseSile.html#sisl.io.BaseSile.dir_file">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">dir_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">filename_base</span><span class="o">=</span><span class="s2">&quot;&quot;</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;File of the current `Sile`&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">filename</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span> <span class="o">/</span> <span class="n">filename_base</span> <span class="o">/</span> <span class="n">filename</span></div>


<div class="viewcode-block" id="BaseSile.read">
<a class="viewcode-back" href="../../../api/io/generated/sisl.io.BaseSile.html#sisl.io.BaseSile.read">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic read method which should be overloaded in child-classes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        kwargs :</span>
<span class="sd">          keyword arguments will try and search for the attribute ``read_&lt;&gt;``</span>
<span class="sd">          and call it with the remaining ``**kwargs`` as arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># Loop all keys and try to read the quantities</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;read_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;read_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Call read</span>
                <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1"># Options for writing</span>
    <span class="c1"># The default routine for writing</span>
    <span class="n">_write_default</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="c1"># Whether only the default should be used</span>
    <span class="c1"># when issuing a write</span>
    <span class="n">_write_default_only</span> <span class="o">=</span> <span class="kc">False</span>

<div class="viewcode-block" id="BaseSile.write">
<a class="viewcode-back" href="../../../api/io/generated/sisl.io.BaseSile.html#sisl.io.BaseSile.write">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generic write method which should be overloaded in child-classes</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        **kwargs :</span>
<span class="sd">          keyword arguments will try and search for the attribute `write_&lt;&gt;`</span>
<span class="sd">          and call it with the remaining ``**kwargs`` as arguments.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_write_default</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_write_default_only</span><span class="p">:</span>
                <span class="k">return</span>

        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># Loop all keys and try to write the quantities</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;write_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">):</span>
                <span class="n">func</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;write_</span><span class="si">{</span><span class="n">key</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="c1"># Call write</span>
                <span class="n">func</span><span class="p">(</span><span class="n">kwargs</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setup the `Sile` after initialization</span>

<span class="sd">        Inherited method for setting up the sile.</span>

<span class="sd">        This method can be overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_base_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Setup the `Sile` after initialization</span>

<span class="sd">        Inherited method for setting up the sile.</span>

<span class="sd">        This method **must** be overwritten *and*</span>
<span class="sd">        end with ``self._setup()``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s2">&quot;base&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">base</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Extract from filename</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span> <span class="o">=</span> <span class="n">base</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_directory</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span> <span class="o">=</span> <span class="s2">&quot;.&quot;</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_directory</span><span class="p">,</span> <span class="p">(</span><span class="nb">str</span><span class="p">,</span> <span class="n">Path</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_filename</span><span class="p">(</span><span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_directory</span><span class="p">)</span><span class="o">.</span><span class="n">resolve</span><span class="p">())</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_base_file</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">f</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Make `f` refer to the file with the appropriate base directory&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_directory</span> <span class="o">/</span> <span class="n">f</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Override to check the handle&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;fh&quot;</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The filehandle for </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="si">}</span><span class="s2"> has not been opened yet...&quot;</span>
            <span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;read_supercell&quot;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;read_lattice&quot;</span><span class="p">):</span>
            <span class="n">deprecate</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.read_supercell is deprecated in favor of read_lattice&quot;</span><span class="p">,</span>
                <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
                <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;read_lattice&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;write_supercell&quot;</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;write_lattice&quot;</span><span class="p">):</span>
            <span class="n">deprecate</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.write_supercell is deprecated in favor of write_lattice&quot;</span><span class="p">,</span>
                <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
                <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;write_lattice&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_ArgumentParser_args_single</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Default arguments for the Sile&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{}</span>

    <span class="c1"># Define the custom ArgumentParser</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">ArgumentParser</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the arguments that may be available for this Sile</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : ArgumentParser</span>
<span class="sd">           the argument parser to add the arguments to.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;The ArgumentParser of &#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">&#39; has not been implemented yet.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">ArgumentParser_out</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Appends additional arguments based on the output of the file</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        p : ArgumentParser</span>
<span class="sd">           the argument parser to add the arguments to.</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_log</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">logging</span><span class="o">.</span><span class="n">INFO</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Provide a log message to the logging mechanism&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;_logger&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__module__</span><span class="si">}</span><span class="s2">.</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">|</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_file</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>
        <span class="n">logger</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_logger</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">log</span><span class="p">(</span><span class="n">level</span><span class="p">,</span> <span class="n">msg</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a representation of the `Sile`&quot;&quot;&quot;</span>
        <span class="c1"># Check if the directory is relative to the current path</span>
        <span class="c1"># If so, only print the relative path, otherwise print the full path</span>
        <span class="n">d</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">base_directory</span><span class="p">()</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">(</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">base_file</span><span class="si">!s}</span><span class="s2">, base=</span><span class="si">{</span><span class="n">d</span><span class="si">!s}</span><span class="s2">)&quot;</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sile_fh_open</span><span class="p">(</span><span class="n">from_closed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">reset</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">BaseSile</span><span class="p">],</span> <span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Method decorator for objects to directly implement opening of the</span>
<span class="sd">    file-handle upon entry (if it isn&#39;t already).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    from_closed :</span>
<span class="sd">       ensure the wrapped function *must* open the file, otherwise it will seek to 0.</span>
<span class="sd">    reset :</span>
<span class="sd">       in case the file gets opened a new, then the `reset` method will be called as</span>
<span class="sd">       ``reset(self)``</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="n">reset</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
            <span class="k">pass</span>

    <span class="k">if</span> <span class="n">from_closed</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">reset</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">pre_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="c1"># This happens when the file seeks to 0,</span>
                    <span class="c1"># so basically the same as re-opening the file</span>
                    <span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">pre_open</span>

    <span class="k">else</span><span class="p">:</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_wrapper</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
            <span class="k">nonlocal</span> <span class="n">reset</span>

            <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">pre_open</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;fh&quot;</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                <span class="k">with</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="n">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">func</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

            <span class="k">return</span> <span class="n">pre_open</span>

    <span class="k">return</span> <span class="n">_wrapper</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BaseBufferSile</span><span class="p">:</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>

        <span class="n">attr</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;read_&quot;</span><span class="p">):</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_read</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;write_&quot;</span><span class="p">):</span>
            <span class="n">attr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">wrap_write</span><span class="p">(</span><span class="n">attr</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">attr</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrap_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap the read function to ensure it is called with the correct file handle&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">func</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrap_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrap the write function to ensure it is called with the correct file handle&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">func</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BufferSile</span><span class="p">(</span><span class="n">BaseBufferSile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Sile for handling `StringIO` and `TextIOBase` objects</span>

<span class="sd">    These are basically meant for users passing down the above objects</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># here, filename is actually a file-handle.</span>
        <span class="c1"># However, to accommodate keyword arguments we *must* have the same name</span>
        <span class="n">filehandle</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filehandle</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># this is not optimal, it will be the current directory, but one should not be able</span>
            <span class="c1"># to write to it</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">()</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="n">filehandle</span><span class="o">.</span><span class="n">mode</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># a StringIO will always be able to read *and* write</span>
            <span class="c1"># to its buffer</span>
            <span class="n">mode</span> <span class="o">=</span> <span class="s2">&quot;rw&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="n">filehandle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fh_init_tell</span> <span class="o">=</span> <span class="n">filehandle</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>

        <span class="c1"># pass mode to the file to let it know what happened</span>
        <span class="c1"># we can&#39;t use super here due to the coupling to the Sile class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_fh_init_tell</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="c1"># we will not close a file-handle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Will not close the file since this is passed by the user&quot;&quot;&quot;</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BufferSileCDF</span><span class="p">(</span><span class="n">BaseBufferSile</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># here, filename is actually a file-handle.</span>
        <span class="c1"># However, to accommodate keyword arguments we *must* have the same name</span>
        <span class="n">filehandle</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filehandle</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;dummy&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">filehandle</span><span class="p">,</span> <span class="n">zipfile</span><span class="o">.</span><span class="n">ZipExtFile</span><span class="p">)</span> <span class="ow">and</span> <span class="n">mode</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
            <span class="c1"># For some convoluted reason that I don&#39;t manage to understand, if</span>
            <span class="c1"># the buffer is a zipfile in reading mode and we have the filename</span>
            <span class="c1"># set to the real name, the read data will be completely wrong</span>
            <span class="c1"># (tests will fail if this line is commented out)</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="s2">&quot;dummy&quot;</span>

        <span class="c1"># Remove the b from the mode, as netCDF4 only accepts &quot;r&quot; or &quot;w&quot;</span>
        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">filehandle</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">filehandle</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The filehandle&#39;s mode (</span><span class="si">{</span><span class="n">filehandle</span><span class="o">.</span><span class="n">mode</span><span class="si">}</span><span class="s2">) does not match the sile&#39;s mode (</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">filehandle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># pass mode to the file to let it know what happened</span>
        <span class="c1"># we can&#39;t use super here due to the coupling to the Sile class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="s2">&quot;fh&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;fh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
                <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">),</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">,</span>
                <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;NETCDF4&quot;</span><span class="p">,</span>
                <span class="n">memory</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">read</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span> <span class="k">else</span> <span class="mi">4</span><span class="p">,</span>
            <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span><span class="o">.</span><span class="n">tobytes</span><span class="p">())</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrap_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_wrapped</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">return</span> <span class="n">_wrapped</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BufferSileBin</span><span class="p">(</span><span class="n">BaseBufferSile</span><span class="p">):</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">close</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># here, filename is actually a file-handle.</span>
        <span class="c1"># However, to accommodate keyword arguments we *must* have the same name</span>
        <span class="n">filehandle</span> <span class="o">=</span> <span class="n">filename</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">filehandle</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="c1"># this is not optimal, it will be the current directory, but one should not be able</span>
            <span class="c1"># to write to it</span>
            <span class="n">filename</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="s2">&quot;dummy&quot;</span><span class="p">)</span>

        <span class="n">mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="n">filehandle</span><span class="p">,</span> <span class="s2">&quot;mode&quot;</span><span class="p">)</span> <span class="ow">and</span> <span class="n">filehandle</span><span class="o">.</span><span class="n">mode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">!=</span> <span class="n">mode</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;The filehandle mode (</span><span class="si">{</span><span class="n">filehandle</span><span class="o">.</span><span class="n">mode</span><span class="si">}</span><span class="s2">) does not match the sile&#39;s mode (</span><span class="si">{</span><span class="n">mode</span><span class="si">}</span><span class="s2">)&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span> <span class="o">=</span> <span class="n">filehandle</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_close</span> <span class="o">=</span> <span class="n">close</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># pass mode to the file to let it know what happened</span>
        <span class="c1"># we can&#39;t use super here due to the coupling to the Sile class</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">):</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">,</span> <span class="s2">&quot;rb&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">data</span> <span class="o">=</span> <span class="n">fp</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">unlink</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_file</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_close</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_wrap_read_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">copy_buffer_content</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_file</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">func</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_temp_file</span> <span class="o">=</span> <span class="n">tempfile</span><span class="o">.</span><span class="n">NamedTemporaryFile</span><span class="p">(</span><span class="n">mode</span><span class="o">=</span><span class="s2">&quot;wb&quot;</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">temp_path</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_temp_file</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>

        <span class="c1"># Set state to account for the fact that we have written the temp file.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file</span> <span class="o">=</span> <span class="n">temp_path</span>

        <span class="k">if</span> <span class="n">copy_buffer_content</span><span class="p">:</span>
            <span class="c1"># Read the data from the buffer</span>
            <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>

            <span class="c1"># Write it to the temporary file</span>
            <span class="k">with</span> <span class="bp">self</span><span class="o">.</span><span class="n">_temp_file</span> <span class="k">as</span> <span class="n">fp</span><span class="p">:</span>
                <span class="n">fp</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>

        <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">_wrapped</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
            <span class="c1"># If the file is inside a zip fortran can&#39;t read directly from it.</span>
            <span class="c1"># We therefore store the contents in a temporary file and set this</span>
            <span class="c1"># as the file to be read from.</span>
            <span class="n">res</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="k">return</span> <span class="n">res</span>

        <span class="k">return</span> <span class="n">_wrapped</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrap_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_read_write</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">copy_buffer_content</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">wrap_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">Callable</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_wrap_read_write</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">copy_buffer_content</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Info</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;An info class that creates .info with inherent properties</span>

<span class="sd">    These properties can be added at will.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="c1"># default to be empty</span>
    <span class="n">_info_attributes_</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">InfoAttr</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="n">_Info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">InfoAttr</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Holder for parsing lines and extracting information from text files</span>

<span class="sd">        This consists of:</span>

<span class="sd">        name:</span>
<span class="sd">            the name of the attribute</span>
<span class="sd">            This will be the `sile.info.&lt;name&gt;` access point.</span>
<span class="sd">        searcher:</span>
<span class="sd">            the regular expression used to match a line.</span>
<span class="sd">            If a `str`, it will be compiled *as is* to a regex pattern.</span>
<span class="sd">            `regex.match(line)` will be used to check if the value should be updated.</span>
<span class="sd">            It can also be a direct method called</span>
<span class="sd">        parser:</span>
<span class="sd">            if `regex.match(line)` returns a match that is true, then this parser will</span>
<span class="sd">            be executed.</span>
<span class="sd">            The parser *must* be a function accepting two arguments:</span>

<span class="sd">                def parser(attr, instance, match)</span>

<span class="sd">            where `attr` is this object, and `match` is the match done on the line.</span>
<span class="sd">            (Note that `match.string` will return the full line used to match against).</span>
<span class="sd">        updatable:</span>
<span class="sd">            control whether a new match on the line will update using `parser`.</span>
<span class="sd">            If false, only the first match will update the value</span>
<span class="sd">        default:</span>
<span class="sd">            the default value of the attribute</span>
<span class="sd">        found:</span>
<span class="sd">            whether the value has been found in the file.</span>
<span class="sd">        not_found: callable or str or Exception</span>
<span class="sd">            what to do when the attribute is not found, defaults to raise a SislInfo.</span>
<span class="sd">            It should accept 2 arguments, the object calling it, and the attribute.</span>

<span class="sd">                def not_found(obj, attr): # do something</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="vm">__slots__</span> <span class="o">=</span> <span class="p">(</span>
            <span class="s2">&quot;name&quot;</span><span class="p">,</span>
            <span class="s2">&quot;searcher&quot;</span><span class="p">,</span>
            <span class="s2">&quot;parser&quot;</span><span class="p">,</span>
            <span class="s2">&quot;updatable&quot;</span><span class="p">,</span>
            <span class="s2">&quot;default&quot;</span><span class="p">,</span>
            <span class="s2">&quot;value&quot;</span><span class="p">,</span>
            <span class="s2">&quot;found&quot;</span><span class="p">,</span>
            <span class="s2">&quot;doc&quot;</span><span class="p">,</span>
            <span class="s2">&quot;not_found&quot;</span><span class="p">,</span>
        <span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span>
            <span class="n">name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
            <span class="n">searcher</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">[[</span><span class="n">InfoAttr</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">,</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">],</span> <span class="nb">str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">],</span>
            <span class="n">parser</span><span class="p">:</span> <span class="n">Callable</span><span class="p">[</span>
                <span class="p">[</span><span class="n">InfoAttr</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Match</span><span class="p">]],</span> <span class="n">Any</span>
            <span class="p">]</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">attr</span><span class="p">,</span> <span class="n">inst</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span><span class="p">,</span>
            <span class="n">doc</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span><span class="p">,</span>
            <span class="n">updatable</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">default</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">found</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
            <span class="n">not_found</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="kc">None</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">,</span> <span class="n">InfoAttr</span><span class="p">],</span> <span class="kc">None</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
            <span class="n">instance</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">searcher</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">searcher</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">searcher</span><span class="p">)</span>

            <span class="k">elif</span> <span class="n">searcher</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">searcher</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">info</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">line</span><span class="p">:</span> <span class="n">line</span>

            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">searcher</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">):</span>

                <span class="k">def</span><span class="w"> </span><span class="nf">used_searcher</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
                    <span class="k">nonlocal</span> <span class="n">searcher</span>

                    <span class="n">match</span> <span class="o">=</span> <span class="n">searcher</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">match</span><span class="p">:</span>
                        <span class="n">info</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">parser</span><span class="p">(</span><span class="n">info</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">match</span><span class="p">)</span>
                        <span class="c1"># print(f&quot;found {info.name}={info.value} with {line}&quot;)</span>
                        <span class="n">info</span><span class="o">.</span><span class="n">found</span> <span class="o">=</span> <span class="kc">True</span>
                        <span class="k">return</span> <span class="kc">True</span>

                    <span class="k">return</span> <span class="kc">False</span>

                <span class="n">used_searcher</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="n">searcher</span><span class="o">.</span><span class="n">pattern</span>
            <span class="k">else</span><span class="p">:</span>

                <span class="n">used_searcher</span> <span class="o">=</span> <span class="n">searcher</span>
                <span class="n">used_searcher</span><span class="o">.</span><span class="n">pattern</span> <span class="o">=</span> <span class="s2">&quot;&lt;custom&gt;&quot;</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span> <span class="o">=</span> <span class="n">used_searcher</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parser</span> <span class="o">=</span> <span class="n">parser</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">updatable</span> <span class="o">=</span> <span class="n">updatable</span>

            <span class="c1"># Figure out if `self` is in the arguments of `default`</span>
            <span class="c1"># If so, instance bind it, use MethodType</span>
            <span class="k">if</span> <span class="nb">callable</span><span class="p">(</span><span class="n">default</span><span class="p">)</span> <span class="ow">and</span> <span class="n">instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">if</span> <span class="s2">&quot;self&quot;</span> <span class="ow">in</span> <span class="n">inspect</span><span class="o">.</span><span class="n">signature</span><span class="p">(</span><span class="n">default</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">:</span>
                    <span class="c1"># Do a type-binding</span>
                    <span class="n">default</span> <span class="o">=</span> <span class="n">MethodType</span><span class="p">(</span><span class="n">default</span><span class="p">,</span> <span class="n">instance</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">default</span> <span class="o">=</span> <span class="n">default</span>
            <span class="c1"># Also set the actual value to the default one</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="n">default</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">found</span> <span class="o">=</span> <span class="n">found</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">doc</span> <span class="o">=</span> <span class="n">doc</span>

            <span class="k">def</span><span class="w"> </span><span class="nf">not_found_factory</span><span class="p">(</span><span class="n">method</span><span class="p">):</span>
                <span class="c1"># first check for a class, then check whether it is a specific class</span>
                <span class="c1"># otherwise a TypeError would be raised...</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">method</span><span class="p">,</span> <span class="ne">BaseException</span><span class="p">):</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">not_found</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                        <span class="k">raise</span> <span class="n">method</span><span class="p">(</span>
                            <span class="sa">f</span><span class="s2">&quot;Attribute </span><span class="si">{</span><span class="n">attr</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> could not be found in </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">.&quot;</span>
                        <span class="p">)</span>

                <span class="k">else</span><span class="p">:</span>

                    <span class="k">def</span><span class="w"> </span><span class="nf">not_found</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
                        <span class="n">method</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Attribute </span><span class="si">{</span><span class="n">attr</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2"> could not be found in </span><span class="si">{</span><span class="n">obj</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>

                <span class="k">return</span> <span class="n">not_found</span>

            <span class="k">if</span> <span class="n">not_found</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">not_found</span> <span class="o">=</span> <span class="n">not_found_factory</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">not_found</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">not_found</span> <span class="o">==</span> <span class="s2">&quot;info&quot;</span><span class="p">:</span>
                    <span class="n">not_found</span> <span class="o">=</span> <span class="n">not_found_factory</span><span class="p">(</span><span class="n">info</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">not_found</span> <span class="o">==</span> <span class="s2">&quot;warn&quot;</span><span class="p">:</span>
                    <span class="n">not_found</span> <span class="o">=</span> <span class="n">not_found_factory</span><span class="p">(</span><span class="n">warn</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">not_found</span> <span class="o">==</span> <span class="s2">&quot;error&quot;</span><span class="p">:</span>
                    <span class="n">not_found</span> <span class="o">=</span> <span class="n">not_found_factory</span><span class="p">(</span><span class="ne">KeyError</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">not_found</span> <span class="o">==</span> <span class="s2">&quot;ignore&quot;</span><span class="p">:</span>
                    <span class="n">not_found</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">obj</span><span class="p">,</span> <span class="n">attr</span><span class="p">:</span> <span class="kc">None</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                        <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> instantiated with unrecognized value in &#39;not_found&#39; argument, got </span><span class="si">{</span><span class="n">not_found</span><span class="si">}</span><span class="s2">.&quot;</span>
                    <span class="p">)</span>

            <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">not_found</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">not_found</span><span class="p">,</span> <span class="ne">BaseException</span><span class="p">):</span>
                <span class="n">not_found</span> <span class="o">=</span> <span class="n">not_found_factory</span><span class="p">(</span><span class="n">not_found</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">not_found</span> <span class="o">=</span> <span class="n">not_found</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">line</span><span class="p">):</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">found</span> <span class="ow">and</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">updatable</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">reset</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Reset the property to the default value&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">value</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">default</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">copy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="p">(</span>
                <span class="n">name</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span>
                <span class="n">searcher</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="p">,</span>
                <span class="n">parser</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">parser</span><span class="p">,</span>
                <span class="n">doc</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">,</span>
                <span class="n">updatable</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">updatable</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="p">,</span>
                <span class="n">found</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">found</span><span class="p">,</span>
                <span class="n">not_found</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">not_found</span><span class="p">,</span>
                <span class="n">instance</span><span class="o">=</span><span class="n">instance</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">return</span> <span class="n">obj</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">documentation</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Returns a documentation string for this object&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">:</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">indent</span><span class="p">(</span><span class="n">dedent</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">doc</span><span class="p">),</span> <span class="s2">&quot; &quot;</span> <span class="o">*</span> <span class="mi">4</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">doc</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
            <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="si">}</span><span class="s2">[</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">value</span><span class="si">}</span><span class="s2">]: r&#39;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">searcher</span><span class="o">.</span><span class="n">pattern</span><span class="si">}</span><span class="s2">&#39;</span><span class="si">{</span><span class="n">doc</span><span class="si">}</span><span class="s2">&quot;</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">_Info</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The actual .info object that will attached to the instance.</span>

<span class="sd">        As of now this is problematic to document.</span>
<span class="sd">        We should figure out a way to do that.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">instance</span><span class="p">):</span>
            <span class="c1"># attach this info instance to the instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span> <span class="o">=</span> <span class="n">instance</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_searching</span> <span class="o">=</span> <span class="kc">False</span>

            <span class="c1"># add the properties</span>
            <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">instance</span><span class="o">.</span><span class="n">_info_attributes_</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="nb">dict</span><span class="p">):</span>
                    <span class="n">prop</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">InfoAttr</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="n">instance</span><span class="p">,</span> <span class="o">**</span><span class="n">prop</span><span class="p">)</span>
                <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">prop</span><span class="p">,</span> <span class="p">(</span><span class="nb">tuple</span><span class="p">,</span> <span class="nb">list</span><span class="p">)):</span>
                    <span class="n">prop</span> <span class="o">=</span> <span class="n">instance</span><span class="o">.</span><span class="n">InfoAttr</span><span class="p">(</span><span class="o">*</span><span class="n">prop</span><span class="p">,</span> <span class="n">instance</span><span class="o">=</span><span class="n">instance</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prop</span> <span class="o">=</span> <span class="n">prop</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">instance</span><span class="o">=</span><span class="n">instance</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_property</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span>

            <span class="c1"># Patch the readline of the instance</span>
            <span class="k">def</span><span class="w"> </span><span class="nf">patch</span><span class="p">(</span><span class="n">info</span><span class="p">):</span>
                <span class="c1"># grab the function to be patched</span>
                <span class="n">properties</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">_properties</span>
                <span class="n">func</span> <span class="o">=</span> <span class="n">info</span><span class="o">.</span><span class="n">_instance</span><span class="o">.</span><span class="n">readline</span>

                <span class="nd">@wraps</span><span class="p">(</span><span class="n">func</span><span class="p">)</span>
                <span class="k">def</span><span class="w"> </span><span class="nf">readline</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
                    <span class="k">for</span> <span class="n">prop</span> <span class="ow">in</span> <span class="n">properties</span><span class="p">:</span>
                        <span class="n">prop</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">info</span><span class="o">.</span><span class="n">_instance</span><span class="p">,</span> <span class="n">line</span><span class="p">)</span>
                    <span class="k">return</span> <span class="n">line</span>

                <span class="k">return</span> <span class="n">readline</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span><span class="o">.</span><span class="n">readline</span> <span class="o">=</span> <span class="n">patch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">add_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">:</span> <span class="n">InfoAttr</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Add a new property to be reachable from the .info&quot;&quot;&quot;</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">name</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">get_property</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prop</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Add a new property to be reachable from the .info&quot;&quot;&quot;</span>
            <span class="k">if</span> <span class="n">prop</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="p">:</span>
                <span class="n">inst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span>
                <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">inst</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.info.</span><span class="si">{</span><span class="n">prop</span><span class="si">}</span><span class="s2"> does not exist, did you mistype?&quot;</span>
                <span class="p">)</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_attrs</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">prop</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Return a string of the contained attributes, with the values they currently contain&quot;&quot;&quot;</span>
            <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">p</span><span class="o">.</span><span class="n">documentation</span><span class="p">()</span> <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">])</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_properties</span><span class="p">)</span>

        <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
<span class="w">            </span><span class="sd">&quot;&quot;&quot;Overwrite the attribute retrieval to be able to fetch the actual values from the information&quot;&quot;&quot;</span>
            <span class="n">inst</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_instance</span>
            <span class="n">prop</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_property</span><span class="p">(</span><span class="n">attr</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">prop</span><span class="o">.</span><span class="n">found</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_searching</span><span class="p">:</span>
                <span class="c1"># only when hitting the new line will this change...</span>
                <span class="k">return</span> <span class="n">prop</span><span class="o">.</span><span class="n">value</span>

            <span class="c1"># we need to parse the rest of the file</span>
            <span class="c1"># This is not ideal, but...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_searching</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">loc</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">loc</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">tell</span><span class="p">()</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>
            <span class="k">with</span> <span class="n">inst</span><span class="p">:</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">while</span> <span class="ow">not</span> <span class="p">(</span><span class="n">prop</span><span class="o">.</span><span class="n">found</span> <span class="ow">or</span> <span class="n">line</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">):</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">inst</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">loc</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">inst</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="n">loc</span><span class="p">)</span>

            <span class="k">if</span> <span class="ow">not</span> <span class="n">prop</span><span class="o">.</span><span class="n">found</span><span class="p">:</span>
                <span class="n">prop</span><span class="o">.</span><span class="n">not_found</span><span class="p">(</span><span class="n">inst</span><span class="p">,</span> <span class="n">prop</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">_searching</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">return</span> <span class="n">prop</span><span class="o">.</span><span class="n">value</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">info</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_Info</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">Sile</span><span class="p">(</span><span class="n">Info</span><span class="p">,</span> <span class="n">BaseSile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Base class for ASCII files</span>

<span class="sd">    All ASCII files that needs to be added to the global lookup table can</span>
<span class="sd">    with benefit inherit this class.</span>

<span class="sd">    By subclassing a `Sile` one can manually specify the buffer class used</span>
<span class="sd">    when passing a `buffer_cls` keyword argument. This enables one to overwrite</span>
<span class="sd">    buffer classes for custom siles.</span>

<span class="sd">    &gt;&gt;&gt; class mySile(otherSislSile, buffer_cls=myBufferClass): ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_buffer_extension_cls</span> <span class="o">=</span> <span class="n">BufferSile</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="n">comment</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;comment&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">comment</span><span class="p">,</span> <span class="p">(</span><span class="nb">list</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">)):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">comment</span><span class="p">)</span>
        <span class="k">elif</span> <span class="ow">not</span> <span class="n">comment</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="p">[</span><span class="n">comment</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span> <span class="o">=</span> <span class="p">[]</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fh_opens</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="c1"># Initialize</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># track how many times this has been called</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;fh&quot;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">seek</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fh_opens</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">suffix</span> <span class="o">==</span> <span class="s2">&quot;.gz&quot;</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">==</span> <span class="s2">&quot;r&quot;</span><span class="p">:</span>
                    <span class="c1"># assume the file is a text file and open in text-mode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;rt&quot;</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1"># assume this is opening in binary or write mode</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="n">gzip</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">)</span>

        <span class="c1"># the file should restart the file-read (as per instructed)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="mi">0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_fh_opens</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens the output file and returns it self&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="c1"># clean-up so that it does not exist</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="Sile.close">
<a class="viewcode-back" href="../../../api/io/generated/sisl.io.Sile.html#sisl.io.Sile.close">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># decrement calls</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_fh_opens</span> <span class="o">-=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_fh_opens</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="nb">delattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">&quot;fh&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_fh_opens</span> <span class="o">=</span> <span class="mi">0</span></div>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">is_keys</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns true if ``not isinstance(keys, str)``&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">key2case</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">case</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts str/list of keywords to proper case&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">key</span>
        <span class="k">return</span> <span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">keys2case</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">case</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Converts str/list of keywords to proper case&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">keys</span>
        <span class="k">return</span> <span class="p">[</span><span class="n">k</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">line_has_key</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">0</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">line_has_keys</span><span class="p">(</span><span class="n">line</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">case</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">|=</span> <span class="n">line</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
                <span class="n">found</span> <span class="o">|=</span> <span class="n">l</span><span class="o">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">lower</span><span class="p">())</span> <span class="o">&gt;=</span> <span class="mi">0</span>
        <span class="k">return</span> <span class="n">found</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reading the entire content, without regarding comments&quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">l</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">l</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">(</span><span class="n">comment</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">readline</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">comment</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Reads the next line of the file&quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">if</span> <span class="n">comment</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">l</span>
        <span class="k">while</span> <span class="n">starts_with_list</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_comment</span><span class="p">):</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">l</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">step_to</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">keywords</span><span class="p">,</span> <span class="n">case</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">allow_reread</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">ret_index</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">reopen</span><span class="o">=</span><span class="kc">False</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Steps the file-handle until the keyword(s) is found in the input</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keywords : str or list</span>
<span class="sd">            keyword(s) to find in the sile</span>
<span class="sd">        case : bool, optional</span>
<span class="sd">            whether to search case sensitive</span>
<span class="sd">        allow_reread : bool, optional</span>
<span class="sd">            whether the search from current position is allowed to</span>
<span class="sd">            loop back to the beginning</span>
<span class="sd">        ret_index : bool, optional</span>
<span class="sd">            returns the index in the keyword list that was matched in the search</span>
<span class="sd">        reopen : bool, optional</span>
<span class="sd">            if True, the search is forced to start from the beginning</span>
<span class="sd">            of the sile (search after sile close and reopen)</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        found : bool</span>
<span class="sd">            whether the search was successful or not</span>
<span class="sd">        l : str</span>
<span class="sd">            the found line that matches the keyword(s)</span>
<span class="sd">        idx : int, optional</span>
<span class="sd">            index of the keyword from the list that was matched</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">reopen</span><span class="p">:</span>
            <span class="c1"># ensure file is read from the beginning</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>

        <span class="c1"># If keyword is a list, it just matches one of the inputs</span>
        <span class="n">found</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="c1"># The previously read line...</span>
        <span class="n">line</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">keywords</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="c1"># convert to list</span>
            <span class="n">keywords</span> <span class="o">=</span> <span class="p">[</span><span class="n">keywords</span><span class="p">]</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">keys2case</span><span class="p">(</span><span class="n">keywords</span><span class="p">,</span> <span class="n">case</span><span class="p">)</span>

        <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span><span class="p">:</span>
            <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                <span class="k">break</span>
            <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_has_keys</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">case</span><span class="p">)</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="p">(</span><span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span> <span class="ow">and</span> <span class="n">line</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="ow">and</span> <span class="n">allow_reread</span><span class="p">:</span>
            <span class="c1"># We may be in the case where the user request</span>
            <span class="c1"># reading the same twice...</span>
            <span class="c1"># So we need to re-read the file...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="c1"># Re-open the file...</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>

            <span class="c1"># Try and read again</span>
            <span class="k">while</span> <span class="ow">not</span> <span class="n">found</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_line</span> <span class="o">&lt;=</span> <span class="n">line</span><span class="p">:</span>
                <span class="n">l</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">l</span> <span class="o">==</span> <span class="s2">&quot;&quot;</span><span class="p">:</span>
                    <span class="k">break</span>
                <span class="n">found</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_has_keys</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">keys</span><span class="p">,</span> <span class="n">case</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">ret_index</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">found</span><span class="p">:</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># force return an index</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">key</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">keys</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">line_has_key</span><span class="p">(</span><span class="n">l</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">case</span><span class="p">):</span>
                    <span class="k">return</span> <span class="n">found</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">i</span>
            <span class="k">return</span> <span class="n">found</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">idx</span>

        <span class="c1"># sometimes the line contains information, as a</span>
        <span class="c1"># default we return the line found</span>
        <span class="k">return</span> <span class="n">found</span><span class="p">,</span> <span class="n">l</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Wrapper to default the write statements&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>


<span class="c1"># Instead of importing netCDF4 on each invocation</span>
<span class="c1"># of the __enter__ functioon (below), we make</span>
<span class="c1"># a pass around it</span>
<span class="k">if</span> <span class="n">has_module</span><span class="p">(</span><span class="s2">&quot;netCDF4&quot;</span><span class="p">):</span>
    <span class="kn">import</span><span class="w"> </span><span class="nn">netCDF4</span>
<span class="k">else</span><span class="p">:</span>

    <span class="k">class</span><span class="w"> </span><span class="nc">_mock_netCDF4</span><span class="p">:</span>
        <span class="k">def</span><span class="w"> </span><span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">attr</span><span class="p">):</span>
            <span class="kn">import</span><span class="w"> </span><span class="nn">sys</span>

            <span class="n">exe</span> <span class="o">=</span> <span class="n">Path</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">executable</span><span class="p">)</span><span class="o">.</span><span class="n">name</span>
            <span class="n">msg</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;Could not import netCDF4. Please install it using &#39;</span><span class="si">{</span><span class="n">exe</span><span class="si">}</span><span class="s2"> -m pip install netCDF4&#39;&quot;</span>
            <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>

    <span class="n">netCDF4</span> <span class="o">=</span> <span class="n">_mock_netCDF4</span><span class="p">()</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SileCDF</span><span class="p">(</span><span class="n">BaseSile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates/Opens a SileCDF</span>

<span class="sd">    Opens a SileCDF with `mode` and compression level `lvl`.</span>
<span class="sd">    If `mode` is in read-mode (r) the compression level</span>
<span class="sd">    is ignored.</span>

<span class="sd">    The final `access` parameter sets how the file should be</span>
<span class="sd">    open and subsequently accessed.</span>

<span class="sd">    0) means direct file access for every variable read</span>
<span class="sd">    1) means stores certain variables in the object.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_buffer_extension_cls</span> <span class="o">=</span> <span class="n">BufferSileCDF</span>

    <span class="n">_is_inside_zip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_buffer_instance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BufferSileCDF</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="n">lvl</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">access</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Open mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">mode</span>
        <span class="c1"># Get file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_is_inside_zip</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">,</span> <span class="n">ZipPath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="c1"># Save compression internally</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_lvl</span> <span class="o">=</span> <span class="n">lvl</span>
        <span class="c1"># Initialize the _data dictionary for access == 1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="o">.</span><span class="n">is_file</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_access</span> <span class="o">=</span> <span class="n">access</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># If it has not been created we should not try</span>
            <span class="c1"># and read anything, no matter what the user says</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_access</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="c1"># The CDF file can easily open the file</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;_open&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>

        <span class="c1"># Must call setup-methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_cmp_args</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Returns the compression arguments for the NetCDF file</span>

<span class="sd">        &gt;&gt;&gt; nc.createVariable(..., **self._cmp_args)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span><span class="s2">&quot;zlib&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lvl</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;complevel&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_lvl</span><span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens the output file and returns it self&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_open</span><span class="p">()</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_open</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens the output file and returns it self&quot;&quot;&quot;</span>
        <span class="c1"># We do the import here</span>
        <span class="k">if</span> <span class="s2">&quot;fh&quot;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">:</span>

            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_inside_zip</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_cls</span><span class="p">(</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">+</span> <span class="s2">&quot;b&quot;</span><span class="p">),</span>
                        <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">,</span>
                    <span class="p">)</span>

                    <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span><span class="o">.</span><span class="n">fh</span>

            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="vm">__dict__</span><span class="p">[</span><span class="s2">&quot;fh&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">(</span>
                    <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">file</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;NETCDF4&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>

        <span class="n">is_read</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;read_&quot;</span><span class="p">)</span>
        <span class="n">is_write</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;write_&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="p">(</span>
            <span class="p">(</span><span class="n">is_read</span> <span class="ow">or</span> <span class="n">is_write</span><span class="p">)</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_inside_zip</span>
            <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
        <span class="p">):</span>
            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
        <span class="k">return</span> <span class="kc">False</span>

<div class="viewcode-block" id="SileCDF.close">
<a class="viewcode-back" href="../../../api/io/generated/sisl.io.SileCDF.html#sisl.io.SileCDF.close">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">close</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span><span class="o">.</span><span class="n">_buffer</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


    <span class="k">def</span><span class="w"> </span><span class="nf">_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Local method for obtaing the dimension in a certain tree&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_dimensions</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve  method to get the NetCDF variable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Local method for obtaining the data from the SileCDF.</span>

<span class="sd">        This method returns the variable as-is.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_access</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="n">tree</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Local method for obtaining the data from the SileCDF.</span>

<span class="sd">        This method returns the value of the variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_variable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="p">)[:]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_variables</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">tree</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Retrieve  method to get the NetCDF variable&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">tree</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="n">g</span> <span class="o">=</span> <span class="n">n</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">tree</span><span class="p">,</span> <span class="nb">list</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">tree</span><span class="p">:</span>
                <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">t</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">g</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">tree</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">g</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_crt_grp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="k">if</span> <span class="s2">&quot;/&quot;</span> <span class="ow">in</span> <span class="n">name</span><span class="p">:</span>  <span class="c1"># this is NetCDF, so / is fixed as seperator!</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s2">&quot;/&quot;</span><span class="p">)</span>
            <span class="n">grp</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">grp</span> <span class="o">=</span> <span class="n">SileCDF</span><span class="o">.</span><span class="n">_crt_grp</span><span class="p">(</span><span class="n">grp</span><span class="p">,</span> <span class="n">group</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">grp</span>

        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">groups</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">groups</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">createGroup</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_crt_dim</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">l</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">dimensions</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">dimensions</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">createDimension</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">l</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">_crt_var</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">n</span><span class="o">.</span><span class="n">variables</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">n</span><span class="o">.</span><span class="n">variables</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>

        <span class="k">if</span> <span class="s2">&quot;attrs&quot;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;attrs&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">attrs</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">var</span> <span class="o">=</span> <span class="n">n</span><span class="o">.</span><span class="n">createVariable</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">attrs</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span> <span class="ow">in</span> <span class="n">attrs</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="nb">setattr</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">var</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isDimension</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return true if ``obj`` is an instance of the NetCDF4 ``Dimension`` type</span>

<span class="sd">        This is just a wrapper for ``isinstance(obj, netCDF4.Dimension)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dimension</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isVariable</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return true if ``obj`` is an instance of the NetCDF4 ``Variable`` type</span>

<span class="sd">        This is just a wrapper for ``isinstance(obj, netCDF4.Variable)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Variable</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isGroup</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return true if ``obj`` is an instance of the NetCDF4 ``Group`` type</span>

<span class="sd">        This is just a wrapper for ``isinstance(obj, netCDF4.Group)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Group</span><span class="p">)</span>

    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">isDataset</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">obj</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return true if ``obj`` is an instance of the NetCDF4 ``Dataset`` type</span>

<span class="sd">        This is just a wrapper for ``isinstance(obj, netCDF4.Dataset)``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">netCDF4</span><span class="o">.</span><span class="n">Dataset</span><span class="p">)</span>

    <span class="n">isRoot</span> <span class="o">=</span> <span class="n">isDataset</span>

<div class="viewcode-block" id="SileCDF.iter">
<a class="viewcode-back" href="../../../api/io/generated/sisl.io.SileCDF.html#sisl.io.SileCDF.iter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">group</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dimension</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">variable</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">levels</span><span class="o">=-</span><span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Iterator on all groups, variables and dimensions.</span>

<span class="sd">        This iterator iterates through all groups, variables and dimensions in the ``Dataset``</span>

<span class="sd">        The generator sequence will _always_ be:</span>

<span class="sd">          1. Group</span>
<span class="sd">          2. Dimensions in group</span>
<span class="sd">          3. Variables in group</span>

<span class="sd">        As the dimensions are generated before the variables it is possible to copy</span>
<span class="sd">        groups, dimensions, and then variables such that one always ensures correct</span>
<span class="sd">        dependencies in the generation of a new ``SileCDF``.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        group : ``bool`` (`True`)</span>
<span class="sd">           whether the iterator yields `Group` instances</span>
<span class="sd">        dimension : ``bool`` (`True`)</span>
<span class="sd">           whether the iterator yields `Dimension` instances</span>
<span class="sd">        variable : ``bool`` (`True`)</span>
<span class="sd">           whether the iterator yields `Variable` instances</span>
<span class="sd">        levels : ``int`` (`-1`)</span>
<span class="sd">           number of levels to traverse, with respect to ``root`` variable, i.e. number of</span>
<span class="sd">           sub-groups this iterator will return.</span>
<span class="sd">        root : ``str`` (`None`)</span>
<span class="sd">           the base root to start iterating from.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        Script for looping and checking each instance.</span>

<span class="sd">        &gt;&gt;&gt; for gv in self.iter():</span>
<span class="sd">        ...     if self.isGroup(gv):</span>
<span class="sd">        ...         # is group</span>
<span class="sd">        ...     elif self.isDimension(gv):</span>
<span class="sd">        ...         # is dimension</span>
<span class="sd">        ...     elif self.isVariable(gv):</span>
<span class="sd">        ...         # is variable</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fh</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">head</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fh</span><span class="p">[</span><span class="n">root</span><span class="p">]</span>

        <span class="c1"># Start by returning the root group</span>
        <span class="k">if</span> <span class="n">group</span><span class="p">:</span>
            <span class="k">yield</span> <span class="n">head</span>

        <span class="k">if</span> <span class="n">dimension</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">head</span><span class="o">.</span><span class="n">dimensions</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">variable</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="n">head</span><span class="o">.</span><span class="n">variables</span><span class="o">.</span><span class="n">values</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">levels</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="c1"># Stop the iterator</span>
            <span class="k">return</span>

        <span class="k">for</span> <span class="n">grp</span> <span class="ow">in</span> <span class="n">head</span><span class="o">.</span><span class="n">groups</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter</span><span class="p">(</span>
                <span class="n">group</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">variable</span><span class="p">,</span> <span class="n">levels</span><span class="o">=</span><span class="n">levels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">root</span><span class="o">=</span><span class="n">grp</span><span class="o">.</span><span class="n">path</span>
            <span class="p">)</span></div>


    <span class="fm">__iter__</span> <span class="o">=</span> <span class="nb">iter</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.io&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">SileBin</span><span class="p">(</span><span class="n">BaseSile</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Creates/Opens a SileBin</span>

<span class="sd">    Opens a SileBin with `mode` (b).</span>
<span class="sd">    If `mode` is in read-mode (r).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">_buffer_extension_cls</span> <span class="o">=</span> <span class="n">BufferSileBin</span>

    <span class="n">_is_inside_zip</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="n">_buffer_instance</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">BufferSileBin</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">filename</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># Open mode</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span> <span class="o">=</span> <span class="n">mode</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;b&quot;</span><span class="p">,</span> <span class="s2">&quot;&quot;</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;b&quot;</span>
        <span class="c1"># Get file</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_file</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_sanitize_filename</span><span class="p">(</span><span class="n">filename</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_is_inside_zip</span> <span class="o">=</span> <span class="nb">isinstance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="p">,</span> <span class="n">ZipPath</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="c1"># Must call setup-methods</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_base_setup</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__getattribute__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
        <span class="c1"># If the file is inside a zip fortran can&#39;t read directly from it.</span>
        <span class="c1"># We open the buffer from the zipfile and then pass it to the BufferSileBin</span>
        <span class="c1"># class, which will handle things as with any other buffer</span>
        <span class="n">is_read_write</span> <span class="o">=</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;read_&quot;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">name</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s2">&quot;write_&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_read_write</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_is_inside_zip</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_buffer_cls</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_file</span><span class="o">.</span><span class="n">open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">),</span> <span class="n">mode</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">,</span> <span class="n">close</span><span class="o">=</span><span class="kc">True</span>
                <span class="p">)</span>

            <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_buffer_instance</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

        <span class="k">return</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__getattribute__</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__enter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Opens the output file and returns it self&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__exit__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">traceback</span><span class="p">):</span>
        <span class="k">return</span> <span class="kc">False</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sile_raise_write</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ok</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;w&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)):</span>
    <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">O</span> <span class="ow">in</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">is_ok</span> <span class="o">=</span> <span class="n">is_ok</span> <span class="ow">or</span> <span class="p">(</span><span class="n">O</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
            <span class="p">(</span>
                <span class="s2">&quot;Writing to file not possible; allowed &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;modes=</span><span class="si">{</span><span class="n">ok</span><span class="si">}</span><span class="s2">, used mode=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">),</span>
            <span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>


<span class="k">def</span><span class="w"> </span><span class="nf">sile_raise_read</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ok</span><span class="o">=</span><span class="p">(</span><span class="s2">&quot;r&quot;</span><span class="p">,</span> <span class="s2">&quot;a&quot;</span><span class="p">)):</span>
    <span class="n">is_ok</span> <span class="o">=</span> <span class="kc">False</span>
    <span class="k">for</span> <span class="n">O</span> <span class="ow">in</span> <span class="n">ok</span><span class="p">:</span>
        <span class="n">is_ok</span> <span class="o">=</span> <span class="n">is_ok</span> <span class="ow">or</span> <span class="p">(</span><span class="n">O</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">is_ok</span><span class="p">:</span>
        <span class="k">raise</span> <span class="n">SileError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;Reading file not possible; allowed &quot;</span>
            <span class="sa">f</span><span class="s2">&quot;modes=</span><span class="si">{</span><span class="n">ok</span><span class="si">}</span><span class="s2">, used mode=</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">_mode</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">,</span>
            <span class="bp">self</span><span class="p">,</span>
        <span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>