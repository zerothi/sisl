

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl.physics.brillouinzone &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=9d09c2c4"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../toolbox/index.html">Toolboxes</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Module code</a></li>
      <li class="breadcrumb-item active">sisl.physics.brillouinzone</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for sisl.physics.brillouinzone</h1><div class="highlight"><pre>
<span></span><span class="c1"># This Source Code Form is subject to the terms of the Mozilla Public</span>
<span class="c1"># License, v. 2.0. If a copy of the MPL was not distributed with this</span>
<span class="c1"># file, You can obtain one at https://mozilla.org/MPL/2.0/.</span>
<span class="sd">&quot;&quot;&quot;Brillouin zone classes</span>
<span class="sd">=========================</span>

<span class="sd">The Brillouin zone objects are all special classes enabling easy manipulation</span>
<span class="sd">of an underlying physical quantity.</span>

<span class="sd">Quite often a physical quantity will be required to be averaged, or calculated individually</span>
<span class="sd">over a number of k-points. In this regard the Brillouin zone objects can help.</span>

<span class="sd">The BrillouinZone object allows direct looping of contained k-points while invoking</span>
<span class="sd">particular methods from the contained object.</span>
<span class="sd">This is best shown with an example:</span>

<span class="sd">&gt;&gt;&gt; import sisl as si</span>
<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; bz = si.BrillouinZone(H)</span>
<span class="sd">&gt;&gt;&gt; bz.apply.array.eigh()</span>

<span class="sd">This will calculate eigenvalues for all k-points associated with the `BrillouinZone` and</span>
<span class="sd">return everything as an array. The `~sisl.physics.BrillouinZone.dispatch` property of</span>
<span class="sd">the `BrillouinZone` object has several use cases (here ``array`` is shown).</span>

<span class="sd">This may be extremely convenient when calculating band-structures:</span>

<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; bs = si.BandStructure(H, [[0, 0, 0], [0.5, 0, 0]], 100)</span>
<span class="sd">&gt;&gt;&gt; bs_eig = bs.apply.array.eigh()</span>
<span class="sd">&gt;&gt;&gt; plt.plot(bs.lineark(), bs_eig)</span>

<span class="sd">and then you have all eigenvalues for all the k-points along the path.</span>

<span class="sd">Sometimes one may want to post-process the data for each k-point.</span>
<span class="sd">As an example lets post-process the DOS on a per k-point basis while</span>
<span class="sd">calculating the average:</span>

<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = si.MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_DOS(eigenstate):</span>
<span class="sd">...    # Calculate the DOS for the eigenstates</span>
<span class="sd">...    DOS = eigenstate.DOS(E)</span>
<span class="sd">...    # Calculate the velocity for the eigenstates</span>
<span class="sd">...    v = eigenstate.velocity()</span>
<span class="sd">...    V = (v ** 2).sum(1)</span>
<span class="sd">...    return DOS.reshape(-1, 1) * v ** 2 / V.reshape(-1, 1)</span>
<span class="sd">&gt;&gt;&gt; DOS = mp.apply.average.eigenstate(wrap=wrap_DOS, eta=True)</span>

<span class="sd">This will, calculate the Monkhorst pack k-averaged DOS split into 3 Cartesian</span>
<span class="sd">directions based on the eigenstates velocity direction. This method of manipulating</span>
<span class="sd">the result can be extremely powerful to calculate many quantities while running an</span>
<span class="sd">efficient `BrillouinZone` average. The `eta` flag will print, to stdout, a progress-bar.</span>
<span class="sd">The usage of the ``wrap`` method are also passed optional arguments, ``parent`` which is</span>
<span class="sd">``H`` in the above example. ``k`` and ``weight`` are the current k-point and weight of the</span>
<span class="sd">corresponding k-point. An example could be to manipulate the DOS depending on the k-point and</span>
<span class="sd">weight:</span>

<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = si.MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_DOS(eigenstate, k, weight):</span>
<span class="sd">...    # Calculate the DOS for the eigenstates and weight by k_x and weight</span>
<span class="sd">...    return eigenstate.DOS(E) * k[0] * weight</span>
<span class="sd">&gt;&gt;&gt; DOS = mp.apply.sum.eigenstate(wrap=wrap_DOS, eta=True)</span>

<span class="sd">When using wrap to calculate more than one quantity per eigenstate it may be advantageous</span>
<span class="sd">to use `~sisl.oplist` to handle cases of `BrillouinZone.apply.average` and `BrillouinZone.apply.sum`.</span>

<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = si.MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; E = np.linspace(-2, 2, 100)</span>
<span class="sd">&gt;&gt;&gt; def wrap_multiple(eigenstate):</span>
<span class="sd">...    # Calculate DOS/PDOS for eigenstates</span>
<span class="sd">...    DOS = eigenstate.DOS(E)</span>
<span class="sd">...    PDOS = eigenstate.PDOS(E)</span>
<span class="sd">...    # Calculate velocity for the eigenstates</span>
<span class="sd">...    v = eigenstate.velocity()</span>
<span class="sd">...    return si.oplist([DOS, PDOS, v])</span>
<span class="sd">&gt;&gt;&gt; DOS, PDOS, v = mp.apply.average.eigenstate(wrap=wrap_multiple, eta=True)</span>

<span class="sd">Which does mathematical operations (averaging/summing) using `~sisl.oplist`.</span>


<span class="sd">Parallel calculations</span>
<span class="sd">---------------------</span>

<span class="sd">The ``apply`` method looping k-points may be explicitly parallelized.</span>
<span class="sd">To run parallel do:</span>

<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = si.MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; with mp.apply.renew(pool=True) as par:</span>
<span class="sd">...     par.eigh()</span>

<span class="sd">This requires you also have the package ``pathos`` available.</span>
<span class="sd">The above will run in parallel using a default number of processors</span>
<span class="sd">in priority:</span>

<span class="sd">1. Environment variable ``SISL_NUM_PROCS``</span>
<span class="sd">2. Return value of ``os.cpu_count()``.</span>

<span class="sd">Note that this may interfere with BLAS implementation which defaults</span>
<span class="sd">to use all CPU&#39;s for threading. The total processors/threads that will</span>
<span class="sd">be created is ``SISL_NUM_PROCS * OMP_NUM_THREADS``. Try and ensure this is below</span>
<span class="sd">or equal to the actual core-count of your machine (or the number of requested</span>
<span class="sd">cores in a HPC environment).</span>


<span class="sd">Alternatively one can control the number of processors locally by doing:</span>

<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = si.MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; with mp.apply.renew(pool=2) as par:</span>
<span class="sd">...     par.eigh()</span>

<span class="sd">which will request 2 processors (regardless of core-count).</span>
<span class="sd">As a last resort you can pass your own ``Pool`` of workers that</span>
<span class="sd">will be used for the parallel processing.</span>

<span class="sd">&gt;&gt;&gt; from multiprocessing import Pool</span>
<span class="sd">&gt;&gt;&gt; pool = Pool(4)</span>
<span class="sd">&gt;&gt;&gt; H = si.Hamiltonian(...)</span>
<span class="sd">&gt;&gt;&gt; mp = si.MonkhorstPack(H, [10, 10, 10])</span>
<span class="sd">&gt;&gt;&gt; with mp.apply.renew(pool=pool) as par:</span>
<span class="sd">...     par.eigh()</span>

<span class="sd">The ``Pool`` should implement some standard methods that are</span>
<span class="sd">existing in the ``pathos`` enviroment such as ``Pool.restart`` and ``Pool.terminate``</span>
<span class="sd">and ``imap`` and ``uimap`` methods. See the ``pathos`` documentation for details.</span>

<span class="sd">Finally, the performance of the parallel pools are generally very dependent</span>
<span class="sd">on the chunksize of the jobs. By default the chunksize is controlled by</span>
<span class="sd">``SISL_PAR_CHUNKSIZE``, and playing with this can heavily impact performance.</span>


<span class="sd">   BrillouinZone</span>
<span class="sd">   MonkhorstPack</span>
<span class="sd">   BandStructure</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">__future__</span><span class="w"> </span><span class="kn">import</span> <span class="n">annotations</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">itertools</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">collections.abc</span><span class="w"> </span><span class="kn">import</span> <span class="n">Sequence</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numbers</span><span class="w"> </span><span class="kn">import</span> <span class="n">Integral</span><span class="p">,</span> <span class="n">Real</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">Union</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">np</span>
<span class="kn">import</span><span class="w"> </span><span class="nn">numpy.typing</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">npt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">numpy</span><span class="w"> </span><span class="kn">import</span> <span class="n">argsort</span><span class="p">,</span> <span class="n">dot</span><span class="p">,</span> <span class="n">pi</span>

<span class="kn">import</span><span class="w"> </span><span class="nn">sisl._array</span><span class="w"> </span><span class="k">as</span><span class="w"> </span><span class="nn">_a</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._core.lattice</span><span class="w"> </span><span class="kn">import</span> <span class="n">Lattice</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._core.quaternion</span><span class="w"> </span><span class="kn">import</span> <span class="n">Quaternion</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._dispatcher</span><span class="w"> </span><span class="kn">import</span> <span class="n">ClassDispatcher</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._internal</span><span class="w"> </span><span class="kn">import</span> <span class="n">set_module</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl._math_small</span><span class="w"> </span><span class="kn">import</span> <span class="n">cross3</span><span class="p">,</span> <span class="n">dot3</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.messages</span><span class="w"> </span><span class="kn">import</span> <span class="n">SislError</span><span class="p">,</span> <span class="n">deprecate_argument</span><span class="p">,</span> <span class="n">info</span><span class="p">,</span> <span class="n">warn</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing</span><span class="w"> </span><span class="kn">import</span> <span class="n">Coord</span><span class="p">,</span> <span class="n">SeqOrScalarFloat</span><span class="p">,</span> <span class="n">SeqOrScalarInt</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.typing._common</span><span class="w"> </span><span class="kn">import</span> <span class="n">KPoint</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils</span><span class="w"> </span><span class="kn">import</span> <span class="n">batched_indices</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.mathematics</span><span class="w"> </span><span class="kn">import</span> <span class="n">cart2spher</span><span class="p">,</span> <span class="n">fnorm</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl.utils.misc</span><span class="w"> </span><span class="kn">import</span> <span class="n">direction</span><span class="p">,</span> <span class="n">listify</span>

<span class="kn">from</span><span class="w"> </span><span class="nn">.spin</span><span class="w"> </span><span class="kn">import</span> <span class="n">Spin</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;BrillouinZone&quot;</span><span class="p">,</span> <span class="s2">&quot;MonkhorstPack&quot;</span><span class="p">,</span> <span class="s2">&quot;BandStructure&quot;</span><span class="p">,</span> <span class="s2">&quot;linspace_bz&quot;</span><span class="p">]</span>


<span class="k">class</span><span class="w"> </span><span class="nc">BrillouinZoneDispatcher</span><span class="p">(</span><span class="n">ClassDispatcher</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Loop over all k-points by applying `parent` methods for all k.</span>

<span class="sd">    This allows potential for running and collecting various computationally</span>
<span class="sd">    heavy methods from a single point on all k-points.</span>

<span class="sd">    The `apply` method will *dispatch* the parent methods through all k-points</span>
<span class="sd">    and passing `k` as arguments to the parent methods in a straight-forward manner.</span>

<span class="sd">    For instance to iterate over all eigenvalues of a Hamiltonian</span>

<span class="sd">    &gt;&gt;&gt; H = Hamiltonian(...)</span>
<span class="sd">    &gt;&gt;&gt; bz = BrillouinZone(H)</span>
<span class="sd">    &gt;&gt;&gt; for ik, eigh in enumerate(bz.apply.eigh()):</span>
<span class="sd">    ...    # do something with eigh which corresponds to bz.k[ik]</span>

<span class="sd">    By default the `apply` method exposes a set of dispatch methods:</span>

<span class="sd">    - ``apply.iter``, the default iterator module</span>
<span class="sd">    - ``apply.average`` reduced result by averaging (using `BrillouinZone.weight` as the weight per k-point.</span>
<span class="sd">    - ``apply.sum`` reduced result without weighing</span>
<span class="sd">    - ``apply.array`` return a single array with all values; has `len` equal to number of k-points</span>
<span class="sd">    - ``apply.none``, specialized method that is mainly useful when wrapping methods</span>
<span class="sd">    - ``apply.list`` same as ``apply.array`` but using Python list as return value</span>
<span class="sd">    - ``apply.oplist`` using `sisl.oplist` allows greater flexibility for mathematical operations element wise</span>
<span class="sd">    - ``apply.datarray`` if `xarray` is available one can retrieve an `xarray.DataArray` instance</span>

<span class="sd">    Please see :ref:`physics.brillouinzone` for further examples.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">pass</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">def</span><span class="w"> </span><span class="nf">linspace_bz</span><span class="p">(</span><span class="n">bz</span><span class="p">,</span> <span class="n">stop</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jumps</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">jump_dk</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.05</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Convert points from a BZ object into a linear spacing of maximum value `stop`</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    bz : BrillouinZone, or ndarray</span>
<span class="sd">       the object containing the k-points</span>
<span class="sd">    stop : int or None, optional</span>
<span class="sd">       maximum value in the linear space, or if None, will return the cumulative</span>
<span class="sd">       distance of the k-points in the Brillouin zone</span>
<span class="sd">    jumps: array_like, optional</span>
<span class="sd">       whether there are any jumps for the k-points that should not be taken into account</span>
<span class="sd">    jump_dk: float or array_like, optional</span>
<span class="sd">       how much total distance the jump points will take</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">bz</span><span class="p">,</span> <span class="n">BrillouinZone</span><span class="p">):</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">bz</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">cart</span> <span class="o">=</span> <span class="n">bz</span>
    <span class="c1"># calculate vectors between each neighboring points</span>
    <span class="n">dcart</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">cart</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">prepend</span><span class="o">=</span><span class="n">cart</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
    <span class="c1"># calculate distances</span>
    <span class="n">dist</span> <span class="o">=</span> <span class="p">(</span><span class="n">dcart</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>

    <span class="k">if</span> <span class="n">jumps</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="c1"># calculate the total distance</span>
        <span class="n">total_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

        <span class="c1"># Zero out the jumps</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">jumps</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">total_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="c1"># correct jumps</span>
        <span class="n">dist</span><span class="p">[</span><span class="n">jumps</span><span class="p">]</span> <span class="o">=</span> <span class="n">total_dist</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">jump_dk</span><span class="p">)</span>

    <span class="c1"># convert to linear scale</span>
    <span class="k">if</span> <span class="n">stop</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>

    <span class="n">total_dist</span> <span class="o">=</span> <span class="n">dist</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">/</span> <span class="n">stop</span>

    <span class="c1"># Scale to total length of `stop`</span>
    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span> <span class="o">/</span> <span class="n">total_dist</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BrillouinZone</span><span class="p">:</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;A class to construct Brillouin zone related quantities</span>

<span class="sd">    It takes any object (which has access to cell-vectors) as an argument</span>
<span class="sd">    and can then return the k-points in non-reduced units from reduced units.</span>

<span class="sd">    The object associated with the BrillouinZone object *has* to implement</span>
<span class="sd">    at least two different properties:</span>

<span class="sd">    1. `cell` which is the lattice vector</span>
<span class="sd">    2. `rcell` which is the reciprocal lattice vectors.</span>

<span class="sd">    The object may also be an array of floats in which case an internal</span>
<span class="sd">    `Lattice` object will be created from the cell vectors (see `Lattice` for</span>
<span class="sd">    details).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array-like</span>
<span class="sd">       An object with associated ``parent.cell`` and ``parent.rcell`` or</span>
<span class="sd">       an array of floats which may be turned into a `Lattice`</span>
<span class="sd">    k : array-like, optional</span>
<span class="sd">       k-points that this Brillouin zone represents</span>
<span class="sd">    weight : scalar or array-like, optional</span>
<span class="sd">       weights for the k-points.</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">apply</span> <span class="o">=</span> <span class="n">BrillouinZoneDispatcher</span><span class="p">(</span>
        <span class="s2">&quot;apply&quot;</span><span class="p">,</span>
        <span class="c1"># Do not allow class dispatching</span>
        <span class="n">type_dispatcher</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
        <span class="n">obj_getattr</span><span class="o">=</span><span class="k">lambda</span> <span class="n">obj</span><span class="p">,</span> <span class="n">key</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="o">.</span><span class="n">parent</span><span class="p">,</span> <span class="n">key</span><span class="p">),</span>
    <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">weight</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="c1"># define a bz_attr as though it has not been set</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_bz_attr</span> <span class="o">=</span> <span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="c1"># Gamma point</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">zerosd</span><span class="p">([</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
            <span class="k">if</span> <span class="n">weight</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">weight</span> <span class="o">=</span> <span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[:]</span> <span class="o">=</span> <span class="n">weight</span>

<div class="viewcode-block" id="BrillouinZone.set_parent">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.set_parent">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">set_parent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Update the parent associated to this object</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : object or array_like</span>
<span class="sd">           an object containing cell vectors</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="c1"># It probably has the supercell attached</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">cell</span>
            <span class="n">parent</span><span class="o">.</span><span class="n">rcell</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">parent</span>
        <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">parent</span> <span class="o">=</span> <span class="n">Lattice</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span></div>


    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of the BrillouinZone&quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_parent_lattice</span><span class="p">())</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="se">{{</span><span class="s2">nk: </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span><span class="si">}</span><span class="s2">,</span><span class="se">\n</span><span class="s2"> </span><span class="si">{</span><span class="n">parent</span><span class="si">}</span><span class="se">\n}}</span><span class="s2">&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">_parent_lattice</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Ensures to return the lattice of the parent, however it may be nested&quot;&quot;&quot;</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">parent</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">parent</span><span class="o">.</span><span class="n">lattice</span><span class="p">,</span> <span class="n">Lattice</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">parent</span><span class="o">.</span><span class="n">lattice</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
            <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> could not extract the lattice object, it must be located elsewhere.&quot;</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dictionary with the current state&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="s2">&quot;parent_class&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="vm">__class__</span><span class="p">,</span>
            <span class="s2">&quot;parent&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">(),</span>
            <span class="s2">&quot;k&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
            <span class="s2">&quot;weight&quot;</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">copy</span><span class="p">(),</span>
        <span class="p">}</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset state of the object&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;k&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;weight&quot;</span><span class="p">]</span>
        <span class="n">parent</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;parent_class&quot;</span><span class="p">]</span><span class="o">.</span><span class="fm">__new__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;parent_class&quot;</span><span class="p">])</span>
        <span class="n">parent</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">[</span><span class="s2">&quot;parent&quot;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_parent</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

<div class="viewcode-block" id="BrillouinZone.merge">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.merge">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">merge</span><span class="p">(</span><span class="n">bzs</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">:</span> <span class="n">SeqOrScalarFloat</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span> <span class="n">parent</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Merge several BrillouinZone objects into one</span>

<span class="sd">        The merging strategy only stores the new list of k-points and weights.</span>
<span class="sd">        Information retained in the merged objects will not be stored.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        bzs : list-like of BrillouinZone objects</span>
<span class="sd">           each element is a BrillouinZone object with ``bzs[i].k`` and ``bzs[i].weight``</span>
<span class="sd">           fields.</span>
<span class="sd">        weight_scale :</span>
<span class="sd">           these are matched item-wise with `bzs` and applied to.</span>
<span class="sd">           Internally ``itertools.zip_longest(fillvalue=weight_scale[-1])`` will be</span>
<span class="sd">           used to extend for all `bzs`.</span>
<span class="sd">        parent : object, optional</span>
<span class="sd">           Associated parent in the returned object, will default to ``bzs[0].parent``</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BrillouinZone:</span>
<span class="sd">            even if all objects are not BrillouinZone objects the returned object</span>
<span class="sd">            will be.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">weight_scale</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">weight_scale</span> <span class="o">=</span> <span class="p">[</span><span class="n">weight_scale</span><span class="p">]</span>

        <span class="c1"># check for lengths (scales cannot be longer!)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">bzs</span><span class="p">)</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">weight_scale</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="s2">&quot;BrillouinZone.merge requires length of weight_scale to be smaller or equal to &quot;</span>
                <span class="s2">&quot;the objects.&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">parent</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parent</span> <span class="o">=</span> <span class="n">bzs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">parent</span>

        <span class="n">k</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">w</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">bz</span><span class="p">,</span> <span class="n">scale</span> <span class="ow">in</span> <span class="n">itertools</span><span class="o">.</span><span class="n">zip_longest</span><span class="p">(</span>
            <span class="n">bzs</span><span class="p">,</span> <span class="n">weight_scale</span><span class="p">,</span> <span class="n">fillvalue</span><span class="o">=</span><span class="n">weight_scale</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="p">):</span>
            <span class="n">k</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bz</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>
            <span class="n">w</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bz</span><span class="o">.</span><span class="n">weight</span> <span class="o">*</span> <span class="n">scale</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span><span class="n">w</span><span class="p">))</span></div>


<div class="viewcode-block" id="BrillouinZone.volume">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.volume">[docs]</a>
    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;periodic&quot;</span><span class="p">,</span>
        <span class="s2">&quot;axes&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument &#39;periodic&#39; has been deprecated in favor of &#39;axes&#39;, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">volume</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">ret_dim</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">axes</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">CellAxes</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">[</span><span class="nb">float</span><span class="p">,</span> <span class="nb">int</span><span class="p">]]:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Calculate the volume of the BrillouinZone, optionally only on some axes `axes`</span>

<span class="sd">        This will return the volume of the Brillouin zone,</span>
<span class="sd">        depending on the dimensions of the system.</span>
<span class="sd">        Here the dimensions of the system is determined by how many dimensions</span>
<span class="sd">        have auxilliary supercells that can contribute to Brillouin zone integrals.</span>
<span class="sd">        Therefore the returned value will have differing units depending on</span>
<span class="sd">        dimensionality.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ret_dim :</span>
<span class="sd">           also return the dimensionality of the system</span>
<span class="sd">        axes :</span>
<span class="sd">           estimate the volume using only the directions indexed by this array.</span>
<span class="sd">           The default axes are only the periodic ones (``self.parent.pbc.nonzero()[0]``).</span>
<span class="sd">           Hence the units might not necessarily be 1/Ang^3.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        vol :</span>
<span class="sd">           the volume of the Brillouin zone. Units are 1/Ang^D with D being the dimensionality.</span>
<span class="sd">           For 0D it will return 0.</span>
<span class="sd">        dimensionality : int</span>
<span class="sd">           the dimensionality of the volume</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_lattice</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">axes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">pbc</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">axes</span> <span class="o">=</span> <span class="nb">map</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">listify</span><span class="p">(</span><span class="n">axes</span><span class="p">))</span> <span class="o">|</span> <span class="n">listify</span>

        <span class="n">cell</span> <span class="o">=</span> <span class="n">lattice</span><span class="o">.</span><span class="n">rcell</span>

        <span class="n">dim</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">axes</span><span class="p">)</span>
        <span class="n">vol</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">3</span><span class="p">:</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="n">dot3</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cross3</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]],</span> <span class="n">cell</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">2</span><span class="p">]])))</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">cross3</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">cell</span><span class="p">[</span><span class="n">axes</span><span class="p">[</span><span class="mi">1</span><span class="p">]]))</span>
        <span class="k">if</span> <span class="n">dim</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">vol</span> <span class="o">=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">cell</span><span class="p">[</span><span class="n">axes</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">ret_dim</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">vol</span><span class="p">,</span> <span class="n">dim</span>
        <span class="k">return</span> <span class="n">vol</span></div>


<div class="viewcode-block" id="BrillouinZone.parametrize">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.parametrize">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">parametrize</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">func</span><span class="p">,</span> <span class="n">N</span><span class="p">:</span> <span class="n">SeqOrScalarInt</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BrillouinZone</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Generate a new `BrillouinZone` object with k-points parameterized via the function `func` in `N` separations</span>

<span class="sd">        Generator of a parameterized Brillouin zone object that contains a parameterized k-point</span>
<span class="sd">        list.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : Lattice, or LatticeChild</span>
<span class="sd">           the object that the returned object will contain as parent</span>
<span class="sd">        func : callable</span>
<span class="sd">           method that parameterizes the k-points, *must* at least accept three arguments,</span>
<span class="sd">           1. ``parent``: object</span>
<span class="sd">           2. ``N``: total number of k-points</span>
<span class="sd">           3. ``i``: current index of the k-point (starting from 0)</span>

<span class="sd">           the function must return a k-point in 3 dimensions.</span>
<span class="sd">        N :</span>
<span class="sd">           number of k-points generated using the parameterization,</span>
<span class="sd">           or a list of integers that will be looped over.</span>
<span class="sd">           In this case arguments ``N`` and ``i`` in `func` will be</span>
<span class="sd">           lists accordingly.</span>
<span class="sd">        *args :</span>
<span class="sd">           additional arguments passed directly to `func`</span>
<span class="sd">        **kwargs :</span>
<span class="sd">           additional keyword arguments passed directly to `func`</span>


<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Simple linear k-points</span>

<span class="sd">        &gt;&gt;&gt; def func(sc, N, i):</span>
<span class="sd">        ...    return [i/N, 0, 0]</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.parametrize(1, func, 10)</span>
<span class="sd">        &gt;&gt;&gt; assert len(bz) == 10</span>
<span class="sd">        &gt;&gt;&gt; assert np.allclose(bz.k[-1, :], [9./10, 0, 0])</span>

<span class="sd">        For double looping, say to create your own grid</span>

<span class="sd">        &gt;&gt;&gt; def func(sc, N, i):</span>
<span class="sd">        ...    return [i[0]/N[0], i[1]/N[1], 0]</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.parametrize(1, func, [10, 5])</span>
<span class="sd">        &gt;&gt;&gt; assert len(bz) == 50</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">):</span>
                <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># N must be some-kind of list like thingy</span>
            <span class="n">Nk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">prod</span><span class="p">(</span><span class="n">N</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">([</span><span class="n">Nk</span><span class="p">,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">indices</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="o">*</span><span class="nb">map</span><span class="p">(</span><span class="nb">range</span><span class="p">,</span> <span class="n">N</span><span class="p">))):</span>
                <span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">func</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrillouinZone.param_circle">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.param_circle">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">param_circle</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">,</span>
        <span class="n">N_or_dk</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">float</span><span class="p">],</span>
        <span class="n">kR</span><span class="p">:</span> <span class="nb">float</span><span class="p">,</span>
        <span class="n">normal</span><span class="p">:</span> <span class="n">Coord</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="n">Coord</span><span class="p">,</span>
        <span class="n">loop</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a parameterized k-point list where the k-points are generated on a circle around an origin</span>

<span class="sd">        The generated circle is a perfect circle in the reciprocal space (Cartesian coordinates).</span>
<span class="sd">        To generate a perfect circle in units of the reciprocal lattice vectors one can</span>
<span class="sd">        generate the circle for a diagonal supercell with side-length :math:`2\pi`, see</span>
<span class="sd">        example below.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        parent : Lattice, or LatticeChild</span>
<span class="sd">           the parent object</span>
<span class="sd">        N_or_dk : int</span>
<span class="sd">           number of k-points generated using the parameterization (if an integer),</span>
<span class="sd">           otherwise it specifies the discretization length on the circle (in 1/Ang),</span>
<span class="sd">           If the latter case will use less than 2 points a warning will be raised and</span>
<span class="sd">           the number of points increased to 2.</span>
<span class="sd">        kR : float</span>
<span class="sd">           radius of the k-point. In 1/Ang</span>
<span class="sd">        normal : array_like of float</span>
<span class="sd">           normal vector to determine the circle plane</span>
<span class="sd">        origin : array_like of float</span>
<span class="sd">           origin of the circle used to generate the circular parameterization</span>
<span class="sd">        loop :</span>
<span class="sd">           whether the first and last point are equal</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; lattice = Lattice([1, 1, 10, 90, 90, 60])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.param_circle(lattice, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>

<span class="sd">        To generate a circular set of k-points in reduced coordinates (reciprocal</span>

<span class="sd">        &gt;&gt;&gt; lattice = Lattice([1, 1, 10, 90, 90, 60])</span>
<span class="sd">        &gt;&gt;&gt; bz = BrillouinZone.param_circle(lattice, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>
<span class="sd">        &gt;&gt;&gt; bz_rec = BrillouinZone.param_circle(2*np.pi, 10, 0.05, [0, 0, 1], [1./3, 2./3, 0])</span>
<span class="sd">        &gt;&gt;&gt; bz.k[:, :] = bz_rec.k[:, :]</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        BrillouinZone</span>
<span class="sd">            with the parameterized k-points.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">N_or_dk</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">N</span> <span class="o">=</span> <span class="n">N_or_dk</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Calculate the required number of points</span>
            <span class="n">N</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">kR</span><span class="o">**</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span> <span class="o">/</span> <span class="n">N_or_dk</span> <span class="o">+</span> <span class="mf">0.5</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">N</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="mi">2</span>
                <span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.param_circle increased the number of circle points to 2.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># Conversion object</span>
        <span class="n">bz</span> <span class="o">=</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="n">normal</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
        <span class="n">k_n</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">normal</span><span class="p">)</span>
        <span class="n">k_o</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>

        <span class="c1"># Generate a preset list of k-points on the unit-circle</span>
        <span class="k">if</span> <span class="n">loop</span><span class="p">:</span>
            <span class="n">radians</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">N</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">radians</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">N</span><span class="p">)</span> <span class="o">/</span> <span class="n">N</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">radians</span><span class="p">)</span>
        <span class="n">k</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.0</span>

        <span class="c1"># Now generate the rotation</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">theta</span><span class="p">,</span> <span class="n">phi</span> <span class="o">=</span> <span class="n">cart2spher</span><span class="p">(</span><span class="n">k_n</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">theta</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">pv</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">([</span><span class="n">k_n</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k_n</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">])</span>
            <span class="n">pv</span> <span class="o">/=</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">pv</span><span class="p">)</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">phi</span><span class="p">,</span> <span class="n">pv</span><span class="p">,</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">*</span> <span class="n">Quaternion</span><span class="p">(</span><span class="n">theta</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">q</span> <span class="o">=</span> <span class="n">Quaternion</span><span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">sign</span><span class="p">(</span><span class="n">k_n</span><span class="p">[</span><span class="mi">2</span><span class="p">])],</span> <span class="n">rad</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

        <span class="c1"># Calculate k-points</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">q</span><span class="o">.</span><span class="n">rotate</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">*=</span> <span class="n">kR</span> <span class="o">/</span> <span class="n">fnorm</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">bz</span><span class="o">.</span><span class="n">toreduced</span><span class="p">(</span><span class="n">k</span> <span class="o">+</span> <span class="n">k_o</span><span class="p">)</span>

        <span class="c1"># The sum of weights is equal to the BZ area</span>
        <span class="n">W</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span> <span class="o">*</span> <span class="n">kR</span><span class="o">**</span><span class="mi">2</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">repeat</span><span class="p">([</span><span class="n">W</span> <span class="o">/</span> <span class="n">N</span><span class="p">],</span> <span class="n">N</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">BrillouinZone</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span><span class="p">)</span></div>


    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">k</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A list of all k-points (if available)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">weight</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Weight of the k-points in the `BrillouinZone` object&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">cell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">cell</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">rcell</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">rcell</span>

<div class="viewcode-block" id="BrillouinZone.tocartesian">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.tocartesian">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tocartesian</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transfer a k-point in reduced coordinates to the Cartesian coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k :</span>
<span class="sd">           k-point in reduced coordinates, defaults to this objects k-points.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            in units of 1/Ang</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">rcell</span><span class="p">)</span></div>


<div class="viewcode-block" id="BrillouinZone.toreduced">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.toreduced">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">toreduced</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Transfer a k-point in Cartesian coordinates to the reduced coordinates</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : list of float</span>
<span class="sd">           k-point in Cartesian coordinates</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            in units of reciprocal lattice vectors ]-0.5 ; 0.5] (if k is in the primitive cell)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">dot</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cell</span><span class="o">.</span><span class="n">T</span> <span class="o">/</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">pi</span><span class="p">))</span></div>


<div class="viewcode-block" id="BrillouinZone.in_primitive">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.in_primitive">[docs]</a>
    <span class="nd">@staticmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">:</span> <span class="n">npt</span><span class="o">.</span><span class="n">ArrayLike</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Move the k-point into the primitive point(s) ]-0.5 ; 0.5]</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           k-point(s) to move into the primitive cell</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            all k-points moved into the primitive cell</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="o">%</span> <span class="mf">1.0</span>

        <span class="c1"># Ensure that we are in the interval ]-0.5; 0.5]</span>
        <span class="n">k</span><span class="p">[</span><span class="n">k</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">]</span> <span class="o">-=</span> <span class="mi">1</span>

        <span class="k">return</span> <span class="n">k</span></div>


<div class="viewcode-block" id="BrillouinZone.iter">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BrillouinZone.html#sisl.physics.BrillouinZone.iter">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">iter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ret_weight</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;An iterator for the k-points and (possibly) the weights</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ret_weight : bool, optional</span>
<span class="sd">          if true, also yield the weight for the respective k-point</span>

<span class="sd">        Yields</span>
<span class="sd">        ------</span>
<span class="sd">        kpt : k-point</span>
<span class="sd">        weight : weight of k-point, only if `ret_weight` is true.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">ret_weight</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)):</span>
                <span class="k">yield</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span></div>


    <span class="fm">__iter__</span> <span class="o">=</span> <span class="nb">iter</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">)</span>


<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">MonkhorstPack</span><span class="p">(</span><span class="n">BrillouinZone</span><span class="p">):</span>
<span class="w">    </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a Monkhorst-Pack grid for the Brillouin zone</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated `parent.cell` and `parent.rcell` or</span>
<span class="sd">       an array of floats which may be turned into a `Lattice`</span>
<span class="sd">    nkpt :</span>
<span class="sd">       a list of number of k-points along each cell direction</span>
<span class="sd">    displacement :</span>
<span class="sd">       the displacement of the evenly spaced grid, a single floating</span>
<span class="sd">       number is the displacement for the 3 directions, else they</span>
<span class="sd">       are the individual displacements</span>
<span class="sd">    size :</span>
<span class="sd">       the size of the Brillouin zone sampled. This reduces the boundaries</span>
<span class="sd">       of the Brillouin zone around the displacement to the fraction specified.</span>
<span class="sd">       I.e. `size` must be of values :math:`]0 ; 1]`. Defaults to the entire BZ.</span>
<span class="sd">       Note that this will also reduce the weights such that the weights</span>
<span class="sd">       are normalized to the entire BZ.</span>
<span class="sd">    centered :</span>
<span class="sd">       whether the k-points are :math:`\Gamma`-centered (for zero displacement)</span>
<span class="sd">    trs :</span>
<span class="sd">       whether time-reversal symmetry exists in the Brillouin zone.</span>
<span class="sd">       If ``None``, it will be true for (un)-polarized calculations.</span>
<span class="sd">       For spin configurations higher than or equal to non-collinear, it will</span>
<span class="sd">       be false.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; lattice = Lattice(3.)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(lattice, 10) # 10 x 10 x 10 (with TRS)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(lattice, [10, 5, 5]) # 10 x 5 x 5 (with TRS)</span>
<span class="sd">    &gt;&gt;&gt; MonkhorstPack(lattice, [10, 5, 5], trs=False) # 10 x 5 x 5 (without TRS)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">parent</span><span class="p">,</span>
        <span class="n">nkpt</span><span class="p">:</span> <span class="n">SeqOrScalarInt</span><span class="p">,</span>
        <span class="n">displacement</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SeqOrScalarFloat</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">size</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">SeqOrScalarFloat</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">centered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">trs</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nkpt</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">nkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">([</span><span class="n">nkpt</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">nkpt</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="n">nkpt</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">)</span>

        <span class="c1"># Now we have a matrix of k-points</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">nkpt</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">))</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> with off-diagonal components is not implemented yet&quot;</span>
            <span class="p">)</span>

        <span class="k">if</span> <span class="n">displacement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">displacement</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">displacement</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># transfer the displacement to the primitive cell</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">displacement</span><span class="p">)</span>
        <span class="n">displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">displacement</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">size</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">Real</span><span class="p">):</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">size</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarrayd</span><span class="p">(</span><span class="n">size</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">trs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">trs</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">trs</span> <span class="o">=</span> <span class="n">parent</span><span class="o">.</span><span class="n">spin</span> <span class="o">&lt;=</span> <span class="n">Spin</span><span class="p">(</span><span class="s2">&quot;polarized&quot;</span><span class="p">)</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="k">pass</span>

        <span class="c1"># Retrieve the diagonal number of values</span>
        <span class="n">Dn</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diag</span><span class="p">(</span><span class="n">nkpt</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">Dn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> *must* be initialized with &quot;</span>
                <span class="s2">&quot;diagonal elements different from 0.&quot;</span>
            <span class="p">)</span>

        <span class="n">i_trs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">trs</span><span class="p">:</span>
            <span class="c1"># Figure out which direction to TRS</span>
            <span class="n">nmax</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">displacement</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="ow">in</span> <span class="p">(</span><span class="mf">0.0</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span> <span class="ow">and</span> <span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">nmax</span><span class="p">:</span>
                    <span class="n">nmax</span> <span class="o">=</span> <span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">i_trs</span> <span class="o">=</span> <span class="n">i</span>
            <span class="k">if</span> <span class="n">nmax</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">i_trs</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">if</span> <span class="n">i_trs</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                <span class="c1"># If we still haven&#39;t decided (say for weird displacements)</span>
                <span class="c1"># simply take the one with the maximum number of k-points.</span>
                <span class="n">i_trs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">Dn</span><span class="p">)</span>

        <span class="c1"># Calculate k-points and weights along all directions</span>
        <span class="n">kw</span> <span class="o">=</span> <span class="p">[</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="n">Dn</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">displacement</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">size</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">centered</span><span class="p">,</span> <span class="n">i</span> <span class="o">==</span> <span class="n">i_trs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>
        <span class="p">]</span>

        <span class="c1"># Now figure out if we have a 0 point along the TRS direction</span>
        <span class="k">if</span> <span class="n">trs</span><span class="p">:</span>
            <span class="c1"># Figure out if the first value is zero</span>
            <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">kw</span><span class="p">[</span><span class="n">i_trs</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mf">1e-10</span><span class="p">:</span>
                <span class="c1"># Find indices we want to delete</span>
                <span class="n">ik1</span><span class="p">,</span> <span class="n">ik2</span> <span class="o">=</span> <span class="p">(</span><span class="n">i_trs</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span><span class="p">,</span> <span class="p">(</span><span class="n">i_trs</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">3</span>
                <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="n">k1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span><span class="p">])</span>
                <span class="n">k_dup</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">k1</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
                <span class="n">k_dup</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k2</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
                <span class="c1"># Figure out the duplicate values</span>
                <span class="c1"># To do this we calculate the norm matrix</span>
                <span class="c1"># Note for a 100 x 100 k-point sampling this will produce</span>
                <span class="c1"># a 100 ^ 4 matrix ~ 93 MB</span>
                <span class="c1"># For larger k-point samplings this is probably not so good (300x300 -&gt; 7.5 GB)</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="n">k_dup</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">k1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="n">k_dup</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                    <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">k1</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">k2</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">2</span>
                <span class="p">)</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="p">(</span>
                    <span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span> <span class="o">+</span> <span class="n">k_dup</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span> <span class="o">&lt;</span> <span class="mf">1e-10</span>
                <span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()</span>
                <span class="c1"># At this point we have found all duplicate points, to only take one</span>
                <span class="c1"># half of the points we only take the lower half</span>
                <span class="c1"># Also, the Gamma point is *always* zero, so we shouldn&#39;t do &lt;=!</span>
                <span class="c1"># Now check the case where one of the directions is (only) the Gamma-point</span>
                <span class="k">if</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik1</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># We keep all indices for the ik1 direction (since it is the Gamma-point!</span>
                    <span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">elif</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">kw</span><span class="p">[</span><span class="n">ik2</span><span class="p">][</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mf">0.0</span><span class="p">:</span>
                    <span class="c1"># We keep all indices for the ik2 direction (since it is the Gamma-point!</span>
                    <span class="n">rel</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">rel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">logical_and</span><span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="p">(</span><span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">rel</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">rel</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="n">rel</span><span class="p">],</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">][</span><span class="n">rel</span><span class="p">])</span>
                <span class="k">del</span> <span class="n">rel</span><span class="p">,</span> <span class="n">k1</span><span class="p">,</span> <span class="n">k2</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># To signal we can&#39;t do this</span>
                <span class="n">k_dup</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">((</span><span class="n">kw</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kw</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="n">kw</span><span class="p">[</span><span class="mi">2</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">size</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">onesd</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">kw</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">[</span><span class="o">...</span><span class="p">,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">k</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">*=</span> <span class="n">np</span><span class="o">.</span><span class="n">rollaxis</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span>

        <span class="k">del</span> <span class="n">kw</span>
        <span class="c1"># Now clean up a few of the points</span>
        <span class="k">if</span> <span class="n">trs</span> <span class="ow">and</span> <span class="n">k_dup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Create the correct indices in the ravelled indices</span>
            <span class="n">k</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="mi">3</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span>
            <span class="n">k_del</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik1</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">k</span><span class="p">[</span><span class="n">ik2</span><span class="p">]</span> <span class="o">=</span> <span class="n">k_dup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">k_dup</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="nb">tuple</span><span class="p">(</span><span class="n">k</span><span class="p">),</span> <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="k">del</span> <span class="n">k</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,)</span>

        <span class="k">if</span> <span class="n">trs</span> <span class="ow">and</span> <span class="n">k_dup</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">k_del</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="n">k_dup</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">[</span><span class="n">k_del</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="n">k_del</span><span class="p">)</span>
            <span class="k">del</span> <span class="n">k_dup</span><span class="p">,</span> <span class="n">k_del</span>

        <span class="c1"># Store information regarding size and diagonal elements</span>
        <span class="c1"># This information is basically only necessary when</span>
        <span class="c1"># we want to replace special k-points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span> <span class="o">=</span> <span class="n">Dn</span>  <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span> <span class="o">=</span> <span class="n">displacement</span>  <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">size</span>  <span class="c1"># vector</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span> <span class="o">=</span> <span class="n">centered</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">=</span> <span class="n">i_trs</span>

    <span class="nd">@property</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">displacement</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">np</span><span class="o">.</span><span class="n">ndarray</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Displacement for this Monkhorst-Pack grid&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span>

    <span class="k">def</span><span class="w"> </span><span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;String representation of `MonkhorstPack`&quot;&quot;&quot;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_lattice</span><span class="p">()</span>
        <span class="k">return</span> <span class="p">(</span>
            <span class="s2">&quot;</span><span class="si">{cls}</span><span class="s2">{{nk: </span><span class="si">{nk:d}</span><span class="s2">, size: [</span><span class="si">{size[0]:.5f}</span><span class="s2"> </span><span class="si">{size[1]:.5f}</span><span class="s2"> </span><span class="si">{size[0]:.5f}</span><span class="s2">], trs: </span><span class="si">{trs}</span><span class="s2">,&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> diagonal: [</span><span class="si">{diag[0]:d}</span><span class="s2"> </span><span class="si">{diag[1]:d}</span><span class="s2"> </span><span class="si">{diag[2]:d}</span><span class="s2">], displacement: [</span><span class="si">{disp[0]:.5f}</span><span class="s2"> </span><span class="si">{disp[1]:.5f}</span><span class="s2"> </span><span class="si">{disp[2]:.5f}</span><span class="s2">],&quot;</span>
            <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> </span><span class="si">{lattice}</span><span class="se">\n</span><span class="s2">}}&quot;</span>
        <span class="p">)</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="bp">cls</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span>
            <span class="n">nk</span><span class="o">=</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span>
            <span class="n">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_size</span><span class="p">,</span>
            <span class="n">trs</span><span class="o">=</span><span class="p">{</span><span class="mi">0</span><span class="p">:</span> <span class="s2">&quot;A&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span> <span class="s2">&quot;B&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">:</span> <span class="s2">&quot;C&quot;</span><span class="p">}</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_trs</span><span class="p">,</span> <span class="s2">&quot;no&quot;</span><span class="p">),</span>
            <span class="n">diag</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_diag</span><span class="p">,</span>
            <span class="n">disp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_displ</span><span class="p">,</span>
            <span class="n">lattice</span><span class="o">=</span><span class="nb">str</span><span class="p">(</span><span class="n">p</span><span class="p">)</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span><span class="p">,</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2"> &quot;</span><span class="p">),</span>
        <span class="p">)</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dictionary with the current state&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;diag&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;displ&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;centered&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;trs&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset state of the object&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;diag&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_displ</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;displ&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;size&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_centered</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;centered&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;trs&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="MonkhorstPack.grid">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.MonkhorstPack.html#sisl.physics.MonkhorstPack.grid">[docs]</a>
    <span class="nd">@classmethod</span>
    <span class="k">def</span><span class="w"> </span><span class="nf">grid</span><span class="p">(</span>
        <span class="bp">cls</span><span class="p">,</span>
        <span class="n">n</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span>
        <span class="n">displ</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span>
        <span class="n">size</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1.0</span><span class="p">,</span>
        <span class="n">centered</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="n">trs</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Create a grid of `n` points with an offset of `displ` and sampling `size` around `displ`</span>

<span class="sd">        The :math:`k`-points are :math:`\Gamma` centered.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        n :</span>
<span class="sd">           number of points in the grid. If `trs` is ``True`` this may be smaller than `n`</span>
<span class="sd">        displ :</span>
<span class="sd">           the displacement of the grid</span>
<span class="sd">        size :</span>
<span class="sd">           the total size of the Brillouin zone to sample</span>
<span class="sd">        centered :</span>
<span class="sd">           if the points are centered</span>
<span class="sd">        trs :</span>
<span class="sd">           whether time-reversal-symmetry is applied</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        k : numpy.ndarray</span>
<span class="sd">           the list of k-points in the Brillouin zone to be sampled</span>
<span class="sd">        w : numpy.ndarray</span>
<span class="sd">           weights for the k-points</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First ensure that displ is in the Brillouin</span>
        <span class="n">displ</span> <span class="o">=</span> <span class="n">displ</span> <span class="o">%</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">&gt;</span> <span class="mf">0.5</span><span class="p">:</span>
            <span class="n">displ</span> <span class="o">-=</span> <span class="mf">1.0</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mf">0.5</span><span class="p">:</span>
            <span class="n">displ</span> <span class="o">+=</span> <span class="mf">1.0</span>

        <span class="c1"># Centered _only_ has effect IFF</span>
        <span class="c1">#  displ == 0. and size == 1</span>
        <span class="c1"># Otherwise we resort to other schemes</span>
        <span class="k">if</span> <span class="n">displ</span> <span class="o">!=</span> <span class="mf">0.0</span> <span class="ow">or</span> <span class="n">size</span> <span class="o">!=</span> <span class="mf">1.0</span><span class="p">:</span>
            <span class="n">centered</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="c1"># size *per k-point*</span>
        <span class="n">dsize</span> <span class="o">=</span> <span class="n">size</span> <span class="o">/</span> <span class="n">n</span>

        <span class="c1"># We create the full grid, then afterwards we figure out TRS</span>
        <span class="n">n_half</span> <span class="o">=</span> <span class="n">n</span> <span class="o">//</span> <span class="mi">2</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="o">-</span><span class="n">n_half</span><span class="p">,</span> <span class="n">n_half</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">dsize</span> <span class="o">+</span> <span class="n">displ</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="o">-</span><span class="n">n_half</span><span class="p">,</span> <span class="n">n_half</span><span class="p">)</span> <span class="o">*</span> <span class="n">dsize</span> <span class="o">+</span> <span class="n">displ</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">centered</span><span class="p">:</span>
                <span class="c1"># Shift everything by halve the size each occupies</span>
                <span class="n">k</span> <span class="o">+=</span> <span class="n">dsize</span> <span class="o">/</span> <span class="mi">2</span>

        <span class="c1"># Move k to the primitive cell and generate weights</span>
        <span class="n">k</span> <span class="o">=</span> <span class="bp">cls</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">dsize</span><span class="p">)</span>

        <span class="c1"># Check for TRS points</span>
        <span class="k">if</span> <span class="n">trs</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">k</span> <span class="o">&lt;</span> <span class="mf">0.0</span><span class="p">):</span>
            <span class="c1"># Make all positive to remove the double conting terms</span>
            <span class="n">k_pos</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">fabs</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

            <span class="c1"># Sort k-points and weights</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">k_pos</span><span class="p">)</span>

            <span class="c1"># Re-arange according to k value</span>
            <span class="n">k_pos</span> <span class="o">=</span> <span class="n">k_pos</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="c1"># Find indices of all equivalent k-points (tolerance of 1e-10 in reciprocal units)</span>
            <span class="c1"># Use the dsize to estimate the difference in positions</span>
            <span class="n">idx_same</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">k_pos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">dsize</span> <span class="o">*</span> <span class="mf">1e-3</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>

            <span class="c1"># The above algorithm should never create more than two duplicates.</span>
            <span class="c1"># Hence we can simply remove all idx_same and double the weight for all</span>
            <span class="c1"># idx_same + 1.</span>
            <span class="n">w</span><span class="p">[</span><span class="n">idx_same</span> <span class="o">+</span> <span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span>
            <span class="c1"># Delete the duplicated k-points (they are already sorted)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">k_pos</span><span class="p">,</span> <span class="n">idx_same</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="n">w</span><span class="p">,</span> <span class="n">idx_same</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Sort them, because it makes more visual sense</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">argsort</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>
            <span class="n">k</span> <span class="o">=</span> <span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
            <span class="n">w</span> <span class="o">=</span> <span class="n">w</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>

        <span class="c1"># Return values</span>
        <span class="k">return</span> <span class="n">k</span><span class="p">,</span> <span class="n">w</span></div>


<div class="viewcode-block" id="MonkhorstPack.replace">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.MonkhorstPack.html#sisl.physics.MonkhorstPack.replace">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">replace</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">k</span><span class="p">:</span> <span class="n">KPoint</span><span class="p">,</span>
        <span class="n">mp</span><span class="p">:</span> <span class="n">MonkhorstPack</span><span class="p">,</span>
        <span class="n">displacement</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">SeqOrScalarFloat</span><span class="p">,</span> <span class="nb">bool</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">as_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">check_vol</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
    <span class="p">):</span>
<span class="w">        </span><span class="sa">r</span><span class="sd">&quot;&quot;&quot;Replace a k-point with a new set of k-points from a Monkhorst-Pack grid</span>

<span class="sd">        This method tries to replace an area corresponding to `mp.size` around the k-point `k`</span>
<span class="sd">        such that the k-points are replaced.</span>
<span class="sd">        This enables one to zoom in on specific points in the Brillouin zone for detailed analysis.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           k-point in this object to replace, if `as_index` is true, it will be regarded as integer</span>
<span class="sd">           positions of the k-points to replace, otherwise the indices of the k-points will be located</span>
<span class="sd">           individually (in chunks of 200 MB).</span>
<span class="sd">        mp : MonkhorstPack</span>
<span class="sd">           object containing the replacement k-points.</span>
<span class="sd">        displacement : array_like or bool, optional</span>
<span class="sd">           the displacment of the `mp` k-points. Needed for doing *lots* of replacements due to efficiency.</span>
<span class="sd">           Defaults to not displace anything. The inserted k-points will be `mp.k + displacement`.</span>
<span class="sd">           If True, it will use `k` as the displacement vector. For multiple k-point replacements</span>
<span class="sd">           each k-point will be replaced my `mp` with k as the displacement.</span>
<span class="sd">        as_index :</span>
<span class="sd">           whether `k` is input as reciprocal k-points, or as indices of k-points in this object.</span>
<span class="sd">        check_vol :</span>
<span class="sd">           whether to check the volume of the replaced k-point(s); by default the volume of each k-point</span>
<span class="sd">           is determined by the original ``size`` and ``nkpt`` values. However, when doing</span>
<span class="sd">           replacements of k-points these values are not kept for the individual k-points</span>
<span class="sd">           that were replaced, so subsequent replacements of these points will cause errors that</span>
<span class="sd">           effectively are not valid.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 3x3x3 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; lattice = Lattice(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(lattice, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(lattice, [3, 3, 3], size=1./3))</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 4x4x4 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; lattice = Lattice(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(lattice, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(lattice, [4, 4, 4], size=1./3))</span>

<span class="sd">        This example creates a zoomed-in view of the :math:`\Gamma`-point by replacing it with</span>
<span class="sd">        a 4x4x1 Monkhorst-Pack grid.</span>

<span class="sd">        &gt;&gt;&gt; lattice = Lattice(1.)</span>
<span class="sd">        &gt;&gt;&gt; mp = MonkhorstPack(lattice, [3, 3, 3])</span>
<span class="sd">        &gt;&gt;&gt; mp.replace([0, 0, 0], MonkhorstPack(lattice, [4, 4, 1], size=1./3))</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        SislError</span>
<span class="sd">            if the size of the replacement `MonkhorstPack` grid is not compatible with the k-point spacing in this object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># First we find all k-points within k +- mp.size</span>
        <span class="c1"># Those are the points we wish to remove.</span>
        <span class="c1"># Secondly we need to ensure that the k-points we remove are occupying *exactly*</span>
        <span class="c1"># the Brillouin zone we wish to replace.</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">mp</span><span class="p">,</span> <span class="n">MonkhorstPack</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Object &#39;mp&#39; is not a MonkhorstPack object&quot;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">check_vol</span><span class="p">:</span>
            <span class="c1"># We can easily figure out the BZ that each k-point is averaging</span>
            <span class="n">k_vol</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">_diag</span>

            <span class="c1"># Compare against the size of this one</span>
            <span class="c1"># Since we can remove more than one k-point, we require that the</span>
            <span class="c1"># size of the replacement MP is an integer multiple of the</span>
            <span class="c1"># k-point volumes.</span>
            <span class="n">k_int</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="n">k_vol</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">np</span><span class="o">.</span><span class="n">allclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">k_int</span><span class="p">),</span> <span class="n">k_int</span><span class="p">):</span>
                <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.reduce could not replace k-point, BZ &quot;</span>
                    <span class="s2">&quot;volume replaced is not equivalent to the inherent k-point volume.&quot;</span>
                <span class="p">)</span>

        <span class="c1"># the size of the k-points that will be added</span>
        <span class="n">s_size2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">mp_size2</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">_size</span> <span class="o">/</span> <span class="mi">2</span>
        <span class="n">dk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">mp_size2</span> <span class="o">&lt;</span> <span class="n">s_size2</span><span class="p">,</span> <span class="n">mp_size2</span><span class="p">,</span> <span class="n">s_size2</span><span class="p">)</span>
        <span class="n">dk</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># determine indices of k-point inputs</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">as_index</span><span class="p">:</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">k</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># find k-points in batches of 200 MB</span>
            <span class="n">k</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">batched_indices</span><span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">dk</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">diff_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span>
            <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">&gt;=</span> <span class="mi">0</span>
            <span class="p">):</span>  <span class="c1"># TRS along a given axis, we can search the mirrored values</span>
                <span class="n">idx2</span> <span class="o">=</span> <span class="n">batched_indices</span><span class="p">(</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">,</span> <span class="o">-</span><span class="n">k</span><span class="p">,</span> <span class="n">atol</span><span class="o">=</span><span class="n">dk</span><span class="p">,</span> <span class="n">batch_size</span><span class="o">=</span><span class="mi">200</span><span class="p">,</span> <span class="n">diff_func</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span>
                <span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">idx</span><span class="p">,</span> <span class="n">idx2</span><span class="p">))</span>
                <span class="c1"># we may find 2 indices for gamm-point in this case... not useful</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.reduce found no k-points to replace. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Searched with precision: </span><span class="si">{</span><span class="n">dk</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Idea of fast replacements is attributed @ahkole in #454, but the resulting code needed some</span>
        <span class="c1"># changes since that code was not stable againts *wrong input*, i.e. k=[0, 0, 0]</span>
        <span class="c1"># replacements.</span>

        <span class="c1"># determine the displacement vector</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">displacement</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">displacement</span><span class="p">:</span>
                <span class="n">displacement</span> <span class="o">=</span> <span class="n">k</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">displacement</span> <span class="o">=</span> <span class="kc">None</span>

        <span class="k">elif</span> <span class="n">displacement</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># convert to array</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">displacement</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">displacement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">displ_nk</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># Ensure we are in the central k-grid</span>
            <span class="n">displacement</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">displacement</span><span class="p">)</span>
            <span class="n">displ_nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">displacement</span><span class="p">)</span>

        <span class="c1"># Now we have the k-points we need to remove</span>
        <span class="c1"># Figure out if the total weight is consistent</span>
        <span class="n">total_weight</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
        <span class="n">replace_weight</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">weight</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">*</span> <span class="n">displ_nk</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">total_weight</span><span class="p">,</span> <span class="n">replace_weight</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1e-4</span>
        <span class="k">if</span> <span class="nb">abs</span><span class="p">(</span><span class="n">total_weight</span> <span class="o">-</span> <span class="n">replace_weight</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">:</span>
            <span class="n">weight_factor</span> <span class="o">=</span> <span class="mf">1.0</span>
        <span class="k">elif</span> <span class="nb">abs</span><span class="p">(</span><span class="n">total_weight</span> <span class="o">-</span> <span class="n">replace_weight</span> <span class="o">*</span> <span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">atol</span><span class="p">:</span>
            <span class="n">weight_factor</span> <span class="o">=</span> <span class="mf">2.0</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_trs</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">info</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.reduce assumes that the replaced k-point has double weights.&quot;</span>
                <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># print(&quot;k-point to replace: &quot;, k.ravel())</span>
            <span class="c1"># print(&quot;delta-k: &quot;, dk.ravel())</span>
            <span class="c1"># print(&quot;Found k-indices that will be replaced:&quot;)</span>
            <span class="c1"># print(idx)</span>
            <span class="c1"># print(&quot;k-points replaced:&quot;)</span>
            <span class="c1"># print(self.k[idx, :])</span>
            <span class="c1"># print(&quot;weights replaced:&quot;)</span>
            <span class="c1"># print(self.weight[idx])</span>
            <span class="c1"># print(self.weight.min(), self.weight.max())</span>
            <span class="c1"># print(mp.weight.min(), mp.weight.max())</span>
            <span class="c1"># print(&quot;Summed weights vs. replaced summed weights: &quot;)</span>
            <span class="c1"># print(total_weight, replace_weight)</span>
            <span class="c1"># print(mp)</span>
            <span class="k">raise</span> <span class="n">SislError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.reduce found inconsistent replacement weights &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;self=</span><span class="si">{</span><span class="n">total_weight</span><span class="si">}</span><span class="s2"> vs. mp=</span><span class="si">{</span><span class="n">replace_weight</span><span class="si">}</span><span class="s2">. &quot;</span>
                <span class="sa">f</span><span class="s2">&quot;Replacement indices: </span><span class="si">{</span><span class="n">idx</span><span class="si">}</span><span class="s2">.&quot;</span>
            <span class="p">)</span>

        <span class="c1"># delete and append new k-points and weights</span>
        <span class="k">if</span> <span class="n">displacement</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span> <span class="n">mp</span><span class="o">.</span><span class="n">_k</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
                <span class="p">(</span>
                    <span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_k</span><span class="p">,</span> <span class="n">idx</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">),</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">in_primitive</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">k</span> <span class="o">+</span> <span class="n">displacement</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">))</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
                        <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
                    <span class="p">),</span>
                <span class="p">),</span>
                <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span>
            <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">(</span>
            <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">delete</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_w</span><span class="p">,</span> <span class="n">idx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">tile</span><span class="p">(</span><span class="n">mp</span><span class="o">.</span><span class="n">_w</span> <span class="o">*</span> <span class="n">weight_factor</span><span class="p">,</span> <span class="n">displ_nk</span><span class="p">))</span>
        <span class="p">)</span></div>



<span class="nd">@set_module</span><span class="p">(</span><span class="s2">&quot;sisl.physics&quot;</span><span class="p">)</span>
<span class="k">class</span><span class="w"> </span><span class="nc">BandStructure</span><span class="p">(</span><span class="n">BrillouinZone</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;Create a path in the Brillouin zone for plotting band-structures etc.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    parent : object or array_like</span>
<span class="sd">       An object with associated `parent.cell` and `parent.rcell` or</span>
<span class="sd">       an array of floats which may be turned into a `Lattice`</span>
<span class="sd">    points : array_like of float</span>
<span class="sd">       a list of points that are the *corners* of the path.</span>
<span class="sd">       Define a discontinuity in the points by adding a `None` in the list.</span>
<span class="sd">    divisions : int or array_like of int</span>
<span class="sd">       number of divisions in each segment.</span>
<span class="sd">       If a single integer is passed it is the total number</span>
<span class="sd">       of points on the path (equally separated).</span>
<span class="sd">       If it is an array_like input it must have length one</span>
<span class="sd">       less than `point`, in this case the total number of points</span>
<span class="sd">       will be ``sum(divisions) + 1`` due to the end-point constraint.</span>
<span class="sd">    names : array_like of str</span>
<span class="sd">       the associated names of the points on the Brillouin Zone path</span>
<span class="sd">    jump_dk: float or array_like, optional</span>
<span class="sd">       Percentage of ``self.lineark()[-1]`` that is used as separation between discontinued</span>
<span class="sd">       jumps in the band-structure.</span>
<span class="sd">       For band-structures with disconnected jumps the `lineark` and `lineartick` methods</span>
<span class="sd">       returns a separation between the disconnected points according to this percentage.</span>
<span class="sd">       Default value is 5% of the total distance. Alternatively an array equal to the</span>
<span class="sd">       number of discontinuity jumps may be passed for individual percentages.</span>
<span class="sd">       Keyword only, argument.</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; lattice = Lattice(10)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(lattice, [[0] * 3, [0.5] * 3], 200)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(lattice, [[0] * 3, [0.5] * 3, [1.] * 3], 200)</span>
<span class="sd">    &gt;&gt;&gt; bs = BandStructure(lattice, [[0] * 3, [0.5] * 3, [1.] * 3], 200, [&#39;Gamma&#39;, &#39;M&#39;, &#39;Gamma&#39;])</span>

<span class="sd">    A disconnected band structure may be created by having None as the element.</span>
<span class="sd">    Note that the number of names does not contain the empty points (they are simply removed).</span>
<span class="sd">    Such a band-structure may be useful when one is interested in a discontinuous band structure.</span>

<span class="sd">    &gt;&gt;&gt; bs = BandStructure(lattice, [[0, 0, 0], [0, 0.5, 0], None, [0.5, 0, 0], [0.5, 0.5, 0]], 200)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="nd">@deprecate_argument</span><span class="p">(</span>
        <span class="s2">&quot;name&quot;</span><span class="p">,</span>
        <span class="s2">&quot;names&quot;</span><span class="p">,</span>
        <span class="s2">&quot;argument &#39;name&#39; has been deprecated in favor of &#39;names&#39;, please update your code.&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.15&quot;</span><span class="p">,</span>
        <span class="s2">&quot;0.17&quot;</span><span class="p">,</span>
    <span class="p">)</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parent</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="c1"># points, divisions, names=None):</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">parent</span><span class="p">)</span>
        <span class="n">lattice</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parent_lattice</span><span class="p">()</span>

        <span class="n">points</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;points&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">points</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">points</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &#39;points&#39; argument missing&quot;</span><span class="p">)</span>

        <span class="c1"># Extract the jump indices</span>
        <span class="c1"># In that case it is a disconnected path</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">is_empty</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span>
            <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">p</span> <span class="ow">is</span> <span class="kc">None</span>

        <span class="n">jump_idx</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_points</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">p</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">points</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">is_empty</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="c1"># we can&#39;t have a jump at the first index</span>
                    <span class="n">jump_idx</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">_points</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lattice</span><span class="o">.</span><span class="n">_fill</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">))</span>

        <span class="c1"># convert to exact array and correct for removed indices</span>
        <span class="n">jump_idx</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">jump_idx</span><span class="p">)</span> <span class="o">-</span> <span class="n">_a</span><span class="o">.</span><span class="n">arangei</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">jump_idx</span><span class="p">))</span>

        <span class="c1"># fill with correct points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayd</span><span class="p">(</span><span class="n">_points</span><span class="p">)</span>
        <span class="k">del</span> <span class="n">_points</span>  <span class="c1"># clean-up for clarity</span>

        <span class="n">divisions</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;divisions&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">divisions</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">divisions</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> &#39;divisions&#39; argument missing&quot;</span>
                <span class="p">)</span>

        <span class="n">names</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;names&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">names</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span> <span class="o">=</span> <span class="n">args</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> unknown arguments after parsing &#39;points&#39;, &#39;divisions&#39; and &#39;names&#39;: </span><span class="si">{</span><span class="n">args</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Store empty split size</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="s2">&quot;jump_dk&quot;</span><span class="p">,</span> <span class="mf">0.05</span><span class="p">))</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> unknown keyword arguments after parsing [points, divisions, names, jump_dk]: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="p">)</span>

        <span class="c1"># remove erroneous jumps</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span> <span class="ow">in</span> <span class="n">jump_idx</span><span class="p">:</span>
            <span class="n">jump_idx</span> <span class="o">=</span> <span class="n">jump_idx</span><span class="p">[:</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span><span class="o">.</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="ow">and</span> <span class="n">jump_idx</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2"> got inconsistent argument lengths (jump_dk does not match jumps in points)&quot;</span>
            <span class="p">)</span>

        <span class="c1"># The jump-idx is equal to using np.split(self.points, jump_idx)</span>
        <span class="c1"># which then returns continuous sections</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span> <span class="o">=</span> <span class="n">jump_idx</span>

        <span class="c1"># If the array has fewer points we try and determine</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nsc</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Could not determine the non-periodic direction&quot;</span><span class="p">)</span>

            <span class="c1"># fix the points where there are no periodicity</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">):</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">parent</span><span class="o">.</span><span class="n">nsc</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

        <span class="c1"># Ensure the shape is correct</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

        <span class="c1"># Now figure out what to do with the divisions</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">divisions</span><span class="p">,</span> <span class="n">Integral</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">divisions</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;Can not evenly split </span><span class="si">{</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)</span><span class="si">}</span><span class="s2"> points into </span><span class="si">{</span><span class="n">divisions</span><span class="si">}</span><span class="s2"> divisions, ensure division&gt;=len(points)&quot;</span>
                <span class="p">)</span>

            <span class="c1"># Get length between different k-points with a total length</span>
            <span class="c1"># of division</span>
            <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span>
                <span class="n">linspace_bz</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="n">jumps</span><span class="o">=</span><span class="n">jump_idx</span><span class="p">,</span> <span class="n">jump_dk</span><span class="o">=</span><span class="mf">0.0</span><span class="p">)</span>
            <span class="p">)</span>

            <span class="c1"># Get floating point divisions</span>
            <span class="n">divs_r</span> <span class="o">=</span> <span class="n">dists</span> <span class="o">*</span> <span class="n">divisions</span> <span class="o">/</span> <span class="n">dists</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="c1"># Convert to integers</span>
            <span class="n">divs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">rint</span><span class="p">(</span><span class="n">divs_r</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">int32</span><span class="p">)</span>
            <span class="c1"># ensure at least 1 point along each division</span>
            <span class="c1"># 1 division means only the starting point</span>
            <span class="n">divs</span><span class="p">[</span><span class="n">divs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">divs</span><span class="p">[</span><span class="n">jump_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">divs_sum</span> <span class="o">=</span> <span class="n">divs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>
            <span class="k">while</span> <span class="n">divs_sum</span> <span class="o">!=</span> <span class="n">divisions</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                <span class="c1"># only check indices where divs &gt; 1</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">divs</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">nonzero</span><span class="p">()[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">dk</span> <span class="o">=</span> <span class="n">dists</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">/</span> <span class="n">divs</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">divs_sum</span> <span class="o">&gt;=</span> <span class="n">divisions</span><span class="p">:</span>
                    <span class="n">divs</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dk</span><span class="p">)]]</span> <span class="o">-=</span> <span class="mi">1</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">divs</span><span class="p">[</span><span class="n">idx</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">dk</span><span class="p">)]]</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="n">divs_sum</span> <span class="o">=</span> <span class="n">divs</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span>

            <span class="n">divisions</span> <span class="o">=</span> <span class="n">divs</span><span class="p">[:]</span>

        <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;inconsistent number of elements in &#39;points&#39; and &#39;divisions&#39; argument. One less &#39;divisions&#39; elements.&quot;</span>
            <span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">arrayi</span><span class="p">(</span><span class="n">divisions</span><span class="p">)</span><span class="o">.</span><span class="n">ravel</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">names</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="s2">&quot;ABCDEFGHIJKLMNOPQRSTUVXYZ&quot;</span><span class="p">[:</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">)]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">names</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span>
                <span class="sa">f</span><span class="s2">&quot;inconsistent number of elements in &#39;points&#39; and &#39;names&#39; argument&quot;</span>
            <span class="p">)</span>

        <span class="c1"># Calculate points</span>
        <span class="n">dpoint</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">k</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">emptyd</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">])</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ik</span><span class="p">,</span> <span class="p">(</span><span class="n">divs</span><span class="p">,</span> <span class="n">dk</span><span class="p">)</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">,</span> <span class="n">dpoint</span><span class="p">)):</span>
            <span class="n">k</span><span class="p">[</span><span class="n">i</span> <span class="p">:</span> <span class="n">i</span> <span class="o">+</span> <span class="n">divs</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="p">(</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="n">ik</span><span class="p">]</span> <span class="o">+</span> <span class="n">dk</span> <span class="o">*</span> <span class="n">_a</span><span class="o">.</span><span class="n">aranged</span><span class="p">(</span><span class="n">divs</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="n">divs</span>
            <span class="p">)</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="n">divs</span>
        <span class="n">k</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># sanity check that should always be obeyed</span>
        <span class="k">assert</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">k</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_k</span> <span class="o">=</span> <span class="n">k</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_w</span> <span class="o">=</span> <span class="n">_a</span><span class="o">.</span><span class="n">fulld</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">),</span> <span class="mi">1</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">))</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__getstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return dictionary with the current state&quot;&quot;&quot;</span>
        <span class="n">state</span> <span class="o">=</span> <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__getstate__</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;divisions&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;jump_idx&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">)</span>
        <span class="n">state</span><span class="p">[</span><span class="s2">&quot;jump_dk&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span>
        <span class="k">return</span> <span class="n">state</span>

    <span class="k">def</span><span class="w"> </span><span class="nf">__setstate__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Reset state of the object&quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="n">__setstate__</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">points</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;points&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">divisions</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;divisions&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">names</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;names&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;jump_dk&quot;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span> <span class="o">=</span> <span class="n">state</span><span class="p">[</span><span class="s2">&quot;jump_idx&quot;</span><span class="p">]</span>

<div class="viewcode-block" id="BandStructure.insert_jump">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.insert_jump">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">insert_jump</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">arrays</span><span class="p">,</span> <span class="n">value</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Return a copy of `arrays` filled with `value` at indices of discontinuity jumps</span>

<span class="sd">        Arrays with `value` in jumps is easier to plot since those lines will be naturally discontinued.</span>
<span class="sd">        For band structures without discontinuity jumps in the Brillouin zone the `arrays` will</span>
<span class="sd">        be return as is.</span>

<span class="sd">        It will insert `value` along the first dimension matching the length of `self`.</span>
<span class="sd">        For each discontinuity jump an element will be inserted.</span>

<span class="sd">        This may be useful for plotting since `np.nan` gets interpreted as a discontinuity</span>
<span class="sd">        in the graph thus removing connections between the segments.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *arrays : array_like</span>
<span class="sd">           arrays will get `value` inserted where there are jumps in the band structure</span>
<span class="sd">        value : optional</span>
<span class="sd">           the value to be inserted at the jump points in the data array</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        Create a bandstructure with a discontinuity.</span>

<span class="sd">        &gt;&gt;&gt; gr = geom.graphene()</span>
<span class="sd">        &gt;&gt;&gt; bs = BandStructure(gr, [[0, 0, 0], [0.5, 0, 0], None, [0, 0, 0], [0, 0.5, 0]], 4)</span>
<span class="sd">        &gt;&gt;&gt; data = np.zeros([len(bs), 10])</span>
<span class="sd">        &gt;&gt;&gt; data_with_jump = bs.insert_jump(data)</span>
<span class="sd">        &gt;&gt;&gt; assert data_with_jump.shape == (len(bs)+1, 10)</span>
<span class="sd">        &gt;&gt;&gt; np.all(data_with_jump[2] == np.nan)</span>
<span class="sd">        True</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># quick return if nothing needs changed</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">return</span> <span class="n">arrays</span>

        <span class="n">nk</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="n">full_jumps</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">)[</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>

        <span class="k">def</span><span class="w"> </span><span class="nf">_insert</span><span class="p">(</span><span class="n">array</span><span class="p">):</span>
            <span class="n">array</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">asarray</span><span class="p">(</span><span class="n">array</span><span class="p">)</span>
            <span class="c1"># ensure dtype is equivalent as input array</span>
            <span class="n">nans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">full_jumps</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">array</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">nans</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
            <span class="n">axis</span> <span class="o">=</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
            <span class="n">shape</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="mi">1</span> <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="n">array</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
            <span class="n">shape</span><span class="p">[</span><span class="n">axis</span><span class="p">]</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
            <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">full_jumps</span><span class="p">,</span> <span class="n">nans</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">shape</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>

        <span class="c1"># convert all</span>
        <span class="n">arrays</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">_insert</span><span class="p">(</span><span class="n">array</span><span class="p">)</span> <span class="k">for</span> <span class="n">array</span> <span class="ow">in</span> <span class="n">arrays</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">arrays</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">arrays</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">arrays</span></div>


<div class="viewcode-block" id="BandStructure.lineartick">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.lineartick">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lineartick</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;The tick-marks corresponding to the linear-k values</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        numpy.ndarray</span>
<span class="sd">            the positions in reciprocal space determined by the distance between points</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        lineark : Routine used to calculate the tick-marks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineark</span><span class="p">(</span><span class="kc">True</span><span class="p">)[</span><span class="mi">1</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span></div>


<div class="viewcode-block" id="BandStructure.tolinear">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.tolinear">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">tolinear</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">ret_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">atol</span><span class="p">:</span> <span class="nb">float</span> <span class="o">=</span> <span class="mf">1e-4</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;Convert a k-point into the equivalent linear k-point via the distance</span>

<span class="sd">        Finds the index of the k-point in `self.k` that is closests to `k`.</span>
<span class="sd">        The returned value is then the equivalent index in `lineark`.</span>

<span class="sd">        This is very useful for extracting certain points along the band structure.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        k : array_like</span>
<span class="sd">           the k-point(s) to locate in the linear values</span>
<span class="sd">        ret_index :</span>
<span class="sd">           whether the indices are also returned</span>
<span class="sd">        atol :</span>
<span class="sd">           when the found k-point has a distance (in Cartesian coordinates)</span>
<span class="sd">           is differing by more than `tol` a warning will be issued.</span>
<span class="sd">           The tolerance is in units 1/Ang.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Faster than to do sqrt all the time</span>
        <span class="n">atol</span> <span class="o">=</span> <span class="n">atol</span><span class="o">**</span><span class="mi">2</span>
        <span class="c1"># first convert to the cartesian coordinates (for proper distances)</span>
        <span class="n">ks</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">atleast_2d</span><span class="p">(</span><span class="n">k</span><span class="p">))</span>
        <span class="n">kk</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tocartesian</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">k</span><span class="p">)</span>

        <span class="c1"># find closest values</span>
        <span class="k">def</span><span class="w"> </span><span class="nf">find</span><span class="p">(</span><span class="n">k</span><span class="p">):</span>
            <span class="n">dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">kk</span> <span class="o">-</span> <span class="n">k</span><span class="p">)</span> <span class="o">**</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dist</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">dist</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">atol</span><span class="p">:</span>
                <span class="n">warn</span><span class="p">(</span>
                    <span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="si">}</span><span class="s2">.tolinear could not find a k-point within given tolerance (</span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">toreduced</span><span class="p">(</span><span class="n">k</span><span class="p">)</span><span class="si">}</span><span class="s2">)&quot;</span>
                <span class="p">)</span>
            <span class="k">return</span> <span class="n">idx</span>

        <span class="n">idxs</span> <span class="o">=</span> <span class="p">[</span><span class="n">find</span><span class="p">(</span><span class="n">k</span><span class="p">)</span> <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">ks</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ret_index</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineark</span><span class="p">()[</span><span class="n">idxs</span><span class="p">],</span> <span class="n">idxs</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">lineark</span><span class="p">()[</span><span class="n">idxs</span><span class="p">]</span></div>


<div class="viewcode-block" id="BandStructure.lineark">
<a class="viewcode-back" href="../../../api/generated/sisl.physics.BandStructure.html#sisl.physics.BandStructure.lineark">[docs]</a>
    <span class="k">def</span><span class="w"> </span><span class="nf">lineark</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ticks</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
<span class="w">        </span><span class="sd">&quot;&quot;&quot;A 1D array which corresponds to the delta-k values of the path</span>

<span class="sd">        This is mainly meant for plotting but may be useful for finding out</span>
<span class="sd">        distances in the reciprocal lattice.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>

<span class="sd">        &gt;&gt;&gt; p = BandStructure(...)</span>
<span class="sd">        &gt;&gt;&gt; eigs = Hamiltonian.eigh(p)</span>
<span class="sd">        &gt;&gt;&gt; for i in range(len(Hamiltonian)):</span>
<span class="sd">        ...     plt.plot(p.lineark(), eigs[:, i])</span>

<span class="sd">        &gt;&gt;&gt; p = BandStructure(...)</span>
<span class="sd">        &gt;&gt;&gt; eigs = Hamiltonian.eigh(p)</span>
<span class="sd">        &gt;&gt;&gt; lk, kt, kl = p.lineark(True)</span>
<span class="sd">        &gt;&gt;&gt; plt.xticks(kt, kl)</span>
<span class="sd">        &gt;&gt;&gt; for i in range(len(Hamiltonian)):</span>
<span class="sd">        ...     plt.plot(lk, eigs[:, i])</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        ticks :</span>
<span class="sd">           if `True` the ticks for the points are also returned</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        linspace_bz : converts k-points into a linear distance parameterization</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        linear_k : numpy.ndarray</span>
<span class="sd">            the positions in reciprocal space determined by the distance between points</span>
<span class="sd">        ticks : numpy.ndarray</span>
<span class="sd">            linear k-positions of the points, only returned if `ticks` is ``True``</span>
<span class="sd">        ticklabels : list of str</span>
<span class="sd">            labels at `ticks`, only returned if `ticks` is ``True``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">cum_divs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">divisions</span><span class="p">)</span>
        <span class="c1"># Calculate points</span>
        <span class="c1"># First we also need to calculate the jumps</span>
        <span class="n">dK</span> <span class="o">=</span> <span class="n">linspace_bz</span><span class="p">(</span>
            <span class="bp">self</span><span class="p">,</span> <span class="n">jumps</span><span class="o">=</span><span class="n">cum_divs</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_idx</span> <span class="o">-</span> <span class="mi">1</span><span class="p">],</span> <span class="n">jump_dk</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_jump_dk</span>
        <span class="p">)</span>

        <span class="c1"># Get label tick, in case self.names is a single string &#39;ABCD&#39;</span>
        <span class="k">if</span> <span class="n">ticks</span><span class="p">:</span>
            <span class="c1"># Get number of points</span>
            <span class="n">xtick</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">points</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>
            <span class="n">xtick</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span> <span class="o">=</span> <span class="n">cum_divs</span>
            <span class="c1"># Ensure the returned label_tick is a copy</span>
            <span class="k">return</span> <span class="n">dK</span><span class="p">,</span> <span class="n">dK</span><span class="p">[</span><span class="n">xtick</span><span class="p">],</span> <span class="p">[</span><span class="n">a</span> <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">names</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">dK</span></div>

</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>