

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>sisl_toolbox.btd.DeviceGreen &mdash; sisl</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=e59714d7" />
      <link rel="stylesheet" type="text/css" href="../../../_static/togglebutton.css?v=13237357" />
      <link rel="stylesheet" type="text/css" href="../../../_static/copybutton.css?v=76b2166b" />
      <link rel="stylesheet" type="text/css" href="../../../_static/tabs.css?v=4c969af8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/plot_directive.css" />
      <link rel="stylesheet" type="text/css" href="../../../_static/graphviz.css?v=fd3f3429" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sg_gallery.css?v=d2d258e8" />
      <link rel="stylesheet" type="text/css" href="../../../_static/sphinx-design.min.css?v=95c83b7e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom_styles.css?v=cafe85c1" />
      <link rel="stylesheet" type="text/css" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" />

  
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=7b70f75b"></script>
      <script src="../../../_static/doctools.js?v=9a2dae69"></script>
      <script src="../../../_static/sphinx_highlight.js?v=dc90522c"></script>
      <script src="../../../_static/clipboard.min.js?v=a7894cd8"></script>
      <script src="../../../_static/copybutton.js?v=7800a641"></script>
      <script src="../../../_static/tabs.js?v=3ee01567"></script>
      <script>let toggleHintShow = 'Click to show';</script>
      <script>let toggleHintHide = 'Click to hide';</script>
      <script>let toggleOpenOnPrint = 'true';</script>
      <script src="../../../_static/togglebutton.js?v=4a39c7ea"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script src="../../../_static/design-tabs.js?v=f930bc37"></script>
      <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
      <script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@^1.0.1/dist/embed-amd.js"></script>
      <script>var togglebuttonSelector = '.toggle, .admonition.dropdown';</script>
      <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
      <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Contributing to sisl" href="../../../dev/index.html" />
    <link rel="prev" title="sisl_toolbox.btd.DownfoldSelfEnergy" href="sisl_toolbox.btd.DownfoldSelfEnergy.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            sisl
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Getting started</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../cite.html">Citing sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Guide</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../tutorials/index.html">Tutorials</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../visualization/index.html">Visualization (<code class="xref py py-obj docutils literal notranslate"><span class="pre">sisl.viz</span></code>)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../scripts/index.html">Command line scripts</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Advanced usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../api/index.html">API reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../environment.html">Environment variables</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../index.html">Toolboxes</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../transiesta/ts_fft.html">TranSiesta Hartree correction for FFT Poisson solver</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../siesta/atom_plot.html">Plotting <em class="xref py py-obj">atom</em> output</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../btd.html">Block-tri-diagonal inversion algorithms</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="sisl_toolbox.btd.BlockMatrix.html">sisl_toolbox.btd.BlockMatrix</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl_toolbox.btd.BlockMatrixIndexer.html">sisl_toolbox.btd.BlockMatrixIndexer</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl_toolbox.btd.PivotSelfEnergy.html">sisl_toolbox.btd.PivotSelfEnergy</a></li>
<li class="toctree-l3"><a class="reference internal" href="sisl_toolbox.btd.DownfoldSelfEnergy.html">sisl_toolbox.btd.DownfoldSelfEnergy</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">sisl_toolbox.btd.DeviceGreen</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen"><code class="docutils literal notranslate"><span class="pre">DeviceGreen</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Development</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../dev/index.html">Contributing to sisl</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Extras</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../math.html">Mathematical notation convention</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../release.html">Release Notes</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../other.html">Related software</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../references.html">Bibliography</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">sisl</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../index.html">Toolboxes</a></li>
          <li class="breadcrumb-item"><a href="../btd.html">Block-tri-diagonal inversion algorithms</a></li>
      <li class="breadcrumb-item active">sisl_toolbox.btd.DeviceGreen</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../../../_sources/toolbox/btd/generated/sisl_toolbox.btd.DeviceGreen.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="sisl-toolbox-btd-devicegreen">
<h1>sisl_toolbox.btd.DeviceGreen<a class="headerlink" href="#sisl-toolbox-btd-devicegreen" title="Link to this heading"></a></h1>
<dl class="py class">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">sisl_toolbox.btd.</span></span><span class="sig-name descname"><span class="pre">DeviceGreen</span></span><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen" title="Link to this definition"></a></dt>
<dd><p>Bases: <a class="reference external" href="https://docs.python.org/3/library/functions.html#object" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></a></p>
<p>Block-tri-diagonal Green function calculator</p>
<p>This class enables the extraction and calculation of some important
quantities not currently accessible in TBtrans.</p>
<p>For instance it may be used to calculate scattering states from
the Green function.
Once scattering states have been calculated one may also calculate
the eigenchannels.</p>
<p>Both calculations are very efficient and uses very little memory
compared to the full matrices normally used.</p>
<p>Consider a regular 2 electrode setup with transport direction
along the 3rd lattice vector. Then the following example may
be used to calculate the eigen-channels.</p>
<p>The below short-form of reading all variables should cover most variables
encountered in the FDF file.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">G</span> <span class="o">=</span> <span class="n">DeviceGreen</span><span class="o">.</span><span class="n">from_fdf</span><span class="p">(</span><span class="s2">&quot;RUN.fdf&quot;</span><span class="p">)</span>

<span class="c1"># Calculate the scattering state from the left electrode</span>
<span class="c1"># and then the eigen channels to the right electrode</span>
<span class="n">state</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">scattering_state</span><span class="p">(</span><span class="s2">&quot;Left&quot;</span><span class="p">,</span> <span class="n">E</span><span class="o">=</span><span class="mf">0.1</span><span class="p">)</span>
<span class="n">eig_channel</span> <span class="o">=</span> <span class="n">G</span><span class="o">.</span><span class="n">eigenchannel</span><span class="p">(</span><span class="n">state</span><span class="p">,</span> <span class="s2">&quot;Right&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>The above <code class="docutils literal notranslate"><span class="pre">DeviceGreen.from_fdf</span></code> is a short-hand for something
like the below (it actually does more than that, so prefer the <a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.from_fdf" title="sisl_toolbox.btd.DeviceGreen.from_fdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_fdf</span></code></a>):</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span><span class="w"> </span><span class="nn">sisl</span>
<span class="kn">from</span><span class="w"> </span><span class="nn">sisl_toolbox.btd</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>
<span class="c1"># First read in the required data</span>
<span class="n">H_elec</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;ELECTRODE.nc&quot;</span><span class="p">)</span>
<span class="n">H</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">Hamiltonian</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="s2">&quot;DEVICE.nc&quot;</span><span class="p">)</span>
<span class="c1"># remove couplings along the self-energy direction</span>
<span class="c1"># to ensure no fake couplings.</span>
<span class="n">H</span><span class="o">.</span><span class="n">set_nsc</span><span class="p">(</span><span class="n">c</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="c1"># Read in a single tbtrans output which contains the BTD matrices</span>
<span class="c1"># and instructs this class how it should pivot the matrix to obtain</span>
<span class="c1"># a BTD matrix.</span>
<span class="n">tbt</span> <span class="o">=</span> <span class="n">sisl</span><span class="o">.</span><span class="n">get_sile</span><span class="p">(</span><span class="s2">&quot;siesta.TBT.nc&quot;</span><span class="p">)</span>

<span class="c1"># Define the self-energy calculators which will downfold the</span>
<span class="c1"># self-energies into the device region.</span>
<span class="c1"># Since a downfolding will be done it requires the device Hamiltonian.</span>
<span class="n">H_elec</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">tbt</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="s2">&quot;Left&quot;</span><span class="p">))</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">DownfoldSelfEnergy</span><span class="p">(</span><span class="s2">&quot;Left&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">RecursiveSI</span><span class="p">(</span><span class="n">H_elec</span><span class="p">,</span> <span class="s2">&quot;-C&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">tbt</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="s2">&quot;Left&quot;</span><span class="p">),</span>
                          <span class="n">tbt</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>
<span class="n">H_elec</span><span class="o">.</span><span class="n">shift</span><span class="p">(</span><span class="n">tbt</span><span class="o">.</span><span class="n">mu</span><span class="p">(</span><span class="s2">&quot;Right&quot;</span><span class="p">))</span>
<span class="n">left</span> <span class="o">=</span> <span class="n">DownfoldSelfEnergy</span><span class="p">(</span><span class="s2">&quot;Right&quot;</span><span class="p">,</span> <span class="n">s</span><span class="o">.</span><span class="n">RecursiveSI</span><span class="p">(</span><span class="n">H_elec</span><span class="p">,</span> <span class="s2">&quot;+C&quot;</span><span class="p">,</span> <span class="n">eta</span><span class="o">=</span><span class="n">tbt</span><span class="o">.</span><span class="n">eta</span><span class="p">(</span><span class="s2">&quot;Right&quot;</span><span class="p">),</span>
                          <span class="n">tbt</span><span class="p">,</span> <span class="n">H</span><span class="p">)</span>

<span class="n">G</span> <span class="o">=</span> <span class="n">DeviceGreen</span><span class="p">(</span><span class="n">H</span><span class="p">,</span> <span class="p">[</span><span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">],</span> <span class="n">tbt</span><span class="p">)</span>
</pre></div>
</div>
<div class="admonition-notes admonition">
<p class="admonition-title">Notes</p>
<p>Sometimes one wishes to investigate more details in the calculation process
to discern importance of the eigenvalue separations.</p>
<p>When calculating scattering states/matrices one can
reduce the complexity by removing eigen/singular values.
By default we use the <em class="xref py py-obj">cutoff</em> values as a relative cutoff value for
the values. I.e. keeping <code class="docutils literal notranslate"><span class="pre">value</span> <span class="pre">/</span> <span class="pre">value.max()</span> <span class="pre">&gt;</span> <span class="pre">cutoff</span></code>.
However, sometimes the relative value is a bad metric since there are
still important values close to unity value. Consider e.g. an array of
values of <code class="docutils literal notranslate"><span class="pre">[1e5,</span> <span class="pre">1e4,</span> <span class="pre">1,</span> <span class="pre">0.5,</span> <span class="pre">1e-4]</span></code>. In this case we would require the
<code class="docutils literal notranslate"><span class="pre">[1,</span> <span class="pre">0.5]</span></code> values as important, but this would only be grabbed by a relative
cutoff value of <code class="docutils literal notranslate"><span class="pre">1e-6</span></code> which in some other cases are a too high value.</p>
<p>Instead of providing <em class="xref py py-obj">cutoff</em> values as <em class="xref py py-obj">float</em> values, one can also
pass a function that takes in an array of values. It should return the
indices of the values it wishes to retain.</p>
<p>The below is equivalent to a cutoff value of <code class="docutils literal notranslate"><span class="pre">1e-4</span></code>, or values
above 0.01.
&gt;&gt;&gt; def cutoff_func(V):
&gt;&gt;&gt;     return np.logical_or(V / V.max() &gt; 1e-4, V &gt; 1e-2).nonzero()[0]</p>
<p>Passing functions for cutting off values can be useful because one
can also debug the values and see what’s happening.</p>
</div>
<p class="rubric">Methods</p>
<table class="autosummary longtable docutils align-default">
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.Hk" title="sisl_toolbox.btd.DeviceGreen.Hk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Hk</span></code></a>(*args, **kwargs)</p></td>
<td><p>Return the Hamiltonian matrix in the pivoted device region</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.Sk" title="sisl_toolbox.btd.DeviceGreen.Sk"><code class="xref py py-obj docutils literal notranslate"><span class="pre">Sk</span></code></a>(*args, **kwargs)</p></td>
<td><p>Return the overlap matrix in the pivoted device region</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.clear" title="sisl_toolbox.btd.DeviceGreen.clear"><code class="xref py py-obj docutils literal notranslate"><span class="pre">clear</span></code></a>(*keys)</p></td>
<td><p>Clean any memory used by this object</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.eigenchannel" title="sisl_toolbox.btd.DeviceGreen.eigenchannel"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenchannel</span></code></a>(state[, elec_to, ret_coeff])</p></td>
<td><p>Calculate the eigenchannel from scattering states entering electrodes <em class="xref py py-obj">elec_to</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.eigenchannel_from_scattering_matrix" title="sisl_toolbox.btd.DeviceGreen.eigenchannel_from_scattering_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">eigenchannel_from_scattering_matrix</span></code></a>(scat_matrix)</p></td>
<td><p>Calculate the eigenchannel from a scattering matrix</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.from_fdf" title="sisl_toolbox.btd.DeviceGreen.from_fdf"><code class="xref py py-obj docutils literal notranslate"><span class="pre">from_fdf</span></code></a>(fdf[, prefix, use_tbt_se, eta])</p></td>
<td><p>Return a new <a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen" title="sisl_toolbox.btd.DeviceGreen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeviceGreen</span></code></a> using information gathered from the fdf file.</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.green" title="sisl_toolbox.btd.DeviceGreen.green"><code class="xref py py-obj docutils literal notranslate"><span class="pre">green</span></code></a>(E[, k, format, dtype])</p></td>
<td><p>Calculate the Green function for a given <em class="xref py py-obj">E</em> and <em class="xref py py-obj">k</em> point</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.scattering_matrix" title="sisl_toolbox.btd.DeviceGreen.scattering_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scattering_matrix</span></code></a>(E, elec_from[, elec_to, ...])</p></td>
<td><p>Calculate the scattering matrix (S-matrix) between <em class="xref py py-obj">elec_from</em> and <em class="xref py py-obj">elec_to</em></p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.scattering_state" title="sisl_toolbox.btd.DeviceGreen.scattering_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scattering_state</span></code></a>(E, elec[, k, cutoff, ...])</p></td>
<td><p>Calculate the scattering states for a given <em class="xref py py-obj">E</em> and <em class="xref py py-obj">k</em> point from a given electrode</p></td>
</tr>
<tr class="row-even"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.spectral" title="sisl_toolbox.btd.DeviceGreen.spectral"><code class="xref py py-obj docutils literal notranslate"><span class="pre">spectral</span></code></a>(E, elec[, k, format, method, herm, ...])</p></td>
<td><p>Calculate the spectral function for a given <em class="xref py py-obj">E</em> and <em class="xref py py-obj">k</em> point from a given electrode</p></td>
</tr>
<tr class="row-odd"><td><p><a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.transmission" title="sisl_toolbox.btd.DeviceGreen.transmission"><code class="xref py py-obj docutils literal notranslate"><span class="pre">transmission</span></code></a>(E, elec_from[, elec_to, k, dtype])</p></td>
<td><p>Calculate the transmission between an electrode, and one or more other electrodes</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.Hk">
<span class="sig-name descname"><span class="pre">Hk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.Hk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.Hk" title="Link to this definition"></a></dt>
<dd><p>Return the Hamiltonian matrix in the pivoted device region</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.Sk">
<span class="sig-name descname"><span class="pre">Sk</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.Sk"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.Sk" title="Link to this definition"></a></dt>
<dd><p>Return the overlap matrix in the pivoted device region</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.clear">
<span class="sig-name descname"><span class="pre">clear</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">keys</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.clear"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.clear" title="Link to this definition"></a></dt>
<dd><p>Clean any memory used by this object</p>
<dl class="field-list simple">
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://docs.python.org/3/library/constants.html#None" title="(in Python v3.14)"><em>None</em></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.eigenchannel">
<span class="sig-name descname"><span class="pre">eigenchannel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">state</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elec_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_coeff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.eigenchannel"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.eigenchannel" title="Link to this definition"></a></dt>
<dd><p>Calculate the eigenchannel from scattering states entering electrodes <em class="xref py py-obj">elec_to</em></p>
<p>The energy and k-point is inferred from the <em class="xref py py-obj">state</em> object as returned from
<a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.scattering_state" title="sisl_toolbox.btd.DeviceGreen.scattering_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scattering_state</span></code></a>.</p>
<p>The eigenchannels are the eigenstates of the transmission matrix in the
DOS weighted scattering states:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\mathbf A_{\mathfrak e_{\mathrm{from}} }(E,\mathbf k) \mathbf u_i &amp;= 2\pi a_i \mathbf u_i
\\
\mathbf t_{\mathbf u} &amp;= \sum \langle \mathbf u | \boldsymbol\Gamma_{ \mathfrak e_{\mathrm{to}} }  | \mathbf u\rangle\end{split}\]</div>
<p>where the eigenvectors of <span class="math notranslate nohighlight">\(\mathbf t_{\mathbf u}\)</span> are the coefficients of the
DOS weighted scattering states (<span class="math notranslate nohighlight">\(\sqrt{2\pi a_i} u_i\)</span>) for the individual eigen channels.
The eigenvalues are the transmission eigenvalues. Further details may be found in <span id="id1">[<a class="reference internal" href="../../../references.html#id13" title="Magnus Paulsson and Mads Brandbyge. Transmission eigenchannels from nonequilibrium green's functions. Phys. Rev. B, September 2007. URL: https://doi.org/10.1103/physrevb.76.115117, doi:10.1103/physrevb.76.115117.">8</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>) – the scattering states as obtained from <a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.scattering_state" title="sisl_toolbox.btd.DeviceGreen.scattering_state"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scattering_state</span></code></a></p></li>
<li><p><strong>elec_to</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">int</span> <span class="pre">(list</span></code> or <code class="xref py py-class docutils literal notranslate"><span class="pre">not)</span></code>) – which electrodes to consider for the transmission eigenchannel
decomposition (the sum in the above equation).
Defaults to all but the origin electrode.</p></li>
<li><p><strong>ret_coeff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – return also the scattering state coefficients</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>T_eig</strong> (<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><code class="xref py py-class docutils literal notranslate"><span class="pre">sisl.physics.electron.StateCElectron</span></code></a>) – the transmission eigenchannels, the <code class="docutils literal notranslate"><span class="pre">T_eig.c</span></code> contains the transmission
eigenvalues.</p></li>
<li><p><strong>coeff</strong> (<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateElectron.html#sisl.physics.electron.StateElectron" title="sisl.physics.electron.StateElectron"><code class="xref py py-class docutils literal notranslate"><span class="pre">sisl.physics.electron.StateElectron</span></code></a>) – coefficients of <em class="xref py py-obj">state</em> that creates the transmission eigenchannels
Only returned if <em class="xref py py-obj">ret_coeff</em> is True. There is a one-to-one correspondance
between <code class="docutils literal notranslate"><span class="pre">coeff</span></code> and <code class="docutils literal notranslate"><span class="pre">T_eig</span></code> (with a prefactor of <span class="math notranslate nohighlight">\(\sqrt{2\pi}\)</span>).
This is equivalent to the <code class="docutils literal notranslate"><span class="pre">T_eig</span></code> states in the scattering state basis.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a> | <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.14)"><em>tuple</em></a>[<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>, <a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateElectron.html#sisl.physics.electron.StateElectron" title="sisl.physics.electron.StateElectron"><em>StateElectron</em></a>]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.eigenchannel_from_scattering_matrix">
<span class="sig-name descname"><span class="pre">eigenchannel_from_scattering_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">scat_matrix</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ret_out</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.eigenchannel_from_scattering_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.eigenchannel_from_scattering_matrix" title="Link to this definition"></a></dt>
<dd><p>Calculate the eigenchannel from a scattering matrix</p>
<p>The energy and k-point is inferred from the <em class="xref py py-obj">state_matrix</em> object as returned from
<a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.scattering_matrix" title="sisl_toolbox.btd.DeviceGreen.scattering_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scattering_matrix</span></code></a>.</p>
<p>The eigenchannels are the SVD of the scattering matrix in the
DOS weighted scattering states:</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state_matrix</strong> – the scattering matrix as obtained from <a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen.scattering_matrix" title="sisl_toolbox.btd.DeviceGreen.scattering_matrix"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scattering_matrix</span></code></a></p></li>
<li><p><strong>scat_matrix</strong> (<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateElectron.html#sisl.physics.electron.StateElectron" title="sisl.physics.electron.StateElectron"><em>StateElectron</em></a>)</p></li>
<li><p><strong>ret_out</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p><ul class="simple">
<li><p><strong>T_eig_in</strong> (<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><code class="xref py py-class docutils literal notranslate"><span class="pre">sisl.physics.electron.StateCElectron</span></code></a>) – the transmission eigenchannels as seen from the incoming state, the <code class="docutils literal notranslate"><span class="pre">T_eig.c</span></code> contains the transmission
eigenvalues.</p></li>
<li><p><strong>T_eig_out</strong> (<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><code class="xref py py-class docutils literal notranslate"><span class="pre">sisl.physics.electron.StateCElectron</span></code></a>) – the transmission eigenchannels as seen from the outgoing state, the <code class="docutils literal notranslate"><span class="pre">T_eig.c</span></code> contains the transmission
eigenvalues.
Only returned if <em class="xref py py-obj">ret_out</em> is true.</p></li>
</ul>
</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a> | <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.14)"><em>tuple</em></a>[<a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><em>StateCElectron</em></a>, …]</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.from_fdf">
<em class="property"><span class="pre">classmethod</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">from_fdf</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fdf</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">prefix</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'TBT'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_tbt_se</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">eta</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.from_fdf"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.from_fdf" title="Link to this definition"></a></dt>
<dd><p>Return a new <a class="reference internal" href="#sisl_toolbox.btd.DeviceGreen" title="sisl_toolbox.btd.DeviceGreen"><code class="xref py py-obj docutils literal notranslate"><span class="pre">DeviceGreen</span></code></a> using information gathered from the fdf file.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fdf</strong> (<a class="reference internal" href="../../../api/generated/sisl.typing.SileLike.html#sisl.typing.SileLike" title="sisl.typing.SileLike"><em>SileLike</em></a>) – fdf file to read the parameters from</p></li>
<li><p><strong>prefix</strong> (<em>Literal</em><em>[</em><em>'TBT'</em><em>, </em><em>'TS'</em><em>]</em>) – which prefix to use, if TBT it will prefer TBT prefix, but fall back
to TS prefixes.
If TS, only these prefixes will be used.</p></li>
<li><p><strong>use_tbt_se</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – whether to use the TBT.SE.nc files for self-energies
or calculate them on the fly.</p></li>
<li><p><strong>eta</strong> (<em>Optional</em><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – force a specific eta value</p></li>
<li><p><strong>kwargs</strong> – passed to the class instantiating.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><em>Self</em></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.green">
<span class="sig-name descname"><span class="pre">green</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.complex128</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.green"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.green" title="Link to this definition"></a></dt>
<dd><p>Calculate the Green function for a given <em class="xref py py-obj">E</em> and <em class="xref py py-obj">k</em> point</p>
<p>The Green function is calculated as:</p>
<div class="math notranslate nohighlight">
\[\mathbf G(E,\mathbf k) = \big[\mathbf S(\mathbf k) E - \mathbf H(\mathbf k)
      - \sum \boldsymbol \Sigma(E,\mathbf k)\big]^{-1}\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a>) – the energy to calculate at, may be a complex value.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – k-point to calculate the Green function at</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{&quot;array&quot;,</span> <span class="pre">&quot;btd&quot;,</span> <span class="pre">&quot;bm&quot;,</span> <span class="pre">&quot;bd&quot;,</span> <span class="pre">&quot;sparse&quot;}</span></code>) – <p>return the matrix in a specific format</p>
<ul>
<li><p>array: a regular numpy array (full matrix)</p></li>
<li><p>btd: a block-matrix object with only the diagonals and first off-diagonals</p></li>
<li><p>bm: a block-matrix object with diagonals and all off-diagonals</p></li>
<li><p>bd: a block-matrix object with only diagonals (no off-diagonals)</p></li>
<li><p>sparse: a sparse-csr matrix for the sparse elements as found in the Hamiltonian</p></li>
</ul>
</p></li>
<li><p><strong>dtype</strong> – the data-type of the array.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the Green function matrix, the format depends on <em class="xref py py-obj">format</em>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> or <a class="reference internal" href="sisl_toolbox.btd.BlockMatrix.html#sisl_toolbox.btd.BlockMatrix" title="sisl_toolbox.btd.BlockMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockMatrix</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.scattering_matrix">
<span class="sig-name descname"><span class="pre">scattering_matrix</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elec_from</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elec_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1e-4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.complex128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.scattering_matrix"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.scattering_matrix" title="Link to this definition"></a></dt>
<dd><p>Calculate the scattering matrix (S-matrix) between <em class="xref py py-obj">elec_from</em> and <em class="xref py py-obj">elec_to</em></p>
<p>The scattering matrix is calculated as</p>
<div class="math notranslate nohighlight">
\[\mathbf S_{\mathfrak e'\mathfrak e}(E, \mathbf) = -\delta_{\alpha\beta} + i
\tilde{\boldsymbol\Gamma}_{\mathfrak e'}
\mathbf G
\tilde{\boldsymbol\Gamma}_{\mathfrak e}\]</div>
<p>Here <span class="math notranslate nohighlight">\(\tilde{\boldsymbol\Gamma}\)</span> is defined as:</p>
<div class="math notranslate nohighlight">
\[\begin{split}\boldsymbol\Gamma(E,\mathbf k) \mathbf u_i &amp;= \lambda_i \mathbf u_i
\\
\tilde{\boldsymbol\Gamma}(E,\mathbf k) &amp;= \operatorname{diag}\{ \sqrt{\boldsymbol\lambda} \} \mathbf u\end{split}\]</div>
<p>Once the scattering matrices have been calculated one can calculate the full transmission
function</p>
<div class="math notranslate nohighlight">
\[\mathcal T_{\mathfrak e\to\mathfrak e'}(E, \mathbf k) = \operatorname{Tr}\big[
\mathbf S_{\mathfrak e'\mathfrak e }^\dagger
\mathbf S_{\mathfrak e'\mathfrak e }\big]\]</div>
<p>The scattering matrix approach can be found in details in
<span id="id2">[<a class="reference internal" href="../../../references.html#id2" title="Sofia Sanz, Nick Papior, Géza Giedke, Daniel Sánchez-Portal, Mads Brandbyge, and Thomas Frederiksen. Mach-Zehnder-like interferometry with graphene nanoribbon networks. J. Phys. Condens. Matter, 35(37):374001, June 2023.">12</a>]</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a>) – the energy to calculate at, may be a complex value.</p></li>
<li><p><strong>elec_from</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – the electrode where the scattering matrix originates from</p></li>
<li><p><strong>elec_to</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span> <span class="pre">of</span></code>) – where the scattering matrix ends in.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – k-point to calculate the scattering matrix at</p></li>
<li><p><strong>cutoff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>) – cutoff eigen states of the broadening matrix.
The cutoff is based on a relative fraction of the maximum eigen value.
that are below this value.
For example, we keep according to <span class="math notranslate nohighlight">\(\lambda_i/\max(\lambda_i) &gt; \mathrm{cutoff}\)</span>.
A too high value will remove too many eigen states and results will be wrong.
A small value improves precision at the cost of bigger matrices.
The <span class="math notranslate nohighlight">\(\Gamma\)</span> matrix should be positive definite, however, due
to the imaginary part of the self-energies it tends to only be <em>close</em>
to positive definite.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>for each <em class="xref py py-obj">elec_to</em> a scattering matrix will be returned. Its dimensions will be
depending on the <em class="xref py py-obj">cutoff</em> value at the cost of precision.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateElectron.html#sisl.physics.electron.StateElectron" title="sisl.physics.electron.StateElectron"><code class="xref py py-class docutils literal notranslate"><span class="pre">sisl.physics.electron.StateElectron</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">tuple[sisl.physics.electron.StateElectron,...]</span></code></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.scattering_state">
<span class="sig-name descname"><span class="pre">scattering_state</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cutoff</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'svd:gamma'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.complex128</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.scattering_state"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.scattering_state" title="Link to this definition"></a></dt>
<dd><p>Calculate the scattering states for a given <em class="xref py py-obj">E</em> and <em class="xref py py-obj">k</em> point from a given electrode</p>
<p>The scattering states are the eigen states of the spectral function:</p>
<div class="math notranslate nohighlight">
\[\mathbf A_{\mathfrak e}(E,\mathbf k) \mathbf u_i = 2\pi a_i \mathbf u_i\]</div>
<p>where <span class="math notranslate nohighlight">\(a_i\)</span> is the DOS carried by the <span class="math notranslate nohighlight">\(i\)</span>’th scattering
state.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a>) – the energy to calculate at, may be a complex value.</p></li>
<li><p><strong>elec</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – the electrode to calculate the spectral function from</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – k-point to calculate the spectral function at</p></li>
<li><p><strong>cutoff</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em> | </em><a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Callable" title="(in Python v3.14)"><em>Callable</em></a>) – Cut off the returned scattering states at some DOS value. Any scattering states
with relative eigenvalues (to the largest eigenvalue), lower than <em class="xref py py-obj">cutoff</em> are discarded.
For example, we keep according to <span class="math notranslate nohighlight">\(\epsilon_i/\max(\epsilon_i) &gt; \mathrm{cutoff}\)</span>.
Values above or close to 0.1 should be used with care.
Can be a function, see the details of this class.</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'svd:gamma'</em><em>, </em><em>'svd:A'</em><em>, </em><em>'eig'</em><em>]</em>) – which method to use for calculating the scattering states.
Use only the <code class="docutils literal notranslate"><span class="pre">eig</span></code> method for testing purposes as it is extremely slow
and requires a substantial amount of memory.
The <code class="docutils literal notranslate"><span class="pre">svd:gamma</span></code> is the fastests while retaining complete precision.
The <code class="docutils literal notranslate"><span class="pre">svd:A</span></code> may be even faster for very large systems with
very little loss of precision, since it diagonalizes <span class="math notranslate nohighlight">\(\mathbf A\)</span> in
the subspace of the electrode <em class="xref py py-obj">elec</em> and reduces the propagated part of the spectral
matrix.</p></li>
<li><p><strong>cutoff_elec</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">float</span></code></a>, <em>optional</em>) – Only used for <code class="docutils literal notranslate"><span class="pre">method=svd:A</span></code>. The initial block of the spectral function is
diagonalized and only eigenvectors with relative eigenvalues
<code class="docutils literal notranslate"><span class="pre">&gt;=cutoff_elec</span></code> are retained.
thus reducing the initial propagated modes. The normalization explained for <em class="xref py py-obj">cutoff</em>
also applies here.
Can be a function, see the details of this class.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the scattering states from the spectral function. The <code class="docutils literal notranslate"><span class="pre">scat.state</span></code> contains
the scattering state vectors (eigenvectors of the spectral function).
<code class="docutils literal notranslate"><span class="pre">scat.c</span></code> contains the DOS of the scattering states scaled by <span class="math notranslate nohighlight">\(1/(2\pi)\)</span>
so ensure correct density of states.
One may recreate the spectral function with <code class="docutils literal notranslate"><span class="pre">scat.outer(matrix=scat.c</span> <span class="pre">*</span> <span class="pre">2</span> <span class="pre">*</span> <span class="pre">pi)</span></code>.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference internal" href="../../../api/generated/sisl.physics.electron.StateCElectron.html#sisl.physics.electron.StateCElectron" title="sisl.physics.electron.StateCElectron"><code class="xref py py-class docutils literal notranslate"><span class="pre">sisl.physics.electron.StateCElectron</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.spectral">
<span class="sig-name descname"><span class="pre">spectral</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elec</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">format</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'array'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'column'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">herm</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.complex128</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.spectral"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.spectral" title="Link to this definition"></a></dt>
<dd><p>Calculate the spectral function for a given <em class="xref py py-obj">E</em> and <em class="xref py py-obj">k</em> point from a given electrode</p>
<p>The spectral function is calculated as:</p>
<div class="math notranslate nohighlight">
\[\mathbf A_{\mathfrak{e}}(E,\mathbf k) = \mathbf G(E,\mathbf k)\boldsymbol\Gamma_{\mathfrak{e}}(E,\mathbf k)
       \mathbf G^\dagger(E,\mathbf k)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a>) – the energy to calculate at, may be a complex value.</p></li>
<li><p><strong>elec</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – the electrode to calculate the spectral function from</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – k-point to calculate the spectral function at</p></li>
<li><p><strong>format</strong> (<code class="docutils literal notranslate"><span class="pre">{&quot;array&quot;,</span> <span class="pre">&quot;btd&quot;,</span> <span class="pre">&quot;bm&quot;,</span> <span class="pre">&quot;bd&quot;}</span></code>) – <p>return the matrix in a specific format</p>
<ul>
<li><p>array: a regular numpy array (full matrix)</p></li>
<li><p>bm: in block-matrix form (full matrix)</p></li>
<li><p>btd: a block-matrix object with only the diagonals and first off-diagonals</p></li>
<li><p>bd: same as btd, since the off-diagonals are already calculated</p></li>
</ul>
</p></li>
<li><p><strong>method</strong> (<a class="reference external" href="https://docs.python.org/3/library/typing.html#typing.Literal" title="(in Python v3.14)"><em>Literal</em></a><em>[</em><em>'column'</em><em>, </em><em>'propagate'</em><em>]</em>) – which method to use for calculating the spectral function.
Depending on the size of the BTD blocks one may be faster than the
other. For large systems you are recommended to time the different methods
and stick with the fastest one, they are numerically identical.</p></li>
<li><p><strong>herm</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#bool" title="(in Python v3.14)"><em>bool</em></a>) – The spectral function is a Hermitian matrix, by default (True), the methods
that can utilize the Hermitian property only calculates the lower triangular
part of <span class="math notranslate nohighlight">\(\mathbf A\)</span>, and then copies the Hermitian to the upper part.
By setting this to <em class="xref py py-obj">False</em> the entire matrix is explicitly calculated.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>the spectral function for a given electrode in the format
as specified by <em class="xref py py-obj">format</em>. Note that some formats does not calculate
the entire spectral function matrix.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p><a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v2.3)"><code class="xref py py-class docutils literal notranslate"><span class="pre">ndarray</span></code></a> or <a class="reference internal" href="sisl_toolbox.btd.BlockMatrix.html#sisl_toolbox.btd.BlockMatrix" title="sisl_toolbox.btd.BlockMatrix"><code class="xref py py-class docutils literal notranslate"><span class="pre">BlockMatrix</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="sisl_toolbox.btd.DeviceGreen.transmission">
<span class="sig-name descname"><span class="pre">transmission</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">E</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elec_from</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">elec_to</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">k</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">(0,</span> <span class="pre">0,</span> <span class="pre">0)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">np.complex128</span></span></em><span class="sig-paren">)</span><a class="reference internal" href="../../../_modules/sisl_toolbox/btd/_green.html#DeviceGreen.transmission"><span class="viewcode-link"><span class="pre">[source]</span></span></a><a class="headerlink" href="#sisl_toolbox.btd.DeviceGreen.transmission" title="Link to this definition"></a></dt>
<dd><p>Calculate the transmission between an electrode, and one or more other electrodes</p>
<p>The transmission function is calculated as:</p>
<div class="math notranslate nohighlight">
\[\mathcal T_{\mathfrak e\to\mathfrak e'}(E,\mathbf k) =
\boldsymbol \Gamma_{\mathfrak e'}(E,\mathbf k)
\mathbf G(E,\mathbf k)
\boldsymbol\Gamma_{\mathfrak e}(E,\mathbf k)
\mathbf G^\dagger(E,\mathbf k)\]</div>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>E</strong> (<a class="reference external" href="https://docs.python.org/3/library/functions.html#complex" title="(in Python v3.14)"><em>complex</em></a>) – the energy to calculate at, may be a complex value.</p></li>
<li><p><strong>elec_from</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a>) – the electrode to calculate the transmission <em>from</em>.</p></li>
<li><p><strong>elec_to</strong> (<a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#str" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">str</span></code></a> or <a class="reference external" href="https://docs.python.org/3/library/functions.html#int" title="(in Python v3.14)"><code class="xref py py-class docutils literal notranslate"><span class="pre">int</span></code></a> or <code class="xref py py-class docutils literal notranslate"><span class="pre">list</span> <span class="pre">of</span></code>) – the electrode(s) to calculate the transmission <em>to</em>.</p></li>
<li><p><strong>k</strong> (<a class="reference external" href="https://docs.python.org/3/library/collections.abc.html#collections.abc.Sequence" title="(in Python v3.14)"><em>Sequence</em></a><em>[</em><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a><em>]</em>) – k-point to calculate the transmission at.</p></li>
</ul>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p><a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a> | <a class="reference external" href="https://docs.python.org/3/library/stdtypes.html#tuple" title="(in Python v3.14)"><em>tuple</em></a>[<a class="reference external" href="https://docs.python.org/3/library/functions.html#float" title="(in Python v3.14)"><em>float</em></a>, …]</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="sisl_toolbox.btd.DownfoldSelfEnergy.html" class="btn btn-neutral float-left" title="sisl_toolbox.btd.DownfoldSelfEnergy" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../../../dev/index.html" class="btn btn-neutral float-right" title="Contributing to sisl" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2015-2025, sisl developers.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>